From: "Saved by Windows Internet Explorer 8"
Subject: Network | Manipulation
Date: Thu, 27 Aug 2015 14:27:33 +0530
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01D0E0D4.83203900"
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7601.17514

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01D0E0D4.83203900
Content-Type: text/html;
	charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://visjs.org/examples/network/other/manipulation.html

=EF=BB=BF<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Network | Manipulation</TITLE>
<META content=3D"text/html; charset=3Dutf-8" http-equiv=3DContent-Type>
<STYLE type=3Dtext/css>BODY {
	FONT: 10pt sans
}
SELECT {
	FONT: 10pt sans
}
#mynetwork {
	BORDER-BOTTOM: lightgray 1px solid; POSITION: relative; BORDER-LEFT: =
lightgray 1px solid; WIDTH: 800px; HEIGHT: 600px; BORDER-TOP: lightgray =
1px solid; BORDER-RIGHT: lightgray 1px solid
}
TABLE.legend_table {
	BORDER-BOTTOM: #d3d3d3 1px solid; BORDER-LEFT: #d3d3d3 1px solid; =
FONT-SIZE: 11px; BORDER-TOP: #d3d3d3 1px solid; BORDER-RIGHT: #d3d3d3 =
1px solid
}
TABLE.legend_table {
	BORDER-BOTTOM: #d3d3d3 1px solid; BORDER-LEFT: #d3d3d3 1px solid; =
PADDING-BOTTOM: 2px; PADDING-LEFT: 2px; PADDING-RIGHT: 2px; BORDER-TOP: =
#d3d3d3 1px solid; BORDER-RIGHT: #d3d3d3 1px solid; PADDING-TOP: 2px
}
TD {
	BORDER-BOTTOM: #d3d3d3 1px solid; BORDER-LEFT: #d3d3d3 1px solid; =
PADDING-BOTTOM: 2px; PADDING-LEFT: 2px; PADDING-RIGHT: 2px; BORDER-TOP: =
#d3d3d3 1px solid; BORDER-RIGHT: #d3d3d3 1px solid; PADDING-TOP: 2px
}
DIV.table_content {
	TEXT-ALIGN: center; WIDTH: 80px
}
DIV.table_description {
	WIDTH: 100px
}
#operation {
	FONT-SIZE: 28px
}
#network-popUp {
	Z-INDEX: 299; BORDER-BOTTOM: #5394ed 3px solid; POSITION: absolute; =
TEXT-ALIGN: center; BORDER-LEFT: #5394ed 3px solid; PADDING-BOTTOM: =
10px; BACKGROUND-COLOR: #f9f9f9; PADDING-LEFT: 10px; WIDTH: 250px; =
PADDING-RIGHT: 10px; DISPLAY: none; HEIGHT: 120px; BORDER-TOP: #5394ed =
3px solid; TOP: 350px; BORDER-RIGHT: #5394ed 3px solid; PADDING-TOP: =
10px; LEFT: 170px
}
</STYLE>

<SCRIPT type=3Dtext/javascript=20
src=3D"http://visjs.org/examples/network/exampleUtil.js"></SCRIPT>

<SCRIPT type=3Dtext/javascript =
src=3D"http://visjs.org/dist/vis.js"></SCRIPT>
<LINK rel=3Dstylesheet type=3Dtext/css =
href=3D"http://visjs.org/dist/vis.css">
<SCRIPT type=3Dtext/javascript>=0A=
    var nodes =3D null;=0A=
    var edges =3D null;=0A=
    var network =3D null;=0A=
    // randomly create some nodes and edges=0A=
    var data =3D getScaleFreeNetwork(25);=0A=
    var seed =3D 2;=0A=
=0A=
=0A=
    function destroy() {=0A=
      if (network !=3D=3D null) {=0A=
        network.destroy();=0A=
        network =3D null;=0A=
      }=0A=
    }=0A=
=0A=
    function draw() {=0A=
      destroy();=0A=
      nodes =3D [];=0A=
      edges =3D [];=0A=
=0A=
      // create a network=0A=
      var container =3D document.getElementById('mynetwork');=0A=
      var options =3D {=0A=
        layout: {randomSeed:seed}, // just to make sure the layout is =
the same when the locale is changed=0A=
        locale: document.getElementById('locale').value,=0A=
        manipulation: {=0A=
          addNode: function (data, callback) {=0A=
            // filling in the popup DOM elements=0A=
            document.getElementById('operation').innerHTML =3D "Add =
Node";=0A=
            document.getElementById('node-id').value =3D data.id;=0A=
            document.getElementById('node-label').value =3D data.label;=0A=
            document.getElementById('saveButton').onclick =3D =
saveData.bind(this, data, callback);=0A=
            document.getElementById('cancelButton').onclick =3D =
clearPopUp.bind();=0A=
            document.getElementById('network-popUp').style.display =3D =
'block';=0A=
          },=0A=
          editNode: function (data, callback) {=0A=
            // filling in the popup DOM elements=0A=
            document.getElementById('operation').innerHTML =3D "Edit =
Node";=0A=
            document.getElementById('node-id').value =3D data.id;=0A=
            document.getElementById('node-label').value =3D data.label;=0A=
            document.getElementById('saveButton').onclick =3D =
saveData.bind(this, data, callback);=0A=
            document.getElementById('cancelButton').onclick =3D =
cancelEdit.bind(this,callback);=0A=
            document.getElementById('network-popUp').style.display =3D =
'block';=0A=
          },=0A=
          addEdge: function (data, callback) {=0A=
            if (data.from =3D=3D data.to) {=0A=
              var r =3D confirm("Do you want to connect the node to =
itself?");=0A=
              if (r =3D=3D true) {=0A=
                callback(data);=0A=
              }=0A=
            }=0A=
            else {=0A=
              callback(data);=0A=
            }=0A=
          }=0A=
        }=0A=
      };=0A=
      network =3D new vis.Network(container, data, options);=0A=
    }=0A=
=0A=
    function clearPopUp() {=0A=
      document.getElementById('saveButton').onclick =3D null;=0A=
      document.getElementById('cancelButton').onclick =3D null;=0A=
      document.getElementById('network-popUp').style.display =3D 'none';=0A=
    }=0A=
=0A=
    function cancelEdit(callback) {=0A=
      clearPopUp();=0A=
      callback(null);=0A=
    }=0A=
=0A=
    function saveData(data,callback) {=0A=
      data.id =3D document.getElementById('node-id').value;=0A=
      data.label =3D document.getElementById('node-label').value;=0A=
      clearPopUp();=0A=
      callback(data);=0A=
    }=0A=
=0A=
  </SCRIPT>

<SCRIPT src=3D"http://visjs.org/examples/googleAnalytics.js"></SCRIPT>

<META name=3DGENERATOR content=3D"MSHTML 8.00.7601.17514"></HEAD>
<BODY onload=3Ddraw();>
<H2>Editing the nodes and edges (localized)</H2>
<P style=3D"TEXT-ALIGN: justify; WIDTH: 700px; FONT-SIZE: 14px">The =
localization=20
is only relevant to the manipulation buttons. </P>
<P><LABEL for=3Dlocale>Select a locale:</LABEL> <SELECT id=3Dlocale=20
  onchange=3Ddraw();> <OPTION selected value=3Den>en</OPTION> <OPTION=20
  value=3Dnl>nl</OPTION></SELECT> </P>
<DIV id=3Dnetwork-popUp><SPAN id=3Doperation>node</SPAN> <BR>
<TABLE style=3D"MARGIN: auto">
  <TBODY>
  <TR>
    <TD>id</TD>
    <TD><INPUT id=3Dnode-id value=3D"new value"></TD></TR>
  <TR>
    <TD>label</TD>
    <TD><INPUT id=3Dnode-label value=3D"new =
value"></TD></TR></TBODY></TABLE><INPUT id=3DsaveButton value=3Dsave =
type=3Dbutton>=20
<INPUT id=3DcancelButton value=3Dcancel type=3Dbutton> </DIV><BR>
<DIV id=3Dmynetwork></DIV></BODY></HTML>

------=_NextPart_000_0000_01D0E0D4.83203900
Content-Type: text/css;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://visjs.org/dist/vis.css

.vis .overlay {
	Z-INDEX: 10; POSITION: absolute; WIDTH: 100%; HEIGHT: 100%; TOP: 0px; =
LEFT: 0px
}
.vis-active {
	box-shadow: 0 0 10px #86d5f8
}
.vis [class*=3D'span'] {
	MIN-HEIGHT: 0px; WIDTH: auto
}
.vis-timeline {
	BOX-SIZING: border-box; BORDER-BOTTOM: #bfbfbf 1px solid; POSITION: =
relative; BORDER-LEFT: #bfbfbf 1px solid; PADDING-BOTTOM: 0px; MARGIN: =
0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; OVERFLOW: hidden; =
BORDER-TOP: #bfbfbf 1px solid; BORDER-RIGHT: #bfbfbf 1px solid; =
PADDING-TOP: 0px
}
.vis-panel {
	BOX-SIZING: border-box; POSITION: absolute; PADDING-BOTTOM: 0px; =
MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px
}
.vis-center.vis-panel {
	BORDER-BOTTOM: #bfbfbf 1px; BORDER-LEFT: #bfbfbf 1px; BORDER-TOP: =
#bfbfbf 1px; BORDER-RIGHT: #bfbfbf 1px
}
.vis-left.vis-panel {
	BORDER-BOTTOM: #bfbfbf 1px; BORDER-LEFT: #bfbfbf 1px; BORDER-TOP: =
#bfbfbf 1px; BORDER-RIGHT: #bfbfbf 1px
}
.vis-right.vis-panel {
	BORDER-BOTTOM: #bfbfbf 1px; BORDER-LEFT: #bfbfbf 1px; BORDER-TOP: =
#bfbfbf 1px; BORDER-RIGHT: #bfbfbf 1px
}
.vis-top.vis-panel {
	BORDER-BOTTOM: #bfbfbf 1px; BORDER-LEFT: #bfbfbf 1px; BORDER-TOP: =
#bfbfbf 1px; BORDER-RIGHT: #bfbfbf 1px
}
.vis-bottom.vis-panel {
	BORDER-BOTTOM: #bfbfbf 1px; BORDER-LEFT: #bfbfbf 1px; BORDER-TOP: =
#bfbfbf 1px; BORDER-RIGHT: #bfbfbf 1px
}
.vis-center.vis-panel {
	BORDER-BOTTOM-STYLE: solid; BORDER-TOP-STYLE: solid; OVERFLOW: hidden
}
.vis-left.vis-panel {
	BORDER-BOTTOM-STYLE: solid; BORDER-TOP-STYLE: solid; OVERFLOW: hidden
}
.vis-right.vis-panel {
	BORDER-BOTTOM-STYLE: solid; BORDER-TOP-STYLE: solid; OVERFLOW: hidden
}
.vis-center.vis-panel {
	BORDER-RIGHT-STYLE: solid; BORDER-LEFT-STYLE: solid
}
.vis-top.vis-panel {
	BORDER-RIGHT-STYLE: solid; BORDER-LEFT-STYLE: solid
}
.vis-bottom.vis-panel {
	BORDER-RIGHT-STYLE: solid; BORDER-LEFT-STYLE: solid
}
.vis-background {
	OVERFLOW: hidden
}
.vis-panel > .vis-content {
	POSITION: relative
}
.vis-panel .vis-shadow {
	POSITION: absolute; WIDTH: 100%; HEIGHT: 1px; box-shadow: 0 0 10px =
rgba(0, 0, 0, 0.8)
}
.vis-panel .vis-top.vis-shadow {
	TOP: -1px; LEFT: 0px
}
.vis-panel .vis-bottom.vis-shadow {
	BOTTOM: -1px; LEFT: 0px
}
.vis-labelset {
	BOX-SIZING: border-box; POSITION: relative; OVERFLOW: hidden
}
.vis-labelset .vis-label {
	BOX-SIZING: border-box; POSITION: relative; WIDTH: 100%; COLOR: =
#4d4d4d; TOP: 0px; LEFT: 0px
}
.vis-labelset .vis-label {
	BORDER-BOTTOM: #bfbfbf 1px solid
}
.vis-labelset .vis-label .vis-inner {
	PADDING-BOTTOM: 5px; PADDING-LEFT: 5px; PADDING-RIGHT: 5px; DISPLAY: =
inline-block; PADDING-TOP: 5px
}
.vis-labelset .vis-label .vis-hidden.vis-inner {
	PADDING-BOTTOM: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; =
PADDING-TOP: 0px
}
.vis-itemset {
	BOX-SIZING: border-box; POSITION: relative; PADDING-BOTTOM: 0px; =
MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px
}
.vis-itemset .vis-background {
	POSITION: absolute; WIDTH: 100%; HEIGHT: 100%; OVERFLOW: visible
}
.vis-itemset .vis-foreground {
	POSITION: absolute; WIDTH: 100%; HEIGHT: 100%; OVERFLOW: visible
}
.vis-axis {
	Z-INDEX: 1; POSITION: absolute; WIDTH: 100%; HEIGHT: 0px; LEFT: 0px
}
.vis-foreground .vis-group {
	BOX-SIZING: border-box; BORDER-BOTTOM: #bfbfbf 1px solid; POSITION: =
relative
}
.vis-overlay {
	Z-INDEX: 10; POSITION: absolute; WIDTH: 100%; HEIGHT: 100%; TOP: 0px; =
LEFT: 0px
}
.vis-item {
	POSITION: absolute; BORDER-BOTTOM-COLOR: #97b0f8; BORDER-RIGHT-WIDTH: =
1px; BACKGROUND-COLOR: #d5ddf6; BORDER-TOP-COLOR: #97b0f8; DISPLAY: =
inline-block; BORDER-TOP-WIDTH: 1px; BORDER-BOTTOM-WIDTH: 1px; COLOR: =
#1a1a1a; BORDER-RIGHT-COLOR: #97b0f8; BORDER-LEFT-COLOR: #97b0f8; =
BORDER-LEFT-WIDTH: 1px
}
.vis-selected.vis-item {
	Z-INDEX: 2; BORDER-BOTTOM-COLOR: #ffc200; BACKGROUND-COLOR: #fff785; =
BORDER-TOP-COLOR: #ffc200; BORDER-RIGHT-COLOR: #ffc200; =
BORDER-LEFT-COLOR: #ffc200
}
.vis-selected.vis-editable {
	CURSOR: move
}
.vis-selected.vis-point.vis-item {
	BACKGROUND-COLOR: #fff785
}
.vis-box.vis-item {
	BORDER-BOTTOM-STYLE: solid; TEXT-ALIGN: center; BORDER-RIGHT-STYLE: =
solid; BORDER-TOP-STYLE: solid; BORDER-LEFT-STYLE: solid; border-radius: =
2px
}
.vis-point.vis-item {
	BACKGROUND: none transparent scroll repeat 0% 0%
}
.vis-dot.vis-item {
	BORDER-BOTTOM: 4px solid; POSITION: absolute; BORDER-LEFT: 4px solid; =
PADDING-BOTTOM: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; BORDER-TOP: =
4px solid; BORDER-RIGHT: 4px solid; PADDING-TOP: 0px; border-radius: 4px
}
.vis-range.vis-item {
	BOX-SIZING: border-box; BORDER-BOTTOM-STYLE: solid; BORDER-RIGHT-STYLE: =
solid; BORDER-TOP-STYLE: solid; BORDER-LEFT-STYLE: solid; border-radius: =
2px
}
.vis-background.vis-item {
	BOX-SIZING: border-box; BORDER-BOTTOM: medium none; BORDER-LEFT: medium =
none; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; =
PADDING-RIGHT: 0px; BORDER-TOP: medium none; BORDER-RIGHT: medium none; =
PADDING-TOP: 0px
}
.vis-item .vis-item-overflow {
	POSITION: relative; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: =
0px; WIDTH: 100%; PADDING-RIGHT: 0px; HEIGHT: 100%; OVERFLOW: hidden; =
PADDING-TOP: 0px
}
.vis-range.vis-item .vis-item-content {
	POSITION: relative; DISPLAY: inline-block
}
.vis-background.vis-item .vis-item-content {
	POSITION: absolute; DISPLAY: inline-block
}
.vis-line.vis-item {
	POSITION: absolute; BORDER-LEFT: 1px solid; PADDING-BOTTOM: 0px; =
PADDING-LEFT: 0px; WIDTH: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px
}
.vis-item .vis-item-content {
	BOX-SIZING: border-box; PADDING-BOTTOM: 5px; PADDING-LEFT: 5px; =
PADDING-RIGHT: 5px; WHITE-SPACE: nowrap; PADDING-TOP: 5px
}
.vis-item .vis-delete {
	POSITION: absolute; WIDTH: 24px; BACKGROUND: =
url(img/timeline/delete.png) no-repeat center 50%; HEIGHT: 24px; TOP: =
-4px; CURSOR: pointer; RIGHT: -24px
}
.vis-range.vis-item .vis-drag-left {
	POSITION: absolute; MIN-WIDTH: 2px; WIDTH: 24px; MAX-WIDTH: 20%; =
HEIGHT: 100%; TOP: 0px; CURSOR: w-resize; LEFT: -4px
}
.vis-range.vis-item .vis-drag-right {
	POSITION: absolute; MIN-WIDTH: 2px; WIDTH: 24px; MAX-WIDTH: 20%; =
HEIGHT: 100%; TOP: 0px; CURSOR: e-resize; RIGHT: -4px
}
.vis-time-axis {
	POSITION: relative; OVERFLOW: hidden
}
.vis-foreground.vis-time-axis {
	WIDTH: 100%; TOP: 0px; LEFT: 0px
}
.vis-background.vis-time-axis {
	POSITION: absolute; WIDTH: 100%; HEIGHT: 100%; TOP: 0px; LEFT: 0px
}
.vis-time-axis .vis-text {
	BOX-SIZING: border-box; POSITION: absolute; PADDING-BOTTOM: 3px; =
PADDING-LEFT: 3px; PADDING-RIGHT: 3px; WHITE-SPACE: nowrap; COLOR: =
#4d4d4d; OVERFLOW: hidden; PADDING-TOP: 3px
}
.vis-time-axis .vis-measure.vis-text {
	POSITION: absolute; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; VISIBILITY: =
hidden; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px
}
.vis-time-axis .vis-vertical.vis-grid {
	POSITION: absolute; BORDER-LEFT: 1px solid
}
.vis-time-axis .vis-minor.vis-grid {
	BORDER-BOTTOM-COLOR: #e5e5e5; BORDER-TOP-COLOR: #e5e5e5; =
BORDER-RIGHT-COLOR: #e5e5e5; BORDER-LEFT-COLOR: #e5e5e5
}
.vis-time-axis .vis-major.vis-grid {
	BORDER-BOTTOM-COLOR: #bfbfbf; BORDER-TOP-COLOR: #bfbfbf; =
BORDER-RIGHT-COLOR: #bfbfbf; BORDER-LEFT-COLOR: #bfbfbf
}
.vis-current-time {
	Z-INDEX: 1; BACKGROUND-COLOR: #ff7f6e; WIDTH: 2px
}
.vis-custom-time {
	Z-INDEX: 1; BACKGROUND-COLOR: #6e94ff; WIDTH: 2px; CURSOR: move
}
.vis-timeline {
=09
}
.vis-panel {
=09
}
.vis-axis {
=09
}
.vis-horizontal.vis-background.vis-panel .vis-horizontal.vis-grid {
	BORDER-BOTTOM: 1px solid; POSITION: absolute; WIDTH: 100%; HEIGHT: 0px
}
.vis-horizontal.vis-background.vis-panel .vis-minor.vis-grid {
	BORDER-BOTTOM-COLOR: #e5e5e5; BORDER-TOP-COLOR: #e5e5e5; =
BORDER-RIGHT-COLOR: #e5e5e5; BORDER-LEFT-COLOR: #e5e5e5
}
.vis-horizontal.vis-background.vis-panel .vis-major.vis-grid {
	BORDER-BOTTOM-COLOR: #bfbfbf; BORDER-TOP-COLOR: #bfbfbf; =
BORDER-RIGHT-COLOR: #bfbfbf; BORDER-LEFT-COLOR: #bfbfbf
}
.vis-data-axis .vis-major.vis-y-axis {
	POSITION: absolute; WIDTH: 100%; WHITE-SPACE: nowrap; COLOR: #4d4d4d
}
.vis-data-axis .vis-measure.vis-major.vis-y-axis {
	BORDER-BOTTOM: 0px; BORDER-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; =
PADDING-LEFT: 0px; WIDTH: auto; PADDING-RIGHT: 0px; VISIBILITY: hidden; =
BORDER-TOP: 0px; BORDER-RIGHT: 0px; PADDING-TOP: 0px
}
.vis-data-axis .vis-minor.vis-y-axis {
	POSITION: absolute; WIDTH: 100%; WHITE-SPACE: nowrap; COLOR: #bebebe
}
.vis-data-axis .vis-measure.vis-minor.vis-y-axis {
	BORDER-BOTTOM: 0px; BORDER-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; =
PADDING-LEFT: 0px; WIDTH: auto; PADDING-RIGHT: 0px; VISIBILITY: hidden; =
BORDER-TOP: 0px; BORDER-RIGHT: 0px; PADDING-TOP: 0px
}
.vis-data-axis .vis-title.vis-y-axis {
	POSITION: absolute; TEXT-ALIGN: center; BOTTOM: 20px; WHITE-SPACE: =
nowrap; COLOR: #4d4d4d
}
.vis-data-axis .vis-measure.vis-title.vis-y-axis {
	PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; WIDTH: auto; =
PADDING-RIGHT: 0px; VISIBILITY: hidden; PADDING-TOP: 0px
}
.vis-data-axis .vis-left.vis-title.vis-y-axis {
	BOTTOM: 0px; -webkit-transform-origin: left top; -moz-transform-origin: =
left top; -ms-transform-origin: left top; -o-transform-origin: left top; =
transform-origin: left bottom; -webkit-transform: rotate(-90deg); =
-moz-transform: rotate(-90deg); -ms-transform: rotate(-90deg); =
-o-transform: rotate(-90deg); transform: rotate(-90deg)
}
.vis-data-axis .vis-right.vis-title.vis-y-axis {
	BOTTOM: 0px; -webkit-transform-origin: right bottom; =
-moz-transform-origin: right bottom; -ms-transform-origin: right bottom; =
-o-transform-origin: right bottom; transform-origin: right bottom; =
-webkit-transform: rotate(90deg); -moz-transform: rotate(90deg); =
-ms-transform: rotate(90deg); -o-transform: rotate(90deg); transform: =
rotate(90deg)
}
.vis-legend {
	BORDER-BOTTOM: #b3b3b3 1px solid; BORDER-LEFT: #b3b3b3 1px solid; =
PADDING-BOTTOM: 5px; PADDING-LEFT: 5px; PADDING-RIGHT: 5px; BORDER-TOP: =
#b3b3b3 1px solid; BORDER-RIGHT: #b3b3b3 1px solid; PADDING-TOP: 5px; =
box-shadow: 2px 2px 10px rgba(154, 154, 154, 0.55)
}
.vis-legend-text {
	DISPLAY: inline-block; WHITE-SPACE: nowrap
}
.vis-graph-group0 {
	fill: #4f81bd; fill-opacity: 0; stroke-width: 2px; stroke: #4f81bd
}
.vis-graph-group1 {
	fill: #f79646; fill-opacity: 0; stroke-width: 2px; stroke: #f79646
}
.vis-graph-group2 {
	fill: #8c51cf; fill-opacity: 0; stroke-width: 2px; stroke: #8c51cf
}
.vis-graph-group3 {
	fill: #75c841; fill-opacity: 0; stroke-width: 2px; stroke: #75c841
}
.vis-graph-group4 {
	fill: #ff0100; fill-opacity: 0; stroke-width: 2px; stroke: #ff0100
}
.vis-graph-group5 {
	fill: #37d8e6; fill-opacity: 0; stroke-width: 2px; stroke: #37d8e6
}
.vis-graph-group6 {
	fill: #042662; fill-opacity: 0; stroke-width: 2px; stroke: #042662
}
.vis-graph-group7 {
	fill: #00ff26; fill-opacity: 0; stroke-width: 2px; stroke: #00ff26
}
.vis-graph-group8 {
	fill: #ff00ff; fill-opacity: 0; stroke-width: 2px; stroke: #ff00ff
}
.vis-graph-group9 {
	fill: #8f3938; fill-opacity: 0; stroke-width: 2px; stroke: #8f3938
}
.vis-timeline .vis-fill {
	fill-opacity: 0.1; stroke: none
}
.vis-timeline .vis-bar {
	fill-opacity: 0.5; stroke-width: 1px
}
.vis-timeline .vis-point {
	fill-opacity: 1.0; stroke-width: 2px
}
.vis-timeline .vis-legend-background {
	fill: #ffffff; fill-opacity: 0.9; stroke-width: 1px; stroke: #c2c2c2
}
.vis-timeline .vis-outline {
	fill: #ffffff; fill-opacity: 1; stroke-width: 1px; stroke: #e5e5e5
}
.vis-timeline .vis-icon-fill {
	fill-opacity: 0.3; stroke: none
}
DIV.vis-network DIV.vis-manipulation {
	BORDER-BOTTOM: #d6d9d8 1px solid; POSITION: absolute; FILTER: =
progid:DXImageTransform.Microsoft.gradient( startColorstr=3D'#ffffff', =
endColorstr=3D'#fcfcfc',GradientType=3D0 ); BORDER-LEFT: #d6d9d8 0px =
solid; WIDTH: 100%; BACKGROUND: #ffffff; HEIGHT: 30px; BORDER-TOP: =
#d6d9d8 0px solid; TOP: 0px; BORDER-RIGHT: #d6d9d8 0px solid; LEFT: 0px
}
DIV.vis-network DIV.vis-edit-mode {
	POSITION: absolute; HEIGHT: 30px; TOP: 15px; LEFT: 0px
}
DIV.vis-network DIV.vis-close {
	BACKGROUND-IMAGE: url(img/network/cross.png); POSITION: absolute; =
WIDTH: 30px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: 20px =
3px; HEIGHT: 30px; TOP: 0px; CURSOR: pointer; RIGHT: 0px; =
-webkit-touch-callout: none; -webkit-user-select: none; =
-khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; =
user-select: none
}
DIV.vis-network DIV.vis-close:hover {
	opacity: 0.6
}
DIV.vis-network DIV.vis-manipulation DIV.vis-button {
	POSITION: relative; PADDING-BOTTOM: 0px; MARGIN: 0px 0px 0px 10px; =
PADDING-LEFT: 8px; PADDING-RIGHT: 8px; DISPLAY: inline-block; =
BACKGROUND-REPEAT: no-repeat; FONT-FAMILY: verdana; BACKGROUND-POSITION: =
0px 0px; HEIGHT: 24px; FONT-SIZE: 12px; VERTICAL-ALIGN: middle; TOP: =
-7px; CURSOR: pointer; PADDING-TOP: 0px; border-radius: 15px; =
-webkit-touch-callout: none; -webkit-user-select: none; =
-khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; =
user-select: none; -moz-border-radius: 15px
}
DIV.vis-network DIV.vis-edit-mode DIV.vis-button {
	POSITION: relative; PADDING-BOTTOM: 0px; MARGIN: 0px 0px 0px 10px; =
PADDING-LEFT: 8px; PADDING-RIGHT: 8px; DISPLAY: inline-block; =
BACKGROUND-REPEAT: no-repeat; FONT-FAMILY: verdana; BACKGROUND-POSITION: =
0px 0px; HEIGHT: 24px; FONT-SIZE: 12px; VERTICAL-ALIGN: middle; TOP: =
-7px; CURSOR: pointer; PADDING-TOP: 0px; border-radius: 15px; =
-webkit-touch-callout: none; -webkit-user-select: none; =
-khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; =
user-select: none; -moz-border-radius: 15px
}
DIV.vis-network DIV.vis-manipulation DIV.vis-button:hover {
	box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.20)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-button:active {
	box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.50)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-back.vis-button {
	BACKGROUND-IMAGE: url(img/network/backIcon.png)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-none.vis-button:hover {
	CURSOR: default; box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.0)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-none.vis-button:active {
	box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.0)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-none.vis-button {
	PADDING-BOTTOM: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; =
PADDING-TOP: 0px
}
DIV.vis-network DIV.vis-manipulation DIV.notification {
	MARGIN: 2px; FONT-WEIGHT: bold
}
DIV.vis-network DIV.vis-manipulation DIV.vis-add.vis-button {
	BACKGROUND-IMAGE: url(img/network/addNodeIcon.png)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-edit.vis-button {
	BACKGROUND-IMAGE: url(img/network/editIcon.png)
}
DIV.vis-network DIV.vis-edit-mode DIV.vis-edit.vis-button {
	BACKGROUND-IMAGE: url(img/network/editIcon.png)
}
DIV.vis-network DIV.vis-edit-mode DIV.vis-edit-mode.vis-edit.vis-button =
{
	BORDER-BOTTOM: #cccccc 1px solid; BORDER-LEFT: #cccccc 1px solid; =
BACKGROUND-COLOR: #fcfcfc; BORDER-TOP: #cccccc 1px solid; BORDER-RIGHT: =
#cccccc 1px solid
}
DIV.vis-network DIV.vis-manipulation DIV.vis-connect.vis-button {
	BACKGROUND-IMAGE: url(img/network/connectIcon.png)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-delete.vis-button {
	BACKGROUND-IMAGE: url(img/network/deleteIcon.png)
}
DIV.vis-network DIV.vis-manipulation DIV.vis-label {
	LINE-HEIGHT: 25px; MARGIN: 0px 0px 0px 23px
}
DIV.vis-network DIV.vis-edit-mode DIV.vis-label {
	LINE-HEIGHT: 25px; MARGIN: 0px 0px 0px 23px
}
DIV.vis-network DIV.vis-manipulation DIV.vis-separator-line {
	BACKGROUND-COLOR: #bdbdbd; MARGIN: 5px 7px 0px 15px; WIDTH: 1px; =
DISPLAY: inline-block; HEIGHT: 20px
}
DIV.vis-network DIV.vis-navigation DIV.vis-button {
	POSITION: absolute; WIDTH: 34px; DISPLAY: inline-block; =
BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: 2px 2px; HEIGHT: =
34px; CURSOR: pointer; border-radius: 17px; -webkit-touch-callout: none; =
-webkit-user-select: none; -khtml-user-select: none; -moz-user-select: =
none; -ms-user-select: none; user-select: none; -moz-border-radius: 17px
}
DIV.vis-network DIV.vis-navigation DIV.vis-button:hover {
	box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.30)
}
DIV.vis-network DIV.vis-navigation DIV.vis-button:active {
	box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95)
}
DIV.vis-network DIV.vis-navigation DIV.vis-up.vis-button {
	BACKGROUND-IMAGE: url(img/network/upArrow.png); BOTTOM: 50px; LEFT: =
55px
}
DIV.vis-network DIV.vis-navigation DIV.vis-down.vis-button {
	BACKGROUND-IMAGE: url(img/network/downArrow.png); BOTTOM: 10px; LEFT: =
55px
}
DIV.vis-network DIV.vis-navigation DIV.vis-left.vis-button {
	BACKGROUND-IMAGE: url(img/network/leftArrow.png); BOTTOM: 10px; LEFT: =
15px
}
DIV.vis-network DIV.vis-navigation DIV.vis-right.vis-button {
	BACKGROUND-IMAGE: url(img/network/rightArrow.png); BOTTOM: 10px; LEFT: =
95px
}
DIV.vis-network DIV.vis-navigation DIV.vis-zoomIn.vis-button {
	BACKGROUND-IMAGE: url(img/network/plus.png); BOTTOM: 10px; RIGHT: 15px
}
DIV.vis-network DIV.vis-navigation DIV.vis-zoomOut.vis-button {
	BACKGROUND-IMAGE: url(img/network/minus.png); BOTTOM: 10px; RIGHT: 55px
}
DIV.vis-network DIV.vis-navigation DIV.vis-zoomExtends.vis-button {
	BACKGROUND-IMAGE: url(img/network/zoomExtends.png); BOTTOM: 50px; =
RIGHT: 15px
}
DIV.vis-network-tooltip {
	BORDER-BOTTOM: #808074 1px solid; POSITION: absolute; BORDER-LEFT: =
#808074 1px solid; PADDING-BOTTOM: 5px; BACKGROUND-COLOR: #f5f4ed; =
PADDING-LEFT: 5px; PADDING-RIGHT: 5px; FONT-FAMILY: verdana; =
WHITE-SPACE: nowrap; VISIBILITY: hidden; FONT-SIZE: 14px; BORDER-TOP: =
#808074 1px solid; BORDER-RIGHT: #808074 1px solid; PADDING-TOP: 5px; =
box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2); border-radius: 3px; =
-moz-border-radius: 3px; font-color: #000000; -webkit-border-radius: =
3px; pointer-events: none
}
DIV.vis-network-configuration {
	POSITION: relative; DISPLAY: block; FLOAT: left; FONT-SIZE: 12px
}
DIV.vis-network-configuration-wrapper {
	WIDTH: 700px; DISPLAY: block
}
DIV.vis-option-container.vis-network-configuration {
	BORDER-BOTTOM: #f7f8fa 2px solid; BORDER-LEFT: #f7f8fa 2px solid; =
BACKGROUND-COLOR: #ffffff; MARGIN-TOP: 20px; PADDING-LEFT: 5px; WIDTH: =
495px; DISPLAY: block; BORDER-TOP: #f7f8fa 2px solid; BORDER-RIGHT: =
#f7f8fa 2px solid; LEFT: 10px; border-radius: 4px
}
DIV.button.vis-network-configuration {
	BORDER-BOTTOM: #ceced0 2px solid; BORDER-LEFT: #ceced0 2px solid; =
LINE-HEIGHT: 25px; BACKGROUND-COLOR: #f7f8fa; MARGIN-TOP: 20px; =
PADDING-LEFT: 5px; WIDTH: 495px; DISPLAY: block; MARGIN-BOTTOM: 30px; =
HEIGHT: 25px; VERTICAL-ALIGN: middle; BORDER-TOP: #ceced0 2px solid; =
CURSOR: pointer; BORDER-RIGHT: #ceced0 2px solid; LEFT: 10px; =
border-radius: 4px
}
DIV.hover.button.vis-network-configuration {
	BORDER-BOTTOM: #214373 2px solid; BORDER-LEFT: #214373 2px solid; =
BACKGROUND-COLOR: #4588e6; COLOR: #ffffff; BORDER-TOP: #214373 2px =
solid; BORDER-RIGHT: #214373 2px solid
}
DIV.item.vis-network-configuration {
	LINE-HEIGHT: 25px; WIDTH: 495px; DISPLAY: block; FLOAT: left; HEIGHT: =
25px; VERTICAL-ALIGN: middle
}
DIV.s2.item.vis-network-configuration {
	BACKGROUND-COLOR: #f7f8fa; PADDING-LEFT: 5px; LEFT: 10px; =
border-radius: 3px
}
DIV.s3.item.vis-network-configuration {
	BACKGROUND-COLOR: #e4e9f0; PADDING-LEFT: 5px; LEFT: 20px; =
border-radius: 3px
}
DIV.s4.item.vis-network-configuration {
	BACKGROUND-COLOR: #cfd8e6; PADDING-LEFT: 5px; LEFT: 30px; =
border-radius: 3px
}
DIV.header.vis-network-configuration {
	FONT-SIZE: 18px; FONT-WEIGHT: bold
}
DIV.label.vis-network-configuration {
	LINE-HEIGHT: 25px; WIDTH: 120px; HEIGHT: 25px
}
DIV.s3.label.vis-network-configuration {
	WIDTH: 110px
}
DIV.s4.label.vis-network-configuration {
	WIDTH: 100px
}
DIV.colorBlock.vis-network-configuration {
	BORDER-BOTTOM: #444444 1px solid; BORDER-LEFT: #444444 1px solid; =
PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; WIDTH: 30px; =
PADDING-RIGHT: 0px; HEIGHT: 19px; BORDER-TOP: #444444 1px solid; TOP: =
1px; CURSOR: pointer; BORDER-RIGHT: #444444 1px solid; PADDING-TOP: 0px; =
border-radius: 2px
}
INPUT.checkbox.vis-network-configuration {
	LEFT: -5px
}
INPUT.rangeinput.vis-network-configuration {
	POSITION: relative; PADDING-BOTTOM: 1px; MARGIN: 0px; PADDING-LEFT: =
1px; WIDTH: 60px; PADDING-RIGHT: 1px; HEIGHT: 13px; TOP: -5px; =
PADDING-TOP: 1px; pointer-events: none
}
INPUT.range.vis-network-configuration {
	BORDER-BOTTOM: white 0px solid; BORDER-LEFT: white 0px solid; WIDTH: =
300px; HEIGHT: 20px; BORDER-TOP: white 0px solid; BORDER-RIGHT: white =
0px solid; -webkit-appearance: none
}
INPUT.range.vis-network-configuration:focus {
	OUTLINE-STYLE: none; OUTLINE-COLOR: invert; OUTLINE-WIDTH: medium
}
DIV.vis-color-picker {
	POSITION: absolute; PADDING-BOTTOM: 10px; BACKGROUND-COLOR: #ffffff; =
MARGIN-TOP: -140px; PADDING-LEFT: 10px; WIDTH: 293px; PADDING-RIGHT: =
10px; DISPLAY: none; HEIGHT: 425px; MARGIN-LEFT: 30px; PADDING-TOP: =
10px; box-shadow: rgba(0, 0, 0, 0.5) 0px 0px 10px 0px; border-radius: =
15px
}
DIV.vis-color-picker DIV.vis-arrow {
	POSITION: absolute; TOP: 147px; LEFT: 5px
}
DIV.vis-color-picker DIV.vis-arrow:after {
	BORDER-BOTTOM: transparent solid; POSITION: absolute; BORDER-LEFT: =
transparent solid; WIDTH: 0px; HEIGHT: 0px; BORDER-TOP: transparent =
solid; CONTENT: " "; TOP: 50%; RIGHT: 100%; BORDER-RIGHT: transparent =
solid; pointer-events: none
}
DIV.vis-color-picker DIV.vis-arrow:before {
	BORDER-BOTTOM: transparent solid; POSITION: absolute; BORDER-LEFT: =
transparent solid; WIDTH: 0px; HEIGHT: 0px; BORDER-TOP: transparent =
solid; CONTENT: " "; TOP: 50%; RIGHT: 100%; BORDER-RIGHT: transparent =
solid; pointer-events: none
}
DIV.vis-color-picker DIV.vis-arrow:after {
	BORDER-RIGHT-WIDTH: 30px; MARGIN-TOP: -30px; BORDER-TOP-WIDTH: 30px; =
BORDER-BOTTOM-WIDTH: 30px; BORDER-RIGHT-COLOR: #ffffff; =
BORDER-LEFT-WIDTH: 30px
}
DIV.vis-color-picker DIV.vis-color {
	POSITION: absolute; WIDTH: 289px; HEIGHT: 289px; CURSOR: pointer
}
DIV.vis-color-picker DIV.vis-brightness {
	POSITION: absolute; TOP: 313px
}
DIV.vis-color-picker DIV.vis-opacity {
	POSITION: absolute; TOP: 350px
}
DIV.vis-color-picker DIV.vis-selector {
	BORDER-BOTTOM: #ffffff 1px solid; POSITION: absolute; FILTER: =
progid:DXImageTransform.Microsoft.gradient( startColorstr=3D'#4c4c4c', =
endColorstr=3D'#131313',GradientType=3D0 ); BORDER-LEFT: #ffffff 1px =
solid; WIDTH: 15px; BACKGROUND: #4c4c4c; HEIGHT: 15px; BORDER-TOP: =
#ffffff 1px solid; TOP: 137px; BORDER-RIGHT: #ffffff 1px solid; LEFT: =
137px; border-radius: 15px
}
DIV.vis-color-picker DIV.vis-new-color {
	POSITION: absolute; TEXT-ALIGN: right; LINE-HEIGHT: 20px; WIDTH: 140px; =
PADDING-RIGHT: 2px; HEIGHT: 20px; FONT-SIZE: 10px; VERTICAL-ALIGN: =
middle; TOP: 380px; LEFT: 159px; border-radius: 5px
}
DIV.vis-color-picker DIV.vis-initial-color {
	POSITION: absolute; TEXT-ALIGN: left; LINE-HEIGHT: 20px; PADDING-LEFT: =
2px; WIDTH: 140px; HEIGHT: 20px; FONT-SIZE: 10px; VERTICAL-ALIGN: =
middle; TOP: 380px; LEFT: 10px; border-radius: 5px
}
DIV.vis-color-picker DIV.vis-label {
	POSITION: absolute; WIDTH: 300px; LEFT: 10px
}
DIV.vis-color-picker DIV.vis-brightness.vis-label {
	TOP: 300px
}
DIV.vis-color-picker DIV.vis-opacity.vis-label {
	TOP: 338px
}
DIV.vis-color-picker DIV.vis-button {
	BORDER-BOTTOM: #d9d9d9 2px solid; POSITION: absolute; TEXT-ALIGN: =
center; BORDER-LEFT: #d9d9d9 2px solid; LINE-HEIGHT: 25px; =
BACKGROUND-COLOR: #f7f7f7; WIDTH: 68px; HEIGHT: 25px; VERTICAL-ALIGN: =
middle; BORDER-TOP: #d9d9d9 2px solid; TOP: 410px; CURSOR: pointer; =
BORDER-RIGHT: #d9d9d9 2px solid; border-radius: 10px
}
DIV.vis-color-picker DIV.vis-cancel.vis-button {
	LEFT: 5px
}
DIV.vis-color-picker DIV.vis-load.vis-button {
	LEFT: 82px
}
DIV.vis-color-picker DIV.vis-apply.vis-button {
	LEFT: 159px
}
DIV.vis-color-picker DIV.vis-save.vis-button {
	LEFT: 236px
}
DIV.vis-color-picker INPUT.vis-range {
	WIDTH: 290px; HEIGHT: 20px
}

------=_NextPart_000_0000_01D0E0D4.83203900
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://visjs.org/examples/network/exampleUtil.js

/**=0A=
 * Created by Alex on 5/20/2015.=0A=
 */=0A=
=0A=
function loadJSON(path, success, error) {=0A=
  var xhr =3D new XMLHttpRequest();=0A=
  xhr.onreadystatechange =3D function () {=0A=
    if (xhr.readyState =3D=3D=3D 4) {=0A=
      if (xhr.status =3D=3D=3D 200) {=0A=
        success(JSON.parse(xhr.responseText));=0A=
      }=0A=
      else {=0A=
        error(xhr);=0A=
      }=0A=
    }=0A=
  };=0A=
  xhr.open('GET', path, true);=0A=
  xhr.send();=0A=
}=0A=
=0A=
=0A=
function getScaleFreeNetwork(nodeCount) {=0A=
  var nodes =3D [];=0A=
  var edges =3D [];=0A=
  var connectionCount =3D [];=0A=
=0A=
  // randomly create some nodes and edges=0A=
  for (var i =3D 0; i < nodeCount; i++) {=0A=
    nodes.push({=0A=
      id: i,=0A=
      label: String(i)=0A=
    });=0A=
=0A=
    connectionCount[i] =3D 0;=0A=
=0A=
    // create edges in a scale-free-network way=0A=
    if (i =3D=3D 1) {=0A=
      var from =3D i;=0A=
      var to =3D 0;=0A=
      edges.push({=0A=
        from: from,=0A=
        to: to=0A=
      });=0A=
      connectionCount[from]++;=0A=
      connectionCount[to]++;=0A=
    }=0A=
    else if (i > 1) {=0A=
      var conn =3D edges.length * 2;=0A=
      var rand =3D Math.floor(Math.random() * conn);=0A=
      var cum =3D 0;=0A=
      var j =3D 0;=0A=
      while (j < connectionCount.length && cum < rand) {=0A=
        cum +=3D connectionCount[j];=0A=
        j++;=0A=
      }=0A=
=0A=
=0A=
      var from =3D i;=0A=
      var to =3D j;=0A=
      edges.push({=0A=
        from: from,=0A=
        to: to=0A=
      });=0A=
      connectionCount[from]++;=0A=
      connectionCount[to]++;=0A=
    }=0A=
  }=0A=
=0A=
  return {nodes:nodes, edges:edges};=0A=
}
------=_NextPart_000_0000_01D0E0D4.83203900
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://visjs.org/dist/vis.js

/**=0A=
 * vis.js=0A=
 * https://github.com/almende/vis=0A=
 *=0A=
 * A dynamic, browser-based visualization library.=0A=
 *=0A=
 * @version 4.7.0=0A=
 * @date    2015-07-27=0A=
 *=0A=
 * @license=0A=
 * Copyright (C) 2011-2014 Almende B.V, http://almende.com=0A=
 *=0A=
 * Vis.js is dual licensed under both=0A=
 *=0A=
 * * The Apache 2.0 License=0A=
 *   http://www.apache.org/licenses/LICENSE-2.0=0A=
 *=0A=
 * and=0A=
 *=0A=
 * * The MIT License=0A=
 *   http://opensource.org/licenses/MIT=0A=
 *=0A=
 * Vis.js may be distributed under either license.=0A=
 */=0A=
=0A=
"use strict";=0A=
=0A=
(function webpackUniversalModuleDefinition(root, factory) {=0A=
	if(typeof exports =3D=3D=3D 'object' && typeof module =3D=3D=3D =
'object')=0A=
		module.exports =3D factory();=0A=
	else if(typeof define =3D=3D=3D 'function' && define.amd)=0A=
		define(factory);=0A=
	else if(typeof exports =3D=3D=3D 'object')=0A=
		exports["vis"] =3D factory();=0A=
	else=0A=
		root["vis"] =3D factory();=0A=
})(this, function() {=0A=
return /******/ (function(modules) { // webpackBootstrap=0A=
/******/ 	// The module cache=0A=
/******/ 	var installedModules =3D {};=0A=
=0A=
/******/ 	// The require function=0A=
/******/ 	function __webpack_require__(moduleId) {=0A=
=0A=
/******/ 		// Check if module is in cache=0A=
/******/ 		if(installedModules[moduleId])=0A=
/******/ 			return installedModules[moduleId].exports;=0A=
=0A=
/******/ 		// Create a new module (and put it into the cache)=0A=
/******/ 		var module =3D installedModules[moduleId] =3D {=0A=
/******/ 			exports: {},=0A=
/******/ 			id: moduleId,=0A=
/******/ 			loaded: false=0A=
/******/ 		};=0A=
=0A=
/******/ 		// Execute the module function=0A=
/******/ 		modules[moduleId].call(module.exports, module, =
module.exports, __webpack_require__);=0A=
=0A=
/******/ 		// Flag the module as loaded=0A=
/******/ 		module.loaded =3D true;=0A=
=0A=
/******/ 		// Return the exports of the module=0A=
/******/ 		return module.exports;=0A=
/******/ 	}=0A=
=0A=
=0A=
/******/ 	// expose the modules object (__webpack_modules__)=0A=
/******/ 	__webpack_require__.m =3D modules;=0A=
=0A=
/******/ 	// expose the module cache=0A=
/******/ 	__webpack_require__.c =3D installedModules;=0A=
=0A=
/******/ 	// __webpack_public_path__=0A=
/******/ 	__webpack_require__.p =3D "";=0A=
=0A=
/******/ 	// Load entry module and return exports=0A=
/******/ 	return __webpack_require__(0);=0A=
/******/ })=0A=
/************************************************************************=
/=0A=
/******/ ([=0A=
/* 0 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  // utils=0A=
  'use strict';=0A=
=0A=
  exports.util =3D __webpack_require__(7);=0A=
  exports.DOMutil =3D __webpack_require__(13);=0A=
=0A=
  // data=0A=
  exports.DataSet =3D __webpack_require__(14);=0A=
  exports.DataView =3D __webpack_require__(16);=0A=
  exports.Queue =3D __webpack_require__(15);=0A=
=0A=
  // Graph3d=0A=
  exports.Graph3d =3D __webpack_require__(17);=0A=
  exports.graph3d =3D {=0A=
    Camera: __webpack_require__(21),=0A=
    Filter: __webpack_require__(22),=0A=
    Point2d: __webpack_require__(18),=0A=
    Point3d: __webpack_require__(20),=0A=
    Slider: __webpack_require__(23),=0A=
    StepNumber: __webpack_require__(24)=0A=
  };=0A=
=0A=
  // Timeline=0A=
  exports.Timeline =3D __webpack_require__(25);=0A=
  exports.Graph2d =3D __webpack_require__(49);=0A=
  exports.timeline =3D {=0A=
    DateUtil: __webpack_require__(29),=0A=
    DataStep: __webpack_require__(52),=0A=
    Range: __webpack_require__(26),=0A=
    stack: __webpack_require__(33),=0A=
    TimeStep: __webpack_require__(35),=0A=
=0A=
    components: {=0A=
      items: {=0A=
        Item: __webpack_require__(2),=0A=
        BackgroundItem: __webpack_require__(38),=0A=
        BoxItem: __webpack_require__(37),=0A=
        PointItem: __webpack_require__(1),=0A=
        RangeItem: __webpack_require__(34)=0A=
      },=0A=
=0A=
      Component: __webpack_require__(28),=0A=
      CurrentTime: __webpack_require__(44),=0A=
      CustomTime: __webpack_require__(42),=0A=
      DataAxis: __webpack_require__(51),=0A=
      GraphGroup: __webpack_require__(53),=0A=
      Group: __webpack_require__(32),=0A=
      BackgroundGroup: __webpack_require__(36),=0A=
      ItemSet: __webpack_require__(31),=0A=
      Legend: __webpack_require__(57),=0A=
      LineGraph: __webpack_require__(50),=0A=
      TimeAxis: __webpack_require__(39)=0A=
    }=0A=
  };=0A=
=0A=
  // Network=0A=
  exports.Network =3D __webpack_require__(59);=0A=
  exports.network =3D {=0A=
    Images: __webpack_require__(114),=0A=
    dotparser: __webpack_require__(112),=0A=
    gephiParser: __webpack_require__(113),=0A=
    allOptions: __webpack_require__(110)=0A=
  };=0A=
  exports.network.convertDot =3D function (input) {=0A=
    return exports.network.dotparser.DOTToGraph(input);=0A=
  };=0A=
  exports.network.convertGephi =3D function (input, options) {=0A=
    return exports.network.gephiParser.parseGephi(input, options);=0A=
  };=0A=
=0A=
  // Deprecated since v3.0.0=0A=
  exports.Graph =3D function () {=0A=
    throw new Error('Graph is renamed to Network. Please create a graph =
as new vis.Network(...)');=0A=
  };=0A=
=0A=
  // bundled external libraries=0A=
  exports.moment =3D __webpack_require__(8);=0A=
  exports.hammer =3D __webpack_require__(3); // TODO: deprecate =
exports.hammer some day=0A=
  exports.Hammer =3D __webpack_require__(3);=0A=
  exports.keycharm =3D __webpack_require__(41);=0A=
=0A=
/***/ },=0A=
/* 1 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Item =3D __webpack_require__(2);=0A=
=0A=
  /**=0A=
   * @constructor PointItem=0A=
   * @extends Item=0A=
   * @param {Object} data             Object containing parameters start=0A=
   *                                  content, className.=0A=
   * @param {{toScreen: function, toTime: function}} conversion=0A=
   *                                  Conversion functions from time to =
screen and vice versa=0A=
   * @param {Object} [options]        Configuration options=0A=
   *                                  // TODO: describe available options=0A=
   */=0A=
  function PointItem(data, conversion, options) {=0A=
    this.props =3D {=0A=
      dot: {=0A=
        top: 0,=0A=
        width: 0,=0A=
        height: 0=0A=
      },=0A=
      content: {=0A=
        height: 0,=0A=
        marginLeft: 0=0A=
      }=0A=
    };=0A=
=0A=
    // validate data=0A=
    if (data) {=0A=
      if (data.start =3D=3D undefined) {=0A=
        throw new Error('Property "start" missing in item ' + data);=0A=
      }=0A=
    }=0A=
=0A=
    Item.call(this, data, conversion, options);=0A=
  }=0A=
=0A=
  PointItem.prototype =3D new Item(null, null, null);=0A=
=0A=
  /**=0A=
   * Check whether this item is visible inside given range=0A=
   * @returns {{start: Number, end: Number}} range with a timestamp for =
start and end=0A=
   * @returns {boolean} True if visible=0A=
   */=0A=
  PointItem.prototype.isVisible =3D function (range) {=0A=
    // determine visibility=0A=
    // TODO: account for the real width of the item. Right now we just =
add 1/4 to the window=0A=
    var interval =3D (range.end - range.start) / 4;=0A=
    return this.data.start > range.start - interval && this.data.start < =
range.end + interval;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the item=0A=
   */=0A=
  PointItem.prototype.redraw =3D function () {=0A=
    var dom =3D this.dom;=0A=
    if (!dom) {=0A=
      // create DOM=0A=
      this.dom =3D {};=0A=
      dom =3D this.dom;=0A=
=0A=
      // background box=0A=
      dom.point =3D document.createElement('div');=0A=
      // className is updated in redraw()=0A=
=0A=
      // contents box, right from the dot=0A=
      dom.content =3D document.createElement('div');=0A=
      dom.content.className =3D 'vis-item-content';=0A=
      dom.point.appendChild(dom.content);=0A=
=0A=
      // dot at start=0A=
      dom.dot =3D document.createElement('div');=0A=
      dom.point.appendChild(dom.dot);=0A=
=0A=
      // attach this item as attribute=0A=
      dom.point['timeline-item'] =3D this;=0A=
=0A=
      this.dirty =3D true;=0A=
    }=0A=
=0A=
    // append DOM to parent DOM=0A=
    if (!this.parent) {=0A=
      throw new Error('Cannot redraw item: no parent attached');=0A=
    }=0A=
    if (!dom.point.parentNode) {=0A=
      var foreground =3D this.parent.dom.foreground;=0A=
      if (!foreground) {=0A=
        throw new Error('Cannot redraw item: parent has no foreground =
container element');=0A=
      }=0A=
      foreground.appendChild(dom.point);=0A=
    }=0A=
    this.displayed =3D true;=0A=
=0A=
    // Update DOM when item is marked dirty. An item is marked dirty =
when:=0A=
    // - the item is not yet rendered=0A=
    // - the item's data is changed=0A=
    // - the item is selected/deselected=0A=
    if (this.dirty) {=0A=
      this._updateContents(this.dom.content);=0A=
      this._updateTitle(this.dom.point);=0A=
      this._updateDataAttributes(this.dom.point);=0A=
      this._updateStyle(this.dom.point);=0A=
=0A=
      var editable =3D (this.options.editable.updateTime || =
this.options.editable.updateGroup || this.editable =3D=3D=3D true) && =
this.editable !=3D=3D false;=0A=
=0A=
      // update class=0A=
      var className =3D (this.data.className ? ' ' + this.data.className =
: '') + (this.selected ? ' vis-selected' : '') + (editable ? ' =
vis-editable' : ' vis-readonly');=0A=
      dom.point.className =3D 'vis-item vis-point' + className;=0A=
      dom.dot.className =3D 'vis-item vis-dot' + className;=0A=
=0A=
      // recalculate size of dot and contents=0A=
      this.props.dot.width =3D dom.dot.offsetWidth;=0A=
      this.props.dot.height =3D dom.dot.offsetHeight;=0A=
      this.props.content.height =3D dom.content.offsetHeight;=0A=
=0A=
      // resize contents=0A=
      dom.content.style.marginLeft =3D 2 * this.props.dot.width + 'px';=0A=
      //dom.content.style.marginRight =3D ... + 'px'; // TODO: margin =
right=0A=
=0A=
      dom.dot.style.top =3D (this.height - this.props.dot.height) / 2 + =
'px';=0A=
      dom.dot.style.left =3D this.props.dot.width / 2 + 'px';=0A=
=0A=
      // recalculate size=0A=
      this.width =3D dom.point.offsetWidth;=0A=
      this.height =3D dom.point.offsetHeight;=0A=
=0A=
      this.dirty =3D false;=0A=
    }=0A=
=0A=
    this._repaintDeleteButton(dom.point);=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the item in the DOM (when not already visible). The items DOM =
will=0A=
   * be created when needed.=0A=
   */=0A=
  PointItem.prototype.show =3D function () {=0A=
    if (!this.displayed) {=0A=
      this.redraw();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the item from the DOM (when visible)=0A=
   */=0A=
  PointItem.prototype.hide =3D function () {=0A=
    if (this.displayed) {=0A=
      if (this.dom.point.parentNode) {=0A=
        this.dom.point.parentNode.removeChild(this.dom.point);=0A=
      }=0A=
=0A=
      this.displayed =3D false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Reposition the item horizontally=0A=
   * @Override=0A=
   */=0A=
  PointItem.prototype.repositionX =3D function () {=0A=
    var start =3D this.conversion.toScreen(this.data.start);=0A=
=0A=
    this.left =3D start - this.props.dot.width;=0A=
=0A=
    // reposition point=0A=
    this.dom.point.style.left =3D this.left + 'px';=0A=
  };=0A=
=0A=
  /**=0A=
   * Reposition the item vertically=0A=
   * @Override=0A=
   */=0A=
  PointItem.prototype.repositionY =3D function () {=0A=
    var orientation =3D this.options.orientation.item;=0A=
    var point =3D this.dom.point;=0A=
=0A=
    if (orientation =3D=3D 'top') {=0A=
      point.style.top =3D this.top + 'px';=0A=
    } else {=0A=
      point.style.top =3D this.parent.height - this.top - this.height + =
'px';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the width of the item left from its start date=0A=
   * @return {number}=0A=
   */=0A=
  PointItem.prototype.getWidthLeft =3D function () {=0A=
    return this.props.dot.width;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the width of the item right from  its start date=0A=
   * @return {number}=0A=
   */=0A=
  PointItem.prototype.getWidthRight =3D function () {=0A=
    return this.width - this.props.dot.width;=0A=
  };=0A=
=0A=
  module.exports =3D PointItem;=0A=
=0A=
/***/ },=0A=
/* 2 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * @constructor Item=0A=
   * @param {Object} data             Object containing (optional) =
parameters type,=0A=
   *                                  start, end, content, group, =
className.=0A=
   * @param {{toScreen: function, toTime: function}} conversion=0A=
   *                                  Conversion functions from time to =
screen and vice versa=0A=
   * @param {Object} options          Configuration options=0A=
   *                                  // TODO: describe available options=0A=
   */=0A=
  function Item(data, conversion, options) {=0A=
    this.id =3D null;=0A=
    this.parent =3D null;=0A=
    this.data =3D data;=0A=
    this.dom =3D null;=0A=
    this.conversion =3D conversion || {};=0A=
    this.options =3D options || {};=0A=
=0A=
    this.selected =3D false;=0A=
    this.displayed =3D false;=0A=
    this.dirty =3D true;=0A=
=0A=
    this.top =3D null;=0A=
    this.left =3D null;=0A=
    this.width =3D null;=0A=
    this.height =3D null;=0A=
=0A=
    this.editable =3D null;=0A=
    if (this.data && this.data.hasOwnProperty('editable') && typeof =
this.data.editable =3D=3D=3D 'boolean') {=0A=
      this.editable =3D data.editable;=0A=
    }=0A=
  }=0A=
=0A=
  Item.prototype.stack =3D true;=0A=
=0A=
  /**=0A=
   * Select current item=0A=
   */=0A=
  Item.prototype.select =3D function () {=0A=
    this.selected =3D true;=0A=
    this.dirty =3D true;=0A=
    if (this.displayed) this.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Unselect current item=0A=
   */=0A=
  Item.prototype.unselect =3D function () {=0A=
    this.selected =3D false;=0A=
    this.dirty =3D true;=0A=
    if (this.displayed) this.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Set data for the item. Existing data will be updated. The id should =
not=0A=
   * be changed. When the item is displayed, it will be redrawn =
immediately.=0A=
   * @param {Object} data=0A=
   */=0A=
  Item.prototype.setData =3D function (data) {=0A=
    var groupChanged =3D data.group !=3D undefined && this.data.group =
!=3D data.group;=0A=
    if (groupChanged) {=0A=
      this.parent.itemSet._moveToGroup(this, data.group);=0A=
    }=0A=
=0A=
    if (data.hasOwnProperty('editable') && typeof data.editable =
=3D=3D=3D 'boolean') {=0A=
      this.editable =3D data.editable;=0A=
    }=0A=
=0A=
    this.data =3D data;=0A=
    this.dirty =3D true;=0A=
    if (this.displayed) this.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a parent for the item=0A=
   * @param {ItemSet | Group} parent=0A=
   */=0A=
  Item.prototype.setParent =3D function (parent) {=0A=
    if (this.displayed) {=0A=
      this.hide();=0A=
      this.parent =3D parent;=0A=
      if (this.parent) {=0A=
        this.show();=0A=
      }=0A=
    } else {=0A=
      this.parent =3D parent;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Check whether this item is visible inside given range=0A=
   * @returns {{start: Number, end: Number}} range with a timestamp for =
start and end=0A=
   * @returns {boolean} True if visible=0A=
   */=0A=
  Item.prototype.isVisible =3D function (range) {=0A=
    // Should be implemented by Item implementations=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the Item in the DOM (when not already visible)=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  Item.prototype.show =3D function () {=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the Item from the DOM (when visible)=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  Item.prototype.hide =3D function () {=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the item=0A=
   */=0A=
  Item.prototype.redraw =3D function () {};=0A=
=0A=
  /**=0A=
   * Reposition the Item horizontally=0A=
   */=0A=
  Item.prototype.repositionX =3D function () {};=0A=
=0A=
  /**=0A=
   * Reposition the Item vertically=0A=
   */=0A=
  Item.prototype.repositionY =3D function () {};=0A=
=0A=
  /**=0A=
   * Repaint a delete button on the top right of the item when the item =
is selected=0A=
   * @param {HTMLElement} anchor=0A=
   * @protected=0A=
   */=0A=
  Item.prototype._repaintDeleteButton =3D function (anchor) {=0A=
    var editable =3D (this.options.editable.remove || this.data.editable =
=3D=3D=3D true) && this.data.editable !=3D=3D false;=0A=
=0A=
    if (this.selected && editable && !this.dom.deleteButton) {=0A=
      // create and show button=0A=
      var me =3D this;=0A=
=0A=
      var deleteButton =3D document.createElement('div');=0A=
      deleteButton.className =3D 'vis-delete';=0A=
      deleteButton.title =3D 'Delete this item';=0A=
=0A=
      // TODO: be able to destroy the delete button=0A=
      new Hammer(deleteButton).on('tap', function (event) {=0A=
        event.stopPropagation();=0A=
        me.parent.removeFromDataSet(me);=0A=
      });=0A=
=0A=
      anchor.appendChild(deleteButton);=0A=
      this.dom.deleteButton =3D deleteButton;=0A=
    } else if (!this.selected && this.dom.deleteButton) {=0A=
      // remove button=0A=
      if (this.dom.deleteButton.parentNode) {=0A=
        =
this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);=0A=
      }=0A=
      this.dom.deleteButton =3D null;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set HTML contents for the item=0A=
   * @param {Element} element   HTML element to fill with the contents=0A=
   * @private=0A=
   */=0A=
  Item.prototype._updateContents =3D function (element) {=0A=
    var content;=0A=
    if (this.options.template) {=0A=
      var itemData =3D this.parent.itemSet.itemsData.get(this.id); // =
get a clone of the data from the dataset=0A=
      content =3D this.options.template(itemData);=0A=
    } else {=0A=
      content =3D this.data.content;=0A=
    }=0A=
=0A=
    var changed =3D this._contentToString(this.content) !=3D=3D =
this._contentToString(content);=0A=
    if (changed) {=0A=
      // only replace the content when changed=0A=
      if (content instanceof Element) {=0A=
        element.innerHTML =3D '';=0A=
        element.appendChild(content);=0A=
      } else if (content !=3D undefined) {=0A=
        element.innerHTML =3D content;=0A=
      } else {=0A=
        if (!(this.data.type =3D=3D 'background' && this.data.content =
=3D=3D=3D undefined)) {=0A=
          throw new Error('Property "content" missing in item ' + =
this.id);=0A=
        }=0A=
      }=0A=
=0A=
      this.content =3D content;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set HTML contents for the item=0A=
   * @param {Element} element   HTML element to fill with the contents=0A=
   * @private=0A=
   */=0A=
  Item.prototype._updateTitle =3D function (element) {=0A=
    if (this.data.title !=3D null) {=0A=
      element.title =3D this.data.title || '';=0A=
    } else {=0A=
      element.removeAttribute('vis-title');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Process dataAttributes timeline option and set as data- attributes =
on dom.content=0A=
   * @param {Element} element   HTML element to which the attributes =
will be attached=0A=
   * @private=0A=
   */=0A=
  Item.prototype._updateDataAttributes =3D function (element) {=0A=
    if (this.options.dataAttributes && =
this.options.dataAttributes.length > 0) {=0A=
      var attributes =3D [];=0A=
=0A=
      if (Array.isArray(this.options.dataAttributes)) {=0A=
        attributes =3D this.options.dataAttributes;=0A=
      } else if (this.options.dataAttributes =3D=3D 'all') {=0A=
        attributes =3D Object.keys(this.data);=0A=
      } else {=0A=
        return;=0A=
      }=0A=
=0A=
      for (var i =3D 0; i < attributes.length; i++) {=0A=
        var name =3D attributes[i];=0A=
        var value =3D this.data[name];=0A=
=0A=
        if (value !=3D null) {=0A=
          element.setAttribute('data-' + name, value);=0A=
        } else {=0A=
          element.removeAttribute('data-' + name);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Update custom styles of the element=0A=
   * @param element=0A=
   * @private=0A=
   */=0A=
  Item.prototype._updateStyle =3D function (element) {=0A=
    // remove old styles=0A=
    if (this.style) {=0A=
      util.removeCssText(element, this.style);=0A=
      this.style =3D null;=0A=
    }=0A=
=0A=
    // append new styles=0A=
    if (this.data.style) {=0A=
      util.addCssText(element, this.data.style);=0A=
      this.style =3D this.data.style;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Stringify the items contents=0A=
   * @param {string | Element | undefined} content=0A=
   * @returns {string | undefined}=0A=
   * @private=0A=
   */=0A=
  Item.prototype._contentToString =3D function (content) {=0A=
    if (typeof content =3D=3D=3D 'string') return content;=0A=
    if (content && 'outerHTML' in content) return content.outerHTML;=0A=
    return content;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the width of the item left from its start date=0A=
   * @return {number}=0A=
   */=0A=
  Item.prototype.getWidthLeft =3D function () {=0A=
    return 0;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the width of the item right from the max of its start and =
end date=0A=
   * @return {number}=0A=
   */=0A=
  Item.prototype.getWidthRight =3D function () {=0A=
    return 0;=0A=
  };=0A=
=0A=
  module.exports =3D Item;=0A=
=0A=
  // should be implemented by the item=0A=
=0A=
  // should be implemented by the item=0A=
=0A=
  // should be implemented by the item=0A=
=0A=
/***/ },=0A=
/* 3 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  // Only load hammer.js when in a browser environment=0A=
  // (loading hammer.js in a node.js environment gives errors)=0A=
  'use strict';=0A=
=0A=
  if (typeof window !=3D=3D 'undefined') {=0A=
    var propagating =3D __webpack_require__(4);=0A=
    var Hammer =3D window['Hammer'] || __webpack_require__(5);=0A=
    module.exports =3D propagating(Hammer, {=0A=
      preventDefault: 'mouse'=0A=
    });=0A=
  } else {=0A=
    module.exports =3D function () {=0A=
      throw Error('hammer.js is only available in a browser, not in =
node.js.');=0A=
    };=0A=
  }=0A=
=0A=
/***/ },=0A=
/* 4 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, =
__WEBPACK_AMD_DEFINE_RESULT__;'use strict';=0A=
=0A=
  (function (factory) {=0A=
    if (true) {=0A=
      // AMD. Register as an anonymous module.=0A=
      !(__WEBPACK_AMD_DEFINE_ARRAY__ =3D [], =
__WEBPACK_AMD_DEFINE_FACTORY__ =3D (factory), =
__WEBPACK_AMD_DEFINE_RESULT__ =3D (typeof __WEBPACK_AMD_DEFINE_FACTORY__ =
=3D=3D=3D 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, =
__WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), =
__WEBPACK_AMD_DEFINE_RESULT__ !=3D=3D undefined && (module.exports =3D =
__WEBPACK_AMD_DEFINE_RESULT__));=0A=
    } else if (typeof exports =3D=3D=3D 'object') {=0A=
      // Node. Does not work with strict CommonJS, but=0A=
      // only CommonJS-like environments that support module.exports,=0A=
      // like Node.=0A=
      module.exports =3D factory();=0A=
    } else {=0A=
      // Browser globals (root is window)=0A=
      window.propagating =3D factory();=0A=
    }=0A=
  }(function () {=0A=
    var _firstTarget =3D null; // singleton, will contain the target =
element where the touch event started=0A=
    var _processing =3D false; // singleton, true when a touch event is =
being handled=0A=
=0A=
    /**=0A=
     * Extend an Hammer.js instance with event propagation.=0A=
     *=0A=
     * Features:=0A=
     * - Events emitted by hammer will propagate in order from child to =
parent=0A=
     *   elements.=0A=
     * - Events are extended with a function `event.stopPropagation()` =
to stop=0A=
     *   propagation to parent elements.=0A=
     * - An option `preventDefault` to stop all default browser behavior.=0A=
     *=0A=
     * Usage:=0A=
     *   var hammer =3D propagatingHammer(new Hammer(element));=0A=
     *   var hammer =3D propagatingHammer(new Hammer(element), =
{preventDefault: true});=0A=
     *=0A=
     * @param {Hammer.Manager} hammer   An hammer instance.=0A=
     * @param {Object} [options]        Available options:=0A=
     *                                  - `preventDefault: true | =
'mouse' | 'touch' | 'pen'`.=0A=
     *                                    Enforce preventing the default =
browser behavior.=0A=
     *                                    Cannot be set to `false`.=0A=
     * @return {Hammer.Manager} Returns the same hammer instance with =
extended=0A=
     *                          functionality=0A=
     */=0A=
    return function propagating(hammer, options) {=0A=
      var _options =3D options || {=0A=
        preventDefault: false=0A=
      };=0A=
=0A=
      if (hammer.Manager) {=0A=
        // This looks like the Hammer constructor.=0A=
        // Overload the constructors with our own.=0A=
        var Hammer =3D hammer;=0A=
=0A=
        var PropagatingHammer =3D function(element, options) {=0A=
          var o =3D Object.create(_options);=0A=
          if (options) Hammer.extend(o, options);=0A=
          return propagating(new Hammer(element, o), o);=0A=
        };=0A=
        Hammer.extend(PropagatingHammer, Hammer);=0A=
=0A=
        PropagatingHammer.Manager =3D function (element, options) {=0A=
          var o =3D Object.create(_options);=0A=
          if (options) Hammer.extend(o, options);=0A=
          return propagating(new Hammer.Manager(element, o), o);=0A=
        };=0A=
=0A=
        return PropagatingHammer;=0A=
      }=0A=
=0A=
      // create a wrapper object which will override the functions=0A=
      // `on`, `off`, `destroy`, and `emit` of the hammer instance=0A=
      var wrapper =3D Object.create(hammer);=0A=
=0A=
      // attach to DOM element=0A=
      var element =3D hammer.element;=0A=
      element.hammer =3D wrapper;=0A=
=0A=
      // register an event to catch the start of a gesture and store the=0A=
      // target in a singleton=0A=
      hammer.on('hammer.input', function (event) {=0A=
        if (_options.preventDefault =3D=3D=3D true || =
(_options.preventDefault =3D=3D=3D event.pointerType)) {=0A=
          event.preventDefault();=0A=
        }=0A=
        if (event.isFirst) {=0A=
          _firstTarget =3D event.target;=0A=
        }=0A=
      });=0A=
=0A=
      /** @type {Object.<String, Array.<function>>} */=0A=
      wrapper._handlers =3D {};=0A=
=0A=
      /**=0A=
       * Register a handler for one or multiple events=0A=
       * @param {String} events    A space separated string with events=0A=
       * @param {function} handler A callback function, called as =
handler(event)=0A=
       * @returns {Hammer.Manager} Returns the hammer instance=0A=
       */=0A=
      wrapper.on =3D function (events, handler) {=0A=
        // register the handler=0A=
        split(events).forEach(function (event) {=0A=
          var _handlers =3D wrapper._handlers[event];=0A=
          if (!_handlers) {=0A=
            wrapper._handlers[event] =3D _handlers =3D [];=0A=
=0A=
            // register the static, propagated handler=0A=
            hammer.on(event, propagatedHandler);=0A=
          }=0A=
          _handlers.push(handler);=0A=
        });=0A=
=0A=
        return wrapper;=0A=
      };=0A=
=0A=
      /**=0A=
       * Unregister a handler for one or multiple events=0A=
       * @param {String} events      A space separated string with events=0A=
       * @param {function} [handler] Optional. The registered handler. =
If not=0A=
       *                             provided, all handlers for given =
events=0A=
       *                             are removed.=0A=
       * @returns {Hammer.Manager}   Returns the hammer instance=0A=
       */=0A=
      wrapper.off =3D function (events, handler) {=0A=
        // unregister the handler=0A=
        split(events).forEach(function (event) {=0A=
          var _handlers =3D wrapper._handlers[event];=0A=
          if (_handlers) {=0A=
            _handlers =3D handler ? _handlers.filter(function (h) {=0A=
              return h !=3D=3D handler;=0A=
            }) : [];=0A=
=0A=
            if (_handlers.length > 0) {=0A=
              wrapper._handlers[event] =3D _handlers;=0A=
            }=0A=
            else {=0A=
              // remove static, propagated handler=0A=
              hammer.off(event, propagatedHandler);=0A=
              delete wrapper._handlers[event];=0A=
            }=0A=
          }=0A=
        });=0A=
=0A=
        return wrapper;=0A=
      };=0A=
=0A=
      /**=0A=
       * Emit to the event listeners=0A=
       * @param {string} eventType=0A=
       * @param {Event} event=0A=
       */=0A=
      wrapper.emit =3D function(eventType, event) {=0A=
        _firstTarget =3D event.target;=0A=
        hammer.emit(eventType, event);=0A=
      };=0A=
=0A=
      wrapper.destroy =3D function () {=0A=
        // Detach from DOM element=0A=
        delete hammer.element.hammer;=0A=
=0A=
        // clear all handlers=0A=
        wrapper._handlers =3D {};=0A=
=0A=
        // call original hammer destroy=0A=
        hammer.destroy();=0A=
      };=0A=
=0A=
      // split a string with space separated words=0A=
      function split(events) {=0A=
        return events.match(/[^ ]+/g);=0A=
      }=0A=
=0A=
      /**=0A=
       * A static event handler, applying event propagation.=0A=
       * @param {Object} event=0A=
       */=0A=
      function propagatedHandler(event) {=0A=
        // let only a single hammer instance handle this event=0A=
        if (event.type !=3D=3D 'hammer.input') {=0A=
          // it is possible that the same srcEvent is used with multiple =
hammer events,=0A=
          // we keep track on which events are handled in an object =
_handled=0A=
          if (!event.srcEvent._handled) {=0A=
            event.srcEvent._handled =3D {};=0A=
          }=0A=
=0A=
          if (event.srcEvent._handled[event.type]) {=0A=
            return;=0A=
          }=0A=
          else {=0A=
            event.srcEvent._handled[event.type] =3D true;=0A=
          }=0A=
        }=0A=
=0A=
        // attach a stopPropagation function to the event=0A=
        var stopped =3D false;=0A=
        event.stopPropagation =3D function () {=0A=
          stopped =3D true;=0A=
        };=0A=
=0A=
        // attach firstTarget property to the event=0A=
        event.firstTarget =3D _firstTarget;=0A=
=0A=
        // propagate over all elements (until stopped)=0A=
        var elem =3D _firstTarget;=0A=
        while (elem && !stopped) {=0A=
          var _handlers =3D elem.hammer && =
elem.hammer._handlers[event.type];=0A=
          if (_handlers) {=0A=
            for (var i =3D 0; i < _handlers.length && !stopped; i++) {=0A=
              _handlers[i](event);=0A=
            }=0A=
          }=0A=
=0A=
          elem =3D elem.parentNode;=0A=
        }=0A=
      }=0A=
=0A=
      return wrapper;=0A=
    };=0A=
  }));=0A=
=0A=
=0A=
/***/ },=0A=
/* 5 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.4 - 2014-09-28=0A=
   * http://hammerjs.github.io/=0A=
   *=0A=
   * Copyright (c) 2014 Jorik Tangelder;=0A=
   * Licensed under the MIT license */=0A=
  (function(window, document, exportName, undefined) {=0A=
    'use strict';=0A=
=0A=
  var VENDOR_PREFIXES =3D ['', 'webkit', 'moz', 'MS', 'ms', 'o'];=0A=
  var TEST_ELEMENT =3D document.createElement('div');=0A=
=0A=
  var TYPE_FUNCTION =3D 'function';=0A=
=0A=
  var round =3D Math.round;=0A=
  var abs =3D Math.abs;=0A=
  var now =3D Date.now;=0A=
=0A=
  /**=0A=
   * set a timeout with a given scope=0A=
   * @param {Function} fn=0A=
   * @param {Number} timeout=0A=
   * @param {Object} context=0A=
   * @returns {number}=0A=
   */=0A=
  function setTimeoutContext(fn, timeout, context) {=0A=
      return setTimeout(bindFn(fn, context), timeout);=0A=
  }=0A=
=0A=
  /**=0A=
   * if the argument is an array, we want to execute the fn on each entry=0A=
   * if it aint an array we don't want to do a thing.=0A=
   * this is used by all the methods that accept a single and array =
argument.=0A=
   * @param {*|Array} arg=0A=
   * @param {String} fn=0A=
   * @param {Object} [context]=0A=
   * @returns {Boolean}=0A=
   */=0A=
  function invokeArrayArg(arg, fn, context) {=0A=
      if (Array.isArray(arg)) {=0A=
          each(arg, context[fn], context);=0A=
          return true;=0A=
      }=0A=
      return false;=0A=
  }=0A=
=0A=
  /**=0A=
   * walk objects and arrays=0A=
   * @param {Object} obj=0A=
   * @param {Function} iterator=0A=
   * @param {Object} context=0A=
   */=0A=
  function each(obj, iterator, context) {=0A=
      var i;=0A=
=0A=
      if (!obj) {=0A=
          return;=0A=
      }=0A=
=0A=
      if (obj.forEach) {=0A=
          obj.forEach(iterator, context);=0A=
      } else if (obj.length !=3D=3D undefined) {=0A=
          i =3D 0;=0A=
          while (i < obj.length) {=0A=
              iterator.call(context, obj[i], i, obj);=0A=
              i++;=0A=
          }=0A=
      } else {=0A=
          for (i in obj) {=0A=
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, =
obj);=0A=
          }=0A=
      }=0A=
  }=0A=
=0A=
  /**=0A=
   * extend object.=0A=
   * means that properties in dest will be overwritten by the ones in =
src.=0A=
   * @param {Object} dest=0A=
   * @param {Object} src=0A=
   * @param {Boolean} [merge]=0A=
   * @returns {Object} dest=0A=
   */=0A=
  function extend(dest, src, merge) {=0A=
      var keys =3D Object.keys(src);=0A=
      var i =3D 0;=0A=
      while (i < keys.length) {=0A=
          if (!merge || (merge && dest[keys[i]] =3D=3D=3D undefined)) {=0A=
              dest[keys[i]] =3D src[keys[i]];=0A=
          }=0A=
          i++;=0A=
      }=0A=
      return dest;=0A=
  }=0A=
=0A=
  /**=0A=
   * merge the values from src in the dest.=0A=
   * means that properties that exist in dest will not be overwritten by =
src=0A=
   * @param {Object} dest=0A=
   * @param {Object} src=0A=
   * @returns {Object} dest=0A=
   */=0A=
  function merge(dest, src) {=0A=
      return extend(dest, src, true);=0A=
  }=0A=
=0A=
  /**=0A=
   * simple class inheritance=0A=
   * @param {Function} child=0A=
   * @param {Function} base=0A=
   * @param {Object} [properties]=0A=
   */=0A=
  function inherit(child, base, properties) {=0A=
      var baseP =3D base.prototype,=0A=
          childP;=0A=
=0A=
      childP =3D child.prototype =3D Object.create(baseP);=0A=
      childP.constructor =3D child;=0A=
      childP._super =3D baseP;=0A=
=0A=
      if (properties) {=0A=
          extend(childP, properties);=0A=
      }=0A=
  }=0A=
=0A=
  /**=0A=
   * simple function bind=0A=
   * @param {Function} fn=0A=
   * @param {Object} context=0A=
   * @returns {Function}=0A=
   */=0A=
  function bindFn(fn, context) {=0A=
      return function boundFn() {=0A=
          return fn.apply(context, arguments);=0A=
      };=0A=
  }=0A=
=0A=
  /**=0A=
   * let a boolean value also be a function that must return a boolean=0A=
   * this first item in args will be used as the context=0A=
   * @param {Boolean|Function} val=0A=
   * @param {Array} [args]=0A=
   * @returns {Boolean}=0A=
   */=0A=
  function boolOrFn(val, args) {=0A=
      if (typeof val =3D=3D TYPE_FUNCTION) {=0A=
          return val.apply(args ? args[0] || undefined : undefined, =
args);=0A=
      }=0A=
      return val;=0A=
  }=0A=
=0A=
  /**=0A=
   * use the val2 when val1 is undefined=0A=
   * @param {*} val1=0A=
   * @param {*} val2=0A=
   * @returns {*}=0A=
   */=0A=
  function ifUndefined(val1, val2) {=0A=
      return (val1 =3D=3D=3D undefined) ? val2 : val1;=0A=
  }=0A=
=0A=
  /**=0A=
   * addEventListener with multiple events at once=0A=
   * @param {EventTarget} target=0A=
   * @param {String} types=0A=
   * @param {Function} handler=0A=
   */=0A=
  function addEventListeners(target, types, handler) {=0A=
      each(splitStr(types), function(type) {=0A=
          target.addEventListener(type, handler, false);=0A=
      });=0A=
  }=0A=
=0A=
  /**=0A=
   * removeEventListener with multiple events at once=0A=
   * @param {EventTarget} target=0A=
   * @param {String} types=0A=
   * @param {Function} handler=0A=
   */=0A=
  function removeEventListeners(target, types, handler) {=0A=
      each(splitStr(types), function(type) {=0A=
          target.removeEventListener(type, handler, false);=0A=
      });=0A=
  }=0A=
=0A=
  /**=0A=
   * find if a node is in the given parent=0A=
   * @method hasParent=0A=
   * @param {HTMLElement} node=0A=
   * @param {HTMLElement} parent=0A=
   * @return {Boolean} found=0A=
   */=0A=
  function hasParent(node, parent) {=0A=
      while (node) {=0A=
          if (node =3D=3D parent) {=0A=
              return true;=0A=
          }=0A=
          node =3D node.parentNode;=0A=
      }=0A=
      return false;=0A=
  }=0A=
=0A=
  /**=0A=
   * small indexOf wrapper=0A=
   * @param {String} str=0A=
   * @param {String} find=0A=
   * @returns {Boolean} found=0A=
   */=0A=
  function inStr(str, find) {=0A=
      return str.indexOf(find) > -1;=0A=
  }=0A=
=0A=
  /**=0A=
   * split string on whitespace=0A=
   * @param {String} str=0A=
   * @returns {Array} words=0A=
   */=0A=
  function splitStr(str) {=0A=
      return str.trim().split(/\s+/g);=0A=
  }=0A=
=0A=
  /**=0A=
   * find if a array contains the object using indexOf or a simple =
polyFill=0A=
   * @param {Array} src=0A=
   * @param {String} find=0A=
   * @param {String} [findByKey]=0A=
   * @return {Boolean|Number} false when not found, or the index=0A=
   */=0A=
  function inArray(src, find, findByKey) {=0A=
      if (src.indexOf && !findByKey) {=0A=
          return src.indexOf(find);=0A=
      } else {=0A=
          var i =3D 0;=0A=
          while (i < src.length) {=0A=
              if ((findByKey && src[i][findByKey] =3D=3D find) || =
(!findByKey && src[i] =3D=3D=3D find)) {=0A=
                  return i;=0A=
              }=0A=
              i++;=0A=
          }=0A=
          return -1;=0A=
      }=0A=
  }=0A=
=0A=
  /**=0A=
   * convert array-like objects to real arrays=0A=
   * @param {Object} obj=0A=
   * @returns {Array}=0A=
   */=0A=
  function toArray(obj) {=0A=
      return Array.prototype.slice.call(obj, 0);=0A=
  }=0A=
=0A=
  /**=0A=
   * unique array with objects based on a key (like 'id') or just by the =
array's value=0A=
   * @param {Array} src [{id:1},{id:2},{id:1}]=0A=
   * @param {String} [key]=0A=
   * @param {Boolean} [sort=3DFalse]=0A=
   * @returns {Array} [{id:1},{id:2}]=0A=
   */=0A=
  function uniqueArray(src, key, sort) {=0A=
      var results =3D [];=0A=
      var values =3D [];=0A=
      var i =3D 0;=0A=
=0A=
      while (i < src.length) {=0A=
          var val =3D key ? src[i][key] : src[i];=0A=
          if (inArray(values, val) < 0) {=0A=
              results.push(src[i]);=0A=
          }=0A=
          values[i] =3D val;=0A=
          i++;=0A=
      }=0A=
=0A=
      if (sort) {=0A=
          if (!key) {=0A=
              results =3D results.sort();=0A=
          } else {=0A=
              results =3D results.sort(function sortUniqueArray(a, b) {=0A=
                  return a[key] > b[key];=0A=
              });=0A=
          }=0A=
      }=0A=
=0A=
      return results;=0A=
  }=0A=
=0A=
  /**=0A=
   * get the prefixed property=0A=
   * @param {Object} obj=0A=
   * @param {String} property=0A=
   * @returns {String|Undefined} prefixed=0A=
   */=0A=
  function prefixed(obj, property) {=0A=
      var prefix, prop;=0A=
      var camelProp =3D property[0].toUpperCase() + property.slice(1);=0A=
=0A=
      var i =3D 0;=0A=
      while (i < VENDOR_PREFIXES.length) {=0A=
          prefix =3D VENDOR_PREFIXES[i];=0A=
          prop =3D (prefix) ? prefix + camelProp : property;=0A=
=0A=
          if (prop in obj) {=0A=
              return prop;=0A=
          }=0A=
          i++;=0A=
      }=0A=
      return undefined;=0A=
  }=0A=
=0A=
  /**=0A=
   * get a unique id=0A=
   * @returns {number} uniqueId=0A=
   */=0A=
  var _uniqueId =3D 1;=0A=
  function uniqueId() {=0A=
      return _uniqueId++;=0A=
  }=0A=
=0A=
  /**=0A=
   * get the window object of an element=0A=
   * @param {HTMLElement} element=0A=
   * @returns {DocumentView|Window}=0A=
   */=0A=
  function getWindowForElement(element) {=0A=
      var doc =3D element.ownerDocument;=0A=
      return (doc.defaultView || doc.parentWindow);=0A=
  }=0A=
=0A=
  var MOBILE_REGEX =3D /mobile|tablet|ip(ad|hone|od)|android/i;=0A=
=0A=
  var SUPPORT_TOUCH =3D ('ontouchstart' in window);=0A=
  var SUPPORT_POINTER_EVENTS =3D prefixed(window, 'PointerEvent') =
!=3D=3D undefined;=0A=
  var SUPPORT_ONLY_TOUCH =3D SUPPORT_TOUCH && =
MOBILE_REGEX.test(navigator.userAgent);=0A=
=0A=
  var INPUT_TYPE_TOUCH =3D 'touch';=0A=
  var INPUT_TYPE_PEN =3D 'pen';=0A=
  var INPUT_TYPE_MOUSE =3D 'mouse';=0A=
  var INPUT_TYPE_KINECT =3D 'kinect';=0A=
=0A=
  var COMPUTE_INTERVAL =3D 25;=0A=
=0A=
  var INPUT_START =3D 1;=0A=
  var INPUT_MOVE =3D 2;=0A=
  var INPUT_END =3D 4;=0A=
  var INPUT_CANCEL =3D 8;=0A=
=0A=
  var DIRECTION_NONE =3D 1;=0A=
  var DIRECTION_LEFT =3D 2;=0A=
  var DIRECTION_RIGHT =3D 4;=0A=
  var DIRECTION_UP =3D 8;=0A=
  var DIRECTION_DOWN =3D 16;=0A=
=0A=
  var DIRECTION_HORIZONTAL =3D DIRECTION_LEFT | DIRECTION_RIGHT;=0A=
  var DIRECTION_VERTICAL =3D DIRECTION_UP | DIRECTION_DOWN;=0A=
  var DIRECTION_ALL =3D DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;=0A=
=0A=
  var PROPS_XY =3D ['x', 'y'];=0A=
  var PROPS_CLIENT_XY =3D ['clientX', 'clientY'];=0A=
=0A=
  /**=0A=
   * create new input type manager=0A=
   * @param {Manager} manager=0A=
   * @param {Function} callback=0A=
   * @returns {Input}=0A=
   * @constructor=0A=
   */=0A=
  function Input(manager, callback) {=0A=
      var self =3D this;=0A=
      this.manager =3D manager;=0A=
      this.callback =3D callback;=0A=
      this.element =3D manager.element;=0A=
      this.target =3D manager.options.inputTarget;=0A=
=0A=
      // smaller wrapper around the handler, for the scope and the =
enabled state of the manager,=0A=
      // so when disabled the input events are completely bypassed.=0A=
      this.domHandler =3D function(ev) {=0A=
          if (boolOrFn(manager.options.enable, [manager])) {=0A=
              self.handler(ev);=0A=
          }=0A=
      };=0A=
=0A=
      this.init();=0A=
=0A=
  }=0A=
=0A=
  Input.prototype =3D {=0A=
      /**=0A=
       * should handle the inputEvent data and trigger the callback=0A=
       * @virtual=0A=
       */=0A=
      handler: function() { },=0A=
=0A=
      /**=0A=
       * bind the events=0A=
       */=0A=
      init: function() {=0A=
          this.evEl && addEventListeners(this.element, this.evEl, =
this.domHandler);=0A=
          this.evTarget && addEventListeners(this.target, this.evTarget, =
this.domHandler);=0A=
          this.evWin && =
addEventListeners(getWindowForElement(this.element), this.evWin, =
this.domHandler);=0A=
      },=0A=
=0A=
      /**=0A=
       * unbind the events=0A=
       */=0A=
      destroy: function() {=0A=
          this.evEl && removeEventListeners(this.element, this.evEl, =
this.domHandler);=0A=
          this.evTarget && removeEventListeners(this.target, =
this.evTarget, this.domHandler);=0A=
          this.evWin && =
removeEventListeners(getWindowForElement(this.element), this.evWin, =
this.domHandler);=0A=
      }=0A=
  };=0A=
=0A=
  /**=0A=
   * create new input type manager=0A=
   * called by the Manager constructor=0A=
   * @param {Hammer} manager=0A=
   * @returns {Input}=0A=
   */=0A=
  function createInputInstance(manager) {=0A=
      var Type;=0A=
      var inputClass =3D manager.options.inputClass;=0A=
=0A=
      if (inputClass) {=0A=
          Type =3D inputClass;=0A=
      } else if (SUPPORT_POINTER_EVENTS) {=0A=
          Type =3D PointerEventInput;=0A=
      } else if (SUPPORT_ONLY_TOUCH) {=0A=
          Type =3D TouchInput;=0A=
      } else if (!SUPPORT_TOUCH) {=0A=
          Type =3D MouseInput;=0A=
      } else {=0A=
          Type =3D TouchMouseInput;=0A=
      }=0A=
      return new (Type)(manager, inputHandler);=0A=
  }=0A=
=0A=
  /**=0A=
   * handle input events=0A=
   * @param {Manager} manager=0A=
   * @param {String} eventType=0A=
   * @param {Object} input=0A=
   */=0A=
  function inputHandler(manager, eventType, input) {=0A=
      var pointersLen =3D input.pointers.length;=0A=
      var changedPointersLen =3D input.changedPointers.length;=0A=
      var isFirst =3D (eventType & INPUT_START && (pointersLen - =
changedPointersLen =3D=3D=3D 0));=0A=
      var isFinal =3D (eventType & (INPUT_END | INPUT_CANCEL) && =
(pointersLen - changedPointersLen =3D=3D=3D 0));=0A=
=0A=
      input.isFirst =3D !!isFirst;=0A=
      input.isFinal =3D !!isFinal;=0A=
=0A=
      if (isFirst) {=0A=
          manager.session =3D {};=0A=
      }=0A=
=0A=
      // source event is the normalized value of the domEvents=0A=
      // like 'touchstart, mouseup, pointerdown'=0A=
      input.eventType =3D eventType;=0A=
=0A=
      // compute scale, rotation etc=0A=
      computeInputData(manager, input);=0A=
=0A=
      // emit secret event=0A=
      manager.emit('hammer.input', input);=0A=
=0A=
      manager.recognize(input);=0A=
      manager.session.prevInput =3D input;=0A=
  }=0A=
=0A=
  /**=0A=
   * extend the data with some usable properties like scale, rotate, =
velocity etc=0A=
   * @param {Object} manager=0A=
   * @param {Object} input=0A=
   */=0A=
  function computeInputData(manager, input) {=0A=
      var session =3D manager.session;=0A=
      var pointers =3D input.pointers;=0A=
      var pointersLength =3D pointers.length;=0A=
=0A=
      // store the first input to calculate the distance and direction=0A=
      if (!session.firstInput) {=0A=
          session.firstInput =3D simpleCloneInputData(input);=0A=
      }=0A=
=0A=
      // to compute scale and rotation we need to store the multiple =
touches=0A=
      if (pointersLength > 1 && !session.firstMultiple) {=0A=
          session.firstMultiple =3D simpleCloneInputData(input);=0A=
      } else if (pointersLength =3D=3D=3D 1) {=0A=
          session.firstMultiple =3D false;=0A=
      }=0A=
=0A=
      var firstInput =3D session.firstInput;=0A=
      var firstMultiple =3D session.firstMultiple;=0A=
      var offsetCenter =3D firstMultiple ? firstMultiple.center : =
firstInput.center;=0A=
=0A=
      var center =3D input.center =3D getCenter(pointers);=0A=
      input.timeStamp =3D now();=0A=
      input.deltaTime =3D input.timeStamp - firstInput.timeStamp;=0A=
=0A=
      input.angle =3D getAngle(offsetCenter, center);=0A=
      input.distance =3D getDistance(offsetCenter, center);=0A=
=0A=
      computeDeltaXY(session, input);=0A=
      input.offsetDirection =3D getDirection(input.deltaX, input.deltaY);=0A=
=0A=
      input.scale =3D firstMultiple ? getScale(firstMultiple.pointers, =
pointers) : 1;=0A=
      input.rotation =3D firstMultiple ? =
getRotation(firstMultiple.pointers, pointers) : 0;=0A=
=0A=
      computeIntervalInputData(session, input);=0A=
=0A=
      // find the correct target=0A=
      var target =3D manager.element;=0A=
      if (hasParent(input.srcEvent.target, target)) {=0A=
          target =3D input.srcEvent.target;=0A=
      }=0A=
      input.target =3D target;=0A=
  }=0A=
=0A=
  function computeDeltaXY(session, input) {=0A=
      var center =3D input.center;=0A=
      var offset =3D session.offsetDelta || {};=0A=
      var prevDelta =3D session.prevDelta || {};=0A=
      var prevInput =3D session.prevInput || {};=0A=
=0A=
      if (input.eventType =3D=3D=3D INPUT_START || prevInput.eventType =
=3D=3D=3D INPUT_END) {=0A=
          prevDelta =3D session.prevDelta =3D {=0A=
              x: prevInput.deltaX || 0,=0A=
              y: prevInput.deltaY || 0=0A=
          };=0A=
=0A=
          offset =3D session.offsetDelta =3D {=0A=
              x: center.x,=0A=
              y: center.y=0A=
          };=0A=
      }=0A=
=0A=
      input.deltaX =3D prevDelta.x + (center.x - offset.x);=0A=
      input.deltaY =3D prevDelta.y + (center.y - offset.y);=0A=
  }=0A=
=0A=
  /**=0A=
   * velocity is calculated every x ms=0A=
   * @param {Object} session=0A=
   * @param {Object} input=0A=
   */=0A=
  function computeIntervalInputData(session, input) {=0A=
      var last =3D session.lastInterval || input,=0A=
          deltaTime =3D input.timeStamp - last.timeStamp,=0A=
          velocity, velocityX, velocityY, direction;=0A=
=0A=
      if (input.eventType !=3D INPUT_CANCEL && (deltaTime > =
COMPUTE_INTERVAL || last.velocity =3D=3D=3D undefined)) {=0A=
          var deltaX =3D last.deltaX - input.deltaX;=0A=
          var deltaY =3D last.deltaY - input.deltaY;=0A=
=0A=
          var v =3D getVelocity(deltaTime, deltaX, deltaY);=0A=
          velocityX =3D v.x;=0A=
          velocityY =3D v.y;=0A=
          velocity =3D (abs(v.x) > abs(v.y)) ? v.x : v.y;=0A=
          direction =3D getDirection(deltaX, deltaY);=0A=
=0A=
          session.lastInterval =3D input;=0A=
      } else {=0A=
          // use latest velocity info if it doesn't overtake a minimum =
period=0A=
          velocity =3D last.velocity;=0A=
          velocityX =3D last.velocityX;=0A=
          velocityY =3D last.velocityY;=0A=
          direction =3D last.direction;=0A=
      }=0A=
=0A=
      input.velocity =3D velocity;=0A=
      input.velocityX =3D velocityX;=0A=
      input.velocityY =3D velocityY;=0A=
      input.direction =3D direction;=0A=
  }=0A=
=0A=
  /**=0A=
   * create a simple clone from the input used for storage of firstInput =
and firstMultiple=0A=
   * @param {Object} input=0A=
   * @returns {Object} clonedInputData=0A=
   */=0A=
  function simpleCloneInputData(input) {=0A=
      // make a simple copy of the pointers because we will get a =
reference if we don't=0A=
      // we only need clientXY for the calculations=0A=
      var pointers =3D [];=0A=
      var i =3D 0;=0A=
      while (i < input.pointers.length) {=0A=
          pointers[i] =3D {=0A=
              clientX: round(input.pointers[i].clientX),=0A=
              clientY: round(input.pointers[i].clientY)=0A=
          };=0A=
          i++;=0A=
      }=0A=
=0A=
      return {=0A=
          timeStamp: now(),=0A=
          pointers: pointers,=0A=
          center: getCenter(pointers),=0A=
          deltaX: input.deltaX,=0A=
          deltaY: input.deltaY=0A=
      };=0A=
  }=0A=
=0A=
  /**=0A=
   * get the center of all the pointers=0A=
   * @param {Array} pointers=0A=
   * @return {Object} center contains `x` and `y` properties=0A=
   */=0A=
  function getCenter(pointers) {=0A=
      var pointersLength =3D pointers.length;=0A=
=0A=
      // no need to loop when only one touch=0A=
      if (pointersLength =3D=3D=3D 1) {=0A=
          return {=0A=
              x: round(pointers[0].clientX),=0A=
              y: round(pointers[0].clientY)=0A=
          };=0A=
      }=0A=
=0A=
      var x =3D 0, y =3D 0, i =3D 0;=0A=
      while (i < pointersLength) {=0A=
          x +=3D pointers[i].clientX;=0A=
          y +=3D pointers[i].clientY;=0A=
          i++;=0A=
      }=0A=
=0A=
      return {=0A=
          x: round(x / pointersLength),=0A=
          y: round(y / pointersLength)=0A=
      };=0A=
  }=0A=
=0A=
  /**=0A=
   * calculate the velocity between two points. unit is in px per ms.=0A=
   * @param {Number} deltaTime=0A=
   * @param {Number} x=0A=
   * @param {Number} y=0A=
   * @return {Object} velocity `x` and `y`=0A=
   */=0A=
  function getVelocity(deltaTime, x, y) {=0A=
      return {=0A=
          x: x / deltaTime || 0,=0A=
          y: y / deltaTime || 0=0A=
      };=0A=
  }=0A=
=0A=
  /**=0A=
   * get the direction between two points=0A=
   * @param {Number} x=0A=
   * @param {Number} y=0A=
   * @return {Number} direction=0A=
   */=0A=
  function getDirection(x, y) {=0A=
      if (x =3D=3D=3D y) {=0A=
          return DIRECTION_NONE;=0A=
      }=0A=
=0A=
      if (abs(x) >=3D abs(y)) {=0A=
          return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;=0A=
      }=0A=
      return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;=0A=
  }=0A=
=0A=
  /**=0A=
   * calculate the absolute distance between two points=0A=
   * @param {Object} p1 {x, y}=0A=
   * @param {Object} p2 {x, y}=0A=
   * @param {Array} [props] containing x and y keys=0A=
   * @return {Number} distance=0A=
   */=0A=
  function getDistance(p1, p2, props) {=0A=
      if (!props) {=0A=
          props =3D PROPS_XY;=0A=
      }=0A=
      var x =3D p2[props[0]] - p1[props[0]],=0A=
          y =3D p2[props[1]] - p1[props[1]];=0A=
=0A=
      return Math.sqrt((x * x) + (y * y));=0A=
  }=0A=
=0A=
  /**=0A=
   * calculate the angle between two coordinates=0A=
   * @param {Object} p1=0A=
   * @param {Object} p2=0A=
   * @param {Array} [props] containing x and y keys=0A=
   * @return {Number} angle=0A=
   */=0A=
  function getAngle(p1, p2, props) {=0A=
      if (!props) {=0A=
          props =3D PROPS_XY;=0A=
      }=0A=
      var x =3D p2[props[0]] - p1[props[0]],=0A=
          y =3D p2[props[1]] - p1[props[1]];=0A=
      return Math.atan2(y, x) * 180 / Math.PI;=0A=
  }=0A=
=0A=
  /**=0A=
   * calculate the rotation degrees between two pointersets=0A=
   * @param {Array} start array of pointers=0A=
   * @param {Array} end array of pointers=0A=
   * @return {Number} rotation=0A=
   */=0A=
  function getRotation(start, end) {=0A=
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) - =
getAngle(start[1], start[0], PROPS_CLIENT_XY);=0A=
  }=0A=
=0A=
  /**=0A=
   * calculate the scale factor between two pointersets=0A=
   * no scale is 1, and goes down to 0 when pinched together, and bigger =
when pinched out=0A=
   * @param {Array} start array of pointers=0A=
   * @param {Array} end array of pointers=0A=
   * @return {Number} scale=0A=
   */=0A=
  function getScale(start, end) {=0A=
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / =
getDistance(start[0], start[1], PROPS_CLIENT_XY);=0A=
  }=0A=
=0A=
  var MOUSE_INPUT_MAP =3D {=0A=
      mousedown: INPUT_START,=0A=
      mousemove: INPUT_MOVE,=0A=
      mouseup: INPUT_END=0A=
  };=0A=
=0A=
  var MOUSE_ELEMENT_EVENTS =3D 'mousedown';=0A=
  var MOUSE_WINDOW_EVENTS =3D 'mousemove mouseup';=0A=
=0A=
  /**=0A=
   * Mouse events input=0A=
   * @constructor=0A=
   * @extends Input=0A=
   */=0A=
  function MouseInput() {=0A=
      this.evEl =3D MOUSE_ELEMENT_EVENTS;=0A=
      this.evWin =3D MOUSE_WINDOW_EVENTS;=0A=
=0A=
      this.allow =3D true; // used by Input.TouchMouse to disable mouse =
events=0A=
      this.pressed =3D false; // mousedown state=0A=
=0A=
      Input.apply(this, arguments);=0A=
  }=0A=
=0A=
  inherit(MouseInput, Input, {=0A=
      /**=0A=
       * handle mouse events=0A=
       * @param {Object} ev=0A=
       */=0A=
      handler: function MEhandler(ev) {=0A=
          var eventType =3D MOUSE_INPUT_MAP[ev.type];=0A=
=0A=
          // on start we want to have the left mouse button down=0A=
          if (eventType & INPUT_START && ev.button =3D=3D=3D 0) {=0A=
              this.pressed =3D true;=0A=
          }=0A=
=0A=
          if (eventType & INPUT_MOVE && ev.which !=3D=3D 1) {=0A=
              eventType =3D INPUT_END;=0A=
          }=0A=
=0A=
          // mouse must be down, and mouse events are allowed (see the =
TouchMouse input)=0A=
          if (!this.pressed || !this.allow) {=0A=
              return;=0A=
          }=0A=
=0A=
          if (eventType & INPUT_END) {=0A=
              this.pressed =3D false;=0A=
          }=0A=
=0A=
          this.callback(this.manager, eventType, {=0A=
              pointers: [ev],=0A=
              changedPointers: [ev],=0A=
              pointerType: INPUT_TYPE_MOUSE,=0A=
              srcEvent: ev=0A=
          });=0A=
      }=0A=
  });=0A=
=0A=
  var POINTER_INPUT_MAP =3D {=0A=
      pointerdown: INPUT_START,=0A=
      pointermove: INPUT_MOVE,=0A=
      pointerup: INPUT_END,=0A=
      pointercancel: INPUT_CANCEL,=0A=
      pointerout: INPUT_CANCEL=0A=
  };=0A=
=0A=
  // in IE10 the pointer types is defined as an enum=0A=
  var IE10_POINTER_TYPE_ENUM =3D {=0A=
      2: INPUT_TYPE_TOUCH,=0A=
      3: INPUT_TYPE_PEN,=0A=
      4: INPUT_TYPE_MOUSE,=0A=
      5: INPUT_TYPE_KINECT // see =
https://twitter.com/jacobrossi/status/480596438489890816=0A=
  };=0A=
=0A=
  var POINTER_ELEMENT_EVENTS =3D 'pointerdown';=0A=
  var POINTER_WINDOW_EVENTS =3D 'pointermove pointerup pointercancel';=0A=
=0A=
  // IE10 has prefixed support, and case-sensitive=0A=
  if (window.MSPointerEvent) {=0A=
      POINTER_ELEMENT_EVENTS =3D 'MSPointerDown';=0A=
      POINTER_WINDOW_EVENTS =3D 'MSPointerMove MSPointerUp =
MSPointerCancel';=0A=
  }=0A=
=0A=
  /**=0A=
   * Pointer events input=0A=
   * @constructor=0A=
   * @extends Input=0A=
   */=0A=
  function PointerEventInput() {=0A=
      this.evEl =3D POINTER_ELEMENT_EVENTS;=0A=
      this.evWin =3D POINTER_WINDOW_EVENTS;=0A=
=0A=
      Input.apply(this, arguments);=0A=
=0A=
      this.store =3D (this.manager.session.pointerEvents =3D []);=0A=
  }=0A=
=0A=
  inherit(PointerEventInput, Input, {=0A=
      /**=0A=
       * handle mouse events=0A=
       * @param {Object} ev=0A=
       */=0A=
      handler: function PEhandler(ev) {=0A=
          var store =3D this.store;=0A=
          var removePointer =3D false;=0A=
=0A=
          var eventTypeNormalized =3D =
ev.type.toLowerCase().replace('ms', '');=0A=
          var eventType =3D POINTER_INPUT_MAP[eventTypeNormalized];=0A=
          var pointerType =3D IE10_POINTER_TYPE_ENUM[ev.pointerType] || =
ev.pointerType;=0A=
=0A=
          var isTouch =3D (pointerType =3D=3D INPUT_TYPE_TOUCH);=0A=
=0A=
          // get index of the event in the store=0A=
          var storeIndex =3D inArray(store, ev.pointerId, 'pointerId');=0A=
=0A=
          // start and mouse must be down=0A=
          if (eventType & INPUT_START && (ev.button =3D=3D=3D 0 || =
isTouch)) {=0A=
              if (storeIndex < 0) {=0A=
                  store.push(ev);=0A=
                  storeIndex =3D store.length - 1;=0A=
              }=0A=
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {=0A=
              removePointer =3D true;=0A=
          }=0A=
=0A=
          // it not found, so the pointer hasn't been down (so it's =
probably a hover)=0A=
          if (storeIndex < 0) {=0A=
              return;=0A=
          }=0A=
=0A=
          // update the event in the store=0A=
          store[storeIndex] =3D ev;=0A=
=0A=
          this.callback(this.manager, eventType, {=0A=
              pointers: store,=0A=
              changedPointers: [ev],=0A=
              pointerType: pointerType,=0A=
              srcEvent: ev=0A=
          });=0A=
=0A=
          if (removePointer) {=0A=
              // remove from the store=0A=
              store.splice(storeIndex, 1);=0A=
          }=0A=
      }=0A=
  });=0A=
=0A=
  var SINGLE_TOUCH_INPUT_MAP =3D {=0A=
      touchstart: INPUT_START,=0A=
      touchmove: INPUT_MOVE,=0A=
      touchend: INPUT_END,=0A=
      touchcancel: INPUT_CANCEL=0A=
  };=0A=
=0A=
  var SINGLE_TOUCH_TARGET_EVENTS =3D 'touchstart';=0A=
  var SINGLE_TOUCH_WINDOW_EVENTS =3D 'touchstart touchmove touchend =
touchcancel';=0A=
=0A=
  /**=0A=
   * Touch events input=0A=
   * @constructor=0A=
   * @extends Input=0A=
   */=0A=
  function SingleTouchInput() {=0A=
      this.evTarget =3D SINGLE_TOUCH_TARGET_EVENTS;=0A=
      this.evWin =3D SINGLE_TOUCH_WINDOW_EVENTS;=0A=
      this.started =3D false;=0A=
=0A=
      Input.apply(this, arguments);=0A=
  }=0A=
=0A=
  inherit(SingleTouchInput, Input, {=0A=
      handler: function TEhandler(ev) {=0A=
          var type =3D SINGLE_TOUCH_INPUT_MAP[ev.type];=0A=
=0A=
          // should we handle the touch events?=0A=
          if (type =3D=3D=3D INPUT_START) {=0A=
              this.started =3D true;=0A=
          }=0A=
=0A=
          if (!this.started) {=0A=
              return;=0A=
          }=0A=
=0A=
          var touches =3D normalizeSingleTouches.call(this, ev, type);=0A=
=0A=
          // when done, reset the started state=0A=
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - =
touches[1].length =3D=3D=3D 0) {=0A=
              this.started =3D false;=0A=
          }=0A=
=0A=
          this.callback(this.manager, type, {=0A=
              pointers: touches[0],=0A=
              changedPointers: touches[1],=0A=
              pointerType: INPUT_TYPE_TOUCH,=0A=
              srcEvent: ev=0A=
          });=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * @this {TouchInput}=0A=
   * @param {Object} ev=0A=
   * @param {Number} type flag=0A=
   * @returns {undefined|Array} [all, changed]=0A=
   */=0A=
  function normalizeSingleTouches(ev, type) {=0A=
      var all =3D toArray(ev.touches);=0A=
      var changed =3D toArray(ev.changedTouches);=0A=
=0A=
      if (type & (INPUT_END | INPUT_CANCEL)) {=0A=
          all =3D uniqueArray(all.concat(changed), 'identifier', true);=0A=
      }=0A=
=0A=
      return [all, changed];=0A=
  }=0A=
=0A=
  var TOUCH_INPUT_MAP =3D {=0A=
      touchstart: INPUT_START,=0A=
      touchmove: INPUT_MOVE,=0A=
      touchend: INPUT_END,=0A=
      touchcancel: INPUT_CANCEL=0A=
  };=0A=
=0A=
  var TOUCH_TARGET_EVENTS =3D 'touchstart touchmove touchend =
touchcancel';=0A=
=0A=
  /**=0A=
   * Multi-user touch events input=0A=
   * @constructor=0A=
   * @extends Input=0A=
   */=0A=
  function TouchInput() {=0A=
      this.evTarget =3D TOUCH_TARGET_EVENTS;=0A=
      this.targetIds =3D {};=0A=
=0A=
      Input.apply(this, arguments);=0A=
  }=0A=
=0A=
  inherit(TouchInput, Input, {=0A=
      handler: function MTEhandler(ev) {=0A=
          var type =3D TOUCH_INPUT_MAP[ev.type];=0A=
          var touches =3D getTouches.call(this, ev, type);=0A=
          if (!touches) {=0A=
              return;=0A=
          }=0A=
=0A=
          this.callback(this.manager, type, {=0A=
              pointers: touches[0],=0A=
              changedPointers: touches[1],=0A=
              pointerType: INPUT_TYPE_TOUCH,=0A=
              srcEvent: ev=0A=
          });=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * @this {TouchInput}=0A=
   * @param {Object} ev=0A=
   * @param {Number} type flag=0A=
   * @returns {undefined|Array} [all, changed]=0A=
   */=0A=
  function getTouches(ev, type) {=0A=
      var allTouches =3D toArray(ev.touches);=0A=
      var targetIds =3D this.targetIds;=0A=
=0A=
      // when there is only one touch, the process can be simplified=0A=
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length =
=3D=3D=3D 1) {=0A=
          targetIds[allTouches[0].identifier] =3D true;=0A=
          return [allTouches, allTouches];=0A=
      }=0A=
=0A=
      var i,=0A=
          targetTouches,=0A=
          changedTouches =3D toArray(ev.changedTouches),=0A=
          changedTargetTouches =3D [],=0A=
          target =3D this.target;=0A=
=0A=
      // get target touches from touches=0A=
      targetTouches =3D allTouches.filter(function(touch) {=0A=
          return hasParent(touch.target, target);=0A=
      });=0A=
=0A=
      // collect touches=0A=
      if (type =3D=3D=3D INPUT_START) {=0A=
          i =3D 0;=0A=
          while (i < targetTouches.length) {=0A=
              targetIds[targetTouches[i].identifier] =3D true;=0A=
              i++;=0A=
          }=0A=
      }=0A=
=0A=
      // filter changed touches to only contain touches that exist in =
the collected target ids=0A=
      i =3D 0;=0A=
      while (i < changedTouches.length) {=0A=
          if (targetIds[changedTouches[i].identifier]) {=0A=
              changedTargetTouches.push(changedTouches[i]);=0A=
          }=0A=
=0A=
          // cleanup removed touches=0A=
          if (type & (INPUT_END | INPUT_CANCEL)) {=0A=
              delete targetIds[changedTouches[i].identifier];=0A=
          }=0A=
          i++;=0A=
      }=0A=
=0A=
      if (!changedTargetTouches.length) {=0A=
          return;=0A=
      }=0A=
=0A=
      return [=0A=
          // merge targetTouches with changedTargetTouches so it =
contains ALL touches, including 'end' and 'cancel'=0A=
          uniqueArray(targetTouches.concat(changedTargetTouches), =
'identifier', true),=0A=
          changedTargetTouches=0A=
      ];=0A=
  }=0A=
=0A=
  /**=0A=
   * Combined touch and mouse input=0A=
   *=0A=
   * Touch has a higher priority then mouse, and while touching no mouse =
events are allowed.=0A=
   * This because touch devices also emit mouse events while doing a =
touch.=0A=
   *=0A=
   * @constructor=0A=
   * @extends Input=0A=
   */=0A=
  function TouchMouseInput() {=0A=
      Input.apply(this, arguments);=0A=
=0A=
      var handler =3D bindFn(this.handler, this);=0A=
      this.touch =3D new TouchInput(this.manager, handler);=0A=
      this.mouse =3D new MouseInput(this.manager, handler);=0A=
  }=0A=
=0A=
  inherit(TouchMouseInput, Input, {=0A=
      /**=0A=
       * handle mouse and touch events=0A=
       * @param {Hammer} manager=0A=
       * @param {String} inputEvent=0A=
       * @param {Object} inputData=0A=
       */=0A=
      handler: function TMEhandler(manager, inputEvent, inputData) {=0A=
          var isTouch =3D (inputData.pointerType =3D=3D =
INPUT_TYPE_TOUCH),=0A=
              isMouse =3D (inputData.pointerType =3D=3D =
INPUT_TYPE_MOUSE);=0A=
=0A=
          // when we're in a touch event, so  block all upcoming mouse =
events=0A=
          // most mobile browser also emit mouseevents, right after =
touchstart=0A=
          if (isTouch) {=0A=
              this.mouse.allow =3D false;=0A=
          } else if (isMouse && !this.mouse.allow) {=0A=
              return;=0A=
          }=0A=
=0A=
          // reset the allowMouse when we're done=0A=
          if (inputEvent & (INPUT_END | INPUT_CANCEL)) {=0A=
              this.mouse.allow =3D true;=0A=
          }=0A=
=0A=
          this.callback(manager, inputEvent, inputData);=0A=
      },=0A=
=0A=
      /**=0A=
       * remove the event listeners=0A=
       */=0A=
      destroy: function destroy() {=0A=
          this.touch.destroy();=0A=
          this.mouse.destroy();=0A=
      }=0A=
  });=0A=
=0A=
  var PREFIXED_TOUCH_ACTION =3D prefixed(TEST_ELEMENT.style, =
'touchAction');=0A=
  var NATIVE_TOUCH_ACTION =3D PREFIXED_TOUCH_ACTION !=3D=3D undefined;=0A=
=0A=
  // magical touchAction value=0A=
  var TOUCH_ACTION_COMPUTE =3D 'compute';=0A=
  var TOUCH_ACTION_AUTO =3D 'auto';=0A=
  var TOUCH_ACTION_MANIPULATION =3D 'manipulation'; // not implemented=0A=
  var TOUCH_ACTION_NONE =3D 'none';=0A=
  var TOUCH_ACTION_PAN_X =3D 'pan-x';=0A=
  var TOUCH_ACTION_PAN_Y =3D 'pan-y';=0A=
=0A=
  /**=0A=
   * Touch Action=0A=
   * sets the touchAction property or uses the js alternative=0A=
   * @param {Manager} manager=0A=
   * @param {String} value=0A=
   * @constructor=0A=
   */=0A=
  function TouchAction(manager, value) {=0A=
      this.manager =3D manager;=0A=
      this.set(value);=0A=
  }=0A=
=0A=
  TouchAction.prototype =3D {=0A=
      /**=0A=
       * set the touchAction value on the element or enable the polyfill=0A=
       * @param {String} value=0A=
       */=0A=
      set: function(value) {=0A=
          // find out the touch-action by the event handlers=0A=
          if (value =3D=3D TOUCH_ACTION_COMPUTE) {=0A=
              value =3D this.compute();=0A=
          }=0A=
=0A=
          if (NATIVE_TOUCH_ACTION) {=0A=
              this.manager.element.style[PREFIXED_TOUCH_ACTION] =3D =
value;=0A=
          }=0A=
          this.actions =3D value.toLowerCase().trim();=0A=
      },=0A=
=0A=
      /**=0A=
       * just re-set the touchAction value=0A=
       */=0A=
      update: function() {=0A=
          this.set(this.manager.options.touchAction);=0A=
      },=0A=
=0A=
      /**=0A=
       * compute the value for the touchAction property based on the =
recognizer's settings=0A=
       * @returns {String} value=0A=
       */=0A=
      compute: function() {=0A=
          var actions =3D [];=0A=
          each(this.manager.recognizers, function(recognizer) {=0A=
              if (boolOrFn(recognizer.options.enable, [recognizer])) {=0A=
                  actions =3D =
actions.concat(recognizer.getTouchAction());=0A=
              }=0A=
          });=0A=
          return cleanTouchActions(actions.join(' '));=0A=
      },=0A=
=0A=
      /**=0A=
       * this method is called on each input cycle and provides the =
preventing of the browser behavior=0A=
       * @param {Object} input=0A=
       */=0A=
      preventDefaults: function(input) {=0A=
          // not needed with native support for the touchAction property=0A=
          if (NATIVE_TOUCH_ACTION) {=0A=
              return;=0A=
          }=0A=
=0A=
          var srcEvent =3D input.srcEvent;=0A=
          var direction =3D input.offsetDirection;=0A=
=0A=
          // if the touch action did prevented once this session=0A=
          if (this.manager.session.prevented) {=0A=
              srcEvent.preventDefault();=0A=
              return;=0A=
          }=0A=
=0A=
          var actions =3D this.actions;=0A=
          var hasNone =3D inStr(actions, TOUCH_ACTION_NONE);=0A=
          var hasPanY =3D inStr(actions, TOUCH_ACTION_PAN_Y);=0A=
          var hasPanX =3D inStr(actions, TOUCH_ACTION_PAN_X);=0A=
=0A=
          if (hasNone ||=0A=
              (hasPanY && direction & DIRECTION_HORIZONTAL) ||=0A=
              (hasPanX && direction & DIRECTION_VERTICAL)) {=0A=
              return this.preventSrc(srcEvent);=0A=
          }=0A=
      },=0A=
=0A=
      /**=0A=
       * call preventDefault to prevent the browser's default behavior =
(scrolling in most cases)=0A=
       * @param {Object} srcEvent=0A=
       */=0A=
      preventSrc: function(srcEvent) {=0A=
          this.manager.session.prevented =3D true;=0A=
          srcEvent.preventDefault();=0A=
      }=0A=
  };=0A=
=0A=
  /**=0A=
   * when the touchActions are collected they are not a valid value, so =
we need to clean things up. *=0A=
   * @param {String} actions=0A=
   * @returns {*}=0A=
   */=0A=
  function cleanTouchActions(actions) {=0A=
      // none=0A=
      if (inStr(actions, TOUCH_ACTION_NONE)) {=0A=
          return TOUCH_ACTION_NONE;=0A=
      }=0A=
=0A=
      var hasPanX =3D inStr(actions, TOUCH_ACTION_PAN_X);=0A=
      var hasPanY =3D inStr(actions, TOUCH_ACTION_PAN_Y);=0A=
=0A=
      // pan-x and pan-y can be combined=0A=
      if (hasPanX && hasPanY) {=0A=
          return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;=0A=
      }=0A=
=0A=
      // pan-x OR pan-y=0A=
      if (hasPanX || hasPanY) {=0A=
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;=0A=
      }=0A=
=0A=
      // manipulation=0A=
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {=0A=
          return TOUCH_ACTION_MANIPULATION;=0A=
      }=0A=
=0A=
      return TOUCH_ACTION_AUTO;=0A=
  }=0A=
=0A=
  /**=0A=
   * Recognizer flow explained; *=0A=
   * All recognizers have the initial state of POSSIBLE when a input =
session starts.=0A=
   * The definition of a input session is from the first input until the =
last input, with all it's movement in it. *=0A=
   * Example session for mouse-input: mousedown -> mousemove -> mouseup=0A=
   *=0A=
   * On each recognizing cycle (see Manager.recognize) the .recognize() =
method is executed=0A=
   * which determines with state it should be.=0A=
   *=0A=
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED =
(equals ENDED), it is reset to=0A=
   * POSSIBLE to give it another change on the next cycle.=0A=
   *=0A=
   *               Possible=0A=
   *                  |=0A=
   *            +-----+---------------+=0A=
   *            |                     |=0A=
   *      +-----+-----+               |=0A=
   *      |           |               |=0A=
   *   Failed      Cancelled          |=0A=
   *                          +-------+------+=0A=
   *                          |              |=0A=
   *                      Recognized       Began=0A=
   *                                         |=0A=
   *                                      Changed=0A=
   *                                         |=0A=
   *                                  Ended/Recognized=0A=
   */=0A=
  var STATE_POSSIBLE =3D 1;=0A=
  var STATE_BEGAN =3D 2;=0A=
  var STATE_CHANGED =3D 4;=0A=
  var STATE_ENDED =3D 8;=0A=
  var STATE_RECOGNIZED =3D STATE_ENDED;=0A=
  var STATE_CANCELLED =3D 16;=0A=
  var STATE_FAILED =3D 32;=0A=
=0A=
  /**=0A=
   * Recognizer=0A=
   * Every recognizer needs to extend from this class.=0A=
   * @constructor=0A=
   * @param {Object} options=0A=
   */=0A=
  function Recognizer(options) {=0A=
      this.id =3D uniqueId();=0A=
=0A=
      this.manager =3D null;=0A=
      this.options =3D merge(options || {}, this.defaults);=0A=
=0A=
      // default is enable true=0A=
      this.options.enable =3D ifUndefined(this.options.enable, true);=0A=
=0A=
      this.state =3D STATE_POSSIBLE;=0A=
=0A=
      this.simultaneous =3D {};=0A=
      this.requireFail =3D [];=0A=
  }=0A=
=0A=
  Recognizer.prototype =3D {=0A=
      /**=0A=
       * @virtual=0A=
       * @type {Object}=0A=
       */=0A=
      defaults: {},=0A=
=0A=
      /**=0A=
       * set options=0A=
       * @param {Object} options=0A=
       * @return {Recognizer}=0A=
       */=0A=
      set: function(options) {=0A=
          extend(this.options, options);=0A=
=0A=
          // also update the touchAction, in case something changed =
about the directions/enabled state=0A=
          this.manager && this.manager.touchAction.update();=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * recognize simultaneous with an other recognizer.=0A=
       * @param {Recognizer} otherRecognizer=0A=
       * @returns {Recognizer} this=0A=
       */=0A=
      recognizeWith: function(otherRecognizer) {=0A=
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {=0A=
              return this;=0A=
          }=0A=
=0A=
          var simultaneous =3D this.simultaneous;=0A=
          otherRecognizer =3D =
getRecognizerByNameIfManager(otherRecognizer, this);=0A=
          if (!simultaneous[otherRecognizer.id]) {=0A=
              simultaneous[otherRecognizer.id] =3D otherRecognizer;=0A=
              otherRecognizer.recognizeWith(this);=0A=
          }=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * drop the simultaneous link. it doesnt remove the link on the =
other recognizer.=0A=
       * @param {Recognizer} otherRecognizer=0A=
       * @returns {Recognizer} this=0A=
       */=0A=
      dropRecognizeWith: function(otherRecognizer) {=0A=
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', =
this)) {=0A=
              return this;=0A=
          }=0A=
=0A=
          otherRecognizer =3D =
getRecognizerByNameIfManager(otherRecognizer, this);=0A=
          delete this.simultaneous[otherRecognizer.id];=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * recognizer can only run when an other is failing=0A=
       * @param {Recognizer} otherRecognizer=0A=
       * @returns {Recognizer} this=0A=
       */=0A=
      requireFailure: function(otherRecognizer) {=0A=
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {=0A=
              return this;=0A=
          }=0A=
=0A=
          var requireFail =3D this.requireFail;=0A=
          otherRecognizer =3D =
getRecognizerByNameIfManager(otherRecognizer, this);=0A=
          if (inArray(requireFail, otherRecognizer) =3D=3D=3D -1) {=0A=
              requireFail.push(otherRecognizer);=0A=
              otherRecognizer.requireFailure(this);=0A=
          }=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * drop the requireFailure link. it does not remove the link on =
the other recognizer.=0A=
       * @param {Recognizer} otherRecognizer=0A=
       * @returns {Recognizer} this=0A=
       */=0A=
      dropRequireFailure: function(otherRecognizer) {=0A=
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', =
this)) {=0A=
              return this;=0A=
          }=0A=
=0A=
          otherRecognizer =3D =
getRecognizerByNameIfManager(otherRecognizer, this);=0A=
          var index =3D inArray(this.requireFail, otherRecognizer);=0A=
          if (index > -1) {=0A=
              this.requireFail.splice(index, 1);=0A=
          }=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * has require failures boolean=0A=
       * @returns {boolean}=0A=
       */=0A=
      hasRequireFailures: function() {=0A=
          return this.requireFail.length > 0;=0A=
      },=0A=
=0A=
      /**=0A=
       * if the recognizer can recognize simultaneous with an other =
recognizer=0A=
       * @param {Recognizer} otherRecognizer=0A=
       * @returns {Boolean}=0A=
       */=0A=
      canRecognizeWith: function(otherRecognizer) {=0A=
          return !!this.simultaneous[otherRecognizer.id];=0A=
      },=0A=
=0A=
      /**=0A=
       * You should use `tryEmit` instead of `emit` directly to check=0A=
       * that all the needed recognizers has failed before emitting.=0A=
       * @param {Object} input=0A=
       */=0A=
      emit: function(input) {=0A=
          var self =3D this;=0A=
          var state =3D this.state;=0A=
=0A=
          function emit(withState) {=0A=
              self.manager.emit(self.options.event + (withState ? =
stateStr(state) : ''), input);=0A=
          }=0A=
=0A=
          // 'panstart' and 'panmove'=0A=
          if (state < STATE_ENDED) {=0A=
              emit(true);=0A=
          }=0A=
=0A=
          emit(); // simple 'eventName' events=0A=
=0A=
          // panend and pancancel=0A=
          if (state >=3D STATE_ENDED) {=0A=
              emit(true);=0A=
          }=0A=
      },=0A=
=0A=
      /**=0A=
       * Check that all the require failure recognizers has failed,=0A=
       * if true, it emits a gesture event,=0A=
       * otherwise, setup the state to FAILED.=0A=
       * @param {Object} input=0A=
       */=0A=
      tryEmit: function(input) {=0A=
          if (this.canEmit()) {=0A=
              return this.emit(input);=0A=
          }=0A=
          // it's failing anyway=0A=
          this.state =3D STATE_FAILED;=0A=
      },=0A=
=0A=
      /**=0A=
       * can we emit?=0A=
       * @returns {boolean}=0A=
       */=0A=
      canEmit: function() {=0A=
          var i =3D 0;=0A=
          while (i < this.requireFail.length) {=0A=
              if (!(this.requireFail[i].state & (STATE_FAILED | =
STATE_POSSIBLE))) {=0A=
                  return false;=0A=
              }=0A=
              i++;=0A=
          }=0A=
          return true;=0A=
      },=0A=
=0A=
      /**=0A=
       * update the recognizer=0A=
       * @param {Object} inputData=0A=
       */=0A=
      recognize: function(inputData) {=0A=
          // make a new copy of the inputData=0A=
          // so we can change the inputData without messing up the other =
recognizers=0A=
          var inputDataClone =3D extend({}, inputData);=0A=
=0A=
          // is is enabled and allow recognizing?=0A=
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {=0A=
              this.reset();=0A=
              this.state =3D STATE_FAILED;=0A=
              return;=0A=
          }=0A=
=0A=
          // reset when we've reached the end=0A=
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | =
STATE_FAILED)) {=0A=
              this.state =3D STATE_POSSIBLE;=0A=
          }=0A=
=0A=
          this.state =3D this.process(inputDataClone);=0A=
=0A=
          // the recognizer has recognized a gesture=0A=
          // so trigger an event=0A=
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | =
STATE_CANCELLED)) {=0A=
              this.tryEmit(inputDataClone);=0A=
          }=0A=
      },=0A=
=0A=
      /**=0A=
       * return the state of the recognizer=0A=
       * the actual recognizing happens in this method=0A=
       * @virtual=0A=
       * @param {Object} inputData=0A=
       * @returns {Const} STATE=0A=
       */=0A=
      process: function(inputData) { }, // jshint ignore:line=0A=
=0A=
      /**=0A=
       * return the preferred touch-action=0A=
       * @virtual=0A=
       * @returns {Array}=0A=
       */=0A=
      getTouchAction: function() { },=0A=
=0A=
      /**=0A=
       * called when the gesture isn't allowed to recognize=0A=
       * like when another is being recognized or it is disabled=0A=
       * @virtual=0A=
       */=0A=
      reset: function() { }=0A=
  };=0A=
=0A=
  /**=0A=
   * get a usable string, used as event postfix=0A=
   * @param {Const} state=0A=
   * @returns {String} state=0A=
   */=0A=
  function stateStr(state) {=0A=
      if (state & STATE_CANCELLED) {=0A=
          return 'cancel';=0A=
      } else if (state & STATE_ENDED) {=0A=
          return 'end';=0A=
      } else if (state & STATE_CHANGED) {=0A=
          return 'move';=0A=
      } else if (state & STATE_BEGAN) {=0A=
          return 'start';=0A=
      }=0A=
      return '';=0A=
  }=0A=
=0A=
  /**=0A=
   * direction cons to string=0A=
   * @param {Const} direction=0A=
   * @returns {String}=0A=
   */=0A=
  function directionStr(direction) {=0A=
      if (direction =3D=3D DIRECTION_DOWN) {=0A=
          return 'down';=0A=
      } else if (direction =3D=3D DIRECTION_UP) {=0A=
          return 'up';=0A=
      } else if (direction =3D=3D DIRECTION_LEFT) {=0A=
          return 'left';=0A=
      } else if (direction =3D=3D DIRECTION_RIGHT) {=0A=
          return 'right';=0A=
      }=0A=
      return '';=0A=
  }=0A=
=0A=
  /**=0A=
   * get a recognizer by name if it is bound to a manager=0A=
   * @param {Recognizer|String} otherRecognizer=0A=
   * @param {Recognizer} recognizer=0A=
   * @returns {Recognizer}=0A=
   */=0A=
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {=0A=
      var manager =3D recognizer.manager;=0A=
      if (manager) {=0A=
          return manager.get(otherRecognizer);=0A=
      }=0A=
      return otherRecognizer;=0A=
  }=0A=
=0A=
  /**=0A=
   * This recognizer is just used as a base for the simple attribute =
recognizers.=0A=
   * @constructor=0A=
   * @extends Recognizer=0A=
   */=0A=
  function AttrRecognizer() {=0A=
      Recognizer.apply(this, arguments);=0A=
  }=0A=
=0A=
  inherit(AttrRecognizer, Recognizer, {=0A=
      /**=0A=
       * @namespace=0A=
       * @memberof AttrRecognizer=0A=
       */=0A=
      defaults: {=0A=
          /**=0A=
           * @type {Number}=0A=
           * @default 1=0A=
           */=0A=
          pointers: 1=0A=
      },=0A=
=0A=
      /**=0A=
       * Used to check if it the recognizer receives valid input, like =
input.distance > 10.=0A=
       * @memberof AttrRecognizer=0A=
       * @param {Object} input=0A=
       * @returns {Boolean} recognized=0A=
       */=0A=
      attrTest: function(input) {=0A=
          var optionPointers =3D this.options.pointers;=0A=
          return optionPointers =3D=3D=3D 0 || input.pointers.length =
=3D=3D=3D optionPointers;=0A=
      },=0A=
=0A=
      /**=0A=
       * Process the input and return the state for the recognizer=0A=
       * @memberof AttrRecognizer=0A=
       * @param {Object} input=0A=
       * @returns {*} State=0A=
       */=0A=
      process: function(input) {=0A=
          var state =3D this.state;=0A=
          var eventType =3D input.eventType;=0A=
=0A=
          var isRecognized =3D state & (STATE_BEGAN | STATE_CHANGED);=0A=
          var isValid =3D this.attrTest(input);=0A=
=0A=
          // on cancel input and we've recognized before, return =
STATE_CANCELLED=0A=
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {=0A=
              return state | STATE_CANCELLED;=0A=
          } else if (isRecognized || isValid) {=0A=
              if (eventType & INPUT_END) {=0A=
                  return state | STATE_ENDED;=0A=
              } else if (!(state & STATE_BEGAN)) {=0A=
                  return STATE_BEGAN;=0A=
              }=0A=
              return state | STATE_CHANGED;=0A=
          }=0A=
          return STATE_FAILED;=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * Pan=0A=
   * Recognized when the pointer is down and moved in the allowed =
direction.=0A=
   * @constructor=0A=
   * @extends AttrRecognizer=0A=
   */=0A=
  function PanRecognizer() {=0A=
      AttrRecognizer.apply(this, arguments);=0A=
=0A=
      this.pX =3D null;=0A=
      this.pY =3D null;=0A=
  }=0A=
=0A=
  inherit(PanRecognizer, AttrRecognizer, {=0A=
      /**=0A=
       * @namespace=0A=
       * @memberof PanRecognizer=0A=
       */=0A=
      defaults: {=0A=
          event: 'pan',=0A=
          threshold: 10,=0A=
          pointers: 1,=0A=
          direction: DIRECTION_ALL=0A=
      },=0A=
=0A=
      getTouchAction: function() {=0A=
          var direction =3D this.options.direction;=0A=
          var actions =3D [];=0A=
          if (direction & DIRECTION_HORIZONTAL) {=0A=
              actions.push(TOUCH_ACTION_PAN_Y);=0A=
          }=0A=
          if (direction & DIRECTION_VERTICAL) {=0A=
              actions.push(TOUCH_ACTION_PAN_X);=0A=
          }=0A=
          return actions;=0A=
      },=0A=
=0A=
      directionTest: function(input) {=0A=
          var options =3D this.options;=0A=
          var hasMoved =3D true;=0A=
          var distance =3D input.distance;=0A=
          var direction =3D input.direction;=0A=
          var x =3D input.deltaX;=0A=
          var y =3D input.deltaY;=0A=
=0A=
          // lock to axis?=0A=
          if (!(direction & options.direction)) {=0A=
              if (options.direction & DIRECTION_HORIZONTAL) {=0A=
                  direction =3D (x =3D=3D=3D 0) ? DIRECTION_NONE : (x < =
0) ? DIRECTION_LEFT : DIRECTION_RIGHT;=0A=
                  hasMoved =3D x !=3D this.pX;=0A=
                  distance =3D Math.abs(input.deltaX);=0A=
              } else {=0A=
                  direction =3D (y =3D=3D=3D 0) ? DIRECTION_NONE : (y < =
0) ? DIRECTION_UP : DIRECTION_DOWN;=0A=
                  hasMoved =3D y !=3D this.pY;=0A=
                  distance =3D Math.abs(input.deltaY);=0A=
              }=0A=
          }=0A=
          input.direction =3D direction;=0A=
          return hasMoved && distance > options.threshold && direction & =
options.direction;=0A=
      },=0A=
=0A=
      attrTest: function(input) {=0A=
          return AttrRecognizer.prototype.attrTest.call(this, input) &&=0A=
              (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) =
&& this.directionTest(input)));=0A=
      },=0A=
=0A=
      emit: function(input) {=0A=
          this.pX =3D input.deltaX;=0A=
          this.pY =3D input.deltaY;=0A=
=0A=
          var direction =3D directionStr(input.direction);=0A=
          if (direction) {=0A=
              this.manager.emit(this.options.event + direction, input);=0A=
          }=0A=
=0A=
          this._super.emit.call(this, input);=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * Pinch=0A=
   * Recognized when two or more pointers are moving toward (zoom-in) or =
away from each other (zoom-out).=0A=
   * @constructor=0A=
   * @extends AttrRecognizer=0A=
   */=0A=
  function PinchRecognizer() {=0A=
      AttrRecognizer.apply(this, arguments);=0A=
  }=0A=
=0A=
  inherit(PinchRecognizer, AttrRecognizer, {=0A=
      /**=0A=
       * @namespace=0A=
       * @memberof PinchRecognizer=0A=
       */=0A=
      defaults: {=0A=
          event: 'pinch',=0A=
          threshold: 0,=0A=
          pointers: 2=0A=
      },=0A=
=0A=
      getTouchAction: function() {=0A=
          return [TOUCH_ACTION_NONE];=0A=
      },=0A=
=0A=
      attrTest: function(input) {=0A=
          return this._super.attrTest.call(this, input) &&=0A=
              (Math.abs(input.scale - 1) > this.options.threshold || =
this.state & STATE_BEGAN);=0A=
      },=0A=
=0A=
      emit: function(input) {=0A=
          this._super.emit.call(this, input);=0A=
          if (input.scale !=3D=3D 1) {=0A=
              var inOut =3D input.scale < 1 ? 'in' : 'out';=0A=
              this.manager.emit(this.options.event + inOut, input);=0A=
          }=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * Press=0A=
   * Recognized when the pointer is down for x ms without any movement.=0A=
   * @constructor=0A=
   * @extends Recognizer=0A=
   */=0A=
  function PressRecognizer() {=0A=
      Recognizer.apply(this, arguments);=0A=
=0A=
      this._timer =3D null;=0A=
      this._input =3D null;=0A=
  }=0A=
=0A=
  inherit(PressRecognizer, Recognizer, {=0A=
      /**=0A=
       * @namespace=0A=
       * @memberof PressRecognizer=0A=
       */=0A=
      defaults: {=0A=
          event: 'press',=0A=
          pointers: 1,=0A=
          time: 500, // minimal time of the pointer to be pressed=0A=
          threshold: 5 // a minimal movement is ok, but keep it low=0A=
      },=0A=
=0A=
      getTouchAction: function() {=0A=
          return [TOUCH_ACTION_AUTO];=0A=
      },=0A=
=0A=
      process: function(input) {=0A=
          var options =3D this.options;=0A=
          var validPointers =3D input.pointers.length =3D=3D=3D =
options.pointers;=0A=
          var validMovement =3D input.distance < options.threshold;=0A=
          var validTime =3D input.deltaTime > options.time;=0A=
=0A=
          this._input =3D input;=0A=
=0A=
          // we only allow little movement=0A=
          // and we've reached an end event, so a tap is possible=0A=
          if (!validMovement || !validPointers || (input.eventType & =
(INPUT_END | INPUT_CANCEL) && !validTime)) {=0A=
              this.reset();=0A=
          } else if (input.eventType & INPUT_START) {=0A=
              this.reset();=0A=
              this._timer =3D setTimeoutContext(function() {=0A=
                  this.state =3D STATE_RECOGNIZED;=0A=
                  this.tryEmit();=0A=
              }, options.time, this);=0A=
          } else if (input.eventType & INPUT_END) {=0A=
              return STATE_RECOGNIZED;=0A=
          }=0A=
          return STATE_FAILED;=0A=
      },=0A=
=0A=
      reset: function() {=0A=
          clearTimeout(this._timer);=0A=
      },=0A=
=0A=
      emit: function(input) {=0A=
          if (this.state !=3D=3D STATE_RECOGNIZED) {=0A=
              return;=0A=
          }=0A=
=0A=
          if (input && (input.eventType & INPUT_END)) {=0A=
              this.manager.emit(this.options.event + 'up', input);=0A=
          } else {=0A=
              this._input.timeStamp =3D now();=0A=
              this.manager.emit(this.options.event, this._input);=0A=
          }=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * Rotate=0A=
   * Recognized when two or more pointer are moving in a circular motion.=0A=
   * @constructor=0A=
   * @extends AttrRecognizer=0A=
   */=0A=
  function RotateRecognizer() {=0A=
      AttrRecognizer.apply(this, arguments);=0A=
  }=0A=
=0A=
  inherit(RotateRecognizer, AttrRecognizer, {=0A=
      /**=0A=
       * @namespace=0A=
       * @memberof RotateRecognizer=0A=
       */=0A=
      defaults: {=0A=
          event: 'rotate',=0A=
          threshold: 0,=0A=
          pointers: 2=0A=
      },=0A=
=0A=
      getTouchAction: function() {=0A=
          return [TOUCH_ACTION_NONE];=0A=
      },=0A=
=0A=
      attrTest: function(input) {=0A=
          return this._super.attrTest.call(this, input) &&=0A=
              (Math.abs(input.rotation) > this.options.threshold || =
this.state & STATE_BEGAN);=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * Swipe=0A=
   * Recognized when the pointer is moving fast (velocity), with enough =
distance in the allowed direction.=0A=
   * @constructor=0A=
   * @extends AttrRecognizer=0A=
   */=0A=
  function SwipeRecognizer() {=0A=
      AttrRecognizer.apply(this, arguments);=0A=
  }=0A=
=0A=
  inherit(SwipeRecognizer, AttrRecognizer, {=0A=
      /**=0A=
       * @namespace=0A=
       * @memberof SwipeRecognizer=0A=
       */=0A=
      defaults: {=0A=
          event: 'swipe',=0A=
          threshold: 10,=0A=
          velocity: 0.65,=0A=
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,=0A=
          pointers: 1=0A=
      },=0A=
=0A=
      getTouchAction: function() {=0A=
          return PanRecognizer.prototype.getTouchAction.call(this);=0A=
      },=0A=
=0A=
      attrTest: function(input) {=0A=
          var direction =3D this.options.direction;=0A=
          var velocity;=0A=
=0A=
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {=0A=
              velocity =3D input.velocity;=0A=
          } else if (direction & DIRECTION_HORIZONTAL) {=0A=
              velocity =3D input.velocityX;=0A=
          } else if (direction & DIRECTION_VERTICAL) {=0A=
              velocity =3D input.velocityY;=0A=
          }=0A=
=0A=
          return this._super.attrTest.call(this, input) &&=0A=
              direction & input.direction &&=0A=
              input.distance > this.options.threshold &&=0A=
              abs(velocity) > this.options.velocity && input.eventType & =
INPUT_END;=0A=
      },=0A=
=0A=
      emit: function(input) {=0A=
          var direction =3D directionStr(input.direction);=0A=
          if (direction) {=0A=
              this.manager.emit(this.options.event + direction, input);=0A=
          }=0A=
=0A=
          this.manager.emit(this.options.event, input);=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * A tap is ecognized when the pointer is doing a small tap/click. =
Multiple taps are recognized if they occur=0A=
   * between the given interval and position. The delay option can be =
used to recognize multi-taps without firing=0A=
   * a single tap.=0A=
   *=0A=
   * The eventData from the emitted event contains the property =
`tapCount`, which contains the amount of=0A=
   * multi-taps being recognized.=0A=
   * @constructor=0A=
   * @extends Recognizer=0A=
   */=0A=
  function TapRecognizer() {=0A=
      Recognizer.apply(this, arguments);=0A=
=0A=
      // previous time and center,=0A=
      // used for tap counting=0A=
      this.pTime =3D false;=0A=
      this.pCenter =3D false;=0A=
=0A=
      this._timer =3D null;=0A=
      this._input =3D null;=0A=
      this.count =3D 0;=0A=
  }=0A=
=0A=
  inherit(TapRecognizer, Recognizer, {=0A=
      /**=0A=
       * @namespace=0A=
       * @memberof PinchRecognizer=0A=
       */=0A=
      defaults: {=0A=
          event: 'tap',=0A=
          pointers: 1,=0A=
          taps: 1,=0A=
          interval: 300, // max time between the multi-tap taps=0A=
          time: 250, // max time of the pointer to be down (like finger =
on the screen)=0A=
          threshold: 2, // a minimal movement is ok, but keep it low=0A=
          posThreshold: 10 // a multi-tap can be a bit off the initial =
position=0A=
      },=0A=
=0A=
      getTouchAction: function() {=0A=
          return [TOUCH_ACTION_MANIPULATION];=0A=
      },=0A=
=0A=
      process: function(input) {=0A=
          var options =3D this.options;=0A=
=0A=
          var validPointers =3D input.pointers.length =3D=3D=3D =
options.pointers;=0A=
          var validMovement =3D input.distance < options.threshold;=0A=
          var validTouchTime =3D input.deltaTime < options.time;=0A=
=0A=
          this.reset();=0A=
=0A=
          if ((input.eventType & INPUT_START) && (this.count =3D=3D=3D =
0)) {=0A=
              return this.failTimeout();=0A=
          }=0A=
=0A=
          // we only allow little movement=0A=
          // and we've reached an end event, so a tap is possible=0A=
          if (validMovement && validTouchTime && validPointers) {=0A=
              if (input.eventType !=3D INPUT_END) {=0A=
                  return this.failTimeout();=0A=
              }=0A=
=0A=
              var validInterval =3D this.pTime ? (input.timeStamp - =
this.pTime < options.interval) : true;=0A=
              var validMultiTap =3D !this.pCenter || =
getDistance(this.pCenter, input.center) < options.posThreshold;=0A=
=0A=
              this.pTime =3D input.timeStamp;=0A=
              this.pCenter =3D input.center;=0A=
=0A=
              if (!validMultiTap || !validInterval) {=0A=
                  this.count =3D 1;=0A=
              } else {=0A=
                  this.count +=3D 1;=0A=
              }=0A=
=0A=
              this._input =3D input;=0A=
=0A=
              // if tap count matches we have recognized it,=0A=
              // else it has began recognizing...=0A=
              var tapCount =3D this.count % options.taps;=0A=
              if (tapCount =3D=3D=3D 0) {=0A=
                  // no failing requirements, immediately trigger the =
tap event=0A=
                  // or wait as long as the multitap interval to trigger=0A=
                  if (!this.hasRequireFailures()) {=0A=
                      return STATE_RECOGNIZED;=0A=
                  } else {=0A=
                      this._timer =3D setTimeoutContext(function() {=0A=
                          this.state =3D STATE_RECOGNIZED;=0A=
                          this.tryEmit();=0A=
                      }, options.interval, this);=0A=
                      return STATE_BEGAN;=0A=
                  }=0A=
              }=0A=
          }=0A=
          return STATE_FAILED;=0A=
      },=0A=
=0A=
      failTimeout: function() {=0A=
          this._timer =3D setTimeoutContext(function() {=0A=
              this.state =3D STATE_FAILED;=0A=
          }, this.options.interval, this);=0A=
          return STATE_FAILED;=0A=
      },=0A=
=0A=
      reset: function() {=0A=
          clearTimeout(this._timer);=0A=
      },=0A=
=0A=
      emit: function() {=0A=
          if (this.state =3D=3D STATE_RECOGNIZED ) {=0A=
              this._input.tapCount =3D this.count;=0A=
              this.manager.emit(this.options.event, this._input);=0A=
          }=0A=
      }=0A=
  });=0A=
=0A=
  /**=0A=
   * Simple way to create an manager with a default set of recognizers.=0A=
   * @param {HTMLElement} element=0A=
   * @param {Object} [options]=0A=
   * @constructor=0A=
   */=0A=
  function Hammer(element, options) {=0A=
      options =3D options || {};=0A=
      options.recognizers =3D ifUndefined(options.recognizers, =
Hammer.defaults.preset);=0A=
      return new Manager(element, options);=0A=
  }=0A=
=0A=
  /**=0A=
   * @const {string}=0A=
   */=0A=
  Hammer.VERSION =3D '2.0.4';=0A=
=0A=
  /**=0A=
   * default settings=0A=
   * @namespace=0A=
   */=0A=
  Hammer.defaults =3D {=0A=
      /**=0A=
       * set if DOM events are being triggered.=0A=
       * But this is slower and unused by simple implementations, so =
disabled by default.=0A=
       * @type {Boolean}=0A=
       * @default false=0A=
       */=0A=
      domEvents: false,=0A=
=0A=
      /**=0A=
       * The value for the touchAction property/fallback.=0A=
       * When set to `compute` it will magically set the correct value =
based on the added recognizers.=0A=
       * @type {String}=0A=
       * @default compute=0A=
       */=0A=
      touchAction: TOUCH_ACTION_COMPUTE,=0A=
=0A=
      /**=0A=
       * @type {Boolean}=0A=
       * @default true=0A=
       */=0A=
      enable: true,=0A=
=0A=
      /**=0A=
       * EXPERIMENTAL FEATURE -- can be removed/changed=0A=
       * Change the parent input target element.=0A=
       * If Null, then it is being set the to main element.=0A=
       * @type {Null|EventTarget}=0A=
       * @default null=0A=
       */=0A=
      inputTarget: null,=0A=
=0A=
      /**=0A=
       * force an input class=0A=
       * @type {Null|Function}=0A=
       * @default null=0A=
       */=0A=
      inputClass: null,=0A=
=0A=
      /**=0A=
       * Default recognizer setup when calling `Hammer()`=0A=
       * When creating a new Manager these will be skipped.=0A=
       * @type {Array}=0A=
       */=0A=
      preset: [=0A=
          // RecognizerClass, options, [recognizeWith, ...], =
[requireFailure, ...]=0A=
          [RotateRecognizer, { enable: false }],=0A=
          [PinchRecognizer, { enable: false }, ['rotate']],=0A=
          [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],=0A=
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, =
['swipe']],=0A=
          [TapRecognizer],=0A=
          [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],=0A=
          [PressRecognizer]=0A=
      ],=0A=
=0A=
      /**=0A=
       * Some CSS properties can be used to improve the working of =
Hammer.=0A=
       * Add them to this method and they will be set when creating a =
new Manager.=0A=
       * @namespace=0A=
       */=0A=
      cssProps: {=0A=
          /**=0A=
           * Disables text selection to improve the dragging gesture. =
Mainly for desktop browsers.=0A=
           * @type {String}=0A=
           * @default 'none'=0A=
           */=0A=
          userSelect: 'none',=0A=
=0A=
          /**=0A=
           * Disable the Windows Phone grippers when pressing an element.=0A=
           * @type {String}=0A=
           * @default 'none'=0A=
           */=0A=
          touchSelect: 'none',=0A=
=0A=
          /**=0A=
           * Disables the default callout shown when you touch and hold =
a touch target.=0A=
           * On iOS, when you touch and hold a touch target such as a =
link, Safari displays=0A=
           * a callout containing information about the link. This =
property allows you to disable that callout.=0A=
           * @type {String}=0A=
           * @default 'none'=0A=
           */=0A=
          touchCallout: 'none',=0A=
=0A=
          /**=0A=
           * Specifies whether zooming is enabled. Used by IE10>=0A=
           * @type {String}=0A=
           * @default 'none'=0A=
           */=0A=
          contentZooming: 'none',=0A=
=0A=
          /**=0A=
           * Specifies that an entire element should be draggable =
instead of its contents. Mainly for desktop browsers.=0A=
           * @type {String}=0A=
           * @default 'none'=0A=
           */=0A=
          userDrag: 'none',=0A=
=0A=
          /**=0A=
           * Overrides the highlight color shown when the user taps a =
link or a JavaScript=0A=
           * clickable element in iOS. This property obeys the alpha =
value, if specified.=0A=
           * @type {String}=0A=
           * @default 'rgba(0,0,0,0)'=0A=
           */=0A=
          tapHighlightColor: 'rgba(0,0,0,0)'=0A=
      }=0A=
  };=0A=
=0A=
  var STOP =3D 1;=0A=
  var FORCED_STOP =3D 2;=0A=
=0A=
  /**=0A=
   * Manager=0A=
   * @param {HTMLElement} element=0A=
   * @param {Object} [options]=0A=
   * @constructor=0A=
   */=0A=
  function Manager(element, options) {=0A=
      options =3D options || {};=0A=
=0A=
      this.options =3D merge(options, Hammer.defaults);=0A=
      this.options.inputTarget =3D this.options.inputTarget || element;=0A=
=0A=
      this.handlers =3D {};=0A=
      this.session =3D {};=0A=
      this.recognizers =3D [];=0A=
=0A=
      this.element =3D element;=0A=
      this.input =3D createInputInstance(this);=0A=
      this.touchAction =3D new TouchAction(this, =
this.options.touchAction);=0A=
=0A=
      toggleCssProps(this, true);=0A=
=0A=
      each(options.recognizers, function(item) {=0A=
          var recognizer =3D this.add(new (item[0])(item[1]));=0A=
          item[2] && recognizer.recognizeWith(item[2]);=0A=
          item[3] && recognizer.requireFailure(item[3]);=0A=
      }, this);=0A=
  }=0A=
=0A=
  Manager.prototype =3D {=0A=
      /**=0A=
       * set options=0A=
       * @param {Object} options=0A=
       * @returns {Manager}=0A=
       */=0A=
      set: function(options) {=0A=
          extend(this.options, options);=0A=
=0A=
          // Options that need a little more setup=0A=
          if (options.touchAction) {=0A=
              this.touchAction.update();=0A=
          }=0A=
          if (options.inputTarget) {=0A=
              // Clean up existing event listeners and reinitialize=0A=
              this.input.destroy();=0A=
              this.input.target =3D options.inputTarget;=0A=
              this.input.init();=0A=
          }=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * stop recognizing for this session.=0A=
       * This session will be discarded, when a new [input]start event =
is fired.=0A=
       * When forced, the recognizer cycle is stopped immediately.=0A=
       * @param {Boolean} [force]=0A=
       */=0A=
      stop: function(force) {=0A=
          this.session.stopped =3D force ? FORCED_STOP : STOP;=0A=
      },=0A=
=0A=
      /**=0A=
       * run the recognizers!=0A=
       * called by the inputHandler function on every movement of the =
pointers (touches)=0A=
       * it walks through all the recognizers and tries to detect the =
gesture that is being made=0A=
       * @param {Object} inputData=0A=
       */=0A=
      recognize: function(inputData) {=0A=
          var session =3D this.session;=0A=
          if (session.stopped) {=0A=
              return;=0A=
          }=0A=
=0A=
          // run the touch-action polyfill=0A=
          this.touchAction.preventDefaults(inputData);=0A=
=0A=
          var recognizer;=0A=
          var recognizers =3D this.recognizers;=0A=
=0A=
          // this holds the recognizer that is being recognized.=0A=
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED =
or RECOGNIZED=0A=
          // if no recognizer is detecting a thing, it is set to `null`=0A=
          var curRecognizer =3D session.curRecognizer;=0A=
=0A=
          // reset when the last recognizer is recognized=0A=
          // or when we're in a new session=0A=
          if (!curRecognizer || (curRecognizer && curRecognizer.state & =
STATE_RECOGNIZED)) {=0A=
              curRecognizer =3D session.curRecognizer =3D null;=0A=
          }=0A=
=0A=
          var i =3D 0;=0A=
          while (i < recognizers.length) {=0A=
              recognizer =3D recognizers[i];=0A=
=0A=
              // find out if we are allowed try to recognize the input =
for this one.=0A=
              // 1.   allow if the session is NOT forced stopped (see =
the .stop() method)=0A=
              // 2.   allow if we still haven't recognized a gesture in =
this session, or the this recognizer is the one=0A=
              //      that is being recognized.=0A=
              // 3.   allow if the recognizer is allowed to run =
simultaneous with the current recognized recognizer.=0A=
              //      this can be setup with the `recognizeWith()` =
method on the recognizer.=0A=
              if (session.stopped !=3D=3D FORCED_STOP && ( // 1=0A=
                      !curRecognizer || recognizer =3D=3D curRecognizer =
|| // 2=0A=
                      recognizer.canRecognizeWith(curRecognizer))) { // 3=0A=
                  recognizer.recognize(inputData);=0A=
              } else {=0A=
                  recognizer.reset();=0A=
              }=0A=
=0A=
              // if the recognizer has been recognizing the input as a =
valid gesture, we want to store this one as the=0A=
              // current active recognizer. but only if we don't already =
have an active recognizer=0A=
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | =
STATE_CHANGED | STATE_ENDED)) {=0A=
                  curRecognizer =3D session.curRecognizer =3D recognizer;=0A=
              }=0A=
              i++;=0A=
          }=0A=
      },=0A=
=0A=
      /**=0A=
       * get a recognizer by its event name.=0A=
       * @param {Recognizer|String} recognizer=0A=
       * @returns {Recognizer|Null}=0A=
       */=0A=
      get: function(recognizer) {=0A=
          if (recognizer instanceof Recognizer) {=0A=
              return recognizer;=0A=
          }=0A=
=0A=
          var recognizers =3D this.recognizers;=0A=
          for (var i =3D 0; i < recognizers.length; i++) {=0A=
              if (recognizers[i].options.event =3D=3D recognizer) {=0A=
                  return recognizers[i];=0A=
              }=0A=
          }=0A=
          return null;=0A=
      },=0A=
=0A=
      /**=0A=
       * add a recognizer to the manager=0A=
       * existing recognizers with the same event name will be removed=0A=
       * @param {Recognizer} recognizer=0A=
       * @returns {Recognizer|Manager}=0A=
       */=0A=
      add: function(recognizer) {=0A=
          if (invokeArrayArg(recognizer, 'add', this)) {=0A=
              return this;=0A=
          }=0A=
=0A=
          // remove existing=0A=
          var existing =3D this.get(recognizer.options.event);=0A=
          if (existing) {=0A=
              this.remove(existing);=0A=
          }=0A=
=0A=
          this.recognizers.push(recognizer);=0A=
          recognizer.manager =3D this;=0A=
=0A=
          this.touchAction.update();=0A=
          return recognizer;=0A=
      },=0A=
=0A=
      /**=0A=
       * remove a recognizer by name or instance=0A=
       * @param {Recognizer|String} recognizer=0A=
       * @returns {Manager}=0A=
       */=0A=
      remove: function(recognizer) {=0A=
          if (invokeArrayArg(recognizer, 'remove', this)) {=0A=
              return this;=0A=
          }=0A=
=0A=
          var recognizers =3D this.recognizers;=0A=
          recognizer =3D this.get(recognizer);=0A=
          recognizers.splice(inArray(recognizers, recognizer), 1);=0A=
=0A=
          this.touchAction.update();=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * bind event=0A=
       * @param {String} events=0A=
       * @param {Function} handler=0A=
       * @returns {EventEmitter} this=0A=
       */=0A=
      on: function(events, handler) {=0A=
          var handlers =3D this.handlers;=0A=
          each(splitStr(events), function(event) {=0A=
              handlers[event] =3D handlers[event] || [];=0A=
              handlers[event].push(handler);=0A=
          });=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * unbind event, leave emit blank to remove all handlers=0A=
       * @param {String} events=0A=
       * @param {Function} [handler]=0A=
       * @returns {EventEmitter} this=0A=
       */=0A=
      off: function(events, handler) {=0A=
          var handlers =3D this.handlers;=0A=
          each(splitStr(events), function(event) {=0A=
              if (!handler) {=0A=
                  delete handlers[event];=0A=
              } else {=0A=
                  handlers[event].splice(inArray(handlers[event], =
handler), 1);=0A=
              }=0A=
          });=0A=
          return this;=0A=
      },=0A=
=0A=
      /**=0A=
       * emit event to the listeners=0A=
       * @param {String} event=0A=
       * @param {Object} data=0A=
       */=0A=
      emit: function(event, data) {=0A=
          // we also want to trigger dom events=0A=
          if (this.options.domEvents) {=0A=
              triggerDomEvent(event, data);=0A=
          }=0A=
=0A=
          // no handlers, so skip it all=0A=
          var handlers =3D this.handlers[event] && =
this.handlers[event].slice();=0A=
          if (!handlers || !handlers.length) {=0A=
              return;=0A=
          }=0A=
=0A=
          data.type =3D event;=0A=
          data.preventDefault =3D function() {=0A=
              data.srcEvent.preventDefault();=0A=
          };=0A=
=0A=
          var i =3D 0;=0A=
          while (i < handlers.length) {=0A=
              handlers[i](data);=0A=
              i++;=0A=
          }=0A=
      },=0A=
=0A=
      /**=0A=
       * destroy the manager and unbinds all events=0A=
       * it doesn't unbind dom events, that is the user own =
responsibility=0A=
       */=0A=
      destroy: function() {=0A=
          this.element && toggleCssProps(this, false);=0A=
=0A=
          this.handlers =3D {};=0A=
          this.session =3D {};=0A=
          this.input.destroy();=0A=
          this.element =3D null;=0A=
      }=0A=
  };=0A=
=0A=
  /**=0A=
   * add/remove the css properties as defined in manager.options.cssProps=0A=
   * @param {Manager} manager=0A=
   * @param {Boolean} add=0A=
   */=0A=
  function toggleCssProps(manager, add) {=0A=
      var element =3D manager.element;=0A=
      each(manager.options.cssProps, function(value, name) {=0A=
          element.style[prefixed(element.style, name)] =3D add ? value : =
'';=0A=
      });=0A=
  }=0A=
=0A=
  /**=0A=
   * trigger dom event=0A=
   * @param {String} event=0A=
   * @param {Object} data=0A=
   */=0A=
  function triggerDomEvent(event, data) {=0A=
      var gestureEvent =3D document.createEvent('Event');=0A=
      gestureEvent.initEvent(event, true, true);=0A=
      gestureEvent.gesture =3D data;=0A=
      data.target.dispatchEvent(gestureEvent);=0A=
  }=0A=
=0A=
  extend(Hammer, {=0A=
      INPUT_START: INPUT_START,=0A=
      INPUT_MOVE: INPUT_MOVE,=0A=
      INPUT_END: INPUT_END,=0A=
      INPUT_CANCEL: INPUT_CANCEL,=0A=
=0A=
      STATE_POSSIBLE: STATE_POSSIBLE,=0A=
      STATE_BEGAN: STATE_BEGAN,=0A=
      STATE_CHANGED: STATE_CHANGED,=0A=
      STATE_ENDED: STATE_ENDED,=0A=
      STATE_RECOGNIZED: STATE_RECOGNIZED,=0A=
      STATE_CANCELLED: STATE_CANCELLED,=0A=
      STATE_FAILED: STATE_FAILED,=0A=
=0A=
      DIRECTION_NONE: DIRECTION_NONE,=0A=
      DIRECTION_LEFT: DIRECTION_LEFT,=0A=
      DIRECTION_RIGHT: DIRECTION_RIGHT,=0A=
      DIRECTION_UP: DIRECTION_UP,=0A=
      DIRECTION_DOWN: DIRECTION_DOWN,=0A=
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,=0A=
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,=0A=
      DIRECTION_ALL: DIRECTION_ALL,=0A=
=0A=
      Manager: Manager,=0A=
      Input: Input,=0A=
      TouchAction: TouchAction,=0A=
=0A=
      TouchInput: TouchInput,=0A=
      MouseInput: MouseInput,=0A=
      PointerEventInput: PointerEventInput,=0A=
      TouchMouseInput: TouchMouseInput,=0A=
      SingleTouchInput: SingleTouchInput,=0A=
=0A=
      Recognizer: Recognizer,=0A=
      AttrRecognizer: AttrRecognizer,=0A=
      Tap: TapRecognizer,=0A=
      Pan: PanRecognizer,=0A=
      Swipe: SwipeRecognizer,=0A=
      Pinch: PinchRecognizer,=0A=
      Rotate: RotateRecognizer,=0A=
      Press: PressRecognizer,=0A=
=0A=
      on: addEventListeners,=0A=
      off: removeEventListeners,=0A=
      each: each,=0A=
      merge: merge,=0A=
      extend: extend,=0A=
      inherit: inherit,=0A=
      bindFn: bindFn,=0A=
      prefixed: prefixed=0A=
  });=0A=
=0A=
  if ("function" =3D=3D TYPE_FUNCTION && __webpack_require__(6)) {=0A=
      !(__WEBPACK_AMD_DEFINE_RESULT__ =3D function() {=0A=
          return Hammer;=0A=
      }.call(exports, __webpack_require__, exports, module), =
__WEBPACK_AMD_DEFINE_RESULT__ !=3D=3D undefined && (module.exports =3D =
__WEBPACK_AMD_DEFINE_RESULT__));=0A=
  } else if (typeof module !=3D 'undefined' && module.exports) {=0A=
      module.exports =3D Hammer;=0A=
  } else {=0A=
      window[exportName] =3D Hammer;=0A=
  }=0A=
=0A=
  })(window, document, 'Hammer');=0A=
=0A=
=0A=
/***/ },=0A=
/* 6 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) =
{module.exports =3D __webpack_amd_options__;=0A=
=0A=
  /* WEBPACK VAR INJECTION */}.call(exports, {}))=0A=
=0A=
/***/ },=0A=
/* 7 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  // utility functions=0A=
=0A=
  // first check if moment.js is already loaded in the browser window, =
if so,=0A=
  // use this instance. Else, load via commonjs.=0A=
=0A=
  'use strict';=0A=
=0A=
  var moment =3D __webpack_require__(8);=0A=
  var uuid =3D __webpack_require__(12);=0A=
=0A=
  /**=0A=
   * Test whether given object is a number=0A=
   * @param {*} object=0A=
   * @return {Boolean} isNumber=0A=
   */=0A=
  exports.isNumber =3D function (object) {=0A=
    return object instanceof Number || typeof object =3D=3D 'number';=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove everything in the DOM object=0A=
   * @param DOMobject=0A=
   */=0A=
  exports.recursiveDOMDelete =3D function (DOMobject) {=0A=
    if (DOMobject) {=0A=
      while (DOMobject.hasChildNodes() =3D=3D=3D true) {=0A=
        exports.recursiveDOMDelete(DOMobject.firstChild);=0A=
        DOMobject.removeChild(DOMobject.firstChild);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this function gives you a range between 0 and 1 based on the min =
and max values in the set, the total sum of all values and the current =
value.=0A=
   *=0A=
   * @param min=0A=
   * @param max=0A=
   * @param total=0A=
   * @param value=0A=
   * @returns {number}=0A=
   */=0A=
  exports.giveRange =3D function (min, max, total, value) {=0A=
    if (max =3D=3D min) {=0A=
      return 0.5;=0A=
    } else {=0A=
      var scale =3D 1 / (max - min);=0A=
      return Math.max(0, (value - min) * scale);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Test whether given object is a string=0A=
   * @param {*} object=0A=
   * @return {Boolean} isString=0A=
   */=0A=
  exports.isString =3D function (object) {=0A=
    return object instanceof String || typeof object =3D=3D 'string';=0A=
  };=0A=
=0A=
  /**=0A=
   * Test whether given object is a Date, or a String containing a Date=0A=
   * @param {Date | String} object=0A=
   * @return {Boolean} isDate=0A=
   */=0A=
  exports.isDate =3D function (object) {=0A=
    if (object instanceof Date) {=0A=
      return true;=0A=
    } else if (exports.isString(object)) {=0A=
      // test whether this string contains a date=0A=
      var match =3D ASPDateRegex.exec(object);=0A=
      if (match) {=0A=
        return true;=0A=
      } else if (!isNaN(Date.parse(object))) {=0A=
        return true;=0A=
      }=0A=
    }=0A=
=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a semi UUID=0A=
   * source: http://stackoverflow.com/a/105074/1262753=0A=
   * @return {String} uuid=0A=
   */=0A=
  exports.randomUUID =3D function () {=0A=
    return uuid.v4();=0A=
  };=0A=
=0A=
  /**=0A=
   * assign all keys of an object that are not nested objects to a =
certain value (used for color objects).=0A=
   * @param obj=0A=
   * @param value=0A=
   */=0A=
  exports.assignAllKeys =3D function (obj, value) {=0A=
    for (var prop in obj) {=0A=
      if (obj.hasOwnProperty(prop)) {=0A=
        if (typeof obj[prop] !=3D=3D 'object') {=0A=
          obj[prop] =3D value;=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Fill an object with a possibly partially defined other object. Only =
copies values if the a object has an object requiring values.=0A=
   * That means an object is not created on a property if only the b =
object has it.=0A=
   * @param obj=0A=
   * @param value=0A=
   */=0A=
  exports.fillIfDefined =3D function (a, b) {=0A=
    var allowDeletion =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? false : arguments[2];=0A=
=0A=
    for (var prop in a) {=0A=
      if (b[prop] !=3D=3D undefined) {=0A=
        if (typeof b[prop] !=3D=3D 'object') {=0A=
          if ((b[prop] =3D=3D=3D undefined || b[prop] =3D=3D=3D null) && =
a[prop] !=3D=3D undefined && allowDeletion =3D=3D=3D true) {=0A=
            delete a[prop];=0A=
          } else {=0A=
            a[prop] =3D b[prop];=0A=
          }=0A=
        } else {=0A=
          if (typeof a[prop] =3D=3D=3D 'object') {=0A=
            exports.fillIfDefined(a[prop], b[prop], allowDeletion);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Extend object a with the properties of object b or a series of =
objects=0A=
   * Only properties with defined values are copied=0A=
   * @param {Object} a=0A=
   * @param {... Object} b=0A=
   * @return {Object} a=0A=
   */=0A=
  exports.protoExtend =3D function (a, b) {=0A=
    for (var i =3D 1; i < arguments.length; i++) {=0A=
      var other =3D arguments[i];=0A=
      for (var prop in other) {=0A=
        a[prop] =3D other[prop];=0A=
      }=0A=
    }=0A=
    return a;=0A=
  };=0A=
=0A=
  /**=0A=
   * Extend object a with the properties of object b or a series of =
objects=0A=
   * Only properties with defined values are copied=0A=
   * @param {Object} a=0A=
   * @param {... Object} b=0A=
   * @return {Object} a=0A=
   */=0A=
  exports.extend =3D function (a, b) {=0A=
    for (var i =3D 1; i < arguments.length; i++) {=0A=
      var other =3D arguments[i];=0A=
      for (var prop in other) {=0A=
        if (other.hasOwnProperty(prop)) {=0A=
          a[prop] =3D other[prop];=0A=
        }=0A=
      }=0A=
    }=0A=
    return a;=0A=
  };=0A=
=0A=
  /**=0A=
   * Extend object a with selected properties of object b or a series of =
objects=0A=
   * Only properties with defined values are copied=0A=
   * @param {Array.<String>} props=0A=
   * @param {Object} a=0A=
   * @param {Object} b=0A=
   * @return {Object} a=0A=
   */=0A=
  exports.selectiveExtend =3D function (props, a, b) {=0A=
    if (!Array.isArray(props)) {=0A=
      throw new Error('Array with property names expected as first =
argument');=0A=
    }=0A=
=0A=
    for (var i =3D 2; i < arguments.length; i++) {=0A=
      var other =3D arguments[i];=0A=
=0A=
      for (var p =3D 0; p < props.length; p++) {=0A=
        var prop =3D props[p];=0A=
        if (other.hasOwnProperty(prop)) {=0A=
          a[prop] =3D other[prop];=0A=
        }=0A=
      }=0A=
    }=0A=
    return a;=0A=
  };=0A=
=0A=
  /**=0A=
   * Extend object a with selected properties of object b or a series of =
objects=0A=
   * Only properties with defined values are copied=0A=
   * @param {Array.<String>} props=0A=
   * @param {Object} a=0A=
   * @param {Object} b=0A=
   * @return {Object} a=0A=
   */=0A=
  exports.selectiveDeepExtend =3D function (props, a, b) {=0A=
    var allowDeletion =3D arguments.length <=3D 3 || arguments[3] =
=3D=3D=3D undefined ? false : arguments[3];=0A=
=0A=
    // TODO: add support for Arrays to deepExtend=0A=
    if (Array.isArray(b)) {=0A=
      throw new TypeError('Arrays are not supported by deepExtend');=0A=
    }=0A=
    for (var i =3D 2; i < arguments.length; i++) {=0A=
      var other =3D arguments[i];=0A=
      for (var p =3D 0; p < props.length; p++) {=0A=
        var prop =3D props[p];=0A=
        if (other.hasOwnProperty(prop)) {=0A=
          if (b[prop] && b[prop].constructor =3D=3D=3D Object) {=0A=
            if (a[prop] =3D=3D=3D undefined) {=0A=
              a[prop] =3D {};=0A=
            }=0A=
            if (a[prop].constructor =3D=3D=3D Object) {=0A=
              exports.deepExtend(a[prop], b[prop], false, allowDeletion);=0A=
            } else {=0A=
              if (b[prop] =3D=3D=3D null && a[prop] !=3D=3D undefined && =
allowDeletion =3D=3D=3D true) {=0A=
                delete a[prop];=0A=
              } else {=0A=
                a[prop] =3D b[prop];=0A=
              }=0A=
            }=0A=
          } else if (Array.isArray(b[prop])) {=0A=
            throw new TypeError('Arrays are not supported by =
deepExtend');=0A=
          } else {=0A=
            a[prop] =3D b[prop];=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
    return a;=0A=
  };=0A=
=0A=
  /**=0A=
   * Extend object a with selected properties of object b or a series of =
objects=0A=
   * Only properties with defined values are copied=0A=
   * @param {Array.<String>} props=0A=
   * @param {Object} a=0A=
   * @param {Object} b=0A=
   * @return {Object} a=0A=
   */=0A=
  exports.selectiveNotDeepExtend =3D function (props, a, b) {=0A=
    var allowDeletion =3D arguments.length <=3D 3 || arguments[3] =
=3D=3D=3D undefined ? false : arguments[3];=0A=
=0A=
    // TODO: add support for Arrays to deepExtend=0A=
    if (Array.isArray(b)) {=0A=
      throw new TypeError('Arrays are not supported by deepExtend');=0A=
    }=0A=
    for (var prop in b) {=0A=
      if (b.hasOwnProperty(prop)) {=0A=
        if (props.indexOf(prop) =3D=3D -1) {=0A=
          if (b[prop] && b[prop].constructor =3D=3D=3D Object) {=0A=
            if (a[prop] =3D=3D=3D undefined) {=0A=
              a[prop] =3D {};=0A=
            }=0A=
            if (a[prop].constructor =3D=3D=3D Object) {=0A=
              exports.deepExtend(a[prop], b[prop]);=0A=
            } else {=0A=
              if (b[prop] =3D=3D=3D null && a[prop] !=3D=3D undefined && =
allowDeletion =3D=3D=3D true) {=0A=
                delete a[prop];=0A=
              } else {=0A=
                a[prop] =3D b[prop];=0A=
              }=0A=
            }=0A=
          } else if (Array.isArray(b[prop])) {=0A=
            a[prop] =3D [];=0A=
            for (var i =3D 0; i < b[prop].length; i++) {=0A=
              a[prop].push(b[prop][i]);=0A=
            }=0A=
          } else {=0A=
            a[prop] =3D b[prop];=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
    return a;=0A=
  };=0A=
=0A=
  /**=0A=
   * Deep extend an object a with the properties of object b=0A=
   * @param {Object} a=0A=
   * @param {Object} b=0A=
   * @param [Boolean] protoExtend --> optional parameter. If true, the =
prototype values will also be extended.=0A=
   *                                  (ie. the options objects that =
inherit from others will also get the inherited options)=0A=
   * @param [Boolean] global      --> optional parameter. If true, the =
values of fields that are null will not deleted=0A=
   * @returns {Object}=0A=
   */=0A=
  exports.deepExtend =3D function (a, b, protoExtend, allowDeletion) {=0A=
    for (var prop in b) {=0A=
      if (b.hasOwnProperty(prop) || protoExtend =3D=3D=3D true) {=0A=
        if (b[prop] && b[prop].constructor =3D=3D=3D Object) {=0A=
          if (a[prop] =3D=3D=3D undefined) {=0A=
            a[prop] =3D {};=0A=
          }=0A=
          if (a[prop].constructor =3D=3D=3D Object) {=0A=
            exports.deepExtend(a[prop], b[prop], protoExtend);=0A=
          } else {=0A=
            if (b[prop] =3D=3D=3D null && a[prop] !=3D=3D undefined && =
allowDeletion =3D=3D=3D true) {=0A=
              delete a[prop];=0A=
            } else {=0A=
              a[prop] =3D b[prop];=0A=
            }=0A=
          }=0A=
        } else if (Array.isArray(b[prop])) {=0A=
          a[prop] =3D [];=0A=
          for (var i =3D 0; i < b[prop].length; i++) {=0A=
            a[prop].push(b[prop][i]);=0A=
          }=0A=
        } else {=0A=
          a[prop] =3D b[prop];=0A=
        }=0A=
      }=0A=
    }=0A=
    return a;=0A=
  };=0A=
=0A=
  /**=0A=
   * Test whether all elements in two arrays are equal.=0A=
   * @param {Array} a=0A=
   * @param {Array} b=0A=
   * @return {boolean} Returns true if both arrays have the same length =
and same=0A=
   *                   elements.=0A=
   */=0A=
  exports.equalArray =3D function (a, b) {=0A=
    if (a.length !=3D b.length) return false;=0A=
=0A=
    for (var i =3D 0, len =3D a.length; i < len; i++) {=0A=
      if (a[i] !=3D b[i]) return false;=0A=
    }=0A=
=0A=
    return true;=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert an object to another type=0A=
   * @param {Boolean | Number | String | Date | Moment | Null | =
undefined} object=0A=
   * @param {String | undefined} type   Name of the type. Available =
types:=0A=
   *                                    'Boolean', 'Number', 'String',=0A=
   *                                    'Date', 'Moment', ISODate', =
'ASPDate'.=0A=
   * @return {*} object=0A=
   * @throws Error=0A=
   */=0A=
  exports.convert =3D function (object, type) {=0A=
    var match;=0A=
=0A=
    if (object =3D=3D=3D undefined) {=0A=
      return undefined;=0A=
    }=0A=
    if (object =3D=3D=3D null) {=0A=
      return null;=0A=
    }=0A=
=0A=
    if (!type) {=0A=
      return object;=0A=
    }=0A=
    if (!(typeof type =3D=3D=3D 'string') && !(type instanceof String)) {=0A=
      throw new Error('Type must be a string');=0A=
    }=0A=
=0A=
    //noinspection FallthroughInSwitchStatementJS=0A=
    switch (type) {=0A=
      case 'boolean':=0A=
      case 'Boolean':=0A=
        return Boolean(object);=0A=
=0A=
      case 'number':=0A=
      case 'Number':=0A=
        return Number(object.valueOf());=0A=
=0A=
      case 'string':=0A=
      case 'String':=0A=
        return String(object);=0A=
=0A=
      case 'Date':=0A=
        if (exports.isNumber(object)) {=0A=
          return new Date(object);=0A=
        }=0A=
        if (object instanceof Date) {=0A=
          return new Date(object.valueOf());=0A=
        } else if (moment.isMoment(object)) {=0A=
          return new Date(object.valueOf());=0A=
        }=0A=
        if (exports.isString(object)) {=0A=
          match =3D ASPDateRegex.exec(object);=0A=
          if (match) {=0A=
            // object is an ASP date=0A=
            return new Date(Number(match[1])); // parse number=0A=
          } else {=0A=
            return moment(object).toDate(); // parse string=0A=
          }=0A=
        } else {=0A=
          throw new Error('Cannot convert object of type ' + =
exports.getType(object) + ' to type Date');=0A=
        }=0A=
=0A=
      case 'Moment':=0A=
        if (exports.isNumber(object)) {=0A=
          return moment(object);=0A=
        }=0A=
        if (object instanceof Date) {=0A=
          return moment(object.valueOf());=0A=
        } else if (moment.isMoment(object)) {=0A=
          return moment(object);=0A=
        }=0A=
        if (exports.isString(object)) {=0A=
          match =3D ASPDateRegex.exec(object);=0A=
          if (match) {=0A=
            // object is an ASP date=0A=
            return moment(Number(match[1])); // parse number=0A=
          } else {=0A=
            return moment(object); // parse string=0A=
          }=0A=
        } else {=0A=
          throw new Error('Cannot convert object of type ' + =
exports.getType(object) + ' to type Date');=0A=
        }=0A=
=0A=
      case 'ISODate':=0A=
        if (exports.isNumber(object)) {=0A=
          return new Date(object);=0A=
        } else if (object instanceof Date) {=0A=
          return object.toISOString();=0A=
        } else if (moment.isMoment(object)) {=0A=
          return object.toDate().toISOString();=0A=
        } else if (exports.isString(object)) {=0A=
          match =3D ASPDateRegex.exec(object);=0A=
          if (match) {=0A=
            // object is an ASP date=0A=
            return new Date(Number(match[1])).toISOString(); // parse =
number=0A=
          } else {=0A=
            return new Date(object).toISOString(); // parse string=0A=
          }=0A=
        } else {=0A=
          throw new Error('Cannot convert object of type ' + =
exports.getType(object) + ' to type ISODate');=0A=
        }=0A=
=0A=
      case 'ASPDate':=0A=
        if (exports.isNumber(object)) {=0A=
          return '/Date(' + object + ')/';=0A=
        } else if (object instanceof Date) {=0A=
          return '/Date(' + object.valueOf() + ')/';=0A=
        } else if (exports.isString(object)) {=0A=
          match =3D ASPDateRegex.exec(object);=0A=
          var value;=0A=
          if (match) {=0A=
            // object is an ASP date=0A=
            value =3D new Date(Number(match[1])).valueOf(); // parse =
number=0A=
          } else {=0A=
            value =3D new Date(object).valueOf(); // parse string=0A=
          }=0A=
          return '/Date(' + value + ')/';=0A=
        } else {=0A=
          throw new Error('Cannot convert object of type ' + =
exports.getType(object) + ' to type ASPDate');=0A=
        }=0A=
=0A=
      default:=0A=
        throw new Error('Unknown type "' + type + '"');=0A=
    }=0A=
  };=0A=
=0A=
  // parse ASP.Net Date pattern,=0A=
  // for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'=0A=
  // code from http://momentjs.com/=0A=
  var ASPDateRegex =3D /^\/?Date\((\-?\d+)/i;=0A=
=0A=
  /**=0A=
   * Get the type of an object, for example exports.getType([]) returns =
'Array'=0A=
   * @param {*} object=0A=
   * @return {String} type=0A=
   */=0A=
  exports.getType =3D function (object) {=0A=
    var type =3D typeof object;=0A=
=0A=
    if (type =3D=3D 'object') {=0A=
      if (object =3D=3D=3D null) {=0A=
        return 'null';=0A=
      }=0A=
      if (object instanceof Boolean) {=0A=
        return 'Boolean';=0A=
      }=0A=
      if (object instanceof Number) {=0A=
        return 'Number';=0A=
      }=0A=
      if (object instanceof String) {=0A=
        return 'String';=0A=
      }=0A=
      if (Array.isArray(object)) {=0A=
        return 'Array';=0A=
      }=0A=
      if (object instanceof Date) {=0A=
        return 'Date';=0A=
      }=0A=
      return 'Object';=0A=
    } else if (type =3D=3D 'number') {=0A=
      return 'Number';=0A=
    } else if (type =3D=3D 'boolean') {=0A=
      return 'Boolean';=0A=
    } else if (type =3D=3D 'string') {=0A=
      return 'String';=0A=
    } else if (type =3D=3D=3D undefined) {=0A=
      return 'undefined';=0A=
    }=0A=
=0A=
    return type;=0A=
  };=0A=
=0A=
  /**=0A=
   * Used to extend an array and copy it. This is used to propagate =
paths recursively.=0A=
   *=0A=
   * @param arr=0A=
   * @param newValue=0A=
   * @returns {Array}=0A=
   */=0A=
  exports.copyAndExtendArray =3D function (arr, newValue) {=0A=
    var newArr =3D [];=0A=
    for (var i =3D 0; i < arr.length; i++) {=0A=
      newArr.push(arr[i]);=0A=
    }=0A=
    newArr.push(newValue);=0A=
    return newArr;=0A=
  };=0A=
=0A=
  /**=0A=
   * Used to extend an array and copy it. This is used to propagate =
paths recursively.=0A=
   *=0A=
   * @param arr=0A=
   * @param newValue=0A=
   * @returns {Array}=0A=
   */=0A=
  exports.copyArray =3D function (arr) {=0A=
    var newArr =3D [];=0A=
    for (var i =3D 0; i < arr.length; i++) {=0A=
      newArr.push(arr[i]);=0A=
    }=0A=
    return newArr;=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the absolute left value of a DOM element=0A=
   * @param {Element} elem        A dom element, for example a div=0A=
   * @return {number} left        The absolute left position of this =
element=0A=
   *                              in the browser page.=0A=
   */=0A=
  exports.getAbsoluteLeft =3D function (elem) {=0A=
    return elem.getBoundingClientRect().left;=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the absolute top value of a DOM element=0A=
   * @param {Element} elem        A dom element, for example a div=0A=
   * @return {number} top        The absolute top position of this =
element=0A=
   *                              in the browser page.=0A=
   */=0A=
  exports.getAbsoluteTop =3D function (elem) {=0A=
    return elem.getBoundingClientRect().top;=0A=
  };=0A=
=0A=
  /**=0A=
   * add a className to the given elements style=0A=
   * @param {Element} elem=0A=
   * @param {String} className=0A=
   */=0A=
  exports.addClassName =3D function (elem, className) {=0A=
    var classes =3D elem.className.split(' ');=0A=
    if (classes.indexOf(className) =3D=3D -1) {=0A=
      classes.push(className); // add the class to the array=0A=
      elem.className =3D classes.join(' ');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * add a className to the given elements style=0A=
   * @param {Element} elem=0A=
   * @param {String} className=0A=
   */=0A=
  exports.removeClassName =3D function (elem, className) {=0A=
    var classes =3D elem.className.split(' ');=0A=
    var index =3D classes.indexOf(className);=0A=
    if (index !=3D -1) {=0A=
      classes.splice(index, 1); // remove the class from the array=0A=
      elem.className =3D classes.join(' ');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * For each method for both arrays and objects.=0A=
   * In case of an array, the built-in Array.forEach() is applied.=0A=
   * In case of an Object, the method loops over all properties of the =
object.=0A=
   * @param {Object | Array} object   An Object or Array=0A=
   * @param {function} callback       Callback method, called for each =
item in=0A=
   *                                  the object or array with three =
parameters:=0A=
   *                                  callback(value, index, object)=0A=
   */=0A=
  exports.forEach =3D function (object, callback) {=0A=
    var i, len;=0A=
    if (Array.isArray(object)) {=0A=
      // array=0A=
      for (i =3D 0, len =3D object.length; i < len; i++) {=0A=
        callback(object[i], i, object);=0A=
      }=0A=
    } else {=0A=
      // object=0A=
      for (i in object) {=0A=
        if (object.hasOwnProperty(i)) {=0A=
          callback(object[i], i, object);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert an object into an array: all objects properties are put =
into the=0A=
   * array. The resulting array is unordered.=0A=
   * @param {Object} object=0A=
   * @param {Array} array=0A=
   */=0A=
  exports.toArray =3D function (object) {=0A=
    var array =3D [];=0A=
=0A=
    for (var prop in object) {=0A=
      if (object.hasOwnProperty(prop)) array.push(object[prop]);=0A=
    }=0A=
=0A=
    return array;=0A=
  };=0A=
=0A=
  /**=0A=
   * Update a property in an object=0A=
   * @param {Object} object=0A=
   * @param {String} key=0A=
   * @param {*} value=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  exports.updateProperty =3D function (object, key, value) {=0A=
    if (object[key] !=3D=3D value) {=0A=
      object[key] =3D value;=0A=
      return true;=0A=
    } else {=0A=
      return false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Add and event listener. Works for all browsers=0A=
   * @param {Element}     element    An html element=0A=
   * @param {string}      action     The action, for example "click",=0A=
   *                                 without the prefix "on"=0A=
   * @param {function}    listener   The callback function to be executed=0A=
   * @param {boolean}     [useCapture]=0A=
   */=0A=
  exports.addEventListener =3D function (element, action, listener, =
useCapture) {=0A=
    if (element.addEventListener) {=0A=
      if (useCapture =3D=3D=3D undefined) useCapture =3D false;=0A=
=0A=
      if (action =3D=3D=3D 'mousewheel' && =
navigator.userAgent.indexOf('Firefox') >=3D 0) {=0A=
        action =3D 'DOMMouseScroll'; // For Firefox=0A=
      }=0A=
=0A=
      element.addEventListener(action, listener, useCapture);=0A=
    } else {=0A=
      element.attachEvent('on' + action, listener); // IE browsers=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove an event listener from an element=0A=
   * @param {Element}     element         An html dom element=0A=
   * @param {string}      action          The name of the event, for =
example "mousedown"=0A=
   * @param {function}    listener        The listener function=0A=
   * @param {boolean}     [useCapture]=0A=
   */=0A=
  exports.removeEventListener =3D function (element, action, listener, =
useCapture) {=0A=
    if (element.removeEventListener) {=0A=
      // non-IE browsers=0A=
      if (useCapture =3D=3D=3D undefined) useCapture =3D false;=0A=
=0A=
      if (action =3D=3D=3D 'mousewheel' && =
navigator.userAgent.indexOf('Firefox') >=3D 0) {=0A=
        action =3D 'DOMMouseScroll'; // For Firefox=0A=
      }=0A=
=0A=
      element.removeEventListener(action, listener, useCapture);=0A=
    } else {=0A=
      // IE browsers=0A=
      element.detachEvent('on' + action, listener);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Cancels the event if it is cancelable, without stopping further =
propagation of the event.=0A=
   */=0A=
  exports.preventDefault =3D function (event) {=0A=
    if (!event) event =3D window.event;=0A=
=0A=
    if (event.preventDefault) {=0A=
      event.preventDefault(); // non-IE browsers=0A=
    } else {=0A=
      event.returnValue =3D false; // IE browsers=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get HTML element which is the target of the event=0A=
   * @param {Event} event=0A=
   * @return {Element} target element=0A=
   */=0A=
  exports.getTarget =3D function (event) {=0A=
    // code from http://www.quirksmode.org/js/events_properties.html=0A=
    if (!event) {=0A=
      event =3D window.event;=0A=
    }=0A=
=0A=
    var target;=0A=
=0A=
    if (event.target) {=0A=
      target =3D event.target;=0A=
    } else if (event.srcElement) {=0A=
      target =3D event.srcElement;=0A=
    }=0A=
=0A=
    if (target.nodeType !=3D undefined && target.nodeType =3D=3D 3) {=0A=
      // defeat Safari bug=0A=
      target =3D target.parentNode;=0A=
    }=0A=
=0A=
    return target;=0A=
  };=0A=
=0A=
  /**=0A=
   * Check if given element contains given parent somewhere in the DOM =
tree=0A=
   * @param {Element} element=0A=
   * @param {Element} parent=0A=
   */=0A=
  exports.hasParent =3D function (element, parent) {=0A=
    var e =3D element;=0A=
=0A=
    while (e) {=0A=
      if (e =3D=3D=3D parent) {=0A=
        return true;=0A=
      }=0A=
      e =3D e.parentNode;=0A=
    }=0A=
=0A=
    return false;=0A=
  };=0A=
=0A=
  exports.option =3D {};=0A=
=0A=
  /**=0A=
   * Convert a value into a boolean=0A=
   * @param {Boolean | function | undefined} value=0A=
   * @param {Boolean} [defaultValue]=0A=
   * @returns {Boolean} bool=0A=
   */=0A=
  exports.option.asBoolean =3D function (value, defaultValue) {=0A=
    if (typeof value =3D=3D 'function') {=0A=
      value =3D value();=0A=
    }=0A=
=0A=
    if (value !=3D null) {=0A=
      return value !=3D false;=0A=
    }=0A=
=0A=
    return defaultValue || null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a value into a number=0A=
   * @param {Boolean | function | undefined} value=0A=
   * @param {Number} [defaultValue]=0A=
   * @returns {Number} number=0A=
   */=0A=
  exports.option.asNumber =3D function (value, defaultValue) {=0A=
    if (typeof value =3D=3D 'function') {=0A=
      value =3D value();=0A=
    }=0A=
=0A=
    if (value !=3D null) {=0A=
      return Number(value) || defaultValue || null;=0A=
    }=0A=
=0A=
    return defaultValue || null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a value into a string=0A=
   * @param {String | function | undefined} value=0A=
   * @param {String} [defaultValue]=0A=
   * @returns {String} str=0A=
   */=0A=
  exports.option.asString =3D function (value, defaultValue) {=0A=
    if (typeof value =3D=3D 'function') {=0A=
      value =3D value();=0A=
    }=0A=
=0A=
    if (value !=3D null) {=0A=
      return String(value);=0A=
    }=0A=
=0A=
    return defaultValue || null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a size or location into a string with pixels or a percentage=0A=
   * @param {String | Number | function | undefined} value=0A=
   * @param {String} [defaultValue]=0A=
   * @returns {String} size=0A=
   */=0A=
  exports.option.asSize =3D function (value, defaultValue) {=0A=
    if (typeof value =3D=3D 'function') {=0A=
      value =3D value();=0A=
    }=0A=
=0A=
    if (exports.isString(value)) {=0A=
      return value;=0A=
    } else if (exports.isNumber(value)) {=0A=
      return value + 'px';=0A=
    } else {=0A=
      return defaultValue || null;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a value into a DOM element=0A=
   * @param {HTMLElement | function | undefined} value=0A=
   * @param {HTMLElement} [defaultValue]=0A=
   * @returns {HTMLElement | null} dom=0A=
   */=0A=
  exports.option.asElement =3D function (value, defaultValue) {=0A=
    if (typeof value =3D=3D 'function') {=0A=
      value =3D value();=0A=
    }=0A=
=0A=
    return value || defaultValue || null;=0A=
  };=0A=
=0A=
  /**=0A=
   * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb=0A=
   *=0A=
   * @param {String} hex=0A=
   * @returns {{r: *, g: *, b: *}} | 255 range=0A=
   */=0A=
  exports.hexToRGB =3D function (hex) {=0A=
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")=0A=
    var shorthandRegex =3D /^#?([a-f\d])([a-f\d])([a-f\d])$/i;=0A=
    hex =3D hex.replace(shorthandRegex, function (m, r, g, b) {=0A=
      return r + r + g + g + b + b;=0A=
    });=0A=
    var result =3D /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);=0A=
    return result ? {=0A=
      r: parseInt(result[1], 16),=0A=
      g: parseInt(result[2], 16),=0A=
      b: parseInt(result[3], 16)=0A=
    } : null;=0A=
  };=0A=
=0A=
  /**=0A=
   * This function takes color in hex format or rgb() or rgba() format =
and overrides the opacity. Returns rgba() string.=0A=
   * @param color=0A=
   * @param opacity=0A=
   * @returns {*}=0A=
   */=0A=
  exports.overrideOpacity =3D function (color, opacity) {=0A=
    if (color.indexOf('rgba') !=3D -1) {=0A=
      return color;=0A=
    } else if (color.indexOf('rgb') !=3D -1) {=0A=
      var rgb =3D color.substr(color.indexOf('(') + 1).replace(')', =
'').split(',');=0A=
      return 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + =
opacity + ')';=0A=
    } else {=0A=
      var rgb =3D exports.hexToRGB(color);=0A=
      if (rgb =3D=3D null) {=0A=
        return color;=0A=
      } else {=0A=
        return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + =
opacity + ')';=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   *=0A=
   * @param red     0 -- 255=0A=
   * @param green   0 -- 255=0A=
   * @param blue    0 -- 255=0A=
   * @returns {string}=0A=
   * @constructor=0A=
   */=0A=
  exports.RGBToHex =3D function (red, green, blue) {=0A=
    return '#' + ((1 << 24) + (red << 16) + (green << 8) + =
blue).toString(16).slice(1);=0A=
  };=0A=
=0A=
  /**=0A=
   * Parse a color property into an object with border, background, and=0A=
   * highlight colors=0A=
   * @param {Object | String} color=0A=
   * @return {Object} colorObject=0A=
   */=0A=
  exports.parseColor =3D function (color) {=0A=
    var c;=0A=
    if (exports.isString(color) =3D=3D=3D true) {=0A=
      if (exports.isValidRGB(color) =3D=3D=3D true) {=0A=
        var rgb =3D color.substr(4).substr(0, color.length - =
5).split(',').map(function (value) {=0A=
          return parseInt(value);=0A=
        });=0A=
        color =3D exports.RGBToHex(rgb[0], rgb[1], rgb[2]);=0A=
      }=0A=
      if (exports.isValidHex(color) =3D=3D=3D true) {=0A=
        var hsv =3D exports.hexToHSV(color);=0A=
        var lighterColorHSV =3D { h: hsv.h, s: hsv.s * 0.8, v: =
Math.min(1, hsv.v * 1.02) };=0A=
        var darkerColorHSV =3D { h: hsv.h, s: Math.min(1, hsv.s * 1.25), =
v: hsv.v * 0.8 };=0A=
        var darkerColorHex =3D exports.HSVToHex(darkerColorHSV.h, =
darkerColorHSV.s, darkerColorHSV.v);=0A=
        var lighterColorHex =3D exports.HSVToHex(lighterColorHSV.h, =
lighterColorHSV.s, lighterColorHSV.v);=0A=
        c =3D {=0A=
          background: color,=0A=
          border: darkerColorHex,=0A=
          highlight: {=0A=
            background: lighterColorHex,=0A=
            border: darkerColorHex=0A=
          },=0A=
          hover: {=0A=
            background: lighterColorHex,=0A=
            border: darkerColorHex=0A=
          }=0A=
        };=0A=
      } else {=0A=
        c =3D {=0A=
          background: color,=0A=
          border: color,=0A=
          highlight: {=0A=
            background: color,=0A=
            border: color=0A=
          },=0A=
          hover: {=0A=
            background: color,=0A=
            border: color=0A=
          }=0A=
        };=0A=
      }=0A=
    } else {=0A=
      c =3D {};=0A=
      c.background =3D color.background || undefined;=0A=
      c.border =3D color.border || undefined;=0A=
=0A=
      if (exports.isString(color.highlight)) {=0A=
        c.highlight =3D {=0A=
          border: color.highlight,=0A=
          background: color.highlight=0A=
        };=0A=
      } else {=0A=
        c.highlight =3D {};=0A=
        c.highlight.background =3D color.highlight && =
color.highlight.background || undefined;=0A=
        c.highlight.border =3D color.highlight && color.highlight.border =
|| undefined;=0A=
      }=0A=
=0A=
      if (exports.isString(color.hover)) {=0A=
        c.hover =3D {=0A=
          border: color.hover,=0A=
          background: color.hover=0A=
        };=0A=
      } else {=0A=
        c.hover =3D {};=0A=
        c.hover.background =3D color.hover && color.hover.background || =
undefined;=0A=
        c.hover.border =3D color.hover && color.hover.border || =
undefined;=0A=
      }=0A=
    }=0A=
=0A=
    return c;=0A=
  };=0A=
=0A=
  /**=0A=
   * http://www.javascripter.net/faq/rgb2hsv.htm=0A=
   *=0A=
   * @param red=0A=
   * @param green=0A=
   * @param blue=0A=
   * @returns {*}=0A=
   * @constructor=0A=
   */=0A=
  exports.RGBToHSV =3D function (red, green, blue) {=0A=
    red =3D red / 255;green =3D green / 255;blue =3D blue / 255;=0A=
    var minRGB =3D Math.min(red, Math.min(green, blue));=0A=
    var maxRGB =3D Math.max(red, Math.max(green, blue));=0A=
=0A=
    // Black-gray-white=0A=
    if (minRGB =3D=3D maxRGB) {=0A=
      return { h: 0, s: 0, v: minRGB };=0A=
    }=0A=
=0A=
    // Colors other than black-gray-white:=0A=
    var d =3D red =3D=3D minRGB ? green - blue : blue =3D=3D minRGB ? =
red - green : blue - red;=0A=
    var h =3D red =3D=3D minRGB ? 3 : blue =3D=3D minRGB ? 1 : 5;=0A=
    var hue =3D 60 * (h - d / (maxRGB - minRGB)) / 360;=0A=
    var saturation =3D (maxRGB - minRGB) / maxRGB;=0A=
    var value =3D maxRGB;=0A=
    return { h: hue, s: saturation, v: value };=0A=
  };=0A=
=0A=
  var cssUtil =3D {=0A=
    // split a string with css styles into an object with key/values=0A=
    split: function split(cssText) {=0A=
      var styles =3D {};=0A=
=0A=
      cssText.split(';').forEach(function (style) {=0A=
        if (style.trim() !=3D '') {=0A=
          var parts =3D style.split(':');=0A=
          var key =3D parts[0].trim();=0A=
          var value =3D parts[1].trim();=0A=
          styles[key] =3D value;=0A=
        }=0A=
      });=0A=
=0A=
      return styles;=0A=
    },=0A=
=0A=
    // build a css text string from an object with key/values=0A=
    join: function join(styles) {=0A=
      return Object.keys(styles).map(function (key) {=0A=
        return key + ': ' + styles[key];=0A=
      }).join('; ');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Append a string with css styles to an element=0A=
   * @param {Element} element=0A=
   * @param {String} cssText=0A=
   */=0A=
  exports.addCssText =3D function (element, cssText) {=0A=
    var currentStyles =3D cssUtil.split(element.style.cssText);=0A=
    var newStyles =3D cssUtil.split(cssText);=0A=
    var styles =3D exports.extend(currentStyles, newStyles);=0A=
=0A=
    element.style.cssText =3D cssUtil.join(styles);=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove a string with css styles from an element=0A=
   * @param {Element} element=0A=
   * @param {String} cssText=0A=
   */=0A=
  exports.removeCssText =3D function (element, cssText) {=0A=
    var styles =3D cssUtil.split(element.style.cssText);=0A=
    var removeStyles =3D cssUtil.split(cssText);=0A=
=0A=
    for (var key in removeStyles) {=0A=
      if (removeStyles.hasOwnProperty(key)) {=0A=
        delete styles[key];=0A=
      }=0A=
    }=0A=
=0A=
    element.style.cssText =3D cssUtil.join(styles);=0A=
  };=0A=
=0A=
  /**=0A=
   * https://gist.github.com/mjijackson/5311256=0A=
   * @param h=0A=
   * @param s=0A=
   * @param v=0A=
   * @returns {{r: number, g: number, b: number}}=0A=
   * @constructor=0A=
   */=0A=
  exports.HSVToRGB =3D function (h, s, v) {=0A=
    var r, g, b;=0A=
=0A=
    var i =3D Math.floor(h * 6);=0A=
    var f =3D h * 6 - i;=0A=
    var p =3D v * (1 - s);=0A=
    var q =3D v * (1 - f * s);=0A=
    var t =3D v * (1 - (1 - f) * s);=0A=
=0A=
    switch (i % 6) {=0A=
      case 0:=0A=
        r =3D v, g =3D t, b =3D p;break;=0A=
      case 1:=0A=
        r =3D q, g =3D v, b =3D p;break;=0A=
      case 2:=0A=
        r =3D p, g =3D v, b =3D t;break;=0A=
      case 3:=0A=
        r =3D p, g =3D q, b =3D v;break;=0A=
      case 4:=0A=
        r =3D t, g =3D p, b =3D v;break;=0A=
      case 5:=0A=
        r =3D v, g =3D p, b =3D q;break;=0A=
    }=0A=
=0A=
    return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: =
Math.floor(b * 255) };=0A=
  };=0A=
=0A=
  exports.HSVToHex =3D function (h, s, v) {=0A=
    var rgb =3D exports.HSVToRGB(h, s, v);=0A=
    return exports.RGBToHex(rgb.r, rgb.g, rgb.b);=0A=
  };=0A=
=0A=
  exports.hexToHSV =3D function (hex) {=0A=
    var rgb =3D exports.hexToRGB(hex);=0A=
    return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);=0A=
  };=0A=
=0A=
  exports.isValidHex =3D function (hex) {=0A=
    var isOk =3D /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);=0A=
    return isOk;=0A=
  };=0A=
=0A=
  exports.isValidRGB =3D function (rgb) {=0A=
    rgb =3D rgb.replace(' ', '');=0A=
    var isOk =3D /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);=0A=
    return isOk;=0A=
  };=0A=
  exports.isValidRGBA =3D function (rgba) {=0A=
    rgba =3D rgba.replace(' ', '');=0A=
    var isOk =3D =
/rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);=0A=
    return isOk;=0A=
  };=0A=
=0A=
  /**=0A=
   * This recursively redirects the prototype of JSON objects to the =
referenceObject=0A=
   * This is used for default options.=0A=
   *=0A=
   * @param referenceObject=0A=
   * @returns {*}=0A=
   */=0A=
  exports.selectiveBridgeObject =3D function (fields, referenceObject) {=0A=
    if (typeof referenceObject =3D=3D 'object') {=0A=
      var objectTo =3D Object.create(referenceObject);=0A=
      for (var i =3D 0; i < fields.length; i++) {=0A=
        if (referenceObject.hasOwnProperty(fields[i])) {=0A=
          if (typeof referenceObject[fields[i]] =3D=3D 'object') {=0A=
            objectTo[fields[i]] =3D =
exports.bridgeObject(referenceObject[fields[i]]);=0A=
          }=0A=
        }=0A=
      }=0A=
      return objectTo;=0A=
    } else {=0A=
      return null;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * This recursively redirects the prototype of JSON objects to the =
referenceObject=0A=
   * This is used for default options.=0A=
   *=0A=
   * @param referenceObject=0A=
   * @returns {*}=0A=
   */=0A=
  exports.bridgeObject =3D function (referenceObject) {=0A=
    if (typeof referenceObject =3D=3D 'object') {=0A=
      var objectTo =3D Object.create(referenceObject);=0A=
      for (var i in referenceObject) {=0A=
        if (referenceObject.hasOwnProperty(i)) {=0A=
          if (typeof referenceObject[i] =3D=3D 'object') {=0A=
            objectTo[i] =3D exports.bridgeObject(referenceObject[i]);=0A=
          }=0A=
        }=0A=
      }=0A=
      return objectTo;=0A=
    } else {=0A=
      return null;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this is used to set the options of subobjects in the options =
object. A requirement of these subobjects=0A=
   * is that they have an 'enabled' element which is optional for the =
user but mandatory for the program.=0A=
   *=0A=
   * @param [object] mergeTarget | this is either this.options or the =
options used for the groups.=0A=
   * @param [object] options     | options=0A=
   * @param [String] option      | this is the option key in the options =
argument=0A=
   * @private=0A=
   */=0A=
  exports.mergeOptions =3D function (mergeTarget, options, option) {=0A=
    var allowDeletion =3D arguments.length <=3D 3 || arguments[3] =
=3D=3D=3D undefined ? false : arguments[3];=0A=
=0A=
    if (options[option] =3D=3D=3D null) {=0A=
      mergeTarget[option] =3D undefined;=0A=
      delete mergeTarget[option];=0A=
    } else {=0A=
      if (options[option] !=3D=3D undefined) {=0A=
        if (typeof options[option] =3D=3D=3D 'boolean') {=0A=
          mergeTarget[option].enabled =3D options[option];=0A=
        } else {=0A=
          if (options[option].enabled =3D=3D=3D undefined) {=0A=
            mergeTarget[option].enabled =3D true;=0A=
          }=0A=
          for (var prop in options[option]) {=0A=
            if (options[option].hasOwnProperty(prop)) {=0A=
              mergeTarget[option][prop] =3D options[option][prop];=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * This function does a binary search for a visible item in a sorted =
list. If we find a visible item, the code that uses=0A=
   * this function will then iterate in both directions over this sorted =
list to find all visible items.=0A=
   *=0A=
   * @param {Item[]} orderedItems       | Items ordered by start=0A=
   * @param {function} searchFunction   | -1 is lower, 0 is found, 1 is =
higher=0A=
   * @param {String} field=0A=
   * @param {String} field2=0A=
   * @returns {number}=0A=
   * @private=0A=
   */=0A=
  exports.binarySearchCustom =3D function (orderedItems, searchFunction, =
field, field2) {=0A=
    var maxIterations =3D 10000;=0A=
    var iteration =3D 0;=0A=
    var low =3D 0;=0A=
    var high =3D orderedItems.length - 1;=0A=
=0A=
    while (low <=3D high && iteration < maxIterations) {=0A=
      var middle =3D Math.floor((low + high) / 2);=0A=
=0A=
      var item =3D orderedItems[middle];=0A=
      var value =3D field2 =3D=3D=3D undefined ? item[field] : =
item[field][field2];=0A=
=0A=
      var searchResult =3D searchFunction(value);=0A=
      if (searchResult =3D=3D 0) {=0A=
        // jihaa, found a visible item!=0A=
        return middle;=0A=
      } else if (searchResult =3D=3D -1) {=0A=
        // it is too small --> increase low=0A=
        low =3D middle + 1;=0A=
      } else {=0A=
        // it is too big --> decrease high=0A=
        high =3D middle - 1;=0A=
      }=0A=
=0A=
      iteration++;=0A=
    }=0A=
=0A=
    return -1;=0A=
  };=0A=
=0A=
  /**=0A=
   * This function does a binary search for a specific value in a sorted =
array. If it does not exist but is in between of=0A=
   * two values, we return either the one before or the one after, =
depending on user input=0A=
   * If it is found, we return the index, else -1.=0A=
   *=0A=
   * @param {Array} orderedItems=0A=
   * @param {{start: number, end: number}} target=0A=
   * @param {String} field=0A=
   * @param {String} sidePreference   'before' or 'after'=0A=
   * @returns {number}=0A=
   * @private=0A=
   */=0A=
  exports.binarySearchValue =3D function (orderedItems, target, field, =
sidePreference) {=0A=
    var maxIterations =3D 10000;=0A=
    var iteration =3D 0;=0A=
    var low =3D 0;=0A=
    var high =3D orderedItems.length - 1;=0A=
    var prevValue, value, nextValue, middle;=0A=
=0A=
    while (low <=3D high && iteration < maxIterations) {=0A=
      // get a new guess=0A=
      middle =3D Math.floor(0.5 * (high + low));=0A=
      prevValue =3D orderedItems[Math.max(0, middle - 1)][field];=0A=
      value =3D orderedItems[middle][field];=0A=
      nextValue =3D orderedItems[Math.min(orderedItems.length - 1, =
middle + 1)][field];=0A=
=0A=
      if (value =3D=3D target) {=0A=
        // we found the target=0A=
        return middle;=0A=
      } else if (prevValue < target && value > target) {=0A=
        // target is in between of the previous and the current=0A=
        return sidePreference =3D=3D 'before' ? Math.max(0, middle - 1) =
: middle;=0A=
      } else if (value < target && nextValue > target) {=0A=
        // target is in between of the current and the next=0A=
        return sidePreference =3D=3D 'before' ? middle : =
Math.min(orderedItems.length - 1, middle + 1);=0A=
      } else {=0A=
        // didnt find the target, we need to change our boundaries.=0A=
        if (value < target) {=0A=
          // it is too small --> increase low=0A=
          low =3D middle + 1;=0A=
        } else {=0A=
          // it is too big --> decrease high=0A=
          high =3D middle - 1;=0A=
        }=0A=
      }=0A=
      iteration++;=0A=
    }=0A=
=0A=
    // didnt find anything. Return -1.=0A=
    return -1;=0A=
  };=0A=
=0A=
  /*=0A=
   * Easing Functions - inspired from http://gizma.com/easing/=0A=
   * only considering the t value for the range [0, 1] =3D> [0, 1]=0A=
   * https://gist.github.com/gre/1650294=0A=
   */=0A=
  exports.easingFunctions =3D {=0A=
    // no easing, no acceleration=0A=
    linear: function linear(t) {=0A=
      return t;=0A=
    },=0A=
    // accelerating from zero velocity=0A=
    easeInQuad: function easeInQuad(t) {=0A=
      return t * t;=0A=
    },=0A=
    // decelerating to zero velocity=0A=
    easeOutQuad: function easeOutQuad(t) {=0A=
      return t * (2 - t);=0A=
    },=0A=
    // acceleration until halfway, then deceleration=0A=
    easeInOutQuad: function easeInOutQuad(t) {=0A=
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;=0A=
    },=0A=
    // accelerating from zero velocity=0A=
    easeInCubic: function easeInCubic(t) {=0A=
      return t * t * t;=0A=
    },=0A=
    // decelerating to zero velocity=0A=
    easeOutCubic: function easeOutCubic(t) {=0A=
      return --t * t * t + 1;=0A=
    },=0A=
    // acceleration until halfway, then deceleration=0A=
    easeInOutCubic: function easeInOutCubic(t) {=0A=
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - =
2) + 1;=0A=
    },=0A=
    // accelerating from zero velocity=0A=
    easeInQuart: function easeInQuart(t) {=0A=
      return t * t * t * t;=0A=
    },=0A=
    // decelerating to zero velocity=0A=
    easeOutQuart: function easeOutQuart(t) {=0A=
      return 1 - --t * t * t * t;=0A=
    },=0A=
    // acceleration until halfway, then deceleration=0A=
    easeInOutQuart: function easeInOutQuart(t) {=0A=
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;=0A=
    },=0A=
    // accelerating from zero velocity=0A=
    easeInQuint: function easeInQuint(t) {=0A=
      return t * t * t * t * t;=0A=
    },=0A=
    // decelerating to zero velocity=0A=
    easeOutQuint: function easeOutQuint(t) {=0A=
      return 1 + --t * t * t * t * t;=0A=
    },=0A=
    // acceleration until halfway, then deceleration=0A=
    easeInOutQuint: function easeInOutQuint(t) {=0A=
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t =
* t;=0A=
    }=0A=
  };=0A=
=0A=
/***/ },=0A=
/* 8 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  // first check if moment.js is already loaded in the browser window, =
if so,=0A=
  // use this instance. Else, load via commonjs.=0A=
  'use strict';=0A=
=0A=
  module.exports =3D typeof window !=3D=3D 'undefined' && =
window['moment'] || __webpack_require__(9);=0A=
=0A=
/***/ },=0A=
/* 9 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  /* WEBPACK VAR INJECTION */(function(module) {//! moment.js=0A=
  //! version : 2.10.5=0A=
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors=0A=
  //! license : MIT=0A=
  //! momentjs.com=0A=
=0A=
  (function (global, factory) {=0A=
       true ? module.exports =3D factory() :=0A=
      typeof define =3D=3D=3D 'function' && define.amd ? define(factory) =
:=0A=
      global.moment =3D factory()=0A=
  }(this, function () { 'use strict';=0A=
=0A=
      var hookCallback;=0A=
=0A=
      function utils_hooks__hooks () {=0A=
          return hookCallback.apply(null, arguments);=0A=
      }=0A=
=0A=
      // This is done to register the method called with moment()=0A=
      // without creating circular dependencies.=0A=
      function setHookCallback (callback) {=0A=
          hookCallback =3D callback;=0A=
      }=0A=
=0A=
      function isArray(input) {=0A=
          return Object.prototype.toString.call(input) =3D=3D=3D =
'[object Array]';=0A=
      }=0A=
=0A=
      function isDate(input) {=0A=
          return input instanceof Date || =
Object.prototype.toString.call(input) =3D=3D=3D '[object Date]';=0A=
      }=0A=
=0A=
      function map(arr, fn) {=0A=
          var res =3D [], i;=0A=
          for (i =3D 0; i < arr.length; ++i) {=0A=
              res.push(fn(arr[i], i));=0A=
          }=0A=
          return res;=0A=
      }=0A=
=0A=
      function hasOwnProp(a, b) {=0A=
          return Object.prototype.hasOwnProperty.call(a, b);=0A=
      }=0A=
=0A=
      function extend(a, b) {=0A=
          for (var i in b) {=0A=
              if (hasOwnProp(b, i)) {=0A=
                  a[i] =3D b[i];=0A=
              }=0A=
          }=0A=
=0A=
          if (hasOwnProp(b, 'toString')) {=0A=
              a.toString =3D b.toString;=0A=
          }=0A=
=0A=
          if (hasOwnProp(b, 'valueOf')) {=0A=
              a.valueOf =3D b.valueOf;=0A=
          }=0A=
=0A=
          return a;=0A=
      }=0A=
=0A=
      function create_utc__createUTC (input, format, locale, strict) {=0A=
          return createLocalOrUTC(input, format, locale, strict, =
true).utc();=0A=
      }=0A=
=0A=
      function defaultParsingFlags() {=0A=
          // We need to deep clone this object.=0A=
          return {=0A=
              empty           : false,=0A=
              unusedTokens    : [],=0A=
              unusedInput     : [],=0A=
              overflow        : -2,=0A=
              charsLeftOver   : 0,=0A=
              nullInput       : false,=0A=
              invalidMonth    : null,=0A=
              invalidFormat   : false,=0A=
              userInvalidated : false,=0A=
              iso             : false=0A=
          };=0A=
      }=0A=
=0A=
      function getParsingFlags(m) {=0A=
          if (m._pf =3D=3D null) {=0A=
              m._pf =3D defaultParsingFlags();=0A=
          }=0A=
          return m._pf;=0A=
      }=0A=
=0A=
      function valid__isValid(m) {=0A=
          if (m._isValid =3D=3D null) {=0A=
              var flags =3D getParsingFlags(m);=0A=
              m._isValid =3D !isNaN(m._d.getTime()) &&=0A=
                  flags.overflow < 0 &&=0A=
                  !flags.empty &&=0A=
                  !flags.invalidMonth &&=0A=
                  !flags.invalidWeekday &&=0A=
                  !flags.nullInput &&=0A=
                  !flags.invalidFormat &&=0A=
                  !flags.userInvalidated;=0A=
=0A=
              if (m._strict) {=0A=
                  m._isValid =3D m._isValid &&=0A=
                      flags.charsLeftOver =3D=3D=3D 0 &&=0A=
                      flags.unusedTokens.length =3D=3D=3D 0 &&=0A=
                      flags.bigHour =3D=3D=3D undefined;=0A=
              }=0A=
          }=0A=
          return m._isValid;=0A=
      }=0A=
=0A=
      function valid__createInvalid (flags) {=0A=
          var m =3D create_utc__createUTC(NaN);=0A=
          if (flags !=3D null) {=0A=
              extend(getParsingFlags(m), flags);=0A=
          }=0A=
          else {=0A=
              getParsingFlags(m).userInvalidated =3D true;=0A=
          }=0A=
=0A=
          return m;=0A=
      }=0A=
=0A=
      var momentProperties =3D utils_hooks__hooks.momentProperties =3D =
[];=0A=
=0A=
      function copyConfig(to, from) {=0A=
          var i, prop, val;=0A=
=0A=
          if (typeof from._isAMomentObject !=3D=3D 'undefined') {=0A=
              to._isAMomentObject =3D from._isAMomentObject;=0A=
          }=0A=
          if (typeof from._i !=3D=3D 'undefined') {=0A=
              to._i =3D from._i;=0A=
          }=0A=
          if (typeof from._f !=3D=3D 'undefined') {=0A=
              to._f =3D from._f;=0A=
          }=0A=
          if (typeof from._l !=3D=3D 'undefined') {=0A=
              to._l =3D from._l;=0A=
          }=0A=
          if (typeof from._strict !=3D=3D 'undefined') {=0A=
              to._strict =3D from._strict;=0A=
          }=0A=
          if (typeof from._tzm !=3D=3D 'undefined') {=0A=
              to._tzm =3D from._tzm;=0A=
          }=0A=
          if (typeof from._isUTC !=3D=3D 'undefined') {=0A=
              to._isUTC =3D from._isUTC;=0A=
          }=0A=
          if (typeof from._offset !=3D=3D 'undefined') {=0A=
              to._offset =3D from._offset;=0A=
          }=0A=
          if (typeof from._pf !=3D=3D 'undefined') {=0A=
              to._pf =3D getParsingFlags(from);=0A=
          }=0A=
          if (typeof from._locale !=3D=3D 'undefined') {=0A=
              to._locale =3D from._locale;=0A=
          }=0A=
=0A=
          if (momentProperties.length > 0) {=0A=
              for (i in momentProperties) {=0A=
                  prop =3D momentProperties[i];=0A=
                  val =3D from[prop];=0A=
                  if (typeof val !=3D=3D 'undefined') {=0A=
                      to[prop] =3D val;=0A=
                  }=0A=
              }=0A=
          }=0A=
=0A=
          return to;=0A=
      }=0A=
=0A=
      var updateInProgress =3D false;=0A=
=0A=
      // Moment prototype object=0A=
      function Moment(config) {=0A=
          copyConfig(this, config);=0A=
          this._d =3D new Date(config._d.getTime());=0A=
          // Prevent infinite loop in case updateOffset creates new =
moment=0A=
          // objects.=0A=
          if (updateInProgress =3D=3D=3D false) {=0A=
              updateInProgress =3D true;=0A=
              utils_hooks__hooks.updateOffset(this);=0A=
              updateInProgress =3D false;=0A=
          }=0A=
      }=0A=
=0A=
      function isMoment (obj) {=0A=
          return obj instanceof Moment || (obj !=3D null && =
obj._isAMomentObject !=3D null);=0A=
      }=0A=
=0A=
      function absFloor (number) {=0A=
          if (number < 0) {=0A=
              return Math.ceil(number);=0A=
          } else {=0A=
              return Math.floor(number);=0A=
          }=0A=
      }=0A=
=0A=
      function toInt(argumentForCoercion) {=0A=
          var coercedNumber =3D +argumentForCoercion,=0A=
              value =3D 0;=0A=
=0A=
          if (coercedNumber !=3D=3D 0 && isFinite(coercedNumber)) {=0A=
              value =3D absFloor(coercedNumber);=0A=
          }=0A=
=0A=
          return value;=0A=
      }=0A=
=0A=
      function compareArrays(array1, array2, dontConvert) {=0A=
          var len =3D Math.min(array1.length, array2.length),=0A=
              lengthDiff =3D Math.abs(array1.length - array2.length),=0A=
              diffs =3D 0,=0A=
              i;=0A=
          for (i =3D 0; i < len; i++) {=0A=
              if ((dontConvert && array1[i] !=3D=3D array2[i]) ||=0A=
                  (!dontConvert && toInt(array1[i]) !=3D=3D =
toInt(array2[i]))) {=0A=
                  diffs++;=0A=
              }=0A=
          }=0A=
          return diffs + lengthDiff;=0A=
      }=0A=
=0A=
      function Locale() {=0A=
      }=0A=
=0A=
      var locales =3D {};=0A=
      var globalLocale;=0A=
=0A=
      function normalizeLocale(key) {=0A=
          return key ? key.toLowerCase().replace('_', '-') : key;=0A=
      }=0A=
=0A=
      // pick the locale from the array=0A=
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move =
through the list trying each=0A=
      // substring from most specific to least, but move to the next =
array item if it's a more specific variant than the current root=0A=
      function chooseLocale(names) {=0A=
          var i =3D 0, j, next, locale, split;=0A=
=0A=
          while (i < names.length) {=0A=
              split =3D normalizeLocale(names[i]).split('-');=0A=
              j =3D split.length;=0A=
              next =3D normalizeLocale(names[i + 1]);=0A=
              next =3D next ? next.split('-') : null;=0A=
              while (j > 0) {=0A=
                  locale =3D loadLocale(split.slice(0, j).join('-'));=0A=
                  if (locale) {=0A=
                      return locale;=0A=
                  }=0A=
                  if (next && next.length >=3D j && compareArrays(split, =
next, true) >=3D j - 1) {=0A=
                      //the next array item is better than a shallower =
substring of this one=0A=
                      break;=0A=
                  }=0A=
                  j--;=0A=
              }=0A=
              i++;=0A=
          }=0A=
          return null;=0A=
      }=0A=
=0A=
      function loadLocale(name) {=0A=
          var oldLocale =3D null;=0A=
          // TODO: Find a better way to register and load all the =
locales in Node=0A=
          if (!locales[name] && typeof module !=3D=3D 'undefined' &&=0A=
                  module && module.exports) {=0A=
              try {=0A=
                  oldLocale =3D globalLocale._abbr;=0A=
                  !(function webpackMissingModule() { var e =3D new =
Error("Cannot find module \"./locale\""); e.code =3D 'MODULE_NOT_FOUND'; =
throw e; }());=0A=
                  // because defineLocale currently also sets the global =
locale, we=0A=
                  // want to undo that for lazy loaded locales=0A=
                  locale_locales__getSetGlobalLocale(oldLocale);=0A=
              } catch (e) { }=0A=
          }=0A=
          return locales[name];=0A=
      }=0A=
=0A=
      // This function will load locale and then set the global locale.  =
If=0A=
      // no arguments are passed in, it will simply return the current =
global=0A=
      // locale key.=0A=
      function locale_locales__getSetGlobalLocale (key, values) {=0A=
          var data;=0A=
          if (key) {=0A=
              if (typeof values =3D=3D=3D 'undefined') {=0A=
                  data =3D locale_locales__getLocale(key);=0A=
              }=0A=
              else {=0A=
                  data =3D defineLocale(key, values);=0A=
              }=0A=
=0A=
              if (data) {=0A=
                  // moment.duration._locale =3D moment._locale =3D data;=0A=
                  globalLocale =3D data;=0A=
              }=0A=
          }=0A=
=0A=
          return globalLocale._abbr;=0A=
      }=0A=
=0A=
      function defineLocale (name, values) {=0A=
          if (values !=3D=3D null) {=0A=
              values.abbr =3D name;=0A=
              locales[name] =3D locales[name] || new Locale();=0A=
              locales[name].set(values);=0A=
=0A=
              // backwards compat for now: also set the locale=0A=
              locale_locales__getSetGlobalLocale(name);=0A=
=0A=
              return locales[name];=0A=
          } else {=0A=
              // useful for testing=0A=
              delete locales[name];=0A=
              return null;=0A=
          }=0A=
      }=0A=
=0A=
      // returns locale data=0A=
      function locale_locales__getLocale (key) {=0A=
          var locale;=0A=
=0A=
          if (key && key._locale && key._locale._abbr) {=0A=
              key =3D key._locale._abbr;=0A=
          }=0A=
=0A=
          if (!key) {=0A=
              return globalLocale;=0A=
          }=0A=
=0A=
          if (!isArray(key)) {=0A=
              //short-circuit everything else=0A=
              locale =3D loadLocale(key);=0A=
              if (locale) {=0A=
                  return locale;=0A=
              }=0A=
              key =3D [key];=0A=
          }=0A=
=0A=
          return chooseLocale(key);=0A=
      }=0A=
=0A=
      var aliases =3D {};=0A=
=0A=
      function addUnitAlias (unit, shorthand) {=0A=
          var lowerCase =3D unit.toLowerCase();=0A=
          aliases[lowerCase] =3D aliases[lowerCase + 's'] =3D =
aliases[shorthand] =3D unit;=0A=
      }=0A=
=0A=
      function normalizeUnits(units) {=0A=
          return typeof units =3D=3D=3D 'string' ? aliases[units] || =
aliases[units.toLowerCase()] : undefined;=0A=
      }=0A=
=0A=
      function normalizeObjectUnits(inputObject) {=0A=
          var normalizedInput =3D {},=0A=
              normalizedProp,=0A=
              prop;=0A=
=0A=
          for (prop in inputObject) {=0A=
              if (hasOwnProp(inputObject, prop)) {=0A=
                  normalizedProp =3D normalizeUnits(prop);=0A=
                  if (normalizedProp) {=0A=
                      normalizedInput[normalizedProp] =3D =
inputObject[prop];=0A=
                  }=0A=
              }=0A=
          }=0A=
=0A=
          return normalizedInput;=0A=
      }=0A=
=0A=
      function makeGetSet (unit, keepTime) {=0A=
          return function (value) {=0A=
              if (value !=3D null) {=0A=
                  get_set__set(this, unit, value);=0A=
                  utils_hooks__hooks.updateOffset(this, keepTime);=0A=
                  return this;=0A=
              } else {=0A=
                  return get_set__get(this, unit);=0A=
              }=0A=
          };=0A=
      }=0A=
=0A=
      function get_set__get (mom, unit) {=0A=
          return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();=0A=
      }=0A=
=0A=
      function get_set__set (mom, unit, value) {=0A=
          return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);=0A=
      }=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function getSet (units, value) {=0A=
          var unit;=0A=
          if (typeof units =3D=3D=3D 'object') {=0A=
              for (unit in units) {=0A=
                  this.set(unit, units[unit]);=0A=
              }=0A=
          } else {=0A=
              units =3D normalizeUnits(units);=0A=
              if (typeof this[units] =3D=3D=3D 'function') {=0A=
                  return this[units](value);=0A=
              }=0A=
          }=0A=
          return this;=0A=
      }=0A=
=0A=
      function zeroFill(number, targetLength, forceSign) {=0A=
          var absNumber =3D '' + Math.abs(number),=0A=
              zerosToFill =3D targetLength - absNumber.length,=0A=
              sign =3D number >=3D 0;=0A=
          return (sign ? (forceSign ? '+' : '') : '-') +=0A=
              Math.pow(10, Math.max(0, =
zerosToFill)).toString().substr(1) + absNumber;=0A=
      }=0A=
=0A=
      var formattingTokens =3D =
/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?=
|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9=
}|x|X|zz?|ZZ?|.)/g;=0A=
=0A=
      var localFormattingTokens =3D =
/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;=0A=
=0A=
      var formatFunctions =3D {};=0A=
=0A=
      var formatTokenFunctions =3D {};=0A=
=0A=
      // token:    'M'=0A=
      // padded:   ['MM', 2]=0A=
      // ordinal:  'Mo'=0A=
      // callback: function () { this.month() + 1 }=0A=
      function addFormatToken (token, padded, ordinal, callback) {=0A=
          var func =3D callback;=0A=
          if (typeof callback =3D=3D=3D 'string') {=0A=
              func =3D function () {=0A=
                  return this[callback]();=0A=
              };=0A=
          }=0A=
          if (token) {=0A=
              formatTokenFunctions[token] =3D func;=0A=
          }=0A=
          if (padded) {=0A=
              formatTokenFunctions[padded[0]] =3D function () {=0A=
                  return zeroFill(func.apply(this, arguments), =
padded[1], padded[2]);=0A=
              };=0A=
          }=0A=
          if (ordinal) {=0A=
              formatTokenFunctions[ordinal] =3D function () {=0A=
                  return this.localeData().ordinal(func.apply(this, =
arguments), token);=0A=
              };=0A=
          }=0A=
      }=0A=
=0A=
      function removeFormattingTokens(input) {=0A=
          if (input.match(/\[[\s\S]/)) {=0A=
              return input.replace(/^\[|\]$/g, '');=0A=
          }=0A=
          return input.replace(/\\/g, '');=0A=
      }=0A=
=0A=
      function makeFormatFunction(format) {=0A=
          var array =3D format.match(formattingTokens), i, length;=0A=
=0A=
          for (i =3D 0, length =3D array.length; i < length; i++) {=0A=
              if (formatTokenFunctions[array[i]]) {=0A=
                  array[i] =3D formatTokenFunctions[array[i]];=0A=
              } else {=0A=
                  array[i] =3D removeFormattingTokens(array[i]);=0A=
              }=0A=
          }=0A=
=0A=
          return function (mom) {=0A=
              var output =3D '';=0A=
              for (i =3D 0; i < length; i++) {=0A=
                  output +=3D array[i] instanceof Function ? =
array[i].call(mom, format) : array[i];=0A=
              }=0A=
              return output;=0A=
          };=0A=
      }=0A=
=0A=
      // format date using native date object=0A=
      function formatMoment(m, format) {=0A=
          if (!m.isValid()) {=0A=
              return m.localeData().invalidDate();=0A=
          }=0A=
=0A=
          format =3D expandFormat(format, m.localeData());=0A=
          formatFunctions[format] =3D formatFunctions[format] || =
makeFormatFunction(format);=0A=
=0A=
          return formatFunctions[format](m);=0A=
      }=0A=
=0A=
      function expandFormat(format, locale) {=0A=
          var i =3D 5;=0A=
=0A=
          function replaceLongDateFormatTokens(input) {=0A=
              return locale.longDateFormat(input) || input;=0A=
          }=0A=
=0A=
          localFormattingTokens.lastIndex =3D 0;=0A=
          while (i >=3D 0 && localFormattingTokens.test(format)) {=0A=
              format =3D format.replace(localFormattingTokens, =
replaceLongDateFormatTokens);=0A=
              localFormattingTokens.lastIndex =3D 0;=0A=
              i -=3D 1;=0A=
          }=0A=
=0A=
          return format;=0A=
      }=0A=
=0A=
      var match1         =3D /\d/;            //       0 - 9=0A=
      var match2         =3D /\d\d/;          //      00 - 99=0A=
      var match3         =3D /\d{3}/;         //     000 - 999=0A=
      var match4         =3D /\d{4}/;         //    0000 - 9999=0A=
      var match6         =3D /[+-]?\d{6}/;    // -999999 - 999999=0A=
      var match1to2      =3D /\d\d?/;         //       0 - 99=0A=
      var match1to3      =3D /\d{1,3}/;       //       0 - 999=0A=
      var match1to4      =3D /\d{1,4}/;       //       0 - 9999=0A=
      var match1to6      =3D /[+-]?\d{1,6}/;  // -999999 - 999999=0A=
=0A=
      var matchUnsigned  =3D /\d+/;           //       0 - inf=0A=
      var matchSigned    =3D /[+-]?\d+/;      //    -inf - inf=0A=
=0A=
      var matchOffset    =3D /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 =
+0000 -0000 or Z=0A=
=0A=
      var matchTimestamp =3D /[+-]?\d+(\.\d{1,3})?/; // 123456789 =
123456789.123=0A=
=0A=
      // any word (or two) characters or numbers including two/three =
word month in arabic.=0A=
      var matchWord =3D =
/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u060=
0-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;=0A=
=0A=
      var regexes =3D {};=0A=
=0A=
      function isFunction (sth) {=0A=
          // https://github.com/moment/moment/issues/2325=0A=
          return typeof sth =3D=3D=3D 'function' &&=0A=
              Object.prototype.toString.call(sth) =3D=3D=3D '[object =
Function]';=0A=
      }=0A=
=0A=
=0A=
      function addRegexToken (token, regex, strictRegex) {=0A=
          regexes[token] =3D isFunction(regex) ? regex : function =
(isStrict) {=0A=
              return (isStrict && strictRegex) ? strictRegex : regex;=0A=
          };=0A=
      }=0A=
=0A=
      function getParseRegexForToken (token, config) {=0A=
          if (!hasOwnProp(regexes, token)) {=0A=
              return new RegExp(unescapeFormat(token));=0A=
          }=0A=
=0A=
          return regexes[token](config._strict, config._locale);=0A=
      }=0A=
=0A=
      // Code from =
http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-funct=
ion-in-javascript=0A=
      function unescapeFormat(s) {=0A=
          return s.replace('\\', =
'').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, =
p1, p2, p3, p4) {=0A=
              return p1 || p2 || p3 || p4;=0A=
          }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');=0A=
      }=0A=
=0A=
      var tokens =3D {};=0A=
=0A=
      function addParseToken (token, callback) {=0A=
          var i, func =3D callback;=0A=
          if (typeof token =3D=3D=3D 'string') {=0A=
              token =3D [token];=0A=
          }=0A=
          if (typeof callback =3D=3D=3D 'number') {=0A=
              func =3D function (input, array) {=0A=
                  array[callback] =3D toInt(input);=0A=
              };=0A=
          }=0A=
          for (i =3D 0; i < token.length; i++) {=0A=
              tokens[token[i]] =3D func;=0A=
          }=0A=
      }=0A=
=0A=
      function addWeekParseToken (token, callback) {=0A=
          addParseToken(token, function (input, array, config, token) {=0A=
              config._w =3D config._w || {};=0A=
              callback(input, config._w, config, token);=0A=
          });=0A=
      }=0A=
=0A=
      function addTimeToArrayFromToken(token, input, config) {=0A=
          if (input !=3D null && hasOwnProp(tokens, token)) {=0A=
              tokens[token](input, config._a, config, token);=0A=
          }=0A=
      }=0A=
=0A=
      var YEAR =3D 0;=0A=
      var MONTH =3D 1;=0A=
      var DATE =3D 2;=0A=
      var HOUR =3D 3;=0A=
      var MINUTE =3D 4;=0A=
      var SECOND =3D 5;=0A=
      var MILLISECOND =3D 6;=0A=
=0A=
      function daysInMonth(year, month) {=0A=
          return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();=0A=
      }=0A=
=0A=
      // FORMATTING=0A=
=0A=
      addFormatToken('M', ['MM', 2], 'Mo', function () {=0A=
          return this.month() + 1;=0A=
      });=0A=
=0A=
      addFormatToken('MMM', 0, 0, function (format) {=0A=
          return this.localeData().monthsShort(this, format);=0A=
      });=0A=
=0A=
      addFormatToken('MMMM', 0, 0, function (format) {=0A=
          return this.localeData().months(this, format);=0A=
      });=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('month', 'M');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('M',    match1to2);=0A=
      addRegexToken('MM',   match1to2, match2);=0A=
      addRegexToken('MMM',  matchWord);=0A=
      addRegexToken('MMMM', matchWord);=0A=
=0A=
      addParseToken(['M', 'MM'], function (input, array) {=0A=
          array[MONTH] =3D toInt(input) - 1;=0A=
      });=0A=
=0A=
      addParseToken(['MMM', 'MMMM'], function (input, array, config, =
token) {=0A=
          var month =3D config._locale.monthsParse(input, token, =
config._strict);=0A=
          // if we didn't find a month name, mark the date as invalid.=0A=
          if (month !=3D null) {=0A=
              array[MONTH] =3D month;=0A=
          } else {=0A=
              getParsingFlags(config).invalidMonth =3D input;=0A=
          }=0A=
      });=0A=
=0A=
      // LOCALES=0A=
=0A=
      var defaultLocaleMonths =3D =
'January_February_March_April_May_June_July_August_September_October_Nove=
mber_December'.split('_');=0A=
      function localeMonths (m) {=0A=
          return this._months[m.month()];=0A=
      }=0A=
=0A=
      var defaultLocaleMonthsShort =3D =
'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');=0A=
      function localeMonthsShort (m) {=0A=
          return this._monthsShort[m.month()];=0A=
      }=0A=
=0A=
      function localeMonthsParse (monthName, format, strict) {=0A=
          var i, mom, regex;=0A=
=0A=
          if (!this._monthsParse) {=0A=
              this._monthsParse =3D [];=0A=
              this._longMonthsParse =3D [];=0A=
              this._shortMonthsParse =3D [];=0A=
          }=0A=
=0A=
          for (i =3D 0; i < 12; i++) {=0A=
              // make the regex if we don't have it already=0A=
              mom =3D create_utc__createUTC([2000, i]);=0A=
              if (strict && !this._longMonthsParse[i]) {=0A=
                  this._longMonthsParse[i] =3D new RegExp('^' + =
this.months(mom, '').replace('.', '') + '$', 'i');=0A=
                  this._shortMonthsParse[i] =3D new RegExp('^' + =
this.monthsShort(mom, '').replace('.', '') + '$', 'i');=0A=
              }=0A=
              if (!strict && !this._monthsParse[i]) {=0A=
                  regex =3D '^' + this.months(mom, '') + '|^' + =
this.monthsShort(mom, '');=0A=
                  this._monthsParse[i] =3D new RegExp(regex.replace('.', =
''), 'i');=0A=
              }=0A=
              // test the regex=0A=
              if (strict && format =3D=3D=3D 'MMMM' && =
this._longMonthsParse[i].test(monthName)) {=0A=
                  return i;=0A=
              } else if (strict && format =3D=3D=3D 'MMM' && =
this._shortMonthsParse[i].test(monthName)) {=0A=
                  return i;=0A=
              } else if (!strict && =
this._monthsParse[i].test(monthName)) {=0A=
                  return i;=0A=
              }=0A=
          }=0A=
      }=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function setMonth (mom, value) {=0A=
          var dayOfMonth;=0A=
=0A=
          // TODO: Move this out of here!=0A=
          if (typeof value =3D=3D=3D 'string') {=0A=
              value =3D mom.localeData().monthsParse(value);=0A=
              // TODO: Another silent failure?=0A=
              if (typeof value !=3D=3D 'number') {=0A=
                  return mom;=0A=
              }=0A=
          }=0A=
=0A=
          dayOfMonth =3D Math.min(mom.date(), daysInMonth(mom.year(), =
value));=0A=
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, =
dayOfMonth);=0A=
          return mom;=0A=
      }=0A=
=0A=
      function getSetMonth (value) {=0A=
          if (value !=3D null) {=0A=
              setMonth(this, value);=0A=
              utils_hooks__hooks.updateOffset(this, true);=0A=
              return this;=0A=
          } else {=0A=
              return get_set__get(this, 'Month');=0A=
          }=0A=
      }=0A=
=0A=
      function getDaysInMonth () {=0A=
          return daysInMonth(this.year(), this.month());=0A=
      }=0A=
=0A=
      function checkOverflow (m) {=0A=
          var overflow;=0A=
          var a =3D m._a;=0A=
=0A=
          if (a && getParsingFlags(m).overflow =3D=3D=3D -2) {=0A=
              overflow =3D=0A=
                  a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :=0A=
                  a[DATE]        < 1 || a[DATE]        > =
daysInMonth(a[YEAR], a[MONTH]) ? DATE :=0A=
                  a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] =
=3D=3D=3D 24 && (a[MINUTE] !=3D=3D 0 || a[SECOND] !=3D=3D 0 || =
a[MILLISECOND] !=3D=3D 0)) ? HOUR :=0A=
                  a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :=0A=
                  a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :=0A=
                  a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? =
MILLISECOND :=0A=
                  -1;=0A=
=0A=
              if (getParsingFlags(m)._overflowDayOfYear && (overflow < =
YEAR || overflow > DATE)) {=0A=
                  overflow =3D DATE;=0A=
              }=0A=
=0A=
              getParsingFlags(m).overflow =3D overflow;=0A=
          }=0A=
=0A=
          return m;=0A=
      }=0A=
=0A=
      function warn(msg) {=0A=
          if (utils_hooks__hooks.suppressDeprecationWarnings =3D=3D=3D =
false && typeof console !=3D=3D 'undefined' && console.warn) {=0A=
              console.warn('Deprecation warning: ' + msg);=0A=
          }=0A=
      }=0A=
=0A=
      function deprecate(msg, fn) {=0A=
          var firstTime =3D true;=0A=
=0A=
          return extend(function () {=0A=
              if (firstTime) {=0A=
                  warn(msg + '\n' + (new Error()).stack);=0A=
                  firstTime =3D false;=0A=
              }=0A=
              return fn.apply(this, arguments);=0A=
          }, fn);=0A=
      }=0A=
=0A=
      var deprecations =3D {};=0A=
=0A=
      function deprecateSimple(name, msg) {=0A=
          if (!deprecations[name]) {=0A=
              warn(msg);=0A=
              deprecations[name] =3D true;=0A=
          }=0A=
      }=0A=
=0A=
      utils_hooks__hooks.suppressDeprecationWarnings =3D false;=0A=
=0A=
      var from_string__isoRegex =3D =
/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T|=
 )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;=0A=
=0A=
      var isoDates =3D [=0A=
          ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],=0A=
          ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],=0A=
          ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],=0A=
          ['GGGG-[W]WW', /\d{4}-W\d{2}/],=0A=
          ['YYYY-DDD', /\d{4}-\d{3}/]=0A=
      ];=0A=
=0A=
      // iso time formats and regexes=0A=
      var isoTimes =3D [=0A=
          ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],=0A=
          ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],=0A=
          ['HH:mm', /(T| )\d\d:\d\d/],=0A=
          ['HH', /(T| )\d\d/]=0A=
      ];=0A=
=0A=
      var aspNetJsonRegex =3D /^\/?Date\((\-?\d+)/i;=0A=
=0A=
      // date from iso format=0A=
      function configFromISO(config) {=0A=
          var i, l,=0A=
              string =3D config._i,=0A=
              match =3D from_string__isoRegex.exec(string);=0A=
=0A=
          if (match) {=0A=
              getParsingFlags(config).iso =3D true;=0A=
              for (i =3D 0, l =3D isoDates.length; i < l; i++) {=0A=
                  if (isoDates[i][1].exec(string)) {=0A=
                      config._f =3D isoDates[i][0];=0A=
                      break;=0A=
                  }=0A=
              }=0A=
              for (i =3D 0, l =3D isoTimes.length; i < l; i++) {=0A=
                  if (isoTimes[i][1].exec(string)) {=0A=
                      // match[6] should be 'T' or space=0A=
                      config._f +=3D (match[6] || ' ') + isoTimes[i][0];=0A=
                      break;=0A=
                  }=0A=
              }=0A=
              if (string.match(matchOffset)) {=0A=
                  config._f +=3D 'Z';=0A=
              }=0A=
              configFromStringAndFormat(config);=0A=
          } else {=0A=
              config._isValid =3D false;=0A=
          }=0A=
      }=0A=
=0A=
      // date from iso format or fallback=0A=
      function configFromString(config) {=0A=
          var matched =3D aspNetJsonRegex.exec(config._i);=0A=
=0A=
          if (matched !=3D=3D null) {=0A=
              config._d =3D new Date(+matched[1]);=0A=
              return;=0A=
          }=0A=
=0A=
          configFromISO(config);=0A=
          if (config._isValid =3D=3D=3D false) {=0A=
              delete config._isValid;=0A=
              utils_hooks__hooks.createFromInputFallback(config);=0A=
          }=0A=
      }=0A=
=0A=
      utils_hooks__hooks.createFromInputFallback =3D deprecate(=0A=
          'moment construction falls back to js Date. This is ' +=0A=
          'discouraged and will be removed in upcoming major ' +=0A=
          'release. Please refer to ' +=0A=
          'https://github.com/moment/moment/issues/1407 for more info.',=0A=
          function (config) {=0A=
              config._d =3D new Date(config._i + (config._useUTC ? ' =
UTC' : ''));=0A=
          }=0A=
      );=0A=
=0A=
      function createDate (y, m, d, h, M, s, ms) {=0A=
          //can't just apply() to create a date:=0A=
          =
//http://stackoverflow.com/questions/181348/instantiating-a-javascript-ob=
ject-by-calling-prototype-constructor-apply=0A=
          var date =3D new Date(y, m, d, h, M, s, ms);=0A=
=0A=
          //the date constructor doesn't accept years < 1970=0A=
          if (y < 1970) {=0A=
              date.setFullYear(y);=0A=
          }=0A=
          return date;=0A=
      }=0A=
=0A=
      function createUTCDate (y) {=0A=
          var date =3D new Date(Date.UTC.apply(null, arguments));=0A=
          if (y < 1970) {=0A=
              date.setUTCFullYear(y);=0A=
          }=0A=
          return date;=0A=
      }=0A=
=0A=
      addFormatToken(0, ['YY', 2], 0, function () {=0A=
          return this.year() % 100;=0A=
      });=0A=
=0A=
      addFormatToken(0, ['YYYY',   4],       0, 'year');=0A=
      addFormatToken(0, ['YYYYY',  5],       0, 'year');=0A=
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('year', 'y');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('Y',      matchSigned);=0A=
      addRegexToken('YY',     match1to2, match2);=0A=
      addRegexToken('YYYY',   match1to4, match4);=0A=
      addRegexToken('YYYYY',  match1to6, match6);=0A=
      addRegexToken('YYYYYY', match1to6, match6);=0A=
=0A=
      addParseToken(['YYYYY', 'YYYYYY'], YEAR);=0A=
      addParseToken('YYYY', function (input, array) {=0A=
          array[YEAR] =3D input.length =3D=3D=3D 2 ? =
utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);=0A=
      });=0A=
      addParseToken('YY', function (input, array) {=0A=
          array[YEAR] =3D utils_hooks__hooks.parseTwoDigitYear(input);=0A=
      });=0A=
=0A=
      // HELPERS=0A=
=0A=
      function daysInYear(year) {=0A=
          return isLeapYear(year) ? 366 : 365;=0A=
      }=0A=
=0A=
      function isLeapYear(year) {=0A=
          return (year % 4 =3D=3D=3D 0 && year % 100 !=3D=3D 0) || year =
% 400 =3D=3D=3D 0;=0A=
      }=0A=
=0A=
      // HOOKS=0A=
=0A=
      utils_hooks__hooks.parseTwoDigitYear =3D function (input) {=0A=
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);=0A=
      };=0A=
=0A=
      // MOMENTS=0A=
=0A=
      var getSetYear =3D makeGetSet('FullYear', false);=0A=
=0A=
      function getIsLeapYear () {=0A=
          return isLeapYear(this.year());=0A=
      }=0A=
=0A=
      addFormatToken('w', ['ww', 2], 'wo', 'week');=0A=
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('week', 'w');=0A=
      addUnitAlias('isoWeek', 'W');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('w',  match1to2);=0A=
      addRegexToken('ww', match1to2, match2);=0A=
      addRegexToken('W',  match1to2);=0A=
      addRegexToken('WW', match1to2, match2);=0A=
=0A=
      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, =
config, token) {=0A=
          week[token.substr(0, 1)] =3D toInt(input);=0A=
      });=0A=
=0A=
      // HELPERS=0A=
=0A=
      // firstDayOfWeek       0 =3D sun, 6 =3D sat=0A=
      //                      the day of the week that starts the week=0A=
      //                      (usually sunday or monday)=0A=
      // firstDayOfWeekOfYear 0 =3D sun, 6 =3D sat=0A=
      //                      the first week is the week that contains =
the first=0A=
      //                      of this day of the week=0A=
      //                      (eg. ISO weeks use thursday (4))=0A=
      function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {=0A=
          var end =3D firstDayOfWeekOfYear - firstDayOfWeek,=0A=
              daysToDayOfWeek =3D firstDayOfWeekOfYear - mom.day(),=0A=
              adjustedMoment;=0A=
=0A=
=0A=
          if (daysToDayOfWeek > end) {=0A=
              daysToDayOfWeek -=3D 7;=0A=
          }=0A=
=0A=
          if (daysToDayOfWeek < end - 7) {=0A=
              daysToDayOfWeek +=3D 7;=0A=
          }=0A=
=0A=
          adjustedMoment =3D =
local__createLocal(mom).add(daysToDayOfWeek, 'd');=0A=
          return {=0A=
              week: Math.ceil(adjustedMoment.dayOfYear() / 7),=0A=
              year: adjustedMoment.year()=0A=
          };=0A=
      }=0A=
=0A=
      // LOCALES=0A=
=0A=
      function localeWeek (mom) {=0A=
          return weekOfYear(mom, this._week.dow, this._week.doy).week;=0A=
      }=0A=
=0A=
      var defaultLocaleWeek =3D {=0A=
          dow : 0, // Sunday is the first day of the week.=0A=
          doy : 6  // The week that contains Jan 1st is the first week =
of the year.=0A=
      };=0A=
=0A=
      function localeFirstDayOfWeek () {=0A=
          return this._week.dow;=0A=
      }=0A=
=0A=
      function localeFirstDayOfYear () {=0A=
          return this._week.doy;=0A=
      }=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function getSetWeek (input) {=0A=
          var week =3D this.localeData().week(this);=0A=
          return input =3D=3D null ? week : this.add((input - week) * 7, =
'd');=0A=
      }=0A=
=0A=
      function getSetISOWeek (input) {=0A=
          var week =3D weekOfYear(this, 1, 4).week;=0A=
          return input =3D=3D null ? week : this.add((input - week) * 7, =
'd');=0A=
      }=0A=
=0A=
      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('dayOfYear', 'DDD');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('DDD',  match1to3);=0A=
      addRegexToken('DDDD', match3);=0A=
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {=0A=
          config._dayOfYear =3D toInt(input);=0A=
      });=0A=
=0A=
      // HELPERS=0A=
=0A=
      =
//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the=
_year.2C_week_number_and_weekday=0A=
      function dayOfYearFromWeeks(year, week, weekday, =
firstDayOfWeekOfYear, firstDayOfWeek) {=0A=
          var week1Jan =3D 6 + firstDayOfWeek - firstDayOfWeekOfYear, =
janX =3D createUTCDate(year, 0, 1 + week1Jan), d =3D janX.getUTCDay(), =
dayOfYear;=0A=
          if (d < firstDayOfWeek) {=0A=
              d +=3D 7;=0A=
          }=0A=
=0A=
          weekday =3D weekday !=3D null ? 1 * weekday : firstDayOfWeek;=0A=
=0A=
          dayOfYear =3D 1 + week1Jan + 7 * (week - 1) - d + weekday;=0A=
=0A=
          return {=0A=
              year: dayOfYear > 0 ? year : year - 1,=0A=
              dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - =
1) + dayOfYear=0A=
          };=0A=
      }=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function getSetDayOfYear (input) {=0A=
          var dayOfYear =3D Math.round((this.clone().startOf('day') - =
this.clone().startOf('year')) / 864e5) + 1;=0A=
          return input =3D=3D null ? dayOfYear : this.add((input - =
dayOfYear), 'd');=0A=
      }=0A=
=0A=
      // Pick the first defined of two or three arguments.=0A=
      function defaults(a, b, c) {=0A=
          if (a !=3D null) {=0A=
              return a;=0A=
          }=0A=
          if (b !=3D null) {=0A=
              return b;=0A=
          }=0A=
          return c;=0A=
      }=0A=
=0A=
      function currentDateArray(config) {=0A=
          var now =3D new Date();=0A=
          if (config._useUTC) {=0A=
              return [now.getUTCFullYear(), now.getUTCMonth(), =
now.getUTCDate()];=0A=
          }=0A=
          return [now.getFullYear(), now.getMonth(), now.getDate()];=0A=
      }=0A=
=0A=
      // convert an array to a date.=0A=
      // the array should mirror the parameters below=0A=
      // note: all values past the year are optional and will default to =
the lowest possible value.=0A=
      // [year, month, day , hour, minute, second, millisecond]=0A=
      function configFromArray (config) {=0A=
          var i, date, input =3D [], currentDate, yearToUse;=0A=
=0A=
          if (config._d) {=0A=
              return;=0A=
          }=0A=
=0A=
          currentDate =3D currentDateArray(config);=0A=
=0A=
          //compute day of the year from weeks and weekdays=0A=
          if (config._w && config._a[DATE] =3D=3D null && =
config._a[MONTH] =3D=3D null) {=0A=
              dayOfYearFromWeekInfo(config);=0A=
          }=0A=
=0A=
          //if the day of the year is set, figure out what it is=0A=
          if (config._dayOfYear) {=0A=
              yearToUse =3D defaults(config._a[YEAR], currentDate[YEAR]);=0A=
=0A=
              if (config._dayOfYear > daysInYear(yearToUse)) {=0A=
                  getParsingFlags(config)._overflowDayOfYear =3D true;=0A=
              }=0A=
=0A=
              date =3D createUTCDate(yearToUse, 0, config._dayOfYear);=0A=
              config._a[MONTH] =3D date.getUTCMonth();=0A=
              config._a[DATE] =3D date.getUTCDate();=0A=
          }=0A=
=0A=
          // Default to current date.=0A=
          // * if no year, month, day of month are given, default to =
today=0A=
          // * if day of month is given, default month and year=0A=
          // * if month is given, default only year=0A=
          // * if year is given, don't default anything=0A=
          for (i =3D 0; i < 3 && config._a[i] =3D=3D null; ++i) {=0A=
              config._a[i] =3D input[i] =3D currentDate[i];=0A=
          }=0A=
=0A=
          // Zero out whatever was not defaulted, including time=0A=
          for (; i < 7; i++) {=0A=
              config._a[i] =3D input[i] =3D (config._a[i] =3D=3D null) ? =
(i =3D=3D=3D 2 ? 1 : 0) : config._a[i];=0A=
          }=0A=
=0A=
          // Check for 24:00:00.000=0A=
          if (config._a[HOUR] =3D=3D=3D 24 &&=0A=
                  config._a[MINUTE] =3D=3D=3D 0 &&=0A=
                  config._a[SECOND] =3D=3D=3D 0 &&=0A=
                  config._a[MILLISECOND] =3D=3D=3D 0) {=0A=
              config._nextDay =3D true;=0A=
              config._a[HOUR] =3D 0;=0A=
          }=0A=
=0A=
          config._d =3D (config._useUTC ? createUTCDate : =
createDate).apply(null, input);=0A=
          // Apply timezone offset from input. The actual utcOffset can =
be changed=0A=
          // with parseZone.=0A=
          if (config._tzm !=3D null) {=0A=
              config._d.setUTCMinutes(config._d.getUTCMinutes() - =
config._tzm);=0A=
          }=0A=
=0A=
          if (config._nextDay) {=0A=
              config._a[HOUR] =3D 24;=0A=
          }=0A=
      }=0A=
=0A=
      function dayOfYearFromWeekInfo(config) {=0A=
          var w, weekYear, week, weekday, dow, doy, temp;=0A=
=0A=
          w =3D config._w;=0A=
          if (w.GG !=3D null || w.W !=3D null || w.E !=3D null) {=0A=
              dow =3D 1;=0A=
              doy =3D 4;=0A=
=0A=
              // TODO: We need to take the current isoWeekYear, but that =
depends on=0A=
              // how we interpret now (local, utc, fixed offset). So =
create=0A=
              // a now version of current config (take local/utc/offset =
flags, and=0A=
              // create now).=0A=
              weekYear =3D defaults(w.GG, config._a[YEAR], =
weekOfYear(local__createLocal(), 1, 4).year);=0A=
              week =3D defaults(w.W, 1);=0A=
              weekday =3D defaults(w.E, 1);=0A=
          } else {=0A=
              dow =3D config._locale._week.dow;=0A=
              doy =3D config._locale._week.doy;=0A=
=0A=
              weekYear =3D defaults(w.gg, config._a[YEAR], =
weekOfYear(local__createLocal(), dow, doy).year);=0A=
              week =3D defaults(w.w, 1);=0A=
=0A=
              if (w.d !=3D null) {=0A=
                  // weekday -- low day numbers are considered next week=0A=
                  weekday =3D w.d;=0A=
                  if (weekday < dow) {=0A=
                      ++week;=0A=
                  }=0A=
              } else if (w.e !=3D null) {=0A=
                  // local weekday -- counting starts from begining of =
week=0A=
                  weekday =3D w.e + dow;=0A=
              } else {=0A=
                  // default to begining of week=0A=
                  weekday =3D dow;=0A=
              }=0A=
          }=0A=
          temp =3D dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);=0A=
=0A=
          config._a[YEAR] =3D temp.year;=0A=
          config._dayOfYear =3D temp.dayOfYear;=0A=
      }=0A=
=0A=
      utils_hooks__hooks.ISO_8601 =3D function () {};=0A=
=0A=
      // date from string and format string=0A=
      function configFromStringAndFormat(config) {=0A=
          // TODO: Move this to another part of the creation flow to =
prevent circular deps=0A=
          if (config._f =3D=3D=3D utils_hooks__hooks.ISO_8601) {=0A=
              configFromISO(config);=0A=
              return;=0A=
          }=0A=
=0A=
          config._a =3D [];=0A=
          getParsingFlags(config).empty =3D true;=0A=
=0A=
          // This array is used to make a Date, either with `new Date` =
or `Date.UTC`=0A=
          var string =3D '' + config._i,=0A=
              i, parsedInput, tokens, token, skipped,=0A=
              stringLength =3D string.length,=0A=
              totalParsedInputLength =3D 0;=0A=
=0A=
          tokens =3D expandFormat(config._f, =
config._locale).match(formattingTokens) || [];=0A=
=0A=
          for (i =3D 0; i < tokens.length; i++) {=0A=
              token =3D tokens[i];=0A=
              parsedInput =3D (string.match(getParseRegexForToken(token, =
config)) || [])[0];=0A=
              if (parsedInput) {=0A=
                  skipped =3D string.substr(0, =
string.indexOf(parsedInput));=0A=
                  if (skipped.length > 0) {=0A=
                      getParsingFlags(config).unusedInput.push(skipped);=0A=
                  }=0A=
                  string =3D string.slice(string.indexOf(parsedInput) + =
parsedInput.length);=0A=
                  totalParsedInputLength +=3D parsedInput.length;=0A=
              }=0A=
              // don't parse if it's not a known token=0A=
              if (formatTokenFunctions[token]) {=0A=
                  if (parsedInput) {=0A=
                      getParsingFlags(config).empty =3D false;=0A=
                  }=0A=
                  else {=0A=
                      getParsingFlags(config).unusedTokens.push(token);=0A=
                  }=0A=
                  addTimeToArrayFromToken(token, parsedInput, config);=0A=
              }=0A=
              else if (config._strict && !parsedInput) {=0A=
                  getParsingFlags(config).unusedTokens.push(token);=0A=
              }=0A=
          }=0A=
=0A=
          // add remaining unparsed input length to the string=0A=
          getParsingFlags(config).charsLeftOver =3D stringLength - =
totalParsedInputLength;=0A=
          if (string.length > 0) {=0A=
              getParsingFlags(config).unusedInput.push(string);=0A=
          }=0A=
=0A=
          // clear _12h flag if hour is <=3D 12=0A=
          if (getParsingFlags(config).bigHour =3D=3D=3D true &&=0A=
                  config._a[HOUR] <=3D 12 &&=0A=
                  config._a[HOUR] > 0) {=0A=
              getParsingFlags(config).bigHour =3D undefined;=0A=
          }=0A=
          // handle meridiem=0A=
          config._a[HOUR] =3D meridiemFixWrap(config._locale, =
config._a[HOUR], config._meridiem);=0A=
=0A=
          configFromArray(config);=0A=
          checkOverflow(config);=0A=
      }=0A=
=0A=
=0A=
      function meridiemFixWrap (locale, hour, meridiem) {=0A=
          var isPm;=0A=
=0A=
          if (meridiem =3D=3D null) {=0A=
              // nothing to do=0A=
              return hour;=0A=
          }=0A=
          if (locale.meridiemHour !=3D null) {=0A=
              return locale.meridiemHour(hour, meridiem);=0A=
          } else if (locale.isPM !=3D null) {=0A=
              // Fallback=0A=
              isPm =3D locale.isPM(meridiem);=0A=
              if (isPm && hour < 12) {=0A=
                  hour +=3D 12;=0A=
              }=0A=
              if (!isPm && hour =3D=3D=3D 12) {=0A=
                  hour =3D 0;=0A=
              }=0A=
              return hour;=0A=
          } else {=0A=
              // this is not supposed to happen=0A=
              return hour;=0A=
          }=0A=
      }=0A=
=0A=
      function configFromStringAndArray(config) {=0A=
          var tempConfig,=0A=
              bestMoment,=0A=
=0A=
              scoreToBeat,=0A=
              i,=0A=
              currentScore;=0A=
=0A=
          if (config._f.length =3D=3D=3D 0) {=0A=
              getParsingFlags(config).invalidFormat =3D true;=0A=
              config._d =3D new Date(NaN);=0A=
              return;=0A=
          }=0A=
=0A=
          for (i =3D 0; i < config._f.length; i++) {=0A=
              currentScore =3D 0;=0A=
              tempConfig =3D copyConfig({}, config);=0A=
              if (config._useUTC !=3D null) {=0A=
                  tempConfig._useUTC =3D config._useUTC;=0A=
              }=0A=
              tempConfig._f =3D config._f[i];=0A=
              configFromStringAndFormat(tempConfig);=0A=
=0A=
              if (!valid__isValid(tempConfig)) {=0A=
                  continue;=0A=
              }=0A=
=0A=
              // if there is any input that was not parsed add a penalty =
for that format=0A=
              currentScore +=3D =
getParsingFlags(tempConfig).charsLeftOver;=0A=
=0A=
              //or tokens=0A=
              currentScore +=3D =
getParsingFlags(tempConfig).unusedTokens.length * 10;=0A=
=0A=
              getParsingFlags(tempConfig).score =3D currentScore;=0A=
=0A=
              if (scoreToBeat =3D=3D null || currentScore < scoreToBeat) =
{=0A=
                  scoreToBeat =3D currentScore;=0A=
                  bestMoment =3D tempConfig;=0A=
              }=0A=
          }=0A=
=0A=
          extend(config, bestMoment || tempConfig);=0A=
      }=0A=
=0A=
      function configFromObject(config) {=0A=
          if (config._d) {=0A=
              return;=0A=
          }=0A=
=0A=
          var i =3D normalizeObjectUnits(config._i);=0A=
          config._a =3D [i.year, i.month, i.day || i.date, i.hour, =
i.minute, i.second, i.millisecond];=0A=
=0A=
          configFromArray(config);=0A=
      }=0A=
=0A=
      function createFromConfig (config) {=0A=
          var res =3D new Moment(checkOverflow(prepareConfig(config)));=0A=
          if (res._nextDay) {=0A=
              // Adding is smart enough around DST=0A=
              res.add(1, 'd');=0A=
              res._nextDay =3D undefined;=0A=
          }=0A=
=0A=
          return res;=0A=
      }=0A=
=0A=
      function prepareConfig (config) {=0A=
          var input =3D config._i,=0A=
              format =3D config._f;=0A=
=0A=
          config._locale =3D config._locale || =
locale_locales__getLocale(config._l);=0A=
=0A=
          if (input =3D=3D=3D null || (format =3D=3D=3D undefined && =
input =3D=3D=3D '')) {=0A=
              return valid__createInvalid({nullInput: true});=0A=
          }=0A=
=0A=
          if (typeof input =3D=3D=3D 'string') {=0A=
              config._i =3D input =3D config._locale.preparse(input);=0A=
          }=0A=
=0A=
          if (isMoment(input)) {=0A=
              return new Moment(checkOverflow(input));=0A=
          } else if (isArray(format)) {=0A=
              configFromStringAndArray(config);=0A=
          } else if (format) {=0A=
              configFromStringAndFormat(config);=0A=
          } else if (isDate(input)) {=0A=
              config._d =3D input;=0A=
          } else {=0A=
              configFromInput(config);=0A=
          }=0A=
=0A=
          return config;=0A=
      }=0A=
=0A=
      function configFromInput(config) {=0A=
          var input =3D config._i;=0A=
          if (input =3D=3D=3D undefined) {=0A=
              config._d =3D new Date();=0A=
          } else if (isDate(input)) {=0A=
              config._d =3D new Date(+input);=0A=
          } else if (typeof input =3D=3D=3D 'string') {=0A=
              configFromString(config);=0A=
          } else if (isArray(input)) {=0A=
              config._a =3D map(input.slice(0), function (obj) {=0A=
                  return parseInt(obj, 10);=0A=
              });=0A=
              configFromArray(config);=0A=
          } else if (typeof(input) =3D=3D=3D 'object') {=0A=
              configFromObject(config);=0A=
          } else if (typeof(input) =3D=3D=3D 'number') {=0A=
              // from milliseconds=0A=
              config._d =3D new Date(input);=0A=
          } else {=0A=
              utils_hooks__hooks.createFromInputFallback(config);=0A=
          }=0A=
      }=0A=
=0A=
      function createLocalOrUTC (input, format, locale, strict, isUTC) {=0A=
          var c =3D {};=0A=
=0A=
          if (typeof(locale) =3D=3D=3D 'boolean') {=0A=
              strict =3D locale;=0A=
              locale =3D undefined;=0A=
          }=0A=
          // object construction must be done this way.=0A=
          // https://github.com/moment/moment/issues/1423=0A=
          c._isAMomentObject =3D true;=0A=
          c._useUTC =3D c._isUTC =3D isUTC;=0A=
          c._l =3D locale;=0A=
          c._i =3D input;=0A=
          c._f =3D format;=0A=
          c._strict =3D strict;=0A=
=0A=
          return createFromConfig(c);=0A=
      }=0A=
=0A=
      function local__createLocal (input, format, locale, strict) {=0A=
          return createLocalOrUTC(input, format, locale, strict, false);=0A=
      }=0A=
=0A=
      var prototypeMin =3D deprecate(=0A=
           'moment().min is deprecated, use moment.min instead. =
https://github.com/moment/moment/issues/1548',=0A=
           function () {=0A=
               var other =3D local__createLocal.apply(null, arguments);=0A=
               return other < this ? this : other;=0A=
           }=0A=
       );=0A=
=0A=
      var prototypeMax =3D deprecate(=0A=
          'moment().max is deprecated, use moment.max instead. =
https://github.com/moment/moment/issues/1548',=0A=
          function () {=0A=
              var other =3D local__createLocal.apply(null, arguments);=0A=
              return other > this ? this : other;=0A=
          }=0A=
      );=0A=
=0A=
      // Pick a moment m from moments so that m[fn](other) is true for =
all=0A=
      // other. This relies on the function fn to be transitive.=0A=
      //=0A=
      // moments should either be an array of moment objects or an =
array, whose=0A=
      // first element is an array of moment objects.=0A=
      function pickBy(fn, moments) {=0A=
          var res, i;=0A=
          if (moments.length =3D=3D=3D 1 && isArray(moments[0])) {=0A=
              moments =3D moments[0];=0A=
          }=0A=
          if (!moments.length) {=0A=
              return local__createLocal();=0A=
          }=0A=
          res =3D moments[0];=0A=
          for (i =3D 1; i < moments.length; ++i) {=0A=
              if (!moments[i].isValid() || moments[i][fn](res)) {=0A=
                  res =3D moments[i];=0A=
              }=0A=
          }=0A=
          return res;=0A=
      }=0A=
=0A=
      // TODO: Use [].sort instead?=0A=
      function min () {=0A=
          var args =3D [].slice.call(arguments, 0);=0A=
=0A=
          return pickBy('isBefore', args);=0A=
      }=0A=
=0A=
      function max () {=0A=
          var args =3D [].slice.call(arguments, 0);=0A=
=0A=
          return pickBy('isAfter', args);=0A=
      }=0A=
=0A=
      function Duration (duration) {=0A=
          var normalizedInput =3D normalizeObjectUnits(duration),=0A=
              years =3D normalizedInput.year || 0,=0A=
              quarters =3D normalizedInput.quarter || 0,=0A=
              months =3D normalizedInput.month || 0,=0A=
              weeks =3D normalizedInput.week || 0,=0A=
              days =3D normalizedInput.day || 0,=0A=
              hours =3D normalizedInput.hour || 0,=0A=
              minutes =3D normalizedInput.minute || 0,=0A=
              seconds =3D normalizedInput.second || 0,=0A=
              milliseconds =3D normalizedInput.millisecond || 0;=0A=
=0A=
          // representation for dateAddRemove=0A=
          this._milliseconds =3D +milliseconds +=0A=
              seconds * 1e3 + // 1000=0A=
              minutes * 6e4 + // 1000 * 60=0A=
              hours * 36e5; // 1000 * 60 * 60=0A=
          // Because of dateAddRemove treats 24 hours as different from a=0A=
          // day when working around DST, we need to store them =
separately=0A=
          this._days =3D +days +=0A=
              weeks * 7;=0A=
          // It is impossible translate months into days without knowing=0A=
          // which months you are are talking about, so we have to store=0A=
          // it separately.=0A=
          this._months =3D +months +=0A=
              quarters * 3 +=0A=
              years * 12;=0A=
=0A=
          this._data =3D {};=0A=
=0A=
          this._locale =3D locale_locales__getLocale();=0A=
=0A=
          this._bubble();=0A=
      }=0A=
=0A=
      function isDuration (obj) {=0A=
          return obj instanceof Duration;=0A=
      }=0A=
=0A=
      function offset (token, separator) {=0A=
          addFormatToken(token, 0, 0, function () {=0A=
              var offset =3D this.utcOffset();=0A=
              var sign =3D '+';=0A=
              if (offset < 0) {=0A=
                  offset =3D -offset;=0A=
                  sign =3D '-';=0A=
              }=0A=
              return sign + zeroFill(~~(offset / 60), 2) + separator + =
zeroFill(~~(offset) % 60, 2);=0A=
          });=0A=
      }=0A=
=0A=
      offset('Z', ':');=0A=
      offset('ZZ', '');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('Z',  matchOffset);=0A=
      addRegexToken('ZZ', matchOffset);=0A=
      addParseToken(['Z', 'ZZ'], function (input, array, config) {=0A=
          config._useUTC =3D true;=0A=
          config._tzm =3D offsetFromString(input);=0A=
      });=0A=
=0A=
      // HELPERS=0A=
=0A=
      // timezone chunker=0A=
      // '+10:00' > ['10',  '00']=0A=
      // '-1530'  > ['-15', '30']=0A=
      var chunkOffset =3D /([\+\-]|\d\d)/gi;=0A=
=0A=
      function offsetFromString(string) {=0A=
          var matches =3D ((string || '').match(matchOffset) || []);=0A=
          var chunk   =3D matches[matches.length - 1] || [];=0A=
          var parts   =3D (chunk + '').match(chunkOffset) || ['-', 0, 0];=0A=
          var minutes =3D +(parts[1] * 60) + toInt(parts[2]);=0A=
=0A=
          return parts[0] =3D=3D=3D '+' ? minutes : -minutes;=0A=
      }=0A=
=0A=
      // Return a moment from input, that is local/utc/zone equivalent =
to model.=0A=
      function cloneWithOffset(input, model) {=0A=
          var res, diff;=0A=
          if (model._isUTC) {=0A=
              res =3D model.clone();=0A=
              diff =3D (isMoment(input) || isDate(input) ? +input : =
+local__createLocal(input)) - (+res);=0A=
              // Use low-level api, because this fn is low-level api.=0A=
              res._d.setTime(+res._d + diff);=0A=
              utils_hooks__hooks.updateOffset(res, false);=0A=
              return res;=0A=
          } else {=0A=
              return local__createLocal(input).local();=0A=
          }=0A=
      }=0A=
=0A=
      function getDateOffset (m) {=0A=
          // On Firefox.24 Date#getTimezoneOffset returns a floating =
point.=0A=
          // https://github.com/moment/moment/pull/1871=0A=
          return -Math.round(m._d.getTimezoneOffset() / 15) * 15;=0A=
      }=0A=
=0A=
      // HOOKS=0A=
=0A=
      // This function will be called whenever a moment is mutated.=0A=
      // It is intended to keep the offset in sync with the timezone.=0A=
      utils_hooks__hooks.updateOffset =3D function () {};=0A=
=0A=
      // MOMENTS=0A=
=0A=
      // keepLocalTime =3D true means only change the timezone, without=0A=
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, =
true)]-->=0A=
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with =
offset=0A=
      // +0200, so we adjust the time as needed, to be valid.=0A=
      //=0A=
      // Keeping the time actually adds/subtracts (one hour)=0A=
      // from the actual represented time. That is why we call =
updateOffset=0A=
      // a second time. In case it wants us to change the offset again=0A=
      // _changeInProgress =3D=3D true case, then we have to adjust, =
because=0A=
      // there is no such time in the given timezone.=0A=
      function getSetOffset (input, keepLocalTime) {=0A=
          var offset =3D this._offset || 0,=0A=
              localAdjust;=0A=
          if (input !=3D null) {=0A=
              if (typeof input =3D=3D=3D 'string') {=0A=
                  input =3D offsetFromString(input);=0A=
              }=0A=
              if (Math.abs(input) < 16) {=0A=
                  input =3D input * 60;=0A=
              }=0A=
              if (!this._isUTC && keepLocalTime) {=0A=
                  localAdjust =3D getDateOffset(this);=0A=
              }=0A=
              this._offset =3D input;=0A=
              this._isUTC =3D true;=0A=
              if (localAdjust !=3D null) {=0A=
                  this.add(localAdjust, 'm');=0A=
              }=0A=
              if (offset !=3D=3D input) {=0A=
                  if (!keepLocalTime || this._changeInProgress) {=0A=
                      add_subtract__addSubtract(this, =
create__createDuration(input - offset, 'm'), 1, false);=0A=
                  } else if (!this._changeInProgress) {=0A=
                      this._changeInProgress =3D true;=0A=
                      utils_hooks__hooks.updateOffset(this, true);=0A=
                      this._changeInProgress =3D null;=0A=
                  }=0A=
              }=0A=
              return this;=0A=
          } else {=0A=
              return this._isUTC ? offset : getDateOffset(this);=0A=
          }=0A=
      }=0A=
=0A=
      function getSetZone (input, keepLocalTime) {=0A=
          if (input !=3D null) {=0A=
              if (typeof input !=3D=3D 'string') {=0A=
                  input =3D -input;=0A=
              }=0A=
=0A=
              this.utcOffset(input, keepLocalTime);=0A=
=0A=
              return this;=0A=
          } else {=0A=
              return -this.utcOffset();=0A=
          }=0A=
      }=0A=
=0A=
      function setOffsetToUTC (keepLocalTime) {=0A=
          return this.utcOffset(0, keepLocalTime);=0A=
      }=0A=
=0A=
      function setOffsetToLocal (keepLocalTime) {=0A=
          if (this._isUTC) {=0A=
              this.utcOffset(0, keepLocalTime);=0A=
              this._isUTC =3D false;=0A=
=0A=
              if (keepLocalTime) {=0A=
                  this.subtract(getDateOffset(this), 'm');=0A=
              }=0A=
          }=0A=
          return this;=0A=
      }=0A=
=0A=
      function setOffsetToParsedOffset () {=0A=
          if (this._tzm) {=0A=
              this.utcOffset(this._tzm);=0A=
          } else if (typeof this._i =3D=3D=3D 'string') {=0A=
              this.utcOffset(offsetFromString(this._i));=0A=
          }=0A=
          return this;=0A=
      }=0A=
=0A=
      function hasAlignedHourOffset (input) {=0A=
          input =3D input ? local__createLocal(input).utcOffset() : 0;=0A=
=0A=
          return (this.utcOffset() - input) % 60 =3D=3D=3D 0;=0A=
      }=0A=
=0A=
      function isDaylightSavingTime () {=0A=
          return (=0A=
              this.utcOffset() > this.clone().month(0).utcOffset() ||=0A=
              this.utcOffset() > this.clone().month(5).utcOffset()=0A=
          );=0A=
      }=0A=
=0A=
      function isDaylightSavingTimeShifted () {=0A=
          if (typeof this._isDSTShifted !=3D=3D 'undefined') {=0A=
              return this._isDSTShifted;=0A=
          }=0A=
=0A=
          var c =3D {};=0A=
=0A=
          copyConfig(c, this);=0A=
          c =3D prepareConfig(c);=0A=
=0A=
          if (c._a) {=0A=
              var other =3D c._isUTC ? create_utc__createUTC(c._a) : =
local__createLocal(c._a);=0A=
              this._isDSTShifted =3D this.isValid() &&=0A=
                  compareArrays(c._a, other.toArray()) > 0;=0A=
          } else {=0A=
              this._isDSTShifted =3D false;=0A=
          }=0A=
=0A=
          return this._isDSTShifted;=0A=
      }=0A=
=0A=
      function isLocal () {=0A=
          return !this._isUTC;=0A=
      }=0A=
=0A=
      function isUtcOffset () {=0A=
          return this._isUTC;=0A=
      }=0A=
=0A=
      function isUtc () {=0A=
          return this._isUTC && this._offset =3D=3D=3D 0;=0A=
      }=0A=
=0A=
      var aspNetRegex =3D =
/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;=0A=
=0A=
      // from =
http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.=
source.html=0A=
      // somewhat more in line with 4.4.3.2 2004 spec, but allows =
decimal anywhere=0A=
      var create__isoRegex =3D =
/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]=
*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;=0A=
=0A=
      function create__createDuration (input, key) {=0A=
          var duration =3D input,=0A=
              // matching against regexp is expensive, do it on demand=0A=
              match =3D null,=0A=
              sign,=0A=
              ret,=0A=
              diffRes;=0A=
=0A=
          if (isDuration(input)) {=0A=
              duration =3D {=0A=
                  ms : input._milliseconds,=0A=
                  d  : input._days,=0A=
                  M  : input._months=0A=
              };=0A=
          } else if (typeof input =3D=3D=3D 'number') {=0A=
              duration =3D {};=0A=
              if (key) {=0A=
                  duration[key] =3D input;=0A=
              } else {=0A=
                  duration.milliseconds =3D input;=0A=
              }=0A=
          } else if (!!(match =3D aspNetRegex.exec(input))) {=0A=
              sign =3D (match[1] =3D=3D=3D '-') ? -1 : 1;=0A=
              duration =3D {=0A=
                  y  : 0,=0A=
                  d  : toInt(match[DATE])        * sign,=0A=
                  h  : toInt(match[HOUR])        * sign,=0A=
                  m  : toInt(match[MINUTE])      * sign,=0A=
                  s  : toInt(match[SECOND])      * sign,=0A=
                  ms : toInt(match[MILLISECOND]) * sign=0A=
              };=0A=
          } else if (!!(match =3D create__isoRegex.exec(input))) {=0A=
              sign =3D (match[1] =3D=3D=3D '-') ? -1 : 1;=0A=
              duration =3D {=0A=
                  y : parseIso(match[2], sign),=0A=
                  M : parseIso(match[3], sign),=0A=
                  d : parseIso(match[4], sign),=0A=
                  h : parseIso(match[5], sign),=0A=
                  m : parseIso(match[6], sign),=0A=
                  s : parseIso(match[7], sign),=0A=
                  w : parseIso(match[8], sign)=0A=
              };=0A=
          } else if (duration =3D=3D null) {// checks for null or =
undefined=0A=
              duration =3D {};=0A=
          } else if (typeof duration =3D=3D=3D 'object' && ('from' in =
duration || 'to' in duration)) {=0A=
              diffRes =3D =
momentsDifference(local__createLocal(duration.from), =
local__createLocal(duration.to));=0A=
=0A=
              duration =3D {};=0A=
              duration.ms =3D diffRes.milliseconds;=0A=
              duration.M =3D diffRes.months;=0A=
          }=0A=
=0A=
          ret =3D new Duration(duration);=0A=
=0A=
          if (isDuration(input) && hasOwnProp(input, '_locale')) {=0A=
              ret._locale =3D input._locale;=0A=
          }=0A=
=0A=
          return ret;=0A=
      }=0A=
=0A=
      create__createDuration.fn =3D Duration.prototype;=0A=
=0A=
      function parseIso (inp, sign) {=0A=
          // We'd normally use ~~inp for this, but unfortunately it also=0A=
          // converts floats to ints.=0A=
          // inp may be undefined, so careful calling replace on it.=0A=
          var res =3D inp && parseFloat(inp.replace(',', '.'));=0A=
          // apply sign while we're at it=0A=
          return (isNaN(res) ? 0 : res) * sign;=0A=
      }=0A=
=0A=
      function positiveMomentsDifference(base, other) {=0A=
          var res =3D {milliseconds: 0, months: 0};=0A=
=0A=
          res.months =3D other.month() - base.month() +=0A=
              (other.year() - base.year()) * 12;=0A=
          if (base.clone().add(res.months, 'M').isAfter(other)) {=0A=
              --res.months;=0A=
          }=0A=
=0A=
          res.milliseconds =3D +other - +(base.clone().add(res.months, =
'M'));=0A=
=0A=
          return res;=0A=
      }=0A=
=0A=
      function momentsDifference(base, other) {=0A=
          var res;=0A=
          other =3D cloneWithOffset(other, base);=0A=
          if (base.isBefore(other)) {=0A=
              res =3D positiveMomentsDifference(base, other);=0A=
          } else {=0A=
              res =3D positiveMomentsDifference(other, base);=0A=
              res.milliseconds =3D -res.milliseconds;=0A=
              res.months =3D -res.months;=0A=
          }=0A=
=0A=
          return res;=0A=
      }=0A=
=0A=
      function createAdder(direction, name) {=0A=
          return function (val, period) {=0A=
              var dur, tmp;=0A=
              //invert the arguments, but complain about it=0A=
              if (period !=3D=3D null && !isNaN(+period)) {=0A=
                  deprecateSimple(name, 'moment().' + name  + '(period, =
number) is deprecated. Please use moment().' + name + '(number, =
period).');=0A=
                  tmp =3D val; val =3D period; period =3D tmp;=0A=
              }=0A=
=0A=
              val =3D typeof val =3D=3D=3D 'string' ? +val : val;=0A=
              dur =3D create__createDuration(val, period);=0A=
              add_subtract__addSubtract(this, dur, direction);=0A=
              return this;=0A=
          };=0A=
      }=0A=
=0A=
      function add_subtract__addSubtract (mom, duration, isAdding, =
updateOffset) {=0A=
          var milliseconds =3D duration._milliseconds,=0A=
              days =3D duration._days,=0A=
              months =3D duration._months;=0A=
          updateOffset =3D updateOffset =3D=3D null ? true : =
updateOffset;=0A=
=0A=
          if (milliseconds) {=0A=
              mom._d.setTime(+mom._d + milliseconds * isAdding);=0A=
          }=0A=
          if (days) {=0A=
              get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days =
* isAdding);=0A=
          }=0A=
          if (months) {=0A=
              setMonth(mom, get_set__get(mom, 'Month') + months * =
isAdding);=0A=
          }=0A=
          if (updateOffset) {=0A=
              utils_hooks__hooks.updateOffset(mom, days || months);=0A=
          }=0A=
      }=0A=
=0A=
      var add_subtract__add      =3D createAdder(1, 'add');=0A=
      var add_subtract__subtract =3D createAdder(-1, 'subtract');=0A=
=0A=
      function moment_calendar__calendar (time, formats) {=0A=
          // We want to compare the start of today, vs this.=0A=
          // Getting start-of-today depends on whether we're =
local/utc/offset or not.=0A=
          var now =3D time || local__createLocal(),=0A=
              sod =3D cloneWithOffset(now, this).startOf('day'),=0A=
              diff =3D this.diff(sod, 'days', true),=0A=
              format =3D diff < -6 ? 'sameElse' :=0A=
                  diff < -1 ? 'lastWeek' :=0A=
                  diff < 0 ? 'lastDay' :=0A=
                  diff < 1 ? 'sameDay' :=0A=
                  diff < 2 ? 'nextDay' :=0A=
                  diff < 7 ? 'nextWeek' : 'sameElse';=0A=
          return this.format(formats && formats[format] || =
this.localeData().calendar(format, this, local__createLocal(now)));=0A=
      }=0A=
=0A=
      function clone () {=0A=
          return new Moment(this);=0A=
      }=0A=
=0A=
      function isAfter (input, units) {=0A=
          var inputMs;=0A=
          units =3D normalizeUnits(typeof units !=3D=3D 'undefined' ? =
units : 'millisecond');=0A=
          if (units =3D=3D=3D 'millisecond') {=0A=
              input =3D isMoment(input) ? input : =
local__createLocal(input);=0A=
              return +this > +input;=0A=
          } else {=0A=
              inputMs =3D isMoment(input) ? +input : =
+local__createLocal(input);=0A=
              return inputMs < +this.clone().startOf(units);=0A=
          }=0A=
      }=0A=
=0A=
      function isBefore (input, units) {=0A=
          var inputMs;=0A=
          units =3D normalizeUnits(typeof units !=3D=3D 'undefined' ? =
units : 'millisecond');=0A=
          if (units =3D=3D=3D 'millisecond') {=0A=
              input =3D isMoment(input) ? input : =
local__createLocal(input);=0A=
              return +this < +input;=0A=
          } else {=0A=
              inputMs =3D isMoment(input) ? +input : =
+local__createLocal(input);=0A=
              return +this.clone().endOf(units) < inputMs;=0A=
          }=0A=
      }=0A=
=0A=
      function isBetween (from, to, units) {=0A=
          return this.isAfter(from, units) && this.isBefore(to, units);=0A=
      }=0A=
=0A=
      function isSame (input, units) {=0A=
          var inputMs;=0A=
          units =3D normalizeUnits(units || 'millisecond');=0A=
          if (units =3D=3D=3D 'millisecond') {=0A=
              input =3D isMoment(input) ? input : =
local__createLocal(input);=0A=
              return +this =3D=3D=3D +input;=0A=
          } else {=0A=
              inputMs =3D +local__createLocal(input);=0A=
              return +(this.clone().startOf(units)) <=3D inputMs && =
inputMs <=3D +(this.clone().endOf(units));=0A=
          }=0A=
      }=0A=
=0A=
      function diff (input, units, asFloat) {=0A=
          var that =3D cloneWithOffset(input, this),=0A=
              zoneDelta =3D (that.utcOffset() - this.utcOffset()) * 6e4,=0A=
              delta, output;=0A=
=0A=
          units =3D normalizeUnits(units);=0A=
=0A=
          if (units =3D=3D=3D 'year' || units =3D=3D=3D 'month' || units =
=3D=3D=3D 'quarter') {=0A=
              output =3D monthDiff(this, that);=0A=
              if (units =3D=3D=3D 'quarter') {=0A=
                  output =3D output / 3;=0A=
              } else if (units =3D=3D=3D 'year') {=0A=
                  output =3D output / 12;=0A=
              }=0A=
          } else {=0A=
              delta =3D this - that;=0A=
              output =3D units =3D=3D=3D 'second' ? delta / 1e3 : // 1000=0A=
                  units =3D=3D=3D 'minute' ? delta / 6e4 : // 1000 * 60=0A=
                  units =3D=3D=3D 'hour' ? delta / 36e5 : // 1000 * 60 * =
60=0A=
                  units =3D=3D=3D 'day' ? (delta - zoneDelta) / 864e5 : =
// 1000 * 60 * 60 * 24, negate dst=0A=
                  units =3D=3D=3D 'week' ? (delta - zoneDelta) / 6048e5 =
: // 1000 * 60 * 60 * 24 * 7, negate dst=0A=
                  delta;=0A=
          }=0A=
          return asFloat ? output : absFloor(output);=0A=
      }=0A=
=0A=
      function monthDiff (a, b) {=0A=
          // difference in months=0A=
          var wholeMonthDiff =3D ((b.year() - a.year()) * 12) + =
(b.month() - a.month()),=0A=
              // b is in (anchor - 1 month, anchor + 1 month)=0A=
              anchor =3D a.clone().add(wholeMonthDiff, 'months'),=0A=
              anchor2, adjust;=0A=
=0A=
          if (b - anchor < 0) {=0A=
              anchor2 =3D a.clone().add(wholeMonthDiff - 1, 'months');=0A=
              // linear across the month=0A=
              adjust =3D (b - anchor) / (anchor - anchor2);=0A=
          } else {=0A=
              anchor2 =3D a.clone().add(wholeMonthDiff + 1, 'months');=0A=
              // linear across the month=0A=
              adjust =3D (b - anchor) / (anchor2 - anchor);=0A=
          }=0A=
=0A=
          return -(wholeMonthDiff + adjust);=0A=
      }=0A=
=0A=
      utils_hooks__hooks.defaultFormat =3D 'YYYY-MM-DDTHH:mm:ssZ';=0A=
=0A=
      function toString () {=0A=
          return this.clone().locale('en').format('ddd MMM DD YYYY =
HH:mm:ss [GMT]ZZ');=0A=
      }=0A=
=0A=
      function moment_format__toISOString () {=0A=
          var m =3D this.clone().utc();=0A=
          if (0 < m.year() && m.year() <=3D 9999) {=0A=
              if ('function' =3D=3D=3D typeof =
Date.prototype.toISOString) {=0A=
                  // native implementation is ~50x faster, use it when =
we can=0A=
                  return this.toDate().toISOString();=0A=
              } else {=0A=
                  return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');=0A=
              }=0A=
          } else {=0A=
              return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');=0A=
          }=0A=
      }=0A=
=0A=
      function format (inputString) {=0A=
          var output =3D formatMoment(this, inputString || =
utils_hooks__hooks.defaultFormat);=0A=
          return this.localeData().postformat(output);=0A=
      }=0A=
=0A=
      function from (time, withoutSuffix) {=0A=
          if (!this.isValid()) {=0A=
              return this.localeData().invalidDate();=0A=
          }=0A=
          return create__createDuration({to: this, from: =
time}).locale(this.locale()).humanize(!withoutSuffix);=0A=
      }=0A=
=0A=
      function fromNow (withoutSuffix) {=0A=
          return this.from(local__createLocal(), withoutSuffix);=0A=
      }=0A=
=0A=
      function to (time, withoutSuffix) {=0A=
          if (!this.isValid()) {=0A=
              return this.localeData().invalidDate();=0A=
          }=0A=
          return create__createDuration({from: this, to: =
time}).locale(this.locale()).humanize(!withoutSuffix);=0A=
      }=0A=
=0A=
      function toNow (withoutSuffix) {=0A=
          return this.to(local__createLocal(), withoutSuffix);=0A=
      }=0A=
=0A=
      function locale (key) {=0A=
          var newLocaleData;=0A=
=0A=
          if (key =3D=3D=3D undefined) {=0A=
              return this._locale._abbr;=0A=
          } else {=0A=
              newLocaleData =3D locale_locales__getLocale(key);=0A=
              if (newLocaleData !=3D null) {=0A=
                  this._locale =3D newLocaleData;=0A=
              }=0A=
              return this;=0A=
          }=0A=
      }=0A=
=0A=
      var lang =3D deprecate(=0A=
          'moment().lang() is deprecated. Instead, use =
moment().localeData() to get the language configuration. Use =
moment().locale() to change languages.',=0A=
          function (key) {=0A=
              if (key =3D=3D=3D undefined) {=0A=
                  return this.localeData();=0A=
              } else {=0A=
                  return this.locale(key);=0A=
              }=0A=
          }=0A=
      );=0A=
=0A=
      function localeData () {=0A=
          return this._locale;=0A=
      }=0A=
=0A=
      function startOf (units) {=0A=
          units =3D normalizeUnits(units);=0A=
          // the following switch intentionally omits break keywords=0A=
          // to utilize falling through the cases.=0A=
          switch (units) {=0A=
          case 'year':=0A=
              this.month(0);=0A=
              /* falls through */=0A=
          case 'quarter':=0A=
          case 'month':=0A=
              this.date(1);=0A=
              /* falls through */=0A=
          case 'week':=0A=
          case 'isoWeek':=0A=
          case 'day':=0A=
              this.hours(0);=0A=
              /* falls through */=0A=
          case 'hour':=0A=
              this.minutes(0);=0A=
              /* falls through */=0A=
          case 'minute':=0A=
              this.seconds(0);=0A=
              /* falls through */=0A=
          case 'second':=0A=
              this.milliseconds(0);=0A=
          }=0A=
=0A=
          // weeks are a special case=0A=
          if (units =3D=3D=3D 'week') {=0A=
              this.weekday(0);=0A=
          }=0A=
          if (units =3D=3D=3D 'isoWeek') {=0A=
              this.isoWeekday(1);=0A=
          }=0A=
=0A=
          // quarters are also special=0A=
          if (units =3D=3D=3D 'quarter') {=0A=
              this.month(Math.floor(this.month() / 3) * 3);=0A=
          }=0A=
=0A=
          return this;=0A=
      }=0A=
=0A=
      function endOf (units) {=0A=
          units =3D normalizeUnits(units);=0A=
          if (units =3D=3D=3D undefined || units =3D=3D=3D =
'millisecond') {=0A=
              return this;=0A=
          }=0A=
          return this.startOf(units).add(1, (units =3D=3D=3D 'isoWeek' ? =
'week' : units)).subtract(1, 'ms');=0A=
      }=0A=
=0A=
      function to_type__valueOf () {=0A=
          return +this._d - ((this._offset || 0) * 60000);=0A=
      }=0A=
=0A=
      function unix () {=0A=
          return Math.floor(+this / 1000);=0A=
      }=0A=
=0A=
      function toDate () {=0A=
          return this._offset ? new Date(+this) : this._d;=0A=
      }=0A=
=0A=
      function toArray () {=0A=
          var m =3D this;=0A=
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), =
m.second(), m.millisecond()];=0A=
      }=0A=
=0A=
      function toObject () {=0A=
          var m =3D this;=0A=
          return {=0A=
              years: m.year(),=0A=
              months: m.month(),=0A=
              date: m.date(),=0A=
              hours: m.hours(),=0A=
              minutes: m.minutes(),=0A=
              seconds: m.seconds(),=0A=
              milliseconds: m.milliseconds()=0A=
          };=0A=
      }=0A=
=0A=
      function moment_valid__isValid () {=0A=
          return valid__isValid(this);=0A=
      }=0A=
=0A=
      function parsingFlags () {=0A=
          return extend({}, getParsingFlags(this));=0A=
      }=0A=
=0A=
      function invalidAt () {=0A=
          return getParsingFlags(this).overflow;=0A=
      }=0A=
=0A=
      addFormatToken(0, ['gg', 2], 0, function () {=0A=
          return this.weekYear() % 100;=0A=
      });=0A=
=0A=
      addFormatToken(0, ['GG', 2], 0, function () {=0A=
          return this.isoWeekYear() % 100;=0A=
      });=0A=
=0A=
      function addWeekYearFormatToken (token, getter) {=0A=
          addFormatToken(0, [token, token.length], 0, getter);=0A=
      }=0A=
=0A=
      addWeekYearFormatToken('gggg',     'weekYear');=0A=
      addWeekYearFormatToken('ggggg',    'weekYear');=0A=
      addWeekYearFormatToken('GGGG',  'isoWeekYear');=0A=
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('weekYear', 'gg');=0A=
      addUnitAlias('isoWeekYear', 'GG');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('G',      matchSigned);=0A=
      addRegexToken('g',      matchSigned);=0A=
      addRegexToken('GG',     match1to2, match2);=0A=
      addRegexToken('gg',     match1to2, match2);=0A=
      addRegexToken('GGGG',   match1to4, match4);=0A=
      addRegexToken('gggg',   match1to4, match4);=0A=
      addRegexToken('GGGGG',  match1to6, match6);=0A=
      addRegexToken('ggggg',  match1to6, match6);=0A=
=0A=
      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function =
(input, week, config, token) {=0A=
          week[token.substr(0, 2)] =3D toInt(input);=0A=
      });=0A=
=0A=
      addWeekParseToken(['gg', 'GG'], function (input, week, config, =
token) {=0A=
          week[token] =3D utils_hooks__hooks.parseTwoDigitYear(input);=0A=
      });=0A=
=0A=
      // HELPERS=0A=
=0A=
      function weeksInYear(year, dow, doy) {=0A=
          return weekOfYear(local__createLocal([year, 11, 31 + dow - =
doy]), dow, doy).week;=0A=
      }=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function getSetWeekYear (input) {=0A=
          var year =3D weekOfYear(this, this.localeData()._week.dow, =
this.localeData()._week.doy).year;=0A=
          return input =3D=3D null ? year : this.add((input - year), =
'y');=0A=
      }=0A=
=0A=
      function getSetISOWeekYear (input) {=0A=
          var year =3D weekOfYear(this, 1, 4).year;=0A=
          return input =3D=3D null ? year : this.add((input - year), =
'y');=0A=
      }=0A=
=0A=
      function getISOWeeksInYear () {=0A=
          return weeksInYear(this.year(), 1, 4);=0A=
      }=0A=
=0A=
      function getWeeksInYear () {=0A=
          var weekInfo =3D this.localeData()._week;=0A=
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);=0A=
      }=0A=
=0A=
      addFormatToken('Q', 0, 0, 'quarter');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('quarter', 'Q');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('Q', match1);=0A=
      addParseToken('Q', function (input, array) {=0A=
          array[MONTH] =3D (toInt(input) - 1) * 3;=0A=
      });=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function getSetQuarter (input) {=0A=
          return input =3D=3D null ? Math.ceil((this.month() + 1) / 3) : =
this.month((input - 1) * 3 + this.month() % 3);=0A=
      }=0A=
=0A=
      addFormatToken('D', ['DD', 2], 'Do', 'date');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('date', 'D');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('D',  match1to2);=0A=
      addRegexToken('DD', match1to2, match2);=0A=
      addRegexToken('Do', function (isStrict, locale) {=0A=
          return isStrict ? locale._ordinalParse : =
locale._ordinalParseLenient;=0A=
      });=0A=
=0A=
      addParseToken(['D', 'DD'], DATE);=0A=
      addParseToken('Do', function (input, array) {=0A=
          array[DATE] =3D toInt(input.match(match1to2)[0], 10);=0A=
      });=0A=
=0A=
      // MOMENTS=0A=
=0A=
      var getSetDayOfMonth =3D makeGetSet('Date', true);=0A=
=0A=
      addFormatToken('d', 0, 'do', 'day');=0A=
=0A=
      addFormatToken('dd', 0, 0, function (format) {=0A=
          return this.localeData().weekdaysMin(this, format);=0A=
      });=0A=
=0A=
      addFormatToken('ddd', 0, 0, function (format) {=0A=
          return this.localeData().weekdaysShort(this, format);=0A=
      });=0A=
=0A=
      addFormatToken('dddd', 0, 0, function (format) {=0A=
          return this.localeData().weekdays(this, format);=0A=
      });=0A=
=0A=
      addFormatToken('e', 0, 0, 'weekday');=0A=
      addFormatToken('E', 0, 0, 'isoWeekday');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('day', 'd');=0A=
      addUnitAlias('weekday', 'e');=0A=
      addUnitAlias('isoWeekday', 'E');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('d',    match1to2);=0A=
      addRegexToken('e',    match1to2);=0A=
      addRegexToken('E',    match1to2);=0A=
      addRegexToken('dd',   matchWord);=0A=
      addRegexToken('ddd',  matchWord);=0A=
      addRegexToken('dddd', matchWord);=0A=
=0A=
      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, =
config) {=0A=
          var weekday =3D config._locale.weekdaysParse(input);=0A=
          // if we didn't get a weekday name, mark the date as invalid=0A=
          if (weekday !=3D null) {=0A=
              week.d =3D weekday;=0A=
          } else {=0A=
              getParsingFlags(config).invalidWeekday =3D input;=0A=
          }=0A=
      });=0A=
=0A=
      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, =
token) {=0A=
          week[token] =3D toInt(input);=0A=
      });=0A=
=0A=
      // HELPERS=0A=
=0A=
      function parseWeekday(input, locale) {=0A=
          if (typeof input !=3D=3D 'string') {=0A=
              return input;=0A=
          }=0A=
=0A=
          if (!isNaN(input)) {=0A=
              return parseInt(input, 10);=0A=
          }=0A=
=0A=
          input =3D locale.weekdaysParse(input);=0A=
          if (typeof input =3D=3D=3D 'number') {=0A=
              return input;=0A=
          }=0A=
=0A=
          return null;=0A=
      }=0A=
=0A=
      // LOCALES=0A=
=0A=
      var defaultLocaleWeekdays =3D =
'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');=0A=
      function localeWeekdays (m) {=0A=
          return this._weekdays[m.day()];=0A=
      }=0A=
=0A=
      var defaultLocaleWeekdaysShort =3D =
'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');=0A=
      function localeWeekdaysShort (m) {=0A=
          return this._weekdaysShort[m.day()];=0A=
      }=0A=
=0A=
      var defaultLocaleWeekdaysMin =3D 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');=0A=
      function localeWeekdaysMin (m) {=0A=
          return this._weekdaysMin[m.day()];=0A=
      }=0A=
=0A=
      function localeWeekdaysParse (weekdayName) {=0A=
          var i, mom, regex;=0A=
=0A=
          this._weekdaysParse =3D this._weekdaysParse || [];=0A=
=0A=
          for (i =3D 0; i < 7; i++) {=0A=
              // make the regex if we don't have it already=0A=
              if (!this._weekdaysParse[i]) {=0A=
                  mom =3D local__createLocal([2000, 1]).day(i);=0A=
                  regex =3D '^' + this.weekdays(mom, '') + '|^' + =
this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');=0A=
                  this._weekdaysParse[i] =3D new =
RegExp(regex.replace('.', ''), 'i');=0A=
              }=0A=
              // test the regex=0A=
              if (this._weekdaysParse[i].test(weekdayName)) {=0A=
                  return i;=0A=
              }=0A=
          }=0A=
      }=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function getSetDayOfWeek (input) {=0A=
          var day =3D this._isUTC ? this._d.getUTCDay() : =
this._d.getDay();=0A=
          if (input !=3D null) {=0A=
              input =3D parseWeekday(input, this.localeData());=0A=
              return this.add(input - day, 'd');=0A=
          } else {=0A=
              return day;=0A=
          }=0A=
      }=0A=
=0A=
      function getSetLocaleDayOfWeek (input) {=0A=
          var weekday =3D (this.day() + 7 - this.localeData()._week.dow) =
% 7;=0A=
          return input =3D=3D null ? weekday : this.add(input - weekday, =
'd');=0A=
      }=0A=
=0A=
      function getSetISODayOfWeek (input) {=0A=
          // behaves the same as moment#day except=0A=
          // as a getter, returns 7 instead of 0 (1-7 range instead of =
0-6)=0A=
          // as a setter, sunday should belong to the previous week.=0A=
          return input =3D=3D null ? this.day() || 7 : =
this.day(this.day() % 7 ? input : input - 7);=0A=
      }=0A=
=0A=
      addFormatToken('H', ['HH', 2], 0, 'hour');=0A=
      addFormatToken('h', ['hh', 2], 0, function () {=0A=
          return this.hours() % 12 || 12;=0A=
      });=0A=
=0A=
      function meridiem (token, lowercase) {=0A=
          addFormatToken(token, 0, 0, function () {=0A=
              return this.localeData().meridiem(this.hours(), =
this.minutes(), lowercase);=0A=
          });=0A=
      }=0A=
=0A=
      meridiem('a', true);=0A=
      meridiem('A', false);=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('hour', 'h');=0A=
=0A=
      // PARSING=0A=
=0A=
      function matchMeridiem (isStrict, locale) {=0A=
          return locale._meridiemParse;=0A=
      }=0A=
=0A=
      addRegexToken('a',  matchMeridiem);=0A=
      addRegexToken('A',  matchMeridiem);=0A=
      addRegexToken('H',  match1to2);=0A=
      addRegexToken('h',  match1to2);=0A=
      addRegexToken('HH', match1to2, match2);=0A=
      addRegexToken('hh', match1to2, match2);=0A=
=0A=
      addParseToken(['H', 'HH'], HOUR);=0A=
      addParseToken(['a', 'A'], function (input, array, config) {=0A=
          config._isPm =3D config._locale.isPM(input);=0A=
          config._meridiem =3D input;=0A=
      });=0A=
      addParseToken(['h', 'hh'], function (input, array, config) {=0A=
          array[HOUR] =3D toInt(input);=0A=
          getParsingFlags(config).bigHour =3D true;=0A=
      });=0A=
=0A=
      // LOCALES=0A=
=0A=
      function localeIsPM (input) {=0A=
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing =
strings like arrays=0A=
          // Using charAt should be more compatible.=0A=
          return ((input + '').toLowerCase().charAt(0) =3D=3D=3D 'p');=0A=
      }=0A=
=0A=
      var defaultLocaleMeridiemParse =3D /[ap]\.?m?\.?/i;=0A=
      function localeMeridiem (hours, minutes, isLower) {=0A=
          if (hours > 11) {=0A=
              return isLower ? 'pm' : 'PM';=0A=
          } else {=0A=
              return isLower ? 'am' : 'AM';=0A=
          }=0A=
      }=0A=
=0A=
=0A=
      // MOMENTS=0A=
=0A=
      // Setting the hour should keep the time, because the user =
explicitly=0A=
      // specified which hour he wants. So trying to maintain the same =
hour (in=0A=
      // a new timezone) makes sense. Adding/subtracting hours does not =
follow=0A=
      // this rule.=0A=
      var getSetHour =3D makeGetSet('Hours', true);=0A=
=0A=
      addFormatToken('m', ['mm', 2], 0, 'minute');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('minute', 'm');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('m',  match1to2);=0A=
      addRegexToken('mm', match1to2, match2);=0A=
      addParseToken(['m', 'mm'], MINUTE);=0A=
=0A=
      // MOMENTS=0A=
=0A=
      var getSetMinute =3D makeGetSet('Minutes', false);=0A=
=0A=
      addFormatToken('s', ['ss', 2], 0, 'second');=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('second', 's');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('s',  match1to2);=0A=
      addRegexToken('ss', match1to2, match2);=0A=
      addParseToken(['s', 'ss'], SECOND);=0A=
=0A=
      // MOMENTS=0A=
=0A=
      var getSetSecond =3D makeGetSet('Seconds', false);=0A=
=0A=
      addFormatToken('S', 0, 0, function () {=0A=
          return ~~(this.millisecond() / 100);=0A=
      });=0A=
=0A=
      addFormatToken(0, ['SS', 2], 0, function () {=0A=
          return ~~(this.millisecond() / 10);=0A=
      });=0A=
=0A=
      addFormatToken(0, ['SSS', 3], 0, 'millisecond');=0A=
      addFormatToken(0, ['SSSS', 4], 0, function () {=0A=
          return this.millisecond() * 10;=0A=
      });=0A=
      addFormatToken(0, ['SSSSS', 5], 0, function () {=0A=
          return this.millisecond() * 100;=0A=
      });=0A=
      addFormatToken(0, ['SSSSSS', 6], 0, function () {=0A=
          return this.millisecond() * 1000;=0A=
      });=0A=
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {=0A=
          return this.millisecond() * 10000;=0A=
      });=0A=
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {=0A=
          return this.millisecond() * 100000;=0A=
      });=0A=
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {=0A=
          return this.millisecond() * 1000000;=0A=
      });=0A=
=0A=
=0A=
      // ALIASES=0A=
=0A=
      addUnitAlias('millisecond', 'ms');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('S',    match1to3, match1);=0A=
      addRegexToken('SS',   match1to3, match2);=0A=
      addRegexToken('SSS',  match1to3, match3);=0A=
=0A=
      var token;=0A=
      for (token =3D 'SSSS'; token.length <=3D 9; token +=3D 'S') {=0A=
          addRegexToken(token, matchUnsigned);=0A=
      }=0A=
=0A=
      function parseMs(input, array) {=0A=
          array[MILLISECOND] =3D toInt(('0.' + input) * 1000);=0A=
      }=0A=
=0A=
      for (token =3D 'S'; token.length <=3D 9; token +=3D 'S') {=0A=
          addParseToken(token, parseMs);=0A=
      }=0A=
      // MOMENTS=0A=
=0A=
      var getSetMillisecond =3D makeGetSet('Milliseconds', false);=0A=
=0A=
      addFormatToken('z',  0, 0, 'zoneAbbr');=0A=
      addFormatToken('zz', 0, 0, 'zoneName');=0A=
=0A=
      // MOMENTS=0A=
=0A=
      function getZoneAbbr () {=0A=
          return this._isUTC ? 'UTC' : '';=0A=
      }=0A=
=0A=
      function getZoneName () {=0A=
          return this._isUTC ? 'Coordinated Universal Time' : '';=0A=
      }=0A=
=0A=
      var momentPrototype__proto =3D Moment.prototype;=0A=
=0A=
      momentPrototype__proto.add          =3D add_subtract__add;=0A=
      momentPrototype__proto.calendar     =3D moment_calendar__calendar;=0A=
      momentPrototype__proto.clone        =3D clone;=0A=
      momentPrototype__proto.diff         =3D diff;=0A=
      momentPrototype__proto.endOf        =3D endOf;=0A=
      momentPrototype__proto.format       =3D format;=0A=
      momentPrototype__proto.from         =3D from;=0A=
      momentPrototype__proto.fromNow      =3D fromNow;=0A=
      momentPrototype__proto.to           =3D to;=0A=
      momentPrototype__proto.toNow        =3D toNow;=0A=
      momentPrototype__proto.get          =3D getSet;=0A=
      momentPrototype__proto.invalidAt    =3D invalidAt;=0A=
      momentPrototype__proto.isAfter      =3D isAfter;=0A=
      momentPrototype__proto.isBefore     =3D isBefore;=0A=
      momentPrototype__proto.isBetween    =3D isBetween;=0A=
      momentPrototype__proto.isSame       =3D isSame;=0A=
      momentPrototype__proto.isValid      =3D moment_valid__isValid;=0A=
      momentPrototype__proto.lang         =3D lang;=0A=
      momentPrototype__proto.locale       =3D locale;=0A=
      momentPrototype__proto.localeData   =3D localeData;=0A=
      momentPrototype__proto.max          =3D prototypeMax;=0A=
      momentPrototype__proto.min          =3D prototypeMin;=0A=
      momentPrototype__proto.parsingFlags =3D parsingFlags;=0A=
      momentPrototype__proto.set          =3D getSet;=0A=
      momentPrototype__proto.startOf      =3D startOf;=0A=
      momentPrototype__proto.subtract     =3D add_subtract__subtract;=0A=
      momentPrototype__proto.toArray      =3D toArray;=0A=
      momentPrototype__proto.toObject     =3D toObject;=0A=
      momentPrototype__proto.toDate       =3D toDate;=0A=
      momentPrototype__proto.toISOString  =3D moment_format__toISOString;=0A=
      momentPrototype__proto.toJSON       =3D moment_format__toISOString;=0A=
      momentPrototype__proto.toString     =3D toString;=0A=
      momentPrototype__proto.unix         =3D unix;=0A=
      momentPrototype__proto.valueOf      =3D to_type__valueOf;=0A=
=0A=
      // Year=0A=
      momentPrototype__proto.year       =3D getSetYear;=0A=
      momentPrototype__proto.isLeapYear =3D getIsLeapYear;=0A=
=0A=
      // Week Year=0A=
      momentPrototype__proto.weekYear    =3D getSetWeekYear;=0A=
      momentPrototype__proto.isoWeekYear =3D getSetISOWeekYear;=0A=
=0A=
      // Quarter=0A=
      momentPrototype__proto.quarter =3D momentPrototype__proto.quarters =
=3D getSetQuarter;=0A=
=0A=
      // Month=0A=
      momentPrototype__proto.month       =3D getSetMonth;=0A=
      momentPrototype__proto.daysInMonth =3D getDaysInMonth;=0A=
=0A=
      // Week=0A=
      momentPrototype__proto.week           =3D =
momentPrototype__proto.weeks        =3D getSetWeek;=0A=
      momentPrototype__proto.isoWeek        =3D =
momentPrototype__proto.isoWeeks     =3D getSetISOWeek;=0A=
      momentPrototype__proto.weeksInYear    =3D getWeeksInYear;=0A=
      momentPrototype__proto.isoWeeksInYear =3D getISOWeeksInYear;=0A=
=0A=
      // Day=0A=
      momentPrototype__proto.date       =3D getSetDayOfMonth;=0A=
      momentPrototype__proto.day        =3D momentPrototype__proto.days  =
           =3D getSetDayOfWeek;=0A=
      momentPrototype__proto.weekday    =3D getSetLocaleDayOfWeek;=0A=
      momentPrototype__proto.isoWeekday =3D getSetISODayOfWeek;=0A=
      momentPrototype__proto.dayOfYear  =3D getSetDayOfYear;=0A=
=0A=
      // Hour=0A=
      momentPrototype__proto.hour =3D momentPrototype__proto.hours =3D =
getSetHour;=0A=
=0A=
      // Minute=0A=
      momentPrototype__proto.minute =3D momentPrototype__proto.minutes =
=3D getSetMinute;=0A=
=0A=
      // Second=0A=
      momentPrototype__proto.second =3D momentPrototype__proto.seconds =
=3D getSetSecond;=0A=
=0A=
      // Millisecond=0A=
      momentPrototype__proto.millisecond =3D =
momentPrototype__proto.milliseconds =3D getSetMillisecond;=0A=
=0A=
      // Offset=0A=
      momentPrototype__proto.utcOffset            =3D getSetOffset;=0A=
      momentPrototype__proto.utc                  =3D setOffsetToUTC;=0A=
      momentPrototype__proto.local                =3D setOffsetToLocal;=0A=
      momentPrototype__proto.parseZone            =3D =
setOffsetToParsedOffset;=0A=
      momentPrototype__proto.hasAlignedHourOffset =3D =
hasAlignedHourOffset;=0A=
      momentPrototype__proto.isDST                =3D =
isDaylightSavingTime;=0A=
      momentPrototype__proto.isDSTShifted         =3D =
isDaylightSavingTimeShifted;=0A=
      momentPrototype__proto.isLocal              =3D isLocal;=0A=
      momentPrototype__proto.isUtcOffset          =3D isUtcOffset;=0A=
      momentPrototype__proto.isUtc                =3D isUtc;=0A=
      momentPrototype__proto.isUTC                =3D isUtc;=0A=
=0A=
      // Timezone=0A=
      momentPrototype__proto.zoneAbbr =3D getZoneAbbr;=0A=
      momentPrototype__proto.zoneName =3D getZoneName;=0A=
=0A=
      // Deprecations=0A=
      momentPrototype__proto.dates  =3D deprecate('dates accessor is =
deprecated. Use date instead.', getSetDayOfMonth);=0A=
      momentPrototype__proto.months =3D deprecate('months accessor is =
deprecated. Use month instead', getSetMonth);=0A=
      momentPrototype__proto.years  =3D deprecate('years accessor is =
deprecated. Use year instead', getSetYear);=0A=
      momentPrototype__proto.zone   =3D deprecate('moment().zone is =
deprecated, use moment().utcOffset instead. =
https://github.com/moment/moment/issues/1779', getSetZone);=0A=
=0A=
      var momentPrototype =3D momentPrototype__proto;=0A=
=0A=
      function moment__createUnix (input) {=0A=
          return local__createLocal(input * 1000);=0A=
      }=0A=
=0A=
      function moment__createInZone () {=0A=
          return local__createLocal.apply(null, arguments).parseZone();=0A=
      }=0A=
=0A=
      var defaultCalendar =3D {=0A=
          sameDay : '[Today at] LT',=0A=
          nextDay : '[Tomorrow at] LT',=0A=
          nextWeek : 'dddd [at] LT',=0A=
          lastDay : '[Yesterday at] LT',=0A=
          lastWeek : '[Last] dddd [at] LT',=0A=
          sameElse : 'L'=0A=
      };=0A=
=0A=
      function locale_calendar__calendar (key, mom, now) {=0A=
          var output =3D this._calendar[key];=0A=
          return typeof output =3D=3D=3D 'function' ? output.call(mom, =
now) : output;=0A=
      }=0A=
=0A=
      var defaultLongDateFormat =3D {=0A=
          LTS  : 'h:mm:ss A',=0A=
          LT   : 'h:mm A',=0A=
          L    : 'MM/DD/YYYY',=0A=
          LL   : 'MMMM D, YYYY',=0A=
          LLL  : 'MMMM D, YYYY h:mm A',=0A=
          LLLL : 'dddd, MMMM D, YYYY h:mm A'=0A=
      };=0A=
=0A=
      function longDateFormat (key) {=0A=
          var format =3D this._longDateFormat[key],=0A=
              formatUpper =3D this._longDateFormat[key.toUpperCase()];=0A=
=0A=
          if (format || !formatUpper) {=0A=
              return format;=0A=
          }=0A=
=0A=
          this._longDateFormat[key] =3D =
formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {=0A=
              return val.slice(1);=0A=
          });=0A=
=0A=
          return this._longDateFormat[key];=0A=
      }=0A=
=0A=
      var defaultInvalidDate =3D 'Invalid date';=0A=
=0A=
      function invalidDate () {=0A=
          return this._invalidDate;=0A=
      }=0A=
=0A=
      var defaultOrdinal =3D '%d';=0A=
      var defaultOrdinalParse =3D /\d{1,2}/;=0A=
=0A=
      function ordinal (number) {=0A=
          return this._ordinal.replace('%d', number);=0A=
      }=0A=
=0A=
      function preParsePostFormat (string) {=0A=
          return string;=0A=
      }=0A=
=0A=
      var defaultRelativeTime =3D {=0A=
          future : 'in %s',=0A=
          past   : '%s ago',=0A=
          s  : 'a few seconds',=0A=
          m  : 'a minute',=0A=
          mm : '%d minutes',=0A=
          h  : 'an hour',=0A=
          hh : '%d hours',=0A=
          d  : 'a day',=0A=
          dd : '%d days',=0A=
          M  : 'a month',=0A=
          MM : '%d months',=0A=
          y  : 'a year',=0A=
          yy : '%d years'=0A=
      };=0A=
=0A=
      function relative__relativeTime (number, withoutSuffix, string, =
isFuture) {=0A=
          var output =3D this._relativeTime[string];=0A=
          return (typeof output =3D=3D=3D 'function') ?=0A=
              output(number, withoutSuffix, string, isFuture) :=0A=
              output.replace(/%d/i, number);=0A=
      }=0A=
=0A=
      function pastFuture (diff, output) {=0A=
          var format =3D this._relativeTime[diff > 0 ? 'future' : =
'past'];=0A=
          return typeof format =3D=3D=3D 'function' ? format(output) : =
format.replace(/%s/i, output);=0A=
      }=0A=
=0A=
      function locale_set__set (config) {=0A=
          var prop, i;=0A=
          for (i in config) {=0A=
              prop =3D config[i];=0A=
              if (typeof prop =3D=3D=3D 'function') {=0A=
                  this[i] =3D prop;=0A=
              } else {=0A=
                  this['_' + i] =3D prop;=0A=
              }=0A=
          }=0A=
          // Lenient ordinal parsing accepts just a number in addition to=0A=
          // number + (possibly) stuff coming from _ordinalParseLenient.=0A=
          this._ordinalParseLenient =3D new =
RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);=0A=
      }=0A=
=0A=
      var prototype__proto =3D Locale.prototype;=0A=
=0A=
      prototype__proto._calendar       =3D defaultCalendar;=0A=
      prototype__proto.calendar        =3D locale_calendar__calendar;=0A=
      prototype__proto._longDateFormat =3D defaultLongDateFormat;=0A=
      prototype__proto.longDateFormat  =3D longDateFormat;=0A=
      prototype__proto._invalidDate    =3D defaultInvalidDate;=0A=
      prototype__proto.invalidDate     =3D invalidDate;=0A=
      prototype__proto._ordinal        =3D defaultOrdinal;=0A=
      prototype__proto.ordinal         =3D ordinal;=0A=
      prototype__proto._ordinalParse   =3D defaultOrdinalParse;=0A=
      prototype__proto.preparse        =3D preParsePostFormat;=0A=
      prototype__proto.postformat      =3D preParsePostFormat;=0A=
      prototype__proto._relativeTime   =3D defaultRelativeTime;=0A=
      prototype__proto.relativeTime    =3D relative__relativeTime;=0A=
      prototype__proto.pastFuture      =3D pastFuture;=0A=
      prototype__proto.set             =3D locale_set__set;=0A=
=0A=
      // Month=0A=
      prototype__proto.months       =3D        localeMonths;=0A=
      prototype__proto._months      =3D defaultLocaleMonths;=0A=
      prototype__proto.monthsShort  =3D        localeMonthsShort;=0A=
      prototype__proto._monthsShort =3D defaultLocaleMonthsShort;=0A=
      prototype__proto.monthsParse  =3D        localeMonthsParse;=0A=
=0A=
      // Week=0A=
      prototype__proto.week =3D localeWeek;=0A=
      prototype__proto._week =3D defaultLocaleWeek;=0A=
      prototype__proto.firstDayOfYear =3D localeFirstDayOfYear;=0A=
      prototype__proto.firstDayOfWeek =3D localeFirstDayOfWeek;=0A=
=0A=
      // Day of Week=0A=
      prototype__proto.weekdays       =3D        localeWeekdays;=0A=
      prototype__proto._weekdays      =3D defaultLocaleWeekdays;=0A=
      prototype__proto.weekdaysMin    =3D        localeWeekdaysMin;=0A=
      prototype__proto._weekdaysMin   =3D defaultLocaleWeekdaysMin;=0A=
      prototype__proto.weekdaysShort  =3D        localeWeekdaysShort;=0A=
      prototype__proto._weekdaysShort =3D defaultLocaleWeekdaysShort;=0A=
      prototype__proto.weekdaysParse  =3D        localeWeekdaysParse;=0A=
=0A=
      // Hours=0A=
      prototype__proto.isPM =3D localeIsPM;=0A=
      prototype__proto._meridiemParse =3D defaultLocaleMeridiemParse;=0A=
      prototype__proto.meridiem =3D localeMeridiem;=0A=
=0A=
      function lists__get (format, index, field, setter) {=0A=
          var locale =3D locale_locales__getLocale();=0A=
          var utc =3D create_utc__createUTC().set(setter, index);=0A=
          return locale[field](utc, format);=0A=
      }=0A=
=0A=
      function list (format, index, field, count, setter) {=0A=
          if (typeof format =3D=3D=3D 'number') {=0A=
              index =3D format;=0A=
              format =3D undefined;=0A=
          }=0A=
=0A=
          format =3D format || '';=0A=
=0A=
          if (index !=3D null) {=0A=
              return lists__get(format, index, field, setter);=0A=
          }=0A=
=0A=
          var i;=0A=
          var out =3D [];=0A=
          for (i =3D 0; i < count; i++) {=0A=
              out[i] =3D lists__get(format, i, field, setter);=0A=
          }=0A=
          return out;=0A=
      }=0A=
=0A=
      function lists__listMonths (format, index) {=0A=
          return list(format, index, 'months', 12, 'month');=0A=
      }=0A=
=0A=
      function lists__listMonthsShort (format, index) {=0A=
          return list(format, index, 'monthsShort', 12, 'month');=0A=
      }=0A=
=0A=
      function lists__listWeekdays (format, index) {=0A=
          return list(format, index, 'weekdays', 7, 'day');=0A=
      }=0A=
=0A=
      function lists__listWeekdaysShort (format, index) {=0A=
          return list(format, index, 'weekdaysShort', 7, 'day');=0A=
      }=0A=
=0A=
      function lists__listWeekdaysMin (format, index) {=0A=
          return list(format, index, 'weekdaysMin', 7, 'day');=0A=
      }=0A=
=0A=
      locale_locales__getSetGlobalLocale('en', {=0A=
          ordinalParse: /\d{1,2}(th|st|nd|rd)/,=0A=
          ordinal : function (number) {=0A=
              var b =3D number % 10,=0A=
                  output =3D (toInt(number % 100 / 10) =3D=3D=3D 1) ? =
'th' :=0A=
                  (b =3D=3D=3D 1) ? 'st' :=0A=
                  (b =3D=3D=3D 2) ? 'nd' :=0A=
                  (b =3D=3D=3D 3) ? 'rd' : 'th';=0A=
              return number + output;=0A=
          }=0A=
      });=0A=
=0A=
      // Side effect imports=0A=
      utils_hooks__hooks.lang =3D deprecate('moment.lang is deprecated. =
Use moment.locale instead.', locale_locales__getSetGlobalLocale);=0A=
      utils_hooks__hooks.langData =3D deprecate('moment.langData is =
deprecated. Use moment.localeData instead.', locale_locales__getLocale);=0A=
=0A=
      var mathAbs =3D Math.abs;=0A=
=0A=
      function duration_abs__abs () {=0A=
          var data           =3D this._data;=0A=
=0A=
          this._milliseconds =3D mathAbs(this._milliseconds);=0A=
          this._days         =3D mathAbs(this._days);=0A=
          this._months       =3D mathAbs(this._months);=0A=
=0A=
          data.milliseconds  =3D mathAbs(data.milliseconds);=0A=
          data.seconds       =3D mathAbs(data.seconds);=0A=
          data.minutes       =3D mathAbs(data.minutes);=0A=
          data.hours         =3D mathAbs(data.hours);=0A=
          data.months        =3D mathAbs(data.months);=0A=
          data.years         =3D mathAbs(data.years);=0A=
=0A=
          return this;=0A=
      }=0A=
=0A=
      function duration_add_subtract__addSubtract (duration, input, =
value, direction) {=0A=
          var other =3D create__createDuration(input, value);=0A=
=0A=
          duration._milliseconds +=3D direction * other._milliseconds;=0A=
          duration._days         +=3D direction * other._days;=0A=
          duration._months       +=3D direction * other._months;=0A=
=0A=
          return duration._bubble();=0A=
      }=0A=
=0A=
      // supports only 2.0-style add(1, 's') or add(duration)=0A=
      function duration_add_subtract__add (input, value) {=0A=
          return duration_add_subtract__addSubtract(this, input, value, =
1);=0A=
      }=0A=
=0A=
      // supports only 2.0-style subtract(1, 's') or subtract(duration)=0A=
      function duration_add_subtract__subtract (input, value) {=0A=
          return duration_add_subtract__addSubtract(this, input, value, =
-1);=0A=
      }=0A=
=0A=
      function absCeil (number) {=0A=
          if (number < 0) {=0A=
              return Math.floor(number);=0A=
          } else {=0A=
              return Math.ceil(number);=0A=
          }=0A=
      }=0A=
=0A=
      function bubble () {=0A=
          var milliseconds =3D this._milliseconds;=0A=
          var days         =3D this._days;=0A=
          var months       =3D this._months;=0A=
          var data         =3D this._data;=0A=
          var seconds, minutes, hours, years, monthsFromDays;=0A=
=0A=
          // if we have a mix of positive and negative values, bubble =
down first=0A=
          // check: https://github.com/moment/moment/issues/2166=0A=
          if (!((milliseconds >=3D 0 && days >=3D 0 && months >=3D 0) ||=0A=
                  (milliseconds <=3D 0 && days <=3D 0 && months <=3D =
0))) {=0A=
              milliseconds +=3D absCeil(monthsToDays(months) + days) * =
864e5;=0A=
              days =3D 0;=0A=
              months =3D 0;=0A=
          }=0A=
=0A=
          // The following code bubbles up values, see the tests for=0A=
          // examples of what that means.=0A=
          data.milliseconds =3D milliseconds % 1000;=0A=
=0A=
          seconds           =3D absFloor(milliseconds / 1000);=0A=
          data.seconds      =3D seconds % 60;=0A=
=0A=
          minutes           =3D absFloor(seconds / 60);=0A=
          data.minutes      =3D minutes % 60;=0A=
=0A=
          hours             =3D absFloor(minutes / 60);=0A=
          data.hours        =3D hours % 24;=0A=
=0A=
          days +=3D absFloor(hours / 24);=0A=
=0A=
          // convert days to months=0A=
          monthsFromDays =3D absFloor(daysToMonths(days));=0A=
          months +=3D monthsFromDays;=0A=
          days -=3D absCeil(monthsToDays(monthsFromDays));=0A=
=0A=
          // 12 months -> 1 year=0A=
          years =3D absFloor(months / 12);=0A=
          months %=3D 12;=0A=
=0A=
          data.days   =3D days;=0A=
          data.months =3D months;=0A=
          data.years  =3D years;=0A=
=0A=
          return this;=0A=
      }=0A=
=0A=
      function daysToMonths (days) {=0A=
          // 400 years have 146097 days (taking into account leap year =
rules)=0A=
          // 400 years have 12 months =3D=3D=3D 4800=0A=
          return days * 4800 / 146097;=0A=
      }=0A=
=0A=
      function monthsToDays (months) {=0A=
          // the reverse of daysToMonths=0A=
          return months * 146097 / 4800;=0A=
      }=0A=
=0A=
      function as (units) {=0A=
          var days;=0A=
          var months;=0A=
          var milliseconds =3D this._milliseconds;=0A=
=0A=
          units =3D normalizeUnits(units);=0A=
=0A=
          if (units =3D=3D=3D 'month' || units =3D=3D=3D 'year') {=0A=
              days   =3D this._days   + milliseconds / 864e5;=0A=
              months =3D this._months + daysToMonths(days);=0A=
              return units =3D=3D=3D 'month' ? months : months / 12;=0A=
          } else {=0A=
              // handle milliseconds separately because of floating =
point math errors (issue #1867)=0A=
              days =3D this._days + =
Math.round(monthsToDays(this._months));=0A=
              switch (units) {=0A=
                  case 'week'   : return days / 7     + milliseconds / =
6048e5;=0A=
                  case 'day'    : return days         + milliseconds / =
864e5;=0A=
                  case 'hour'   : return days * 24    + milliseconds / =
36e5;=0A=
                  case 'minute' : return days * 1440  + milliseconds / =
6e4;=0A=
                  case 'second' : return days * 86400 + milliseconds / =
1000;=0A=
                  // Math.floor prevents floating point math errors here=0A=
                  case 'millisecond': return Math.floor(days * 864e5) + =
milliseconds;=0A=
                  default: throw new Error('Unknown unit ' + units);=0A=
              }=0A=
          }=0A=
      }=0A=
=0A=
      // TODO: Use this.as('ms')?=0A=
      function duration_as__valueOf () {=0A=
          return (=0A=
              this._milliseconds +=0A=
              this._days * 864e5 +=0A=
              (this._months % 12) * 2592e6 +=0A=
              toInt(this._months / 12) * 31536e6=0A=
          );=0A=
      }=0A=
=0A=
      function makeAs (alias) {=0A=
          return function () {=0A=
              return this.as(alias);=0A=
          };=0A=
      }=0A=
=0A=
      var asMilliseconds =3D makeAs('ms');=0A=
      var asSeconds      =3D makeAs('s');=0A=
      var asMinutes      =3D makeAs('m');=0A=
      var asHours        =3D makeAs('h');=0A=
      var asDays         =3D makeAs('d');=0A=
      var asWeeks        =3D makeAs('w');=0A=
      var asMonths       =3D makeAs('M');=0A=
      var asYears        =3D makeAs('y');=0A=
=0A=
      function duration_get__get (units) {=0A=
          units =3D normalizeUnits(units);=0A=
          return this[units + 's']();=0A=
      }=0A=
=0A=
      function makeGetter(name) {=0A=
          return function () {=0A=
              return this._data[name];=0A=
          };=0A=
      }=0A=
=0A=
      var milliseconds =3D makeGetter('milliseconds');=0A=
      var seconds      =3D makeGetter('seconds');=0A=
      var minutes      =3D makeGetter('minutes');=0A=
      var hours        =3D makeGetter('hours');=0A=
      var days         =3D makeGetter('days');=0A=
      var months       =3D makeGetter('months');=0A=
      var years        =3D makeGetter('years');=0A=
=0A=
      function weeks () {=0A=
          return absFloor(this.days() / 7);=0A=
      }=0A=
=0A=
      var round =3D Math.round;=0A=
      var thresholds =3D {=0A=
          s: 45,  // seconds to minute=0A=
          m: 45,  // minutes to hour=0A=
          h: 22,  // hours to day=0A=
          d: 26,  // days to month=0A=
          M: 11   // months to year=0A=
      };=0A=
=0A=
      // helper function for moment.fn.from, moment.fn.fromNow, and =
moment.duration.fn.humanize=0A=
      function substituteTimeAgo(string, number, withoutSuffix, =
isFuture, locale) {=0A=
          return locale.relativeTime(number || 1, !!withoutSuffix, =
string, isFuture);=0A=
      }=0A=
=0A=
      function duration_humanize__relativeTime (posNegDuration, =
withoutSuffix, locale) {=0A=
          var duration =3D create__createDuration(posNegDuration).abs();=0A=
          var seconds  =3D round(duration.as('s'));=0A=
          var minutes  =3D round(duration.as('m'));=0A=
          var hours    =3D round(duration.as('h'));=0A=
          var days     =3D round(duration.as('d'));=0A=
          var months   =3D round(duration.as('M'));=0A=
          var years    =3D round(duration.as('y'));=0A=
=0A=
          var a =3D seconds < thresholds.s && ['s', seconds]  ||=0A=
                  minutes =3D=3D=3D 1          && ['m']           ||=0A=
                  minutes < thresholds.m && ['mm', minutes] ||=0A=
                  hours   =3D=3D=3D 1          && ['h']           ||=0A=
                  hours   < thresholds.h && ['hh', hours]   ||=0A=
                  days    =3D=3D=3D 1          && ['d']           ||=0A=
                  days    < thresholds.d && ['dd', days]    ||=0A=
                  months  =3D=3D=3D 1          && ['M']           ||=0A=
                  months  < thresholds.M && ['MM', months]  ||=0A=
                  years   =3D=3D=3D 1          && ['y']           || =
['yy', years];=0A=
=0A=
          a[2] =3D withoutSuffix;=0A=
          a[3] =3D +posNegDuration > 0;=0A=
          a[4] =3D locale;=0A=
          return substituteTimeAgo.apply(null, a);=0A=
      }=0A=
=0A=
      // This function allows you to set a threshold for relative time =
strings=0A=
      function duration_humanize__getSetRelativeTimeThreshold =
(threshold, limit) {=0A=
          if (thresholds[threshold] =3D=3D=3D undefined) {=0A=
              return false;=0A=
          }=0A=
          if (limit =3D=3D=3D undefined) {=0A=
              return thresholds[threshold];=0A=
          }=0A=
          thresholds[threshold] =3D limit;=0A=
          return true;=0A=
      }=0A=
=0A=
      function humanize (withSuffix) {=0A=
          var locale =3D this.localeData();=0A=
          var output =3D duration_humanize__relativeTime(this, =
!withSuffix, locale);=0A=
=0A=
          if (withSuffix) {=0A=
              output =3D locale.pastFuture(+this, output);=0A=
          }=0A=
=0A=
          return locale.postformat(output);=0A=
      }=0A=
=0A=
      var iso_string__abs =3D Math.abs;=0A=
=0A=
      function iso_string__toISOString() {=0A=
          // for ISO strings we do not use the normal bubbling rules:=0A=
          //  * milliseconds bubble up until they become hours=0A=
          //  * days do not bubble at all=0A=
          //  * months bubble up until they become years=0A=
          // This is because there is no context-free conversion between =
hours and days=0A=
          // (think of clock changes)=0A=
          // and also not between days and months (28-31 days per month)=0A=
          var seconds =3D iso_string__abs(this._milliseconds) / 1000;=0A=
          var days         =3D iso_string__abs(this._days);=0A=
          var months       =3D iso_string__abs(this._months);=0A=
          var minutes, hours, years;=0A=
=0A=
          // 3600 seconds -> 60 minutes -> 1 hour=0A=
          minutes           =3D absFloor(seconds / 60);=0A=
          hours             =3D absFloor(minutes / 60);=0A=
          seconds %=3D 60;=0A=
          minutes %=3D 60;=0A=
=0A=
          // 12 months -> 1 year=0A=
          years  =3D absFloor(months / 12);=0A=
          months %=3D 12;=0A=
=0A=
=0A=
          // inspired by =
https://github.com/dordille/moment-isoduration/blob/master/moment.isodura=
tion.js=0A=
          var Y =3D years;=0A=
          var M =3D months;=0A=
          var D =3D days;=0A=
          var h =3D hours;=0A=
          var m =3D minutes;=0A=
          var s =3D seconds;=0A=
          var total =3D this.asSeconds();=0A=
=0A=
          if (!total) {=0A=
              // this is the same as C#'s (Noda) and python (isodate)...=0A=
              // but not other JS (goog.date)=0A=
              return 'P0D';=0A=
          }=0A=
=0A=
          return (total < 0 ? '-' : '') +=0A=
              'P' +=0A=
              (Y ? Y + 'Y' : '') +=0A=
              (M ? M + 'M' : '') +=0A=
              (D ? D + 'D' : '') +=0A=
              ((h || m || s) ? 'T' : '') +=0A=
              (h ? h + 'H' : '') +=0A=
              (m ? m + 'M' : '') +=0A=
              (s ? s + 'S' : '');=0A=
      }=0A=
=0A=
      var duration_prototype__proto =3D Duration.prototype;=0A=
=0A=
      duration_prototype__proto.abs            =3D duration_abs__abs;=0A=
      duration_prototype__proto.add            =3D =
duration_add_subtract__add;=0A=
      duration_prototype__proto.subtract       =3D =
duration_add_subtract__subtract;=0A=
      duration_prototype__proto.as             =3D as;=0A=
      duration_prototype__proto.asMilliseconds =3D asMilliseconds;=0A=
      duration_prototype__proto.asSeconds      =3D asSeconds;=0A=
      duration_prototype__proto.asMinutes      =3D asMinutes;=0A=
      duration_prototype__proto.asHours        =3D asHours;=0A=
      duration_prototype__proto.asDays         =3D asDays;=0A=
      duration_prototype__proto.asWeeks        =3D asWeeks;=0A=
      duration_prototype__proto.asMonths       =3D asMonths;=0A=
      duration_prototype__proto.asYears        =3D asYears;=0A=
      duration_prototype__proto.valueOf        =3D duration_as__valueOf;=0A=
      duration_prototype__proto._bubble        =3D bubble;=0A=
      duration_prototype__proto.get            =3D duration_get__get;=0A=
      duration_prototype__proto.milliseconds   =3D milliseconds;=0A=
      duration_prototype__proto.seconds        =3D seconds;=0A=
      duration_prototype__proto.minutes        =3D minutes;=0A=
      duration_prototype__proto.hours          =3D hours;=0A=
      duration_prototype__proto.days           =3D days;=0A=
      duration_prototype__proto.weeks          =3D weeks;=0A=
      duration_prototype__proto.months         =3D months;=0A=
      duration_prototype__proto.years          =3D years;=0A=
      duration_prototype__proto.humanize       =3D humanize;=0A=
      duration_prototype__proto.toISOString    =3D =
iso_string__toISOString;=0A=
      duration_prototype__proto.toString       =3D =
iso_string__toISOString;=0A=
      duration_prototype__proto.toJSON         =3D =
iso_string__toISOString;=0A=
      duration_prototype__proto.locale         =3D locale;=0A=
      duration_prototype__proto.localeData     =3D localeData;=0A=
=0A=
      // Deprecations=0A=
      duration_prototype__proto.toIsoString =3D deprecate('toIsoString() =
is deprecated. Please use toISOString() instead (notice the capitals)', =
iso_string__toISOString);=0A=
      duration_prototype__proto.lang =3D lang;=0A=
=0A=
      // Side effect imports=0A=
=0A=
      addFormatToken('X', 0, 0, 'unix');=0A=
      addFormatToken('x', 0, 0, 'valueOf');=0A=
=0A=
      // PARSING=0A=
=0A=
      addRegexToken('x', matchSigned);=0A=
      addRegexToken('X', matchTimestamp);=0A=
      addParseToken('X', function (input, array, config) {=0A=
          config._d =3D new Date(parseFloat(input, 10) * 1000);=0A=
      });=0A=
      addParseToken('x', function (input, array, config) {=0A=
          config._d =3D new Date(toInt(input));=0A=
      });=0A=
=0A=
      // Side effect imports=0A=
=0A=
=0A=
      utils_hooks__hooks.version =3D '2.10.5';=0A=
=0A=
      setHookCallback(local__createLocal);=0A=
=0A=
      utils_hooks__hooks.fn                    =3D momentPrototype;=0A=
      utils_hooks__hooks.min                   =3D min;=0A=
      utils_hooks__hooks.max                   =3D max;=0A=
      utils_hooks__hooks.utc                   =3D create_utc__createUTC;=0A=
      utils_hooks__hooks.unix                  =3D moment__createUnix;=0A=
      utils_hooks__hooks.months                =3D lists__listMonths;=0A=
      utils_hooks__hooks.isDate                =3D isDate;=0A=
      utils_hooks__hooks.locale                =3D =
locale_locales__getSetGlobalLocale;=0A=
      utils_hooks__hooks.invalid               =3D valid__createInvalid;=0A=
      utils_hooks__hooks.duration              =3D =
create__createDuration;=0A=
      utils_hooks__hooks.isMoment              =3D isMoment;=0A=
      utils_hooks__hooks.weekdays              =3D lists__listWeekdays;=0A=
      utils_hooks__hooks.parseZone             =3D moment__createInZone;=0A=
      utils_hooks__hooks.localeData            =3D =
locale_locales__getLocale;=0A=
      utils_hooks__hooks.isDuration            =3D isDuration;=0A=
      utils_hooks__hooks.monthsShort           =3D =
lists__listMonthsShort;=0A=
      utils_hooks__hooks.weekdaysMin           =3D =
lists__listWeekdaysMin;=0A=
      utils_hooks__hooks.defineLocale          =3D defineLocale;=0A=
      utils_hooks__hooks.weekdaysShort         =3D =
lists__listWeekdaysShort;=0A=
      utils_hooks__hooks.normalizeUnits        =3D normalizeUnits;=0A=
      utils_hooks__hooks.relativeTimeThreshold =3D =
duration_humanize__getSetRelativeTimeThreshold;=0A=
=0A=
      var _moment =3D utils_hooks__hooks;=0A=
=0A=
      return _moment;=0A=
=0A=
  }));=0A=
  /* WEBPACK VAR INJECTION */}.call(exports, =
__webpack_require__(10)(module)))=0A=
=0A=
/***/ },=0A=
/* 10 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  module.exports =3D function(module) {=0A=
  	if(!module.webpackPolyfill) {=0A=
  		module.deprecate =3D function() {};=0A=
  		module.paths =3D [];=0A=
  		// module.parent =3D undefined by default=0A=
  		module.children =3D [];=0A=
  		module.webpackPolyfill =3D 1;=0A=
  	}=0A=
  	return module;=0A=
  }=0A=
=0A=
=0A=
/***/ },=0A=
/* 11 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  function webpackContext(req) {=0A=
  	throw new Error("Cannot find module '" + req + "'.");=0A=
  }=0A=
  webpackContext.keys =3D function() { return []; };=0A=
  webpackContext.resolve =3D webpackContext;=0A=
  module.exports =3D webpackContext;=0A=
  webpackContext.id =3D 11;=0A=
=0A=
=0A=
/***/ },=0A=
/* 12 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /* WEBPACK VAR INJECTION */(function(global) {'use strict';=0A=
=0A=
  var _rng;=0A=
=0A=
  var globalVar =3D typeof window !=3D=3D 'undefined' ? window : typeof =
global !=3D=3D 'undefined' ? global : null;=0A=
=0A=
  if (globalVar && globalVar.crypto && crypto.getRandomValues) {=0A=
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto=0A=
    // Moderately fast, high quality=0A=
    var _rnds8 =3D new Uint8Array(16);=0A=
    _rng =3D function whatwgRNG() {=0A=
      crypto.getRandomValues(_rnds8);=0A=
      return _rnds8;=0A=
    };=0A=
  }=0A=
=0A=
  if (!_rng) {=0A=
    // Math.random()-based (RNG)=0A=
    //=0A=
    // If all else fails, use Math.random().  It's fast, but is of =
unspecified=0A=
    // quality.=0A=
    var _rnds =3D new Array(16);=0A=
    _rng =3D function () {=0A=
      for (var i =3D 0, r; i < 16; i++) {=0A=
        if ((i & 0x03) =3D=3D=3D 0) r =3D Math.random() * 0x100000000;=0A=
        _rnds[i] =3D r >>> ((i & 0x03) << 3) & 0xff;=0A=
      }=0A=
=0A=
      return _rnds;=0A=
    };=0A=
  }=0A=
=0A=
  //     uuid.js=0A=
  //=0A=
  //     Copyright (c) 2010-2012 Robert Kieffer=0A=
  //     MIT License - http://opensource.org/licenses/mit-license.php=0A=
=0A=
  // Unique ID creation requires a high quality random # generator.  We =
feature=0A=
  // detect to determine the best RNG source, normalizing to a function =
that=0A=
  // returns 128-bits of randomness, since that's what's usually required=0A=
=0A=
  //var _rng =3D require('./rng');=0A=
=0A=
  // Maps for number <-> hex string conversion=0A=
  var _byteToHex =3D [];=0A=
  var _hexToByte =3D {};=0A=
  for (var i =3D 0; i < 256; i++) {=0A=
    _byteToHex[i] =3D (i + 0x100).toString(16).substr(1);=0A=
    _hexToByte[_byteToHex[i]] =3D i;=0A=
  }=0A=
=0A=
  // **`parse()` - Parse a UUID into it's component bytes**=0A=
  function parse(s, buf, offset) {=0A=
    var i =3D buf && offset || 0,=0A=
        ii =3D 0;=0A=
=0A=
    buf =3D buf || [];=0A=
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {=0A=
      if (ii < 16) {=0A=
        // Don't overflow!=0A=
        buf[i + ii++] =3D _hexToByte[oct];=0A=
      }=0A=
    });=0A=
=0A=
    // Zero out remaining bytes if string was short=0A=
    while (ii < 16) {=0A=
      buf[i + ii++] =3D 0;=0A=
    }=0A=
=0A=
    return buf;=0A=
  }=0A=
=0A=
  // **`unparse()` - Convert UUID byte array (ala parse()) into a =
string**=0A=
  function unparse(buf, offset) {=0A=
    var i =3D offset || 0,=0A=
        bth =3D _byteToHex;=0A=
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] =
+ '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + =
bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + =
bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + =
bth[buf[i++]] + bth[buf[i++]];=0A=
  }=0A=
=0A=
  // **`v1()` - Generate time-based UUID**=0A=
  //=0A=
  // Inspired by https://github.com/LiosK/UUID.js=0A=
  // and http://docs.python.org/library/uuid.html=0A=
=0A=
  // random #'s we need to init node and clockseq=0A=
  var _seedBytes =3D _rng();=0A=
=0A=
  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit =
=3D 1)=0A=
  var _nodeId =3D [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], =
_seedBytes[3], _seedBytes[4], _seedBytes[5]];=0A=
=0A=
  // Per 4.2.2, randomize (14 bit) clockseq=0A=
  var _clockseq =3D (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;=0A=
=0A=
  // Previous uuid creation time=0A=
  var _lastMSecs =3D 0,=0A=
      _lastNSecs =3D 0;=0A=
=0A=
  // See https://github.com/broofa/node-uuid for API details=0A=
  function v1(options, buf, offset) {=0A=
    var i =3D buf && offset || 0;=0A=
    var b =3D buf || [];=0A=
=0A=
    options =3D options || {};=0A=
=0A=
    var clockseq =3D options.clockseq !=3D=3D undefined ? =
options.clockseq : _clockseq;=0A=
=0A=
    // UUID timestamps are 100 nano-second units since the Gregorian =
epoch,=0A=
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so=0A=
    // time is handled internally as 'msecs' (integer milliseconds) and =
'nsecs'=0A=
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 =
00:00.=0A=
    var msecs =3D options.msecs !=3D=3D undefined ? options.msecs : new =
Date().getTime();=0A=
=0A=
    // Per 4.2.1.2, use count of uuid's generated during the current =
clock=0A=
    // cycle to simulate higher resolution clock=0A=
    var nsecs =3D options.nsecs !=3D=3D undefined ? options.nsecs : =
_lastNSecs + 1;=0A=
=0A=
    // Time since last uuid creation (in msecs)=0A=
    var dt =3D msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;=0A=
=0A=
    // Per 4.2.1.2, Bump clockseq on clock regression=0A=
    if (dt < 0 && options.clockseq =3D=3D=3D undefined) {=0A=
      clockseq =3D clockseq + 1 & 0x3fff;=0A=
    }=0A=
=0A=
    // Reset nsecs if clock regresses (new clockseq) or we've moved onto =
a new=0A=
    // time interval=0A=
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs =3D=3D=3D =
undefined) {=0A=
      nsecs =3D 0;=0A=
    }=0A=
=0A=
    // Per 4.2.1.2 Throw error if too many uuids are requested=0A=
    if (nsecs >=3D 10000) {=0A=
      throw new Error('uuid.v1(): Can\'t create more than 10M =
uuids/sec');=0A=
    }=0A=
=0A=
    _lastMSecs =3D msecs;=0A=
    _lastNSecs =3D nsecs;=0A=
    _clockseq =3D clockseq;=0A=
=0A=
    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch=0A=
    msecs +=3D 12219292800000;=0A=
=0A=
    // `time_low`=0A=
    var tl =3D ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;=0A=
    b[i++] =3D tl >>> 24 & 0xff;=0A=
    b[i++] =3D tl >>> 16 & 0xff;=0A=
    b[i++] =3D tl >>> 8 & 0xff;=0A=
    b[i++] =3D tl & 0xff;=0A=
=0A=
    // `time_mid`=0A=
    var tmh =3D msecs / 0x100000000 * 10000 & 0xfffffff;=0A=
    b[i++] =3D tmh >>> 8 & 0xff;=0A=
    b[i++] =3D tmh & 0xff;=0A=
=0A=
    // `time_high_and_version`=0A=
    b[i++] =3D tmh >>> 24 & 0xf | 0x10; // include version=0A=
    b[i++] =3D tmh >>> 16 & 0xff;=0A=
=0A=
    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)=0A=
    b[i++] =3D clockseq >>> 8 | 0x80;=0A=
=0A=
    // `clock_seq_low`=0A=
    b[i++] =3D clockseq & 0xff;=0A=
=0A=
    // `node`=0A=
    var node =3D options.node || _nodeId;=0A=
    for (var n =3D 0; n < 6; n++) {=0A=
      b[i + n] =3D node[n];=0A=
    }=0A=
=0A=
    return buf ? buf : unparse(b);=0A=
  }=0A=
=0A=
  // **`v4()` - Generate random UUID**=0A=
=0A=
  // See https://github.com/broofa/node-uuid for API details=0A=
  function v4(options, buf, offset) {=0A=
    // Deprecated - 'format' argument, as supported in v1.2=0A=
    var i =3D buf && offset || 0;=0A=
=0A=
    if (typeof options =3D=3D 'string') {=0A=
      buf =3D options =3D=3D 'binary' ? new Array(16) : null;=0A=
      options =3D null;=0A=
    }=0A=
    options =3D options || {};=0A=
=0A=
    var rnds =3D options.random || (options.rng || _rng)();=0A=
=0A=
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`=0A=
    rnds[6] =3D rnds[6] & 0x0f | 0x40;=0A=
    rnds[8] =3D rnds[8] & 0x3f | 0x80;=0A=
=0A=
    // Copy bytes to buffer, if provided=0A=
    if (buf) {=0A=
      for (var ii =3D 0; ii < 16; ii++) {=0A=
        buf[i + ii] =3D rnds[ii];=0A=
      }=0A=
    }=0A=
=0A=
    return buf || unparse(rnds);=0A=
  }=0A=
=0A=
  // Export public API=0A=
  var uuid =3D v4;=0A=
  uuid.v1 =3D v1;=0A=
  uuid.v4 =3D v4;=0A=
  uuid.parse =3D parse;=0A=
  uuid.unparse =3D unparse;=0A=
=0A=
  module.exports =3D uuid;=0A=
  /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; =
}())))=0A=
=0A=
/***/ },=0A=
/* 13 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  // DOM utility methods=0A=
=0A=
  /**=0A=
   * this prepares the JSON container for allocating SVG elements=0A=
   * @param JSONcontainer=0A=
   * @private=0A=
   */=0A=
  'use strict';=0A=
=0A=
  exports.prepareElements =3D function (JSONcontainer) {=0A=
    // cleanup the redundant svgElements;=0A=
    for (var elementType in JSONcontainer) {=0A=
      if (JSONcontainer.hasOwnProperty(elementType)) {=0A=
        JSONcontainer[elementType].redundant =3D =
JSONcontainer[elementType].used;=0A=
        JSONcontainer[elementType].used =3D [];=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this cleans up all the unused SVG elements. By asking for the =
parentNode, we only need to supply the JSON container from=0A=
   * which to remove the redundant elements.=0A=
   *=0A=
   * @param JSONcontainer=0A=
   * @private=0A=
   */=0A=
  exports.cleanupElements =3D function (JSONcontainer) {=0A=
    // cleanup the redundant svgElements;=0A=
    for (var elementType in JSONcontainer) {=0A=
      if (JSONcontainer.hasOwnProperty(elementType)) {=0A=
        if (JSONcontainer[elementType].redundant) {=0A=
          for (var i =3D 0; i < =
JSONcontainer[elementType].redundant.length; i++) {=0A=
            =
JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontai=
ner[elementType].redundant[i]);=0A=
          }=0A=
          JSONcontainer[elementType].redundant =3D [];=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Allocate or generate an SVG element if needed. Store a reference to =
it in the JSON container and draw it in the svgContainer=0A=
   * the JSON container and the SVG container have to be supplied so =
other svg containers (like the legend) can use this.=0A=
   *=0A=
   * @param elementType=0A=
   * @param JSONcontainer=0A=
   * @param svgContainer=0A=
   * @returns {*}=0A=
   * @private=0A=
   */=0A=
  exports.getSVGElement =3D function (elementType, JSONcontainer, =
svgContainer) {=0A=
    var element;=0A=
    // allocate SVG element, if it doesnt yet exist, create one.=0A=
    if (JSONcontainer.hasOwnProperty(elementType)) {=0A=
      // this element has been created before=0A=
      // check if there is an redundant element=0A=
      if (JSONcontainer[elementType].redundant.length > 0) {=0A=
        element =3D JSONcontainer[elementType].redundant[0];=0A=
        JSONcontainer[elementType].redundant.shift();=0A=
      } else {=0A=
        // create a new element and add it to the SVG=0A=
        element =3D =
document.createElementNS('http://www.w3.org/2000/svg', elementType);=0A=
        svgContainer.appendChild(element);=0A=
      }=0A=
    } else {=0A=
      // create a new element and add it to the SVG, also create a new =
object in the svgElements to keep track of it.=0A=
      element =3D document.createElementNS('http://www.w3.org/2000/svg', =
elementType);=0A=
      JSONcontainer[elementType] =3D { used: [], redundant: [] };=0A=
      svgContainer.appendChild(element);=0A=
    }=0A=
    JSONcontainer[elementType].used.push(element);=0A=
    return element;=0A=
  };=0A=
=0A=
  /**=0A=
   * Allocate or generate an SVG element if needed. Store a reference to =
it in the JSON container and draw it in the svgContainer=0A=
   * the JSON container and the SVG container have to be supplied so =
other svg containers (like the legend) can use this.=0A=
   *=0A=
   * @param elementType=0A=
   * @param JSONcontainer=0A=
   * @param DOMContainer=0A=
   * @returns {*}=0A=
   * @private=0A=
   */=0A=
  exports.getDOMElement =3D function (elementType, JSONcontainer, =
DOMContainer, insertBefore) {=0A=
    var element;=0A=
    // allocate DOM element, if it doesnt yet exist, create one.=0A=
    if (JSONcontainer.hasOwnProperty(elementType)) {=0A=
      // this element has been created before=0A=
      // check if there is an redundant element=0A=
      if (JSONcontainer[elementType].redundant.length > 0) {=0A=
        element =3D JSONcontainer[elementType].redundant[0];=0A=
        JSONcontainer[elementType].redundant.shift();=0A=
      } else {=0A=
        // create a new element and add it to the SVG=0A=
        element =3D document.createElement(elementType);=0A=
        if (insertBefore !=3D=3D undefined) {=0A=
          DOMContainer.insertBefore(element, insertBefore);=0A=
        } else {=0A=
          DOMContainer.appendChild(element);=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // create a new element and add it to the SVG, also create a new =
object in the svgElements to keep track of it.=0A=
      element =3D document.createElement(elementType);=0A=
      JSONcontainer[elementType] =3D { used: [], redundant: [] };=0A=
      if (insertBefore !=3D=3D undefined) {=0A=
        DOMContainer.insertBefore(element, insertBefore);=0A=
      } else {=0A=
        DOMContainer.appendChild(element);=0A=
      }=0A=
    }=0A=
    JSONcontainer[elementType].used.push(element);=0A=
    return element;=0A=
  };=0A=
=0A=
  /**=0A=
   * Draw a point object. This is a separate function because it can =
also be called by the legend.=0A=
   * The reason the JSONcontainer and the target SVG svgContainer have =
to be supplied is so the legend can use these functions=0A=
   * as well.=0A=
   *=0A=
   * @param x=0A=
   * @param y=0A=
   * @param groupTemplate: A template containing the necessary =
information to draw the datapoint e.g., {style: 'circle', size: 5, =
className: 'className' }=0A=
   * @param JSONcontainer=0A=
   * @param svgContainer=0A=
   * @param labelObj=0A=
   * @returns {*}=0A=
   */=0A=
  exports.drawPoint =3D function (x, y, groupTemplate, JSONcontainer, =
svgContainer, labelObj) {=0A=
    var point;=0A=
    if (groupTemplate.style =3D=3D 'circle') {=0A=
      point =3D exports.getSVGElement('circle', JSONcontainer, =
svgContainer);=0A=
      point.setAttributeNS(null, 'cx', x);=0A=
      point.setAttributeNS(null, 'cy', y);=0A=
      point.setAttributeNS(null, 'r', 0.5 * groupTemplate.size);=0A=
    } else {=0A=
      point =3D exports.getSVGElement('rect', JSONcontainer, =
svgContainer);=0A=
      point.setAttributeNS(null, 'x', x - 0.5 * groupTemplate.size);=0A=
      point.setAttributeNS(null, 'y', y - 0.5 * groupTemplate.size);=0A=
      point.setAttributeNS(null, 'width', groupTemplate.size);=0A=
      point.setAttributeNS(null, 'height', groupTemplate.size);=0A=
    }=0A=
=0A=
    if (groupTemplate.style !=3D=3D undefined) {=0A=
      point.setAttributeNS(null, 'style', groupTemplate.style);=0A=
    }=0A=
    point.setAttributeNS(null, 'class', groupTemplate.className + ' =
vis-point');=0A=
    //handle label=0A=
=0A=
    if (labelObj) {=0A=
      var label =3D exports.getSVGElement('text', JSONcontainer, =
svgContainer);=0A=
      if (labelObj.xOffset) {=0A=
        x =3D x + labelObj.xOffset;=0A=
      }=0A=
=0A=
      if (labelObj.yOffset) {=0A=
        y =3D y + labelObj.yOffset;=0A=
      }=0A=
      if (labelObj.content) {=0A=
        label.textContent =3D labelObj.content;=0A=
      }=0A=
=0A=
      if (labelObj.className) {=0A=
        label.setAttributeNS(null, 'class', labelObj.className + ' =
vis-label');=0A=
      }=0A=
      label.setAttributeNS(null, 'x', x);=0A=
      label.setAttributeNS(null, 'y', y);=0A=
    }=0A=
=0A=
    return point;=0A=
  };=0A=
=0A=
  /**=0A=
   * draw a bar SVG element centered on the X coordinate=0A=
   *=0A=
   * @param x=0A=
   * @param y=0A=
   * @param className=0A=
   */=0A=
  exports.drawBar =3D function (x, y, width, height, className, =
JSONcontainer, svgContainer, style) {=0A=
    if (height !=3D 0) {=0A=
      if (height < 0) {=0A=
        height *=3D -1;=0A=
        y -=3D height;=0A=
      }=0A=
      var rect =3D exports.getSVGElement('rect', JSONcontainer, =
svgContainer);=0A=
      rect.setAttributeNS(null, 'x', x - 0.5 * width);=0A=
      rect.setAttributeNS(null, 'y', y);=0A=
      rect.setAttributeNS(null, 'width', width);=0A=
      rect.setAttributeNS(null, 'height', height);=0A=
      rect.setAttributeNS(null, 'class', className);=0A=
      if (style) {=0A=
        rect.setAttributeNS(null, 'style', style);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
/***/ },=0A=
/* 14 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var Queue =3D __webpack_require__(15);=0A=
=0A=
  /**=0A=
   * DataSet=0A=
   *=0A=
   * Usage:=0A=
   *     var dataSet =3D new DataSet({=0A=
   *         fieldId: '_id',=0A=
   *         type: {=0A=
   *             // ...=0A=
   *         }=0A=
   *     });=0A=
   *=0A=
   *     dataSet.add(item);=0A=
   *     dataSet.add(data);=0A=
   *     dataSet.update(item);=0A=
   *     dataSet.update(data);=0A=
   *     dataSet.remove(id);=0A=
   *     dataSet.remove(ids);=0A=
   *     var data =3D dataSet.get();=0A=
   *     var data =3D dataSet.get(id);=0A=
   *     var data =3D dataSet.get(ids);=0A=
   *     var data =3D dataSet.get(ids, options, data);=0A=
   *     dataSet.clear();=0A=
   *=0A=
   * A data set can:=0A=
   * - add/remove/update data=0A=
   * - gives triggers upon changes in the data=0A=
   * - can  import/export data in various data formats=0A=
   *=0A=
   * @param {Array} [data]    Optional array with initial data=0A=
   * @param {Object} [options]   Available options:=0A=
   *                             {String} fieldId Field name of the id =
in the=0A=
   *                                              items, 'id' by default.=0A=
   *                             {Object.<String, String} type=0A=
   *                                              A map with field names =
as key,=0A=
   *                                              and the field type as =
value.=0A=
   *                             {Object} queue   Queue changes to the =
DataSet,=0A=
   *                                              flush them all at once.=0A=
   *                                              Queue options:=0A=
   *                                              - {number} delay  =
Delay in ms, null by default=0A=
   *                                              - {number} max    =
Maximum number of entries in the queue, Infinity by default=0A=
   * @constructor DataSet=0A=
   */=0A=
  // TODO: add a DataSet constructor DataSet(data, options)=0A=
  function DataSet(data, options) {=0A=
    // correctly read optional arguments=0A=
    if (data && !Array.isArray(data)) {=0A=
      options =3D data;=0A=
      data =3D null;=0A=
    }=0A=
=0A=
    this._options =3D options || {};=0A=
    this._data =3D {}; // map with data indexed by id=0A=
    this.length =3D 0; // number of items in the DataSet=0A=
    this._fieldId =3D this._options.fieldId || 'id'; // name of the =
field containing id=0A=
    this._type =3D {}; // internal field types (NOTE: this can differ =
from this._options.type)=0A=
=0A=
    // all variants of a Date are internally stored as Date, so we can =
convert=0A=
    // from everything to everything (also from ISODate to Number for =
example)=0A=
    if (this._options.type) {=0A=
      for (var field in this._options.type) {=0A=
        if (this._options.type.hasOwnProperty(field)) {=0A=
          var value =3D this._options.type[field];=0A=
          if (value =3D=3D 'Date' || value =3D=3D 'ISODate' || value =
=3D=3D 'ASPDate') {=0A=
            this._type[field] =3D 'Date';=0A=
          } else {=0A=
            this._type[field] =3D value;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // TODO: deprecated since version 1.1.1 (or 2.0.0?)=0A=
    if (this._options.convert) {=0A=
      throw new Error('Option "convert" is deprecated. Use "type" =
instead.');=0A=
    }=0A=
=0A=
    this._subscribers =3D {}; // event subscribers=0A=
=0A=
    // add initial data when provided=0A=
    if (data) {=0A=
      this.add(data);=0A=
    }=0A=
=0A=
    this.setOptions(options);=0A=
  }=0A=
=0A=
  /**=0A=
   * @param {Object} [options]   Available options:=0A=
   *                             {Object} queue   Queue changes to the =
DataSet,=0A=
   *                                              flush them all at once.=0A=
   *                                              Queue options:=0A=
   *                                              - {number} delay  =
Delay in ms, null by default=0A=
   *                                              - {number} max    =
Maximum number of entries in the queue, Infinity by default=0A=
   * @param options=0A=
   */=0A=
  DataSet.prototype.setOptions =3D function (options) {=0A=
    if (options && options.queue !=3D=3D undefined) {=0A=
      if (options.queue =3D=3D=3D false) {=0A=
        // delete queue if loaded=0A=
        if (this._queue) {=0A=
          this._queue.destroy();=0A=
          delete this._queue;=0A=
        }=0A=
      } else {=0A=
        // create queue and update its options=0A=
        if (!this._queue) {=0A=
          this._queue =3D Queue.extend(this, {=0A=
            replace: ['add', 'update', 'remove']=0A=
          });=0A=
        }=0A=
=0A=
        if (typeof options.queue =3D=3D=3D 'object') {=0A=
          this._queue.setOptions(options.queue);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Subscribe to an event, add an event listener=0A=
   * @param {String} event        Event name. Available events: 'put', =
'update',=0A=
   *                              'remove'=0A=
   * @param {function} callback   Callback method. Called with three =
parameters:=0A=
   *                                  {String} event=0A=
   *                                  {Object | null} params=0A=
   *                                  {String | Number} senderId=0A=
   */=0A=
  DataSet.prototype.on =3D function (event, callback) {=0A=
    var subscribers =3D this._subscribers[event];=0A=
    if (!subscribers) {=0A=
      subscribers =3D [];=0A=
      this._subscribers[event] =3D subscribers;=0A=
    }=0A=
=0A=
    subscribers.push({=0A=
      callback: callback=0A=
    });=0A=
  };=0A=
=0A=
  // TODO: remove this deprecated function some day (replaced with `on` =
since version 0.5, deprecated since v4.0)=0A=
  DataSet.prototype.subscribe =3D function () {=0A=
    throw new Error('DataSet.subscribe is deprecated. Use DataSet.on =
instead.');=0A=
  };=0A=
=0A=
  /**=0A=
   * Unsubscribe from an event, remove an event listener=0A=
   * @param {String} event=0A=
   * @param {function} callback=0A=
   */=0A=
  DataSet.prototype.off =3D function (event, callback) {=0A=
    var subscribers =3D this._subscribers[event];=0A=
    if (subscribers) {=0A=
      this._subscribers[event] =3D subscribers.filter(function =
(listener) {=0A=
        return listener.callback !=3D callback;=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  // TODO: remove this deprecated function some day (replaced with `on` =
since version 0.5, deprecated since v4.0)=0A=
  DataSet.prototype.unsubscribe =3D function () {=0A=
    throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off =
instead.');=0A=
  };=0A=
=0A=
  /**=0A=
   * Trigger an event=0A=
   * @param {String} event=0A=
   * @param {Object | null} params=0A=
   * @param {String} [senderId]       Optional id of the sender.=0A=
   * @private=0A=
   */=0A=
  DataSet.prototype._trigger =3D function (event, params, senderId) {=0A=
    if (event =3D=3D '*') {=0A=
      throw new Error('Cannot trigger event *');=0A=
    }=0A=
=0A=
    var subscribers =3D [];=0A=
    if (event in this._subscribers) {=0A=
      subscribers =3D subscribers.concat(this._subscribers[event]);=0A=
    }=0A=
    if ('*' in this._subscribers) {=0A=
      subscribers =3D subscribers.concat(this._subscribers['*']);=0A=
    }=0A=
=0A=
    for (var i =3D 0; i < subscribers.length; i++) {=0A=
      var subscriber =3D subscribers[i];=0A=
      if (subscriber.callback) {=0A=
        subscriber.callback(event, params, senderId || null);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Add data.=0A=
   * Adding an item will fail when there already is an item with the =
same id.=0A=
   * @param {Object | Array} data=0A=
   * @param {String} [senderId] Optional sender id=0A=
   * @return {Array} addedIds      Array with the ids of the added items=0A=
   */=0A=
  DataSet.prototype.add =3D function (data, senderId) {=0A=
    var addedIds =3D [],=0A=
        id,=0A=
        me =3D this;=0A=
=0A=
    if (Array.isArray(data)) {=0A=
      // Array=0A=
      for (var i =3D 0, len =3D data.length; i < len; i++) {=0A=
        id =3D me._addItem(data[i]);=0A=
        addedIds.push(id);=0A=
      }=0A=
    } else if (data instanceof Object) {=0A=
      // Single item=0A=
      id =3D me._addItem(data);=0A=
      addedIds.push(id);=0A=
    } else {=0A=
      throw new Error('Unknown dataType');=0A=
    }=0A=
=0A=
    if (addedIds.length) {=0A=
      this._trigger('add', { items: addedIds }, senderId);=0A=
    }=0A=
=0A=
    return addedIds;=0A=
  };=0A=
=0A=
  /**=0A=
   * Update existing items. When an item does not exist, it will be =
created=0A=
   * @param {Object | Array} data=0A=
   * @param {String} [senderId] Optional sender id=0A=
   * @return {Array} updatedIds     The ids of the added or updated items=0A=
   */=0A=
  DataSet.prototype.update =3D function (data, senderId) {=0A=
    var addedIds =3D [];=0A=
    var updatedIds =3D [];=0A=
    var updatedData =3D [];=0A=
    var me =3D this;=0A=
    var fieldId =3D me._fieldId;=0A=
=0A=
    var addOrUpdate =3D function addOrUpdate(item) {=0A=
      var id =3D item[fieldId];=0A=
      if (me._data[id]) {=0A=
        // update item=0A=
        id =3D me._updateItem(item);=0A=
        updatedIds.push(id);=0A=
        updatedData.push(item);=0A=
      } else {=0A=
        // add new item=0A=
        id =3D me._addItem(item);=0A=
        addedIds.push(id);=0A=
      }=0A=
    };=0A=
=0A=
    if (Array.isArray(data)) {=0A=
      // Array=0A=
      for (var i =3D 0, len =3D data.length; i < len; i++) {=0A=
        addOrUpdate(data[i]);=0A=
      }=0A=
    } else if (data instanceof Object) {=0A=
      // Single item=0A=
      addOrUpdate(data);=0A=
    } else {=0A=
      throw new Error('Unknown dataType');=0A=
    }=0A=
=0A=
    if (addedIds.length) {=0A=
      this._trigger('add', { items: addedIds }, senderId);=0A=
    }=0A=
    if (updatedIds.length) {=0A=
      this._trigger('update', { items: updatedIds, data: updatedData }, =
senderId);=0A=
    }=0A=
=0A=
    return addedIds.concat(updatedIds);=0A=
  };=0A=
=0A=
  /**=0A=
   * Get a data item or multiple items.=0A=
   *=0A=
   * Usage:=0A=
   *=0A=
   *     get()=0A=
   *     get(options: Object)=0A=
   *=0A=
   *     get(id: Number | String)=0A=
   *     get(id: Number | String, options: Object)=0A=
   *=0A=
   *     get(ids: Number[] | String[])=0A=
   *     get(ids: Number[] | String[], options: Object)=0A=
   *=0A=
   * Where:=0A=
   *=0A=
   * {Number | String} id         The id of an item=0A=
   * {Number[] | String{}} ids    An array with ids of items=0A=
   * {Object} options             An Object with options. Available =
options:=0A=
   * {String} [returnType]        Type of data to be returned.=0A=
   *                              Can be 'Array' (default) or 'Object'.=0A=
   * {Object.<String, String>} [type]=0A=
   * {String[]} [fields]          field names to be returned=0A=
   * {function} [filter]          filter items=0A=
   * {String | function} [order]  Order the items by a field name or =
custom sort function.=0A=
   * @throws Error=0A=
   */=0A=
  DataSet.prototype.get =3D function (args) {=0A=
    var me =3D this;=0A=
=0A=
    // parse the arguments=0A=
    var id, ids, options;=0A=
    var firstType =3D util.getType(arguments[0]);=0A=
    if (firstType =3D=3D 'String' || firstType =3D=3D 'Number') {=0A=
      // get(id [, options])=0A=
      id =3D arguments[0];=0A=
      options =3D arguments[1];=0A=
    } else if (firstType =3D=3D 'Array') {=0A=
      // get(ids [, options])=0A=
      ids =3D arguments[0];=0A=
      options =3D arguments[1];=0A=
    } else {=0A=
      // get([, options])=0A=
      options =3D arguments[0];=0A=
    }=0A=
=0A=
    // determine the return type=0A=
    var returnType;=0A=
    if (options && options.returnType) {=0A=
      var allowedValues =3D ['Array', 'Object'];=0A=
      returnType =3D allowedValues.indexOf(options.returnType) =3D=3D -1 =
? 'Array' : options.returnType;=0A=
    } else {=0A=
      returnType =3D 'Array';=0A=
    }=0A=
=0A=
    // build options=0A=
    var type =3D options && options.type || this._options.type;=0A=
    var filter =3D options && options.filter;=0A=
    var items =3D [],=0A=
        item,=0A=
        itemId,=0A=
        i,=0A=
        len;=0A=
=0A=
    // convert items=0A=
    if (id !=3D undefined) {=0A=
      // return a single item=0A=
      item =3D me._getItem(id, type);=0A=
      if (filter && !filter(item)) {=0A=
        item =3D null;=0A=
      }=0A=
    } else if (ids !=3D undefined) {=0A=
      // return a subset of items=0A=
      for (i =3D 0, len =3D ids.length; i < len; i++) {=0A=
        item =3D me._getItem(ids[i], type);=0A=
        if (!filter || filter(item)) {=0A=
          items.push(item);=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // return all items=0A=
      for (itemId in this._data) {=0A=
        if (this._data.hasOwnProperty(itemId)) {=0A=
          item =3D me._getItem(itemId, type);=0A=
          if (!filter || filter(item)) {=0A=
            items.push(item);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // order the results=0A=
    if (options && options.order && id =3D=3D undefined) {=0A=
      this._sort(items, options.order);=0A=
    }=0A=
=0A=
    // filter fields of the items=0A=
    if (options && options.fields) {=0A=
      var fields =3D options.fields;=0A=
      if (id !=3D undefined) {=0A=
        item =3D this._filterFields(item, fields);=0A=
      } else {=0A=
        for (i =3D 0, len =3D items.length; i < len; i++) {=0A=
          items[i] =3D this._filterFields(items[i], fields);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // return the results=0A=
    if (returnType =3D=3D 'Object') {=0A=
      var result =3D {};=0A=
      for (i =3D 0; i < items.length; i++) {=0A=
        result[items[i].id] =3D items[i];=0A=
      }=0A=
      return result;=0A=
    } else {=0A=
      if (id !=3D undefined) {=0A=
        // a single item=0A=
        return item;=0A=
      } else {=0A=
        // just return our array=0A=
        return items;=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get ids of all items or from a filtered set of items.=0A=
   * @param {Object} [options]    An Object with options. Available =
options:=0A=
   *                              {function} [filter] filter items=0A=
   *                              {String | function} [order] Order the =
items by=0A=
   *                                  a field name or custom sort =
function.=0A=
   * @return {Array} ids=0A=
   */=0A=
  DataSet.prototype.getIds =3D function (options) {=0A=
    var data =3D this._data,=0A=
        filter =3D options && options.filter,=0A=
        order =3D options && options.order,=0A=
        type =3D options && options.type || this._options.type,=0A=
        i,=0A=
        len,=0A=
        id,=0A=
        item,=0A=
        items,=0A=
        ids =3D [];=0A=
=0A=
    if (filter) {=0A=
      // get filtered items=0A=
      if (order) {=0A=
        // create ordered list=0A=
        items =3D [];=0A=
        for (id in data) {=0A=
          if (data.hasOwnProperty(id)) {=0A=
            item =3D this._getItem(id, type);=0A=
            if (filter(item)) {=0A=
              items.push(item);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        this._sort(items, order);=0A=
=0A=
        for (i =3D 0, len =3D items.length; i < len; i++) {=0A=
          ids[i] =3D items[i][this._fieldId];=0A=
        }=0A=
      } else {=0A=
        // create unordered list=0A=
        for (id in data) {=0A=
          if (data.hasOwnProperty(id)) {=0A=
            item =3D this._getItem(id, type);=0A=
            if (filter(item)) {=0A=
              ids.push(item[this._fieldId]);=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // get all items=0A=
      if (order) {=0A=
        // create an ordered list=0A=
        items =3D [];=0A=
        for (id in data) {=0A=
          if (data.hasOwnProperty(id)) {=0A=
            items.push(data[id]);=0A=
          }=0A=
        }=0A=
=0A=
        this._sort(items, order);=0A=
=0A=
        for (i =3D 0, len =3D items.length; i < len; i++) {=0A=
          ids[i] =3D items[i][this._fieldId];=0A=
        }=0A=
      } else {=0A=
        // create unordered list=0A=
        for (id in data) {=0A=
          if (data.hasOwnProperty(id)) {=0A=
            item =3D data[id];=0A=
            ids.push(item[this._fieldId]);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return ids;=0A=
  };=0A=
=0A=
  /**=0A=
   * Returns the DataSet itself. Is overwritten for example by the =
DataView,=0A=
   * which returns the DataSet it is connected to instead.=0A=
   */=0A=
  DataSet.prototype.getDataSet =3D function () {=0A=
    return this;=0A=
  };=0A=
=0A=
  /**=0A=
   * Execute a callback function for every item in the dataset.=0A=
   * @param {function} callback=0A=
   * @param {Object} [options]    Available options:=0A=
   *                              {Object.<String, String>} [type]=0A=
   *                              {String[]} [fields] filter fields=0A=
   *                              {function} [filter] filter items=0A=
   *                              {String | function} [order] Order the =
items by=0A=
   *                                  a field name or custom sort =
function.=0A=
   */=0A=
  DataSet.prototype.forEach =3D function (callback, options) {=0A=
    var filter =3D options && options.filter,=0A=
        type =3D options && options.type || this._options.type,=0A=
        data =3D this._data,=0A=
        item,=0A=
        id;=0A=
=0A=
    if (options && options.order) {=0A=
      // execute forEach on ordered list=0A=
      var items =3D this.get(options);=0A=
=0A=
      for (var i =3D 0, len =3D items.length; i < len; i++) {=0A=
        item =3D items[i];=0A=
        id =3D item[this._fieldId];=0A=
        callback(item, id);=0A=
      }=0A=
    } else {=0A=
      // unordered=0A=
      for (id in data) {=0A=
        if (data.hasOwnProperty(id)) {=0A=
          item =3D this._getItem(id, type);=0A=
          if (!filter || filter(item)) {=0A=
            callback(item, id);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Map every item in the dataset.=0A=
   * @param {function} callback=0A=
   * @param {Object} [options]    Available options:=0A=
   *                              {Object.<String, String>} [type]=0A=
   *                              {String[]} [fields] filter fields=0A=
   *                              {function} [filter] filter items=0A=
   *                              {String | function} [order] Order the =
items by=0A=
   *                                  a field name or custom sort =
function.=0A=
   * @return {Object[]} mappedItems=0A=
   */=0A=
  DataSet.prototype.map =3D function (callback, options) {=0A=
    var filter =3D options && options.filter,=0A=
        type =3D options && options.type || this._options.type,=0A=
        mappedItems =3D [],=0A=
        data =3D this._data,=0A=
        item;=0A=
=0A=
    // convert and filter items=0A=
    for (var id in data) {=0A=
      if (data.hasOwnProperty(id)) {=0A=
        item =3D this._getItem(id, type);=0A=
        if (!filter || filter(item)) {=0A=
          mappedItems.push(callback(item, id));=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // order items=0A=
    if (options && options.order) {=0A=
      this._sort(mappedItems, options.order);=0A=
    }=0A=
=0A=
    return mappedItems;=0A=
  };=0A=
=0A=
  /**=0A=
   * Filter the fields of an item=0A=
   * @param {Object | null} item=0A=
   * @param {String[]} fields     Field names=0A=
   * @return {Object | null} filteredItem or null if no item is provided=0A=
   * @private=0A=
   */=0A=
  DataSet.prototype._filterFields =3D function (item, fields) {=0A=
    if (!item) {=0A=
      // item is null=0A=
      return item;=0A=
    }=0A=
=0A=
    var filteredItem =3D {};=0A=
=0A=
    if (Array.isArray(fields)) {=0A=
      for (var field in item) {=0A=
        if (item.hasOwnProperty(field) && fields.indexOf(field) !=3D -1) =
{=0A=
          filteredItem[field] =3D item[field];=0A=
        }=0A=
      }=0A=
    } else {=0A=
      for (var field in item) {=0A=
        if (item.hasOwnProperty(field) && fields.hasOwnProperty(field)) {=0A=
          filteredItem[fields[field]] =3D item[field];=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return filteredItem;=0A=
  };=0A=
=0A=
  /**=0A=
   * Sort the provided array with items=0A=
   * @param {Object[]} items=0A=
   * @param {String | function} order      A field name or custom sort =
function.=0A=
   * @private=0A=
   */=0A=
  DataSet.prototype._sort =3D function (items, order) {=0A=
    if (util.isString(order)) {=0A=
      // order by provided field name=0A=
      var name =3D order; // field name=0A=
      items.sort(function (a, b) {=0A=
        var av =3D a[name];=0A=
        var bv =3D b[name];=0A=
        return av > bv ? 1 : av < bv ? -1 : 0;=0A=
      });=0A=
    } else if (typeof order =3D=3D=3D 'function') {=0A=
      // order by sort function=0A=
      items.sort(order);=0A=
    }=0A=
    // TODO: extend order by an Object {field:String, direction:String}=0A=
    //       where direction can be 'asc' or 'desc'=0A=
    else {=0A=
      throw new TypeError('Order must be a function or a string');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove an object by pointer or by id=0A=
   * @param {String | Number | Object | Array} id Object or id, or an =
array with=0A=
   *                                              objects or ids to be =
removed=0A=
   * @param {String} [senderId] Optional sender id=0A=
   * @return {Array} removedIds=0A=
   */=0A=
  DataSet.prototype.remove =3D function (id, senderId) {=0A=
    var removedIds =3D [],=0A=
        i,=0A=
        len,=0A=
        removedId;=0A=
=0A=
    if (Array.isArray(id)) {=0A=
      for (i =3D 0, len =3D id.length; i < len; i++) {=0A=
        removedId =3D this._remove(id[i]);=0A=
        if (removedId !=3D null) {=0A=
          removedIds.push(removedId);=0A=
        }=0A=
      }=0A=
    } else {=0A=
      removedId =3D this._remove(id);=0A=
      if (removedId !=3D null) {=0A=
        removedIds.push(removedId);=0A=
      }=0A=
    }=0A=
=0A=
    if (removedIds.length) {=0A=
      this._trigger('remove', { items: removedIds }, senderId);=0A=
    }=0A=
=0A=
    return removedIds;=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove an item by its id=0A=
   * @param {Number | String | Object} id   id or item=0A=
   * @returns {Number | String | null} id=0A=
   * @private=0A=
   */=0A=
  DataSet.prototype._remove =3D function (id) {=0A=
    if (util.isNumber(id) || util.isString(id)) {=0A=
      if (this._data[id]) {=0A=
        delete this._data[id];=0A=
        this.length--;=0A=
        return id;=0A=
      }=0A=
    } else if (id instanceof Object) {=0A=
      var itemId =3D id[this._fieldId];=0A=
      if (itemId && this._data[itemId]) {=0A=
        delete this._data[itemId];=0A=
        this.length--;=0A=
        return itemId;=0A=
      }=0A=
    }=0A=
    return null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Clear the data=0A=
   * @param {String} [senderId] Optional sender id=0A=
   * @return {Array} removedIds    The ids of all removed items=0A=
   */=0A=
  DataSet.prototype.clear =3D function (senderId) {=0A=
    var ids =3D Object.keys(this._data);=0A=
=0A=
    this._data =3D {};=0A=
    this.length =3D 0;=0A=
=0A=
    this._trigger('remove', { items: ids }, senderId);=0A=
=0A=
    return ids;=0A=
  };=0A=
=0A=
  /**=0A=
   * Find the item with maximum value of a specified field=0A=
   * @param {String} field=0A=
   * @return {Object | null} item  Item containing max value, or null if =
no items=0A=
   */=0A=
  DataSet.prototype.max =3D function (field) {=0A=
    var data =3D this._data,=0A=
        max =3D null,=0A=
        maxField =3D null;=0A=
=0A=
    for (var id in data) {=0A=
      if (data.hasOwnProperty(id)) {=0A=
        var item =3D data[id];=0A=
        var itemField =3D item[field];=0A=
        if (itemField !=3D null && (!max || itemField > maxField)) {=0A=
          max =3D item;=0A=
          maxField =3D itemField;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return max;=0A=
  };=0A=
=0A=
  /**=0A=
   * Find the item with minimum value of a specified field=0A=
   * @param {String} field=0A=
   * @return {Object | null} item  Item containing max value, or null if =
no items=0A=
   */=0A=
  DataSet.prototype.min =3D function (field) {=0A=
    var data =3D this._data,=0A=
        min =3D null,=0A=
        minField =3D null;=0A=
=0A=
    for (var id in data) {=0A=
      if (data.hasOwnProperty(id)) {=0A=
        var item =3D data[id];=0A=
        var itemField =3D item[field];=0A=
        if (itemField !=3D null && (!min || itemField < minField)) {=0A=
          min =3D item;=0A=
          minField =3D itemField;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return min;=0A=
  };=0A=
=0A=
  /**=0A=
   * Find all distinct values of a specified field=0A=
   * @param {String} field=0A=
   * @return {Array} values  Array containing all distinct values. If =
data items=0A=
   *                         do not contain the specified field are =
ignored.=0A=
   *                         The returned array is unordered.=0A=
   */=0A=
  DataSet.prototype.distinct =3D function (field) {=0A=
    var data =3D this._data;=0A=
    var values =3D [];=0A=
    var fieldType =3D this._options.type && this._options.type[field] || =
null;=0A=
    var count =3D 0;=0A=
    var i;=0A=
=0A=
    for (var prop in data) {=0A=
      if (data.hasOwnProperty(prop)) {=0A=
        var item =3D data[prop];=0A=
        var value =3D item[field];=0A=
        var exists =3D false;=0A=
        for (i =3D 0; i < count; i++) {=0A=
          if (values[i] =3D=3D value) {=0A=
            exists =3D true;=0A=
            break;=0A=
          }=0A=
        }=0A=
        if (!exists && value !=3D=3D undefined) {=0A=
          values[count] =3D value;=0A=
          count++;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    if (fieldType) {=0A=
      for (i =3D 0; i < values.length; i++) {=0A=
        values[i] =3D util.convert(values[i], fieldType);=0A=
      }=0A=
    }=0A=
=0A=
    return values;=0A=
  };=0A=
=0A=
  /**=0A=
   * Add a single item. Will fail when an item with the same id already =
exists.=0A=
   * @param {Object} item=0A=
   * @return {String} id=0A=
   * @private=0A=
   */=0A=
  DataSet.prototype._addItem =3D function (item) {=0A=
    var id =3D item[this._fieldId];=0A=
=0A=
    if (id !=3D undefined) {=0A=
      // check whether this id is already taken=0A=
      if (this._data[id]) {=0A=
        // item already exists=0A=
        throw new Error('Cannot add item: item with id ' + id + ' =
already exists');=0A=
      }=0A=
    } else {=0A=
      // generate an id=0A=
      id =3D util.randomUUID();=0A=
      item[this._fieldId] =3D id;=0A=
    }=0A=
=0A=
    var d =3D {};=0A=
    for (var field in item) {=0A=
      if (item.hasOwnProperty(field)) {=0A=
        var fieldType =3D this._type[field]; // type may be undefined=0A=
        d[field] =3D util.convert(item[field], fieldType);=0A=
      }=0A=
    }=0A=
    this._data[id] =3D d;=0A=
    this.length++;=0A=
=0A=
    return id;=0A=
  };=0A=
=0A=
  /**=0A=
   * Get an item. Fields can be converted to a specific type=0A=
   * @param {String} id=0A=
   * @param {Object.<String, String>} [types]  field types to convert=0A=
   * @return {Object | null} item=0A=
   * @private=0A=
   */=0A=
  DataSet.prototype._getItem =3D function (id, types) {=0A=
    var field, value;=0A=
=0A=
    // get the item from the dataset=0A=
    var raw =3D this._data[id];=0A=
    if (!raw) {=0A=
      return null;=0A=
    }=0A=
=0A=
    // convert the items field types=0A=
    var converted =3D {};=0A=
    if (types) {=0A=
      for (field in raw) {=0A=
        if (raw.hasOwnProperty(field)) {=0A=
          value =3D raw[field];=0A=
          converted[field] =3D util.convert(value, types[field]);=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // no field types specified, no converting needed=0A=
      for (field in raw) {=0A=
        if (raw.hasOwnProperty(field)) {=0A=
          value =3D raw[field];=0A=
          converted[field] =3D value;=0A=
        }=0A=
      }=0A=
    }=0A=
    return converted;=0A=
  };=0A=
=0A=
  /**=0A=
   * Update a single item: merge with existing item.=0A=
   * Will fail when the item has no id, or when there does not exist an =
item=0A=
   * with the same id.=0A=
   * @param {Object} item=0A=
   * @return {String} id=0A=
   * @private=0A=
   */=0A=
  DataSet.prototype._updateItem =3D function (item) {=0A=
    var id =3D item[this._fieldId];=0A=
    if (id =3D=3D undefined) {=0A=
      throw new Error('Cannot update item: item has no id (item: ' + =
JSON.stringify(item) + ')');=0A=
    }=0A=
    var d =3D this._data[id];=0A=
    if (!d) {=0A=
      // item doesn't exist=0A=
      throw new Error('Cannot update item: no item with id ' + id + ' =
found');=0A=
    }=0A=
=0A=
    // merge with current item=0A=
    for (var field in item) {=0A=
      if (item.hasOwnProperty(field)) {=0A=
        var fieldType =3D this._type[field]; // type may be undefined=0A=
        d[field] =3D util.convert(item[field], fieldType);=0A=
      }=0A=
    }=0A=
=0A=
    return id;=0A=
  };=0A=
=0A=
  module.exports =3D DataSet;=0A=
=0A=
/***/ },=0A=
/* 15 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * A queue=0A=
   * @param {Object} options=0A=
   *            Available options:=0A=
   *            - delay: number    When provided, the queue will be =
flushed=0A=
   *                               automatically after an inactivity of =
this delay=0A=
   *                               in milliseconds.=0A=
   *                               Default value is null.=0A=
   *            - max: number      When the queue exceeds the given =
maximum number=0A=
   *                               of entries, the queue is flushed =
automatically.=0A=
   *                               Default value of max is Infinity.=0A=
   * @constructor=0A=
   */=0A=
  'use strict';=0A=
=0A=
  function Queue(options) {=0A=
    // options=0A=
    this.delay =3D null;=0A=
    this.max =3D Infinity;=0A=
=0A=
    // properties=0A=
    this._queue =3D [];=0A=
    this._timeout =3D null;=0A=
    this._extended =3D null;=0A=
=0A=
    this.setOptions(options);=0A=
  }=0A=
=0A=
  /**=0A=
   * Update the configuration of the queue=0A=
   * @param {Object} options=0A=
   *            Available options:=0A=
   *            - delay: number    When provided, the queue will be =
flushed=0A=
   *                               automatically after an inactivity of =
this delay=0A=
   *                               in milliseconds.=0A=
   *                               Default value is null.=0A=
   *            - max: number      When the queue exceeds the given =
maximum number=0A=
   *                               of entries, the queue is flushed =
automatically.=0A=
   *                               Default value of max is Infinity.=0A=
   * @param options=0A=
   */=0A=
  Queue.prototype.setOptions =3D function (options) {=0A=
    if (options && typeof options.delay !=3D=3D 'undefined') {=0A=
      this.delay =3D options.delay;=0A=
    }=0A=
    if (options && typeof options.max !=3D=3D 'undefined') {=0A=
      this.max =3D options.max;=0A=
    }=0A=
=0A=
    this._flushIfNeeded();=0A=
  };=0A=
=0A=
  /**=0A=
   * Extend an object with queuing functionality.=0A=
   * The object will be extended with a function flush, and the methods =
provided=0A=
   * in options.replace will be replaced with queued ones.=0A=
   * @param {Object} object=0A=
   * @param {Object} options=0A=
   *            Available options:=0A=
   *            - replace: Array.<string>=0A=
   *                               A list with method names of the =
methods=0A=
   *                               on the object to be replaced with =
queued ones.=0A=
   *            - delay: number    When provided, the queue will be =
flushed=0A=
   *                               automatically after an inactivity of =
this delay=0A=
   *                               in milliseconds.=0A=
   *                               Default value is null.=0A=
   *            - max: number      When the queue exceeds the given =
maximum number=0A=
   *                               of entries, the queue is flushed =
automatically.=0A=
   *                               Default value of max is Infinity.=0A=
   * @return {Queue} Returns the created queue=0A=
   */=0A=
  Queue.extend =3D function (object, options) {=0A=
    var queue =3D new Queue(options);=0A=
=0A=
    if (object.flush !=3D=3D undefined) {=0A=
      throw new Error('Target object already has a property flush');=0A=
    }=0A=
    object.flush =3D function () {=0A=
      queue.flush();=0A=
    };=0A=
=0A=
    var methods =3D [{=0A=
      name: 'flush',=0A=
      original: undefined=0A=
    }];=0A=
=0A=
    if (options && options.replace) {=0A=
      for (var i =3D 0; i < options.replace.length; i++) {=0A=
        var name =3D options.replace[i];=0A=
        methods.push({=0A=
          name: name,=0A=
          original: object[name]=0A=
        });=0A=
        queue.replace(object, name);=0A=
      }=0A=
    }=0A=
=0A=
    queue._extended =3D {=0A=
      object: object,=0A=
      methods: methods=0A=
    };=0A=
=0A=
    return queue;=0A=
  };=0A=
=0A=
  /**=0A=
   * Destroy the queue. The queue will first flush all queued actions, =
and in=0A=
   * case it has extended an object, will restore the original object.=0A=
   */=0A=
  Queue.prototype.destroy =3D function () {=0A=
    this.flush();=0A=
=0A=
    if (this._extended) {=0A=
      var object =3D this._extended.object;=0A=
      var methods =3D this._extended.methods;=0A=
      for (var i =3D 0; i < methods.length; i++) {=0A=
        var method =3D methods[i];=0A=
        if (method.original) {=0A=
          object[method.name] =3D method.original;=0A=
        } else {=0A=
          delete object[method.name];=0A=
        }=0A=
      }=0A=
      this._extended =3D null;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Replace a method on an object with a queued version=0A=
   * @param {Object} object   Object having the method=0A=
   * @param {string} method   The method name=0A=
   */=0A=
  Queue.prototype.replace =3D function (object, method) {=0A=
    var me =3D this;=0A=
    var original =3D object[method];=0A=
    if (!original) {=0A=
      throw new Error('Method ' + method + ' undefined');=0A=
    }=0A=
=0A=
    object[method] =3D function () {=0A=
      // create an Array with the arguments=0A=
      var args =3D [];=0A=
      for (var i =3D 0; i < arguments.length; i++) {=0A=
        args[i] =3D arguments[i];=0A=
      }=0A=
=0A=
      // add this call to the queue=0A=
      me.queue({=0A=
        args: args,=0A=
        fn: original,=0A=
        context: this=0A=
      });=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Queue a call=0A=
   * @param {function | {fn: function, args: Array} | {fn: function, =
args: Array, context: Object}} entry=0A=
   */=0A=
  Queue.prototype.queue =3D function (entry) {=0A=
    if (typeof entry =3D=3D=3D 'function') {=0A=
      this._queue.push({ fn: entry });=0A=
    } else {=0A=
      this._queue.push(entry);=0A=
    }=0A=
=0A=
    this._flushIfNeeded();=0A=
  };=0A=
=0A=
  /**=0A=
   * Check whether the queue needs to be flushed=0A=
   * @private=0A=
   */=0A=
  Queue.prototype._flushIfNeeded =3D function () {=0A=
    // flush when the maximum is exceeded.=0A=
    if (this._queue.length > this.max) {=0A=
      this.flush();=0A=
    }=0A=
=0A=
    // flush after a period of inactivity when a delay is configured=0A=
    clearTimeout(this._timeout);=0A=
    if (this.queue.length > 0 && typeof this.delay =3D=3D=3D 'number') {=0A=
      var me =3D this;=0A=
      this._timeout =3D setTimeout(function () {=0A=
        me.flush();=0A=
      }, this.delay);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Flush all queued calls=0A=
   */=0A=
  Queue.prototype.flush =3D function () {=0A=
    while (this._queue.length > 0) {=0A=
      var entry =3D this._queue.shift();=0A=
      entry.fn.apply(entry.context || entry.fn, entry.args || []);=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D Queue;=0A=
=0A=
/***/ },=0A=
/* 16 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
=0A=
  /**=0A=
   * DataView=0A=
   *=0A=
   * a dataview offers a filtered view on a dataset or an other dataview.=0A=
   *=0A=
   * @param {DataSet | DataView} data=0A=
   * @param {Object} [options]   Available options: see method get=0A=
   *=0A=
   * @constructor DataView=0A=
   */=0A=
  function DataView(data, options) {=0A=
    this._data =3D null;=0A=
    this._ids =3D {}; // ids of the items currently in memory (just =
contains a boolean true)=0A=
    this.length =3D 0; // number of items in the DataView=0A=
    this._options =3D options || {};=0A=
    this._fieldId =3D 'id'; // name of the field containing id=0A=
    this._subscribers =3D {}; // event subscribers=0A=
=0A=
    var me =3D this;=0A=
    this.listener =3D function () {=0A=
      me._onEvent.apply(me, arguments);=0A=
    };=0A=
=0A=
    this.setData(data);=0A=
  }=0A=
=0A=
  // TODO: implement a function .config() to dynamically update things =
like configured filter=0A=
  // and trigger changes accordingly=0A=
=0A=
  /**=0A=
   * Set a data source for the view=0A=
   * @param {DataSet | DataView} data=0A=
   */=0A=
  DataView.prototype.setData =3D function (data) {=0A=
    var ids, i, len;=0A=
=0A=
    if (this._data) {=0A=
      // unsubscribe from current dataset=0A=
      if (this._data.off) {=0A=
        this._data.off('*', this.listener);=0A=
      }=0A=
=0A=
      // trigger a remove of all items in memory=0A=
      ids =3D [];=0A=
      for (var id in this._ids) {=0A=
        if (this._ids.hasOwnProperty(id)) {=0A=
          ids.push(id);=0A=
        }=0A=
      }=0A=
      this._ids =3D {};=0A=
      this.length =3D 0;=0A=
      this._trigger('remove', { items: ids });=0A=
    }=0A=
=0A=
    this._data =3D data;=0A=
=0A=
    if (this._data) {=0A=
      // update fieldId=0A=
      this._fieldId =3D this._options.fieldId || this._data && =
this._data.options && this._data.options.fieldId || 'id';=0A=
=0A=
      // trigger an add of all added items=0A=
      ids =3D this._data.getIds({ filter: this._options && =
this._options.filter });=0A=
      for (i =3D 0, len =3D ids.length; i < len; i++) {=0A=
        id =3D ids[i];=0A=
        this._ids[id] =3D true;=0A=
      }=0A=
      this.length =3D ids.length;=0A=
      this._trigger('add', { items: ids });=0A=
=0A=
      // subscribe to new dataset=0A=
      if (this._data.on) {=0A=
        this._data.on('*', this.listener);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Refresh the DataView. Useful when the DataView has a filter function=0A=
   * containing a variable parameter.=0A=
   */=0A=
  DataView.prototype.refresh =3D function () {=0A=
    var id;=0A=
    var ids =3D this._data.getIds({ filter: this._options && =
this._options.filter });=0A=
    var newIds =3D {};=0A=
    var added =3D [];=0A=
    var removed =3D [];=0A=
=0A=
    // check for additions=0A=
    for (var i =3D 0; i < ids.length; i++) {=0A=
      id =3D ids[i];=0A=
      newIds[id] =3D true;=0A=
      if (!this._ids[id]) {=0A=
        added.push(id);=0A=
        this._ids[id] =3D true;=0A=
        this.length++;=0A=
      }=0A=
    }=0A=
=0A=
    // check for removals=0A=
    for (id in this._ids) {=0A=
      if (this._ids.hasOwnProperty(id)) {=0A=
        if (!newIds[id]) {=0A=
          removed.push(id);=0A=
          delete this._ids[id];=0A=
          this.length--;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // trigger events=0A=
    if (added.length) {=0A=
      this._trigger('add', { items: added });=0A=
    }=0A=
    if (removed.length) {=0A=
      this._trigger('remove', { items: removed });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get data from the data view=0A=
   *=0A=
   * Usage:=0A=
   *=0A=
   *     get()=0A=
   *     get(options: Object)=0A=
   *     get(options: Object, data: Array | DataTable)=0A=
   *=0A=
   *     get(id: Number)=0A=
   *     get(id: Number, options: Object)=0A=
   *     get(id: Number, options: Object, data: Array | DataTable)=0A=
   *=0A=
   *     get(ids: Number[])=0A=
   *     get(ids: Number[], options: Object)=0A=
   *     get(ids: Number[], options: Object, data: Array | DataTable)=0A=
   *=0A=
   * Where:=0A=
   *=0A=
   * {Number | String} id         The id of an item=0A=
   * {Number[] | String{}} ids    An array with ids of items=0A=
   * {Object} options             An Object with options. Available =
options:=0A=
   *                              {String} [type] Type of data to be =
returned. Can=0A=
   *                                              be 'DataTable' or =
'Array' (default)=0A=
   *                              {Object.<String, String>} [convert]=0A=
   *                              {String[]} [fields] field names to be =
returned=0A=
   *                              {function} [filter] filter items=0A=
   *                              {String | function} [order] Order the =
items by=0A=
   *                                  a field name or custom sort =
function.=0A=
   * {Array | DataTable} [data]   If provided, items will be appended to =
this=0A=
   *                              array or table. Required in case of =
Google=0A=
   *                              DataTable.=0A=
   * @param args=0A=
   */=0A=
  DataView.prototype.get =3D function (args) {=0A=
    var me =3D this;=0A=
=0A=
    // parse the arguments=0A=
    var ids, options, data;=0A=
    var firstType =3D util.getType(arguments[0]);=0A=
    if (firstType =3D=3D 'String' || firstType =3D=3D 'Number' || =
firstType =3D=3D 'Array') {=0A=
      // get(id(s) [, options] [, data])=0A=
      ids =3D arguments[0]; // can be a single id or an array with ids=0A=
      options =3D arguments[1];=0A=
      data =3D arguments[2];=0A=
    } else {=0A=
      // get([, options] [, data])=0A=
      options =3D arguments[0];=0A=
      data =3D arguments[1];=0A=
    }=0A=
=0A=
    // extend the options with the default options and provided options=0A=
    var viewOptions =3D util.extend({}, this._options, options);=0A=
=0A=
    // create a combined filter method when needed=0A=
    if (this._options.filter && options && options.filter) {=0A=
      viewOptions.filter =3D function (item) {=0A=
        return me._options.filter(item) && options.filter(item);=0A=
      };=0A=
    }=0A=
=0A=
    // build up the call to the linked data set=0A=
    var getArguments =3D [];=0A=
    if (ids !=3D undefined) {=0A=
      getArguments.push(ids);=0A=
    }=0A=
    getArguments.push(viewOptions);=0A=
    getArguments.push(data);=0A=
=0A=
    return this._data && this._data.get.apply(this._data, getArguments);=0A=
  };=0A=
=0A=
  /**=0A=
   * Get ids of all items or from a filtered set of items.=0A=
   * @param {Object} [options]    An Object with options. Available =
options:=0A=
   *                              {function} [filter] filter items=0A=
   *                              {String | function} [order] Order the =
items by=0A=
   *                                  a field name or custom sort =
function.=0A=
   * @return {Array} ids=0A=
   */=0A=
  DataView.prototype.getIds =3D function (options) {=0A=
    var ids;=0A=
=0A=
    if (this._data) {=0A=
      var defaultFilter =3D this._options.filter;=0A=
      var filter;=0A=
=0A=
      if (options && options.filter) {=0A=
        if (defaultFilter) {=0A=
          filter =3D function (item) {=0A=
            return defaultFilter(item) && options.filter(item);=0A=
          };=0A=
        } else {=0A=
          filter =3D options.filter;=0A=
        }=0A=
      } else {=0A=
        filter =3D defaultFilter;=0A=
      }=0A=
=0A=
      ids =3D this._data.getIds({=0A=
        filter: filter,=0A=
        order: options && options.order=0A=
      });=0A=
    } else {=0A=
      ids =3D [];=0A=
    }=0A=
=0A=
    return ids;=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the DataSet to which this DataView is connected. In case there =
is a chain=0A=
   * of multiple DataViews, the root DataSet of this chain is returned.=0A=
   * @return {DataSet} dataSet=0A=
   */=0A=
  DataView.prototype.getDataSet =3D function () {=0A=
    var dataSet =3D this;=0A=
    while (dataSet instanceof DataView) {=0A=
      dataSet =3D dataSet._data;=0A=
    }=0A=
    return dataSet || null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Event listener. Will propagate all events from the connected data =
set to=0A=
   * the subscribers of the DataView, but will filter the items and only =
trigger=0A=
   * when there are changes in the filtered data set.=0A=
   * @param {String} event=0A=
   * @param {Object | null} params=0A=
   * @param {String} senderId=0A=
   * @private=0A=
   */=0A=
  DataView.prototype._onEvent =3D function (event, params, senderId) {=0A=
    var i, len, id, item;=0A=
    var ids =3D params && params.items;=0A=
    var data =3D this._data;=0A=
    var updatedData =3D [];=0A=
    var added =3D [];=0A=
    var updated =3D [];=0A=
    var removed =3D [];=0A=
=0A=
    if (ids && data) {=0A=
      switch (event) {=0A=
        case 'add':=0A=
          // filter the ids of the added items=0A=
          for (i =3D 0, len =3D ids.length; i < len; i++) {=0A=
            id =3D ids[i];=0A=
            item =3D this.get(id);=0A=
            if (item) {=0A=
              this._ids[id] =3D true;=0A=
              added.push(id);=0A=
            }=0A=
          }=0A=
=0A=
          break;=0A=
=0A=
        case 'update':=0A=
          // determine the event from the views viewpoint: an updated=0A=
          // item can be added, updated, or removed from this view.=0A=
          for (i =3D 0, len =3D ids.length; i < len; i++) {=0A=
            id =3D ids[i];=0A=
            item =3D this.get(id);=0A=
=0A=
            if (item) {=0A=
              if (this._ids[id]) {=0A=
                updated.push(id);=0A=
                updatedData.push(params.data[i]);=0A=
              } else {=0A=
                this._ids[id] =3D true;=0A=
                added.push(id);=0A=
              }=0A=
            } else {=0A=
              if (this._ids[id]) {=0A=
                delete this._ids[id];=0A=
                removed.push(id);=0A=
              } else {}=0A=
            }=0A=
          }=0A=
=0A=
          break;=0A=
=0A=
        case 'remove':=0A=
          // filter the ids of the removed items=0A=
          for (i =3D 0, len =3D ids.length; i < len; i++) {=0A=
            id =3D ids[i];=0A=
            if (this._ids[id]) {=0A=
              delete this._ids[id];=0A=
              removed.push(id);=0A=
            }=0A=
          }=0A=
=0A=
          break;=0A=
      }=0A=
=0A=
      this.length +=3D added.length - removed.length;=0A=
=0A=
      if (added.length) {=0A=
        this._trigger('add', { items: added }, senderId);=0A=
      }=0A=
      if (updated.length) {=0A=
        this._trigger('update', { items: updated, data: updatedData }, =
senderId);=0A=
      }=0A=
      if (removed.length) {=0A=
        this._trigger('remove', { items: removed }, senderId);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  // copy subscription functionality from DataSet=0A=
  DataView.prototype.on =3D DataSet.prototype.on;=0A=
  DataView.prototype.off =3D DataSet.prototype.off;=0A=
  DataView.prototype._trigger =3D DataSet.prototype._trigger;=0A=
=0A=
  // TODO: make these functions deprecated (replaced with `on` and `off` =
since version 0.5)=0A=
  DataView.prototype.subscribe =3D DataView.prototype.on;=0A=
  DataView.prototype.unsubscribe =3D DataView.prototype.off;=0A=
=0A=
  module.exports =3D DataView;=0A=
=0A=
  // nothing interesting for me :-(=0A=
=0A=
/***/ },=0A=
/* 17 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Emitter =3D __webpack_require__(19);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
  var util =3D __webpack_require__(7);=0A=
  var Point3d =3D __webpack_require__(20);=0A=
  var Point2d =3D __webpack_require__(18);=0A=
  var Camera =3D __webpack_require__(21);=0A=
  var Filter =3D __webpack_require__(22);=0A=
  var Slider =3D __webpack_require__(23);=0A=
  var StepNumber =3D __webpack_require__(24);=0A=
=0A=
  /**=0A=
   * @constructor Graph3d=0A=
   * Graph3d displays data in 3d.=0A=
   *=0A=
   * Graph3d is developed in javascript as a Google Visualization Chart.=0A=
   *=0A=
   * @param {Element} container   The DOM element in which the Graph3d =
will=0A=
   *                              be created. Normally a div element.=0A=
   * @param {DataSet | DataView | Array} [data]=0A=
   * @param {Object} [options]=0A=
   */=0A=
  function Graph3d(container, data, options) {=0A=
    if (!(this instanceof Graph3d)) {=0A=
      throw new SyntaxError('Constructor must be called with the new =
operator');=0A=
    }=0A=
=0A=
    // create variables and set default values=0A=
    this.containerElement =3D container;=0A=
    this.width =3D '400px';=0A=
    this.height =3D '400px';=0A=
    this.margin =3D 10; // px=0A=
    this.defaultXCenter =3D '55%';=0A=
    this.defaultYCenter =3D '50%';=0A=
=0A=
    this.xLabel =3D 'x';=0A=
    this.yLabel =3D 'y';=0A=
    this.zLabel =3D 'z';=0A=
=0A=
    var passValueFn =3D function passValueFn(v) {=0A=
      return v;=0A=
    };=0A=
    this.xValueLabel =3D passValueFn;=0A=
    this.yValueLabel =3D passValueFn;=0A=
    this.zValueLabel =3D passValueFn;=0A=
=0A=
    this.filterLabel =3D 'time';=0A=
    this.legendLabel =3D 'value';=0A=
=0A=
    this.style =3D Graph3d.STYLE.DOT;=0A=
    this.showPerspective =3D true;=0A=
    this.showGrid =3D true;=0A=
    this.keepAspectRatio =3D true;=0A=
    this.showShadow =3D false;=0A=
    this.showGrayBottom =3D false; // TODO: this does not work correctly=0A=
    this.showTooltip =3D false;=0A=
    this.verticalRatio =3D 0.5; // 0.1 to 1.0, where 1.0 results in a =
'cube'=0A=
=0A=
    this.animationInterval =3D 1000; // milliseconds=0A=
    this.animationPreload =3D false;=0A=
=0A=
    this.camera =3D new Camera();=0A=
    this.camera.setArmRotation(1.0, 0.5);=0A=
    this.camera.setArmLength(1.7);=0A=
    this.eye =3D new Point3d(0, 0, -1); // TODO: set eye.z about 3/4 of =
the width of the window?=0A=
=0A=
    this.dataTable =3D null; // The original data table=0A=
    this.dataPoints =3D null; // The table with point objects=0A=
=0A=
    // the column indexes=0A=
    this.colX =3D undefined;=0A=
    this.colY =3D undefined;=0A=
    this.colZ =3D undefined;=0A=
    this.colValue =3D undefined;=0A=
    this.colFilter =3D undefined;=0A=
=0A=
    this.xMin =3D 0;=0A=
    this.xStep =3D undefined; // auto by default=0A=
    this.xMax =3D 1;=0A=
    this.yMin =3D 0;=0A=
    this.yStep =3D undefined; // auto by default=0A=
    this.yMax =3D 1;=0A=
    this.zMin =3D 0;=0A=
    this.zStep =3D undefined; // auto by default=0A=
    this.zMax =3D 1;=0A=
    this.valueMin =3D 0;=0A=
    this.valueMax =3D 1;=0A=
    this.xBarWidth =3D 1;=0A=
    this.yBarWidth =3D 1;=0A=
    // TODO: customize axis range=0A=
=0A=
    // colors=0A=
    this.axisColor =3D '#4D4D4D';=0A=
    this.gridColor =3D '#D3D3D3';=0A=
    this.dataColor =3D {=0A=
      fill: '#7DC1FF',=0A=
      stroke: '#3267D2',=0A=
      strokeWidth: 1 // px=0A=
    };=0A=
=0A=
    // create a frame and canvas=0A=
    this.create();=0A=
=0A=
    // apply options (also when undefined)=0A=
    this.setOptions(options);=0A=
=0A=
    // apply data=0A=
    if (data) {=0A=
      this.setData(data);=0A=
    }=0A=
  }=0A=
=0A=
  // Extend Graph3d with an Emitter mixin=0A=
  Emitter(Graph3d.prototype);=0A=
=0A=
  /**=0A=
   * Calculate the scaling values, dependent on the range in x, y, and z =
direction=0A=
   */=0A=
  Graph3d.prototype._setScale =3D function () {=0A=
    this.scale =3D new Point3d(1 / (this.xMax - this.xMin), 1 / =
(this.yMax - this.yMin), 1 / (this.zMax - this.zMin));=0A=
=0A=
    // keep aspect ration between x and y scale if desired=0A=
    if (this.keepAspectRatio) {=0A=
      if (this.scale.x < this.scale.y) {=0A=
        //noinspection JSSuspiciousNameCombination=0A=
        this.scale.y =3D this.scale.x;=0A=
      } else {=0A=
        //noinspection JSSuspiciousNameCombination=0A=
        this.scale.x =3D this.scale.y;=0A=
      }=0A=
    }=0A=
=0A=
    // scale the vertical axis=0A=
    this.scale.z *=3D this.verticalRatio;=0A=
    // TODO: can this be automated? verticalRatio?=0A=
=0A=
    // determine scale for (optional) value=0A=
    this.scale.value =3D 1 / (this.valueMax - this.valueMin);=0A=
=0A=
    // position the camera arm=0A=
    var xCenter =3D (this.xMax + this.xMin) / 2 * this.scale.x;=0A=
    var yCenter =3D (this.yMax + this.yMin) / 2 * this.scale.y;=0A=
    var zCenter =3D (this.zMax + this.zMin) / 2 * this.scale.z;=0A=
    this.camera.setArmLocation(xCenter, yCenter, zCenter);=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a 3D location to a 2D location on screen=0A=
   * http://en.wikipedia.org/wiki/3D_projection=0A=
   * @param {Point3d} point3d   A 3D point with parameters x, y, z=0A=
   * @return {Point2d} point2d  A 2D point with parameters x, y=0A=
   */=0A=
  Graph3d.prototype._convert3Dto2D =3D function (point3d) {=0A=
    var translation =3D this._convertPointToTranslation(point3d);=0A=
    return this._convertTranslationToScreen(translation);=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a 3D location its translation seen from the camera=0A=
   * http://en.wikipedia.org/wiki/3D_projection=0A=
   * @param {Point3d} point3d    A 3D point with parameters x, y, z=0A=
   * @return {Point3d} translation A 3D point with parameters x, y, z =
This is=0A=
   *                   the translation of the point, seen from the=0A=
   *                   camera=0A=
   */=0A=
  Graph3d.prototype._convertPointToTranslation =3D function (point3d) {=0A=
    var ax =3D point3d.x * this.scale.x,=0A=
        ay =3D point3d.y * this.scale.y,=0A=
        az =3D point3d.z * this.scale.z,=0A=
        cx =3D this.camera.getCameraLocation().x,=0A=
        cy =3D this.camera.getCameraLocation().y,=0A=
        cz =3D this.camera.getCameraLocation().z,=0A=
=0A=
    // calculate angles=0A=
    sinTx =3D Math.sin(this.camera.getCameraRotation().x),=0A=
        cosTx =3D Math.cos(this.camera.getCameraRotation().x),=0A=
        sinTy =3D Math.sin(this.camera.getCameraRotation().y),=0A=
        cosTy =3D Math.cos(this.camera.getCameraRotation().y),=0A=
        sinTz =3D Math.sin(this.camera.getCameraRotation().z),=0A=
        cosTz =3D Math.cos(this.camera.getCameraRotation().z),=0A=
=0A=
    // calculate translation=0A=
    dx =3D cosTy * (sinTz * (ay - cy) + cosTz * (ax - cx)) - sinTy * (az =
- cz),=0A=
        dy =3D sinTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + =
cosTz * (ax - cx))) + cosTx * (cosTz * (ay - cy) - sinTz * (ax - cx)),=0A=
        dz =3D cosTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + =
cosTz * (ax - cx))) - sinTx * (cosTz * (ay - cy) - sinTz * (ax - cx));=0A=
=0A=
    return new Point3d(dx, dy, dz);=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a translation point to a point on the screen=0A=
   * @param {Point3d} translation   A 3D point with parameters x, y, z =
This is=0A=
   *                    the translation of the point, seen from the=0A=
   *                    camera=0A=
   * @return {Point2d} point2d    A 2D point with parameters x, y=0A=
   */=0A=
  Graph3d.prototype._convertTranslationToScreen =3D function =
(translation) {=0A=
    var ex =3D this.eye.x,=0A=
        ey =3D this.eye.y,=0A=
        ez =3D this.eye.z,=0A=
        dx =3D translation.x,=0A=
        dy =3D translation.y,=0A=
        dz =3D translation.z;=0A=
=0A=
    // calculate position on screen from translation=0A=
    var bx;=0A=
    var by;=0A=
    if (this.showPerspective) {=0A=
      bx =3D (dx - ex) * (ez / dz);=0A=
      by =3D (dy - ey) * (ez / dz);=0A=
    } else {=0A=
      bx =3D dx * -(ez / this.camera.getArmLength());=0A=
      by =3D dy * -(ez / this.camera.getArmLength());=0A=
    }=0A=
=0A=
    // shift and scale the point to the center of the screen=0A=
    // use the width of the graph to scale both horizontally and =
vertically.=0A=
    return new Point2d(this.xcenter + bx * =
this.frame.canvas.clientWidth, this.ycenter - by * =
this.frame.canvas.clientWidth);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the background styling for the graph=0A=
   * @param {string | {fill: string, stroke: string, strokeWidth: =
string}} backgroundColor=0A=
   */=0A=
  Graph3d.prototype._setBackgroundColor =3D function (backgroundColor) {=0A=
    var fill =3D 'white';=0A=
    var stroke =3D 'gray';=0A=
    var strokeWidth =3D 1;=0A=
=0A=
    if (typeof backgroundColor =3D=3D=3D 'string') {=0A=
      fill =3D backgroundColor;=0A=
      stroke =3D 'none';=0A=
      strokeWidth =3D 0;=0A=
    } else if (typeof backgroundColor =3D=3D=3D 'object') {=0A=
      if (backgroundColor.fill !=3D=3D undefined) fill =3D =
backgroundColor.fill;=0A=
      if (backgroundColor.stroke !=3D=3D undefined) stroke =3D =
backgroundColor.stroke;=0A=
      if (backgroundColor.strokeWidth !=3D=3D undefined) strokeWidth =3D =
backgroundColor.strokeWidth;=0A=
    } else if (backgroundColor =3D=3D=3D undefined) {} else {=0A=
      throw 'Unsupported type of backgroundColor';=0A=
    }=0A=
=0A=
    this.frame.style.backgroundColor =3D fill;=0A=
    this.frame.style.borderColor =3D stroke;=0A=
    this.frame.style.borderWidth =3D strokeWidth + 'px';=0A=
    this.frame.style.borderStyle =3D 'solid';=0A=
  };=0A=
=0A=
  /// enumerate the available styles=0A=
  Graph3d.STYLE =3D {=0A=
    BAR: 0,=0A=
    BARCOLOR: 1,=0A=
    BARSIZE: 2,=0A=
    DOT: 3,=0A=
    DOTLINE: 4,=0A=
    DOTCOLOR: 5,=0A=
    DOTSIZE: 6,=0A=
    GRID: 7,=0A=
    LINE: 8,=0A=
    SURFACE: 9=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the style index from given styleName=0A=
   * @param {string} styleName  Style name such as 'dot', 'grid', =
'dot-line'=0A=
   * @return {Number} styleNumber Enumeration value representing the =
style, or -1=0A=
   *                when not found=0A=
   */=0A=
  Graph3d.prototype._getStyleNumber =3D function (styleName) {=0A=
    switch (styleName) {=0A=
      case 'dot':=0A=
        return Graph3d.STYLE.DOT;=0A=
      case 'dot-line':=0A=
        return Graph3d.STYLE.DOTLINE;=0A=
      case 'dot-color':=0A=
        return Graph3d.STYLE.DOTCOLOR;=0A=
      case 'dot-size':=0A=
        return Graph3d.STYLE.DOTSIZE;=0A=
      case 'line':=0A=
        return Graph3d.STYLE.LINE;=0A=
      case 'grid':=0A=
        return Graph3d.STYLE.GRID;=0A=
      case 'surface':=0A=
        return Graph3d.STYLE.SURFACE;=0A=
      case 'bar':=0A=
        return Graph3d.STYLE.BAR;=0A=
      case 'bar-color':=0A=
        return Graph3d.STYLE.BARCOLOR;=0A=
      case 'bar-size':=0A=
        return Graph3d.STYLE.BARSIZE;=0A=
    }=0A=
=0A=
    return -1;=0A=
  };=0A=
=0A=
  /**=0A=
   * Determine the indexes of the data columns, based on the given style =
and data=0A=
   * @param {DataSet} data=0A=
   * @param {Number}  style=0A=
   */=0A=
  Graph3d.prototype._determineColumnIndexes =3D function (data, style) {=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.DOT || this.style =3D=3D=3D =
Graph3d.STYLE.DOTLINE || this.style =3D=3D=3D Graph3d.STYLE.LINE || =
this.style =3D=3D=3D Graph3d.STYLE.GRID || this.style =3D=3D=3D =
Graph3d.STYLE.SURFACE || this.style =3D=3D=3D Graph3d.STYLE.BAR) {=0A=
      // 3 columns expected, and optionally a 4th with filter values=0A=
      this.colX =3D 0;=0A=
      this.colY =3D 1;=0A=
      this.colZ =3D 2;=0A=
      this.colValue =3D undefined;=0A=
=0A=
      if (data.getNumberOfColumns() > 3) {=0A=
        this.colFilter =3D 3;=0A=
      }=0A=
    } else if (this.style =3D=3D=3D Graph3d.STYLE.DOTCOLOR || this.style =
=3D=3D=3D Graph3d.STYLE.DOTSIZE || this.style =3D=3D=3D =
Graph3d.STYLE.BARCOLOR || this.style =3D=3D=3D Graph3d.STYLE.BARSIZE) {=0A=
      // 4 columns expected, and optionally a 5th with filter values=0A=
      this.colX =3D 0;=0A=
      this.colY =3D 1;=0A=
      this.colZ =3D 2;=0A=
      this.colValue =3D 3;=0A=
=0A=
      if (data.getNumberOfColumns() > 4) {=0A=
        this.colFilter =3D 4;=0A=
      }=0A=
    } else {=0A=
      throw 'Unknown style "' + this.style + '"';=0A=
    }=0A=
  };=0A=
=0A=
  Graph3d.prototype.getNumberOfRows =3D function (data) {=0A=
    return data.length;=0A=
  };=0A=
=0A=
  Graph3d.prototype.getNumberOfColumns =3D function (data) {=0A=
    var counter =3D 0;=0A=
    for (var column in data[0]) {=0A=
      if (data[0].hasOwnProperty(column)) {=0A=
        counter++;=0A=
      }=0A=
    }=0A=
    return counter;=0A=
  };=0A=
=0A=
  Graph3d.prototype.getDistinctValues =3D function (data, column) {=0A=
    var distinctValues =3D [];=0A=
    for (var i =3D 0; i < data.length; i++) {=0A=
      if (distinctValues.indexOf(data[i][column]) =3D=3D -1) {=0A=
        distinctValues.push(data[i][column]);=0A=
      }=0A=
    }=0A=
    return distinctValues;=0A=
  };=0A=
=0A=
  Graph3d.prototype.getColumnRange =3D function (data, column) {=0A=
    var minMax =3D { min: data[0][column], max: data[0][column] };=0A=
    for (var i =3D 0; i < data.length; i++) {=0A=
      if (minMax.min > data[i][column]) {=0A=
        minMax.min =3D data[i][column];=0A=
      }=0A=
      if (minMax.max < data[i][column]) {=0A=
        minMax.max =3D data[i][column];=0A=
      }=0A=
    }=0A=
    return minMax;=0A=
  };=0A=
=0A=
  /**=0A=
   * Initialize the data from the data table. Calculate minimum and =
maximum values=0A=
   * and column index values=0A=
   * @param {Array | DataSet | DataView} rawData   The data containing =
the items for the Graph.=0A=
   * @param {Number}     style   Style Number=0A=
   */=0A=
  Graph3d.prototype._dataInitialize =3D function (rawData, style) {=0A=
    var me =3D this;=0A=
=0A=
    // unsubscribe from the dataTable=0A=
    if (this.dataSet) {=0A=
      this.dataSet.off('*', this._onChange);=0A=
    }=0A=
=0A=
    if (rawData =3D=3D=3D undefined) return;=0A=
=0A=
    if (Array.isArray(rawData)) {=0A=
      rawData =3D new DataSet(rawData);=0A=
    }=0A=
=0A=
    var data;=0A=
    if (rawData instanceof DataSet || rawData instanceof DataView) {=0A=
      data =3D rawData.get();=0A=
    } else {=0A=
      throw new Error('Array, DataSet, or DataView expected');=0A=
    }=0A=
=0A=
    if (data.length =3D=3D 0) return;=0A=
=0A=
    this.dataSet =3D rawData;=0A=
    this.dataTable =3D data;=0A=
=0A=
    // subscribe to changes in the dataset=0A=
    this._onChange =3D function () {=0A=
      me.setData(me.dataSet);=0A=
    };=0A=
    this.dataSet.on('*', this._onChange);=0A=
=0A=
    // _determineColumnIndexes=0A=
    // getNumberOfRows (points)=0A=
    // getNumberOfColumns (x,y,z,v,t,t1,t2...)=0A=
    // getDistinctValues (unique values?)=0A=
    // getColumnRange=0A=
=0A=
    // determine the location of x,y,z,value,filter columns=0A=
    this.colX =3D 'x';=0A=
    this.colY =3D 'y';=0A=
    this.colZ =3D 'z';=0A=
    this.colValue =3D 'style';=0A=
    this.colFilter =3D 'filter';=0A=
=0A=
    // check if a filter column is provided=0A=
    if (data[0].hasOwnProperty('filter')) {=0A=
      if (this.dataFilter =3D=3D=3D undefined) {=0A=
        this.dataFilter =3D new Filter(rawData, this.colFilter, this);=0A=
        this.dataFilter.setOnLoadCallback(function () {=0A=
          me.redraw();=0A=
        });=0A=
      }=0A=
    }=0A=
=0A=
    var withBars =3D this.style =3D=3D Graph3d.STYLE.BAR || this.style =
=3D=3D Graph3d.STYLE.BARCOLOR || this.style =3D=3D Graph3d.STYLE.BARSIZE;=0A=
=0A=
    // determine barWidth from data=0A=
    if (withBars) {=0A=
      if (this.defaultXBarWidth !=3D=3D undefined) {=0A=
        this.xBarWidth =3D this.defaultXBarWidth;=0A=
      } else {=0A=
        var dataX =3D this.getDistinctValues(data, this.colX);=0A=
        this.xBarWidth =3D dataX[1] - dataX[0] || 1;=0A=
      }=0A=
=0A=
      if (this.defaultYBarWidth !=3D=3D undefined) {=0A=
        this.yBarWidth =3D this.defaultYBarWidth;=0A=
      } else {=0A=
        var dataY =3D this.getDistinctValues(data, this.colY);=0A=
        this.yBarWidth =3D dataY[1] - dataY[0] || 1;=0A=
      }=0A=
    }=0A=
=0A=
    // calculate minimums and maximums=0A=
    var xRange =3D this.getColumnRange(data, this.colX);=0A=
    if (withBars) {=0A=
      xRange.min -=3D this.xBarWidth / 2;=0A=
      xRange.max +=3D this.xBarWidth / 2;=0A=
    }=0A=
    this.xMin =3D this.defaultXMin !=3D=3D undefined ? this.defaultXMin =
: xRange.min;=0A=
    this.xMax =3D this.defaultXMax !=3D=3D undefined ? this.defaultXMax =
: xRange.max;=0A=
    if (this.xMax <=3D this.xMin) this.xMax =3D this.xMin + 1;=0A=
    this.xStep =3D this.defaultXStep !=3D=3D undefined ? =
this.defaultXStep : (this.xMax - this.xMin) / 5;=0A=
=0A=
    var yRange =3D this.getColumnRange(data, this.colY);=0A=
    if (withBars) {=0A=
      yRange.min -=3D this.yBarWidth / 2;=0A=
      yRange.max +=3D this.yBarWidth / 2;=0A=
    }=0A=
    this.yMin =3D this.defaultYMin !=3D=3D undefined ? this.defaultYMin =
: yRange.min;=0A=
    this.yMax =3D this.defaultYMax !=3D=3D undefined ? this.defaultYMax =
: yRange.max;=0A=
    if (this.yMax <=3D this.yMin) this.yMax =3D this.yMin + 1;=0A=
    this.yStep =3D this.defaultYStep !=3D=3D undefined ? =
this.defaultYStep : (this.yMax - this.yMin) / 5;=0A=
=0A=
    var zRange =3D this.getColumnRange(data, this.colZ);=0A=
    this.zMin =3D this.defaultZMin !=3D=3D undefined ? this.defaultZMin =
: zRange.min;=0A=
    this.zMax =3D this.defaultZMax !=3D=3D undefined ? this.defaultZMax =
: zRange.max;=0A=
    if (this.zMax <=3D this.zMin) this.zMax =3D this.zMin + 1;=0A=
    this.zStep =3D this.defaultZStep !=3D=3D undefined ? =
this.defaultZStep : (this.zMax - this.zMin) / 5;=0A=
=0A=
    if (this.colValue !=3D=3D undefined) {=0A=
      var valueRange =3D this.getColumnRange(data, this.colValue);=0A=
      this.valueMin =3D this.defaultValueMin !=3D=3D undefined ? =
this.defaultValueMin : valueRange.min;=0A=
      this.valueMax =3D this.defaultValueMax !=3D=3D undefined ? =
this.defaultValueMax : valueRange.max;=0A=
      if (this.valueMax <=3D this.valueMin) this.valueMax =3D =
this.valueMin + 1;=0A=
    }=0A=
=0A=
    // set the scale dependent on the ranges.=0A=
    this._setScale();=0A=
  };=0A=
=0A=
  /**=0A=
   * Filter the data based on the current filter=0A=
   * @param {Array} data=0A=
   * @return {Array} dataPoints   Array with point objects which can be =
drawn on screen=0A=
   */=0A=
  Graph3d.prototype._getDataPoints =3D function (data) {=0A=
    // TODO: store the created matrix dataPoints in the filters instead =
of reloading each time=0A=
    var x, y, i, z, obj, point;=0A=
=0A=
    var dataPoints =3D [];=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.GRID || this.style =3D=3D=3D =
Graph3d.STYLE.SURFACE) {=0A=
      // copy all values from the google data table to a matrix=0A=
      // the provided values are supposed to form a grid of (x,y) =
positions=0A=
=0A=
      // create two lists with all present x and y values=0A=
      var dataX =3D [];=0A=
      var dataY =3D [];=0A=
      for (i =3D 0; i < this.getNumberOfRows(data); i++) {=0A=
        x =3D data[i][this.colX] || 0;=0A=
        y =3D data[i][this.colY] || 0;=0A=
=0A=
        if (dataX.indexOf(x) =3D=3D=3D -1) {=0A=
          dataX.push(x);=0A=
        }=0A=
        if (dataY.indexOf(y) =3D=3D=3D -1) {=0A=
          dataY.push(y);=0A=
        }=0A=
      }=0A=
=0A=
      var sortNumber =3D function sortNumber(a, b) {=0A=
        return a - b;=0A=
      };=0A=
      dataX.sort(sortNumber);=0A=
      dataY.sort(sortNumber);=0A=
=0A=
      // create a grid, a 2d matrix, with all values.=0A=
      var dataMatrix =3D []; // temporary data matrix=0A=
      for (i =3D 0; i < data.length; i++) {=0A=
        x =3D data[i][this.colX] || 0;=0A=
        y =3D data[i][this.colY] || 0;=0A=
        z =3D data[i][this.colZ] || 0;=0A=
=0A=
        var xIndex =3D dataX.indexOf(x); // TODO: implement =
Array().indexOf() for Internet Explorer=0A=
        var yIndex =3D dataY.indexOf(y);=0A=
=0A=
        if (dataMatrix[xIndex] =3D=3D=3D undefined) {=0A=
          dataMatrix[xIndex] =3D [];=0A=
        }=0A=
=0A=
        var point3d =3D new Point3d();=0A=
        point3d.x =3D x;=0A=
        point3d.y =3D y;=0A=
        point3d.z =3D z;=0A=
=0A=
        obj =3D {};=0A=
        obj.point =3D point3d;=0A=
        obj.trans =3D undefined;=0A=
        obj.screen =3D undefined;=0A=
        obj.bottom =3D new Point3d(x, y, this.zMin);=0A=
=0A=
        dataMatrix[xIndex][yIndex] =3D obj;=0A=
=0A=
        dataPoints.push(obj);=0A=
      }=0A=
=0A=
      // fill in the pointers to the neighbors.=0A=
      for (x =3D 0; x < dataMatrix.length; x++) {=0A=
        for (y =3D 0; y < dataMatrix[x].length; y++) {=0A=
          if (dataMatrix[x][y]) {=0A=
            dataMatrix[x][y].pointRight =3D x < dataMatrix.length - 1 ? =
dataMatrix[x + 1][y] : undefined;=0A=
            dataMatrix[x][y].pointTop =3D y < dataMatrix[x].length - 1 ? =
dataMatrix[x][y + 1] : undefined;=0A=
            dataMatrix[x][y].pointCross =3D x < dataMatrix.length - 1 && =
y < dataMatrix[x].length - 1 ? dataMatrix[x + 1][y + 1] : undefined;=0A=
          }=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // 'dot', 'dot-line', etc.=0A=
      // copy all values from the google data table to a list with =
Point3d objects=0A=
      for (i =3D 0; i < data.length; i++) {=0A=
        point =3D new Point3d();=0A=
        point.x =3D data[i][this.colX] || 0;=0A=
        point.y =3D data[i][this.colY] || 0;=0A=
        point.z =3D data[i][this.colZ] || 0;=0A=
=0A=
        if (this.colValue !=3D=3D undefined) {=0A=
          point.value =3D data[i][this.colValue] || 0;=0A=
        }=0A=
=0A=
        obj =3D {};=0A=
        obj.point =3D point;=0A=
        obj.bottom =3D new Point3d(point.x, point.y, this.zMin);=0A=
        obj.trans =3D undefined;=0A=
        obj.screen =3D undefined;=0A=
=0A=
        dataPoints.push(obj);=0A=
      }=0A=
    }=0A=
=0A=
    return dataPoints;=0A=
  };=0A=
=0A=
  /**=0A=
   * Create the main frame for the Graph3d.=0A=
   * This function is executed once when a Graph3d object is created. =
The frame=0A=
   * contains a canvas, and this canvas contains all objects like the =
axis and=0A=
   * nodes.=0A=
   */=0A=
  Graph3d.prototype.create =3D function () {=0A=
    // remove all elements from the container element.=0A=
    while (this.containerElement.hasChildNodes()) {=0A=
      =
this.containerElement.removeChild(this.containerElement.firstChild);=0A=
    }=0A=
=0A=
    this.frame =3D document.createElement('div');=0A=
    this.frame.style.position =3D 'relative';=0A=
    this.frame.style.overflow =3D 'hidden';=0A=
=0A=
    // create the graph canvas (HTML canvas element)=0A=
    this.frame.canvas =3D document.createElement('canvas');=0A=
    this.frame.canvas.style.position =3D 'relative';=0A=
    this.frame.appendChild(this.frame.canvas);=0A=
    //if (!this.frame.canvas.getContext) {=0A=
    {=0A=
      var noCanvas =3D document.createElement('DIV');=0A=
      noCanvas.style.color =3D 'red';=0A=
      noCanvas.style.fontWeight =3D 'bold';=0A=
      noCanvas.style.padding =3D '10px';=0A=
      noCanvas.innerHTML =3D 'Error: your browser does not support HTML =
canvas';=0A=
      this.frame.canvas.appendChild(noCanvas);=0A=
    }=0A=
=0A=
    this.frame.filter =3D document.createElement('div');=0A=
    this.frame.filter.style.position =3D 'absolute';=0A=
    this.frame.filter.style.bottom =3D '0px';=0A=
    this.frame.filter.style.left =3D '0px';=0A=
    this.frame.filter.style.width =3D '100%';=0A=
    this.frame.appendChild(this.frame.filter);=0A=
=0A=
    // add event listeners to handle moving and zooming the contents=0A=
    var me =3D this;=0A=
    var onmousedown =3D function onmousedown(event) {=0A=
      me._onMouseDown(event);=0A=
    };=0A=
    var ontouchstart =3D function ontouchstart(event) {=0A=
      me._onTouchStart(event);=0A=
    };=0A=
    var onmousewheel =3D function onmousewheel(event) {=0A=
      me._onWheel(event);=0A=
    };=0A=
    var ontooltip =3D function ontooltip(event) {=0A=
      me._onTooltip(event);=0A=
    };=0A=
    // TODO: these events are never cleaned up... can give a 'memory =
leakage'=0A=
=0A=
    util.addEventListener(this.frame.canvas, 'keydown', onkeydown);=0A=
    util.addEventListener(this.frame.canvas, 'mousedown', onmousedown);=0A=
    util.addEventListener(this.frame.canvas, 'touchstart', ontouchstart);=0A=
    util.addEventListener(this.frame.canvas, 'mousewheel', onmousewheel);=0A=
    util.addEventListener(this.frame.canvas, 'mousemove', ontooltip);=0A=
=0A=
    // add the new graph to the container element=0A=
    this.containerElement.appendChild(this.frame);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a new size for the graph=0A=
   * @param {string} width   Width in pixels or percentage (for example =
'800px'=0A=
   *             or '50%')=0A=
   * @param {string} height  Height in pixels or percentage  (for =
example '400px'=0A=
   *             or '30%')=0A=
   */=0A=
  Graph3d.prototype.setSize =3D function (width, height) {=0A=
    this.frame.style.width =3D width;=0A=
    this.frame.style.height =3D height;=0A=
=0A=
    this._resizeCanvas();=0A=
  };=0A=
=0A=
  /**=0A=
   * Resize the canvas to the current size of the frame=0A=
   */=0A=
  Graph3d.prototype._resizeCanvas =3D function () {=0A=
    this.frame.canvas.style.width =3D '100%';=0A=
    this.frame.canvas.style.height =3D '100%';=0A=
=0A=
    this.frame.canvas.width =3D this.frame.canvas.clientWidth;=0A=
    this.frame.canvas.height =3D this.frame.canvas.clientHeight;=0A=
=0A=
    // adjust with for margin=0A=
    this.frame.filter.style.width =3D this.frame.canvas.clientWidth - 2 =
* 10 + 'px';=0A=
  };=0A=
=0A=
  /**=0A=
   * Start animation=0A=
   */=0A=
  Graph3d.prototype.animationStart =3D function () {=0A=
    if (!this.frame.filter || !this.frame.filter.slider) throw 'No =
animation available';=0A=
=0A=
    this.frame.filter.slider.play();=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop animation=0A=
   */=0A=
  Graph3d.prototype.animationStop =3D function () {=0A=
    if (!this.frame.filter || !this.frame.filter.slider) return;=0A=
=0A=
    this.frame.filter.slider.stop();=0A=
  };=0A=
=0A=
  /**=0A=
   * Resize the center position based on the current values in =
this.defaultXCenter=0A=
   * and this.defaultYCenter (which are strings with a percentage or a =
value=0A=
   * in pixels). The center positions are the variables this.xCenter=0A=
   * and this.yCenter=0A=
   */=0A=
  Graph3d.prototype._resizeCenter =3D function () {=0A=
    // calculate the horizontal center position=0A=
    if (this.defaultXCenter.charAt(this.defaultXCenter.length - 1) =
=3D=3D=3D '%') {=0A=
      this.xcenter =3D parseFloat(this.defaultXCenter) / 100 * =
this.frame.canvas.clientWidth;=0A=
    } else {=0A=
      this.xcenter =3D parseFloat(this.defaultXCenter); // supposed to =
be in px=0A=
    }=0A=
=0A=
    // calculate the vertical center position=0A=
    if (this.defaultYCenter.charAt(this.defaultYCenter.length - 1) =
=3D=3D=3D '%') {=0A=
      this.ycenter =3D parseFloat(this.defaultYCenter) / 100 * =
(this.frame.canvas.clientHeight - this.frame.filter.clientHeight);=0A=
    } else {=0A=
      this.ycenter =3D parseFloat(this.defaultYCenter); // supposed to =
be in px=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the rotation and distance of the camera=0A=
   * @param {Object} pos   An object with the camera position. The object=0A=
   *             contains three parameters:=0A=
   *             - horizontal {Number}=0A=
   *             The horizontal rotation, between 0 and 2*PI.=0A=
   *             Optional, can be left undefined.=0A=
   *             - vertical {Number}=0A=
   *             The vertical rotation, between 0 and 0.5*PI=0A=
   *             if vertical=3D0.5*PI, the graph is shown from the=0A=
   *             top. Optional, can be left undefined.=0A=
   *             - distance {Number}=0A=
   *             The (normalized) distance of the camera to the=0A=
   *             center of the graph, a value between 0.71 and 5.0.=0A=
   *             Optional, can be left undefined.=0A=
   */=0A=
  Graph3d.prototype.setCameraPosition =3D function (pos) {=0A=
    if (pos =3D=3D=3D undefined) {=0A=
      return;=0A=
    }=0A=
=0A=
    if (pos.horizontal !=3D=3D undefined && pos.vertical !=3D=3D =
undefined) {=0A=
      this.camera.setArmRotation(pos.horizontal, pos.vertical);=0A=
    }=0A=
=0A=
    if (pos.distance !=3D=3D undefined) {=0A=
      this.camera.setArmLength(pos.distance);=0A=
    }=0A=
=0A=
    this.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the current camera rotation=0A=
   * @return {object}   An object with parameters horizontal, vertical, =
and=0A=
   *          distance=0A=
   */=0A=
  Graph3d.prototype.getCameraPosition =3D function () {=0A=
    var pos =3D this.camera.getArmRotation();=0A=
    pos.distance =3D this.camera.getArmLength();=0A=
    return pos;=0A=
  };=0A=
=0A=
  /**=0A=
   * Load data into the 3D Graph=0A=
   */=0A=
  Graph3d.prototype._readData =3D function (data) {=0A=
    // read the data=0A=
    this._dataInitialize(data, this.style);=0A=
=0A=
    if (this.dataFilter) {=0A=
      // apply filtering=0A=
      this.dataPoints =3D this.dataFilter._getDataPoints();=0A=
    } else {=0A=
      // no filtering. load all data=0A=
      this.dataPoints =3D this._getDataPoints(this.dataTable);=0A=
    }=0A=
=0A=
    // draw the filter=0A=
    this._redrawFilter();=0A=
  };=0A=
=0A=
  /**=0A=
   * Replace the dataset of the Graph3d=0A=
   * @param {Array | DataSet | DataView} data=0A=
   */=0A=
  Graph3d.prototype.setData =3D function (data) {=0A=
    this._readData(data);=0A=
    this.redraw();=0A=
=0A=
    // start animation when option is true=0A=
    if (this.animationAutoStart && this.dataFilter) {=0A=
      this.animationStart();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Update the options. Options will be merged with current options=0A=
   * @param {Object} options=0A=
   */=0A=
  Graph3d.prototype.setOptions =3D function (options) {=0A=
    var cameraPosition =3D undefined;=0A=
=0A=
    this.animationStop();=0A=
=0A=
    if (options !=3D=3D undefined) {=0A=
      // retrieve parameter values=0A=
      if (options.width !=3D=3D undefined) this.width =3D options.width;=0A=
      if (options.height !=3D=3D undefined) this.height =3D =
options.height;=0A=
=0A=
      if (options.xCenter !=3D=3D undefined) this.defaultXCenter =3D =
options.xCenter;=0A=
      if (options.yCenter !=3D=3D undefined) this.defaultYCenter =3D =
options.yCenter;=0A=
=0A=
      if (options.filterLabel !=3D=3D undefined) this.filterLabel =3D =
options.filterLabel;=0A=
      if (options.legendLabel !=3D=3D undefined) this.legendLabel =3D =
options.legendLabel;=0A=
      if (options.xLabel !=3D=3D undefined) this.xLabel =3D =
options.xLabel;=0A=
      if (options.yLabel !=3D=3D undefined) this.yLabel =3D =
options.yLabel;=0A=
      if (options.zLabel !=3D=3D undefined) this.zLabel =3D =
options.zLabel;=0A=
=0A=
      if (options.xValueLabel !=3D=3D undefined) this.xValueLabel =3D =
options.xValueLabel;=0A=
      if (options.yValueLabel !=3D=3D undefined) this.yValueLabel =3D =
options.yValueLabel;=0A=
      if (options.zValueLabel !=3D=3D undefined) this.zValueLabel =3D =
options.zValueLabel;=0A=
=0A=
      if (options.style !=3D=3D undefined) {=0A=
        var styleNumber =3D this._getStyleNumber(options.style);=0A=
        if (styleNumber !=3D=3D -1) {=0A=
          this.style =3D styleNumber;=0A=
        }=0A=
      }=0A=
      if (options.showGrid !=3D=3D undefined) this.showGrid =3D =
options.showGrid;=0A=
      if (options.showPerspective !=3D=3D undefined) =
this.showPerspective =3D options.showPerspective;=0A=
      if (options.showShadow !=3D=3D undefined) this.showShadow =3D =
options.showShadow;=0A=
      if (options.tooltip !=3D=3D undefined) this.showTooltip =3D =
options.tooltip;=0A=
      if (options.showAnimationControls !=3D=3D undefined) =
this.showAnimationControls =3D options.showAnimationControls;=0A=
      if (options.keepAspectRatio !=3D=3D undefined) =
this.keepAspectRatio =3D options.keepAspectRatio;=0A=
      if (options.verticalRatio !=3D=3D undefined) this.verticalRatio =
=3D options.verticalRatio;=0A=
=0A=
      if (options.animationInterval !=3D=3D undefined) =
this.animationInterval =3D options.animationInterval;=0A=
      if (options.animationPreload !=3D=3D undefined) =
this.animationPreload =3D options.animationPreload;=0A=
      if (options.animationAutoStart !=3D=3D undefined) =
this.animationAutoStart =3D options.animationAutoStart;=0A=
=0A=
      if (options.xBarWidth !=3D=3D undefined) this.defaultXBarWidth =3D =
options.xBarWidth;=0A=
      if (options.yBarWidth !=3D=3D undefined) this.defaultYBarWidth =3D =
options.yBarWidth;=0A=
=0A=
      if (options.xMin !=3D=3D undefined) this.defaultXMin =3D =
options.xMin;=0A=
      if (options.xStep !=3D=3D undefined) this.defaultXStep =3D =
options.xStep;=0A=
      if (options.xMax !=3D=3D undefined) this.defaultXMax =3D =
options.xMax;=0A=
      if (options.yMin !=3D=3D undefined) this.defaultYMin =3D =
options.yMin;=0A=
      if (options.yStep !=3D=3D undefined) this.defaultYStep =3D =
options.yStep;=0A=
      if (options.yMax !=3D=3D undefined) this.defaultYMax =3D =
options.yMax;=0A=
      if (options.zMin !=3D=3D undefined) this.defaultZMin =3D =
options.zMin;=0A=
      if (options.zStep !=3D=3D undefined) this.defaultZStep =3D =
options.zStep;=0A=
      if (options.zMax !=3D=3D undefined) this.defaultZMax =3D =
options.zMax;=0A=
      if (options.valueMin !=3D=3D undefined) this.defaultValueMin =3D =
options.valueMin;=0A=
      if (options.valueMax !=3D=3D undefined) this.defaultValueMax =3D =
options.valueMax;=0A=
      if (options.backgroundColor !=3D=3D undefined) =
this._setBackgroundColor(options.backgroundColor);=0A=
=0A=
      if (options.cameraPosition !=3D=3D undefined) cameraPosition =3D =
options.cameraPosition;=0A=
=0A=
      if (cameraPosition !=3D=3D undefined) {=0A=
        this.camera.setArmRotation(cameraPosition.horizontal, =
cameraPosition.vertical);=0A=
        this.camera.setArmLength(cameraPosition.distance);=0A=
      }=0A=
=0A=
      // colors=0A=
      if (options.axisColor !=3D=3D undefined) this.axisColor =3D =
options.axisColor;=0A=
      if (options.gridColor !=3D=3D undefined) this.gridColor =3D =
options.gridColor;=0A=
      if (options.dataColor) {=0A=
        if (typeof options.dataColor =3D=3D=3D 'string') {=0A=
          this.dataColor.fill =3D options.dataColor;=0A=
          this.dataColor.stroke =3D options.dataColor;=0A=
        } else {=0A=
          if (options.dataColor.fill) {=0A=
            this.dataColor.fill =3D options.dataColor.fill;=0A=
          }=0A=
          if (options.dataColor.stroke) {=0A=
            this.dataColor.stroke =3D options.dataColor.stroke;=0A=
          }=0A=
          if (options.dataColor.strokeWidth !=3D=3D undefined) {=0A=
            this.dataColor.strokeWidth =3D options.dataColor.strokeWidth;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    this.setSize(this.width, this.height);=0A=
=0A=
    // re-load the data=0A=
    if (this.dataTable) {=0A=
      this.setData(this.dataTable);=0A=
    }=0A=
=0A=
    // start animation when option is true=0A=
    if (this.animationAutoStart && this.dataFilter) {=0A=
      this.animationStart();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw the Graph.=0A=
   */=0A=
  Graph3d.prototype.redraw =3D function () {=0A=
    if (this.dataPoints =3D=3D=3D undefined) {=0A=
      throw 'Error: graph data not initialized';=0A=
    }=0A=
=0A=
    this._resizeCanvas();=0A=
    this._resizeCenter();=0A=
    this._redrawSlider();=0A=
    this._redrawClear();=0A=
    this._redrawAxis();=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.GRID || this.style =3D=3D=3D =
Graph3d.STYLE.SURFACE) {=0A=
      this._redrawDataGrid();=0A=
    } else if (this.style =3D=3D=3D Graph3d.STYLE.LINE) {=0A=
      this._redrawDataLine();=0A=
    } else if (this.style =3D=3D=3D Graph3d.STYLE.BAR || this.style =
=3D=3D=3D Graph3d.STYLE.BARCOLOR || this.style =3D=3D=3D =
Graph3d.STYLE.BARSIZE) {=0A=
      this._redrawDataBar();=0A=
    } else {=0A=
      // style is DOT, DOTLINE, DOTCOLOR, DOTSIZE=0A=
      this._redrawDataDot();=0A=
    }=0A=
=0A=
    this._redrawInfo();=0A=
    this._redrawLegend();=0A=
  };=0A=
=0A=
  /**=0A=
   * Clear the canvas before redrawing=0A=
   */=0A=
  Graph3d.prototype._redrawClear =3D function () {=0A=
    var canvas =3D this.frame.canvas;=0A=
    var ctx =3D canvas.getContext('2d');=0A=
=0A=
    ctx.clearRect(0, 0, canvas.width, canvas.height);=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw the legend showing the colors=0A=
   */=0A=
  Graph3d.prototype._redrawLegend =3D function () {=0A=
    var y;=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.DOTCOLOR || this.style =
=3D=3D=3D Graph3d.STYLE.DOTSIZE) {=0A=
=0A=
      var dotSize =3D this.frame.clientWidth * 0.02;=0A=
=0A=
      var widthMin, widthMax;=0A=
      if (this.style =3D=3D=3D Graph3d.STYLE.DOTSIZE) {=0A=
        widthMin =3D dotSize / 2; // px=0A=
        widthMax =3D dotSize / 2 + dotSize * 2; // Todo: put this in one =
function=0A=
      } else {=0A=
        widthMin =3D 20; // px=0A=
        widthMax =3D 20; // px=0A=
      }=0A=
=0A=
      var height =3D Math.max(this.frame.clientHeight * 0.25, 100);=0A=
      var top =3D this.margin;=0A=
      var right =3D this.frame.clientWidth - this.margin;=0A=
      var left =3D right - widthMax;=0A=
      var bottom =3D top + height;=0A=
    }=0A=
=0A=
    var canvas =3D this.frame.canvas;=0A=
    var ctx =3D canvas.getContext('2d');=0A=
    ctx.lineWidth =3D 1;=0A=
    ctx.font =3D '14px arial'; // TODO: put in options=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.DOTCOLOR) {=0A=
      // draw the color bar=0A=
      var ymin =3D 0;=0A=
      var ymax =3D height; // Todo: make height customizable=0A=
      for (y =3D ymin; y < ymax; y++) {=0A=
        var f =3D (y - ymin) / (ymax - ymin);=0A=
=0A=
        //var width =3D (dotSize / 2 + (1-f) * dotSize * 2); // Todo: =
put this in one function=0A=
        var hue =3D f * 240;=0A=
        var color =3D this._hsv2rgb(hue, 1, 1);=0A=
=0A=
        ctx.strokeStyle =3D color;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(left, top + y);=0A=
        ctx.lineTo(right, top + y);=0A=
        ctx.stroke();=0A=
      }=0A=
=0A=
      ctx.strokeStyle =3D this.axisColor;=0A=
      ctx.strokeRect(left, top, widthMax, height);=0A=
    }=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.DOTSIZE) {=0A=
      // draw border around color bar=0A=
      ctx.strokeStyle =3D this.axisColor;=0A=
      ctx.fillStyle =3D this.dataColor.fill;=0A=
      ctx.beginPath();=0A=
      ctx.moveTo(left, top);=0A=
      ctx.lineTo(right, top);=0A=
      ctx.lineTo(right - widthMax + widthMin, bottom);=0A=
      ctx.lineTo(left, bottom);=0A=
      ctx.closePath();=0A=
      ctx.fill();=0A=
      ctx.stroke();=0A=
    }=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.DOTCOLOR || this.style =
=3D=3D=3D Graph3d.STYLE.DOTSIZE) {=0A=
      // print values along the color bar=0A=
      var gridLineLen =3D 5; // px=0A=
      var step =3D new StepNumber(this.valueMin, this.valueMax, =
(this.valueMax - this.valueMin) / 5, true);=0A=
      step.start();=0A=
      if (step.getCurrent() < this.valueMin) {=0A=
        step.next();=0A=
      }=0A=
      while (!step.end()) {=0A=
        y =3D bottom - (step.getCurrent() - this.valueMin) / =
(this.valueMax - this.valueMin) * height;=0A=
=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(left - gridLineLen, y);=0A=
        ctx.lineTo(left, y);=0A=
        ctx.stroke();=0A=
=0A=
        ctx.textAlign =3D 'right';=0A=
        ctx.textBaseline =3D 'middle';=0A=
        ctx.fillStyle =3D this.axisColor;=0A=
        ctx.fillText(step.getCurrent(), left - 2 * gridLineLen, y);=0A=
=0A=
        step.next();=0A=
      }=0A=
=0A=
      ctx.textAlign =3D 'right';=0A=
      ctx.textBaseline =3D 'top';=0A=
      var label =3D this.legendLabel;=0A=
      ctx.fillText(label, right, bottom + this.margin);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw the filter=0A=
   */=0A=
  Graph3d.prototype._redrawFilter =3D function () {=0A=
    this.frame.filter.innerHTML =3D '';=0A=
=0A=
    if (this.dataFilter) {=0A=
      var options =3D {=0A=
        'visible': this.showAnimationControls=0A=
      };=0A=
      var slider =3D new Slider(this.frame.filter, options);=0A=
      this.frame.filter.slider =3D slider;=0A=
=0A=
      // TODO: css here is not nice here...=0A=
      this.frame.filter.style.padding =3D '10px';=0A=
      //this.frame.filter.style.backgroundColor =3D '#EFEFEF';=0A=
=0A=
      slider.setValues(this.dataFilter.values);=0A=
      slider.setPlayInterval(this.animationInterval);=0A=
=0A=
      // create an event handler=0A=
      var me =3D this;=0A=
      var onchange =3D function onchange() {=0A=
        var index =3D slider.getIndex();=0A=
=0A=
        me.dataFilter.selectValue(index);=0A=
        me.dataPoints =3D me.dataFilter._getDataPoints();=0A=
=0A=
        me.redraw();=0A=
      };=0A=
      slider.setOnChangeCallback(onchange);=0A=
    } else {=0A=
      this.frame.filter.slider =3D undefined;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw the slider=0A=
   */=0A=
  Graph3d.prototype._redrawSlider =3D function () {=0A=
    if (this.frame.filter.slider !=3D=3D undefined) {=0A=
      this.frame.filter.slider.redraw();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw common information=0A=
   */=0A=
  Graph3d.prototype._redrawInfo =3D function () {=0A=
    if (this.dataFilter) {=0A=
      var canvas =3D this.frame.canvas;=0A=
      var ctx =3D canvas.getContext('2d');=0A=
=0A=
      ctx.font =3D '14px arial'; // TODO: put in options=0A=
      ctx.lineStyle =3D 'gray';=0A=
      ctx.fillStyle =3D 'gray';=0A=
      ctx.textAlign =3D 'left';=0A=
      ctx.textBaseline =3D 'top';=0A=
=0A=
      var x =3D this.margin;=0A=
      var y =3D this.margin;=0A=
      ctx.fillText(this.dataFilter.getLabel() + ': ' + =
this.dataFilter.getSelectedValue(), x, y);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw the axis=0A=
   */=0A=
  Graph3d.prototype._redrawAxis =3D function () {=0A=
    var canvas =3D this.frame.canvas,=0A=
        ctx =3D canvas.getContext('2d'),=0A=
        from,=0A=
        to,=0A=
        step,=0A=
        prettyStep,=0A=
        text,=0A=
        xText,=0A=
        yText,=0A=
        zText,=0A=
        offset,=0A=
        xOffset,=0A=
        yOffset,=0A=
        xMin2d,=0A=
        xMax2d;=0A=
=0A=
    // TODO: get the actual rendered style of the containerElement=0A=
    //ctx.font =3D this.containerElement.style.font;=0A=
    ctx.font =3D 24 / this.camera.getArmLength() + 'px arial';=0A=
=0A=
    // calculate the length for the short grid lines=0A=
    var gridLenX =3D 0.025 / this.scale.x;=0A=
    var gridLenY =3D 0.025 / this.scale.y;=0A=
    var textMargin =3D 5 / this.camera.getArmLength(); // px=0A=
    var armAngle =3D this.camera.getArmRotation().horizontal;=0A=
=0A=
    // draw x-grid lines=0A=
    ctx.lineWidth =3D 1;=0A=
    prettyStep =3D this.defaultXStep =3D=3D=3D undefined;=0A=
    step =3D new StepNumber(this.xMin, this.xMax, this.xStep, =
prettyStep);=0A=
    step.start();=0A=
    if (step.getCurrent() < this.xMin) {=0A=
      step.next();=0A=
    }=0A=
    while (!step.end()) {=0A=
      var x =3D step.getCurrent();=0A=
=0A=
      if (this.showGrid) {=0A=
        from =3D this._convert3Dto2D(new Point3d(x, this.yMin, =
this.zMin));=0A=
        to =3D this._convert3Dto2D(new Point3d(x, this.yMax, this.zMin));=0A=
        ctx.strokeStyle =3D this.gridColor;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(from.x, from.y);=0A=
        ctx.lineTo(to.x, to.y);=0A=
        ctx.stroke();=0A=
      } else {=0A=
        from =3D this._convert3Dto2D(new Point3d(x, this.yMin, =
this.zMin));=0A=
        to =3D this._convert3Dto2D(new Point3d(x, this.yMin + gridLenX, =
this.zMin));=0A=
        ctx.strokeStyle =3D this.axisColor;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(from.x, from.y);=0A=
        ctx.lineTo(to.x, to.y);=0A=
        ctx.stroke();=0A=
=0A=
        from =3D this._convert3Dto2D(new Point3d(x, this.yMax, =
this.zMin));=0A=
        to =3D this._convert3Dto2D(new Point3d(x, this.yMax - gridLenX, =
this.zMin));=0A=
        ctx.strokeStyle =3D this.axisColor;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(from.x, from.y);=0A=
        ctx.lineTo(to.x, to.y);=0A=
        ctx.stroke();=0A=
      }=0A=
=0A=
      yText =3D Math.cos(armAngle) > 0 ? this.yMin : this.yMax;=0A=
      text =3D this._convert3Dto2D(new Point3d(x, yText, this.zMin));=0A=
      if (Math.cos(armAngle * 2) > 0) {=0A=
        ctx.textAlign =3D 'center';=0A=
        ctx.textBaseline =3D 'top';=0A=
        text.y +=3D textMargin;=0A=
      } else if (Math.sin(armAngle * 2) < 0) {=0A=
        ctx.textAlign =3D 'right';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      } else {=0A=
        ctx.textAlign =3D 'left';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      }=0A=
      ctx.fillStyle =3D this.axisColor;=0A=
      ctx.fillText('  ' + this.xValueLabel(step.getCurrent()) + '  ', =
text.x, text.y);=0A=
=0A=
      step.next();=0A=
    }=0A=
=0A=
    // draw y-grid lines=0A=
    ctx.lineWidth =3D 1;=0A=
    prettyStep =3D this.defaultYStep =3D=3D=3D undefined;=0A=
    step =3D new StepNumber(this.yMin, this.yMax, this.yStep, =
prettyStep);=0A=
    step.start();=0A=
    if (step.getCurrent() < this.yMin) {=0A=
      step.next();=0A=
    }=0A=
    while (!step.end()) {=0A=
      if (this.showGrid) {=0A=
        from =3D this._convert3Dto2D(new Point3d(this.xMin, =
step.getCurrent(), this.zMin));=0A=
        to =3D this._convert3Dto2D(new Point3d(this.xMax, =
step.getCurrent(), this.zMin));=0A=
        ctx.strokeStyle =3D this.gridColor;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(from.x, from.y);=0A=
        ctx.lineTo(to.x, to.y);=0A=
        ctx.stroke();=0A=
      } else {=0A=
        from =3D this._convert3Dto2D(new Point3d(this.xMin, =
step.getCurrent(), this.zMin));=0A=
        to =3D this._convert3Dto2D(new Point3d(this.xMin + gridLenY, =
step.getCurrent(), this.zMin));=0A=
        ctx.strokeStyle =3D this.axisColor;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(from.x, from.y);=0A=
        ctx.lineTo(to.x, to.y);=0A=
        ctx.stroke();=0A=
=0A=
        from =3D this._convert3Dto2D(new Point3d(this.xMax, =
step.getCurrent(), this.zMin));=0A=
        to =3D this._convert3Dto2D(new Point3d(this.xMax - gridLenY, =
step.getCurrent(), this.zMin));=0A=
        ctx.strokeStyle =3D this.axisColor;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(from.x, from.y);=0A=
        ctx.lineTo(to.x, to.y);=0A=
        ctx.stroke();=0A=
      }=0A=
=0A=
      xText =3D Math.sin(armAngle) > 0 ? this.xMin : this.xMax;=0A=
      text =3D this._convert3Dto2D(new Point3d(xText, step.getCurrent(), =
this.zMin));=0A=
      if (Math.cos(armAngle * 2) < 0) {=0A=
        ctx.textAlign =3D 'center';=0A=
        ctx.textBaseline =3D 'top';=0A=
        text.y +=3D textMargin;=0A=
      } else if (Math.sin(armAngle * 2) > 0) {=0A=
        ctx.textAlign =3D 'right';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      } else {=0A=
        ctx.textAlign =3D 'left';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      }=0A=
      ctx.fillStyle =3D this.axisColor;=0A=
      ctx.fillText('  ' + this.yValueLabel(step.getCurrent()) + '  ', =
text.x, text.y);=0A=
=0A=
      step.next();=0A=
    }=0A=
=0A=
    // draw z-grid lines and axis=0A=
    ctx.lineWidth =3D 1;=0A=
    prettyStep =3D this.defaultZStep =3D=3D=3D undefined;=0A=
    step =3D new StepNumber(this.zMin, this.zMax, this.zStep, =
prettyStep);=0A=
    step.start();=0A=
    if (step.getCurrent() < this.zMin) {=0A=
      step.next();=0A=
    }=0A=
    xText =3D Math.cos(armAngle) > 0 ? this.xMin : this.xMax;=0A=
    yText =3D Math.sin(armAngle) < 0 ? this.yMin : this.yMax;=0A=
    while (!step.end()) {=0A=
      // TODO: make z-grid lines really 3d?=0A=
      from =3D this._convert3Dto2D(new Point3d(xText, yText, =
step.getCurrent()));=0A=
      ctx.strokeStyle =3D this.axisColor;=0A=
      ctx.beginPath();=0A=
      ctx.moveTo(from.x, from.y);=0A=
      ctx.lineTo(from.x - textMargin, from.y);=0A=
      ctx.stroke();=0A=
=0A=
      ctx.textAlign =3D 'right';=0A=
      ctx.textBaseline =3D 'middle';=0A=
      ctx.fillStyle =3D this.axisColor;=0A=
      ctx.fillText(this.zValueLabel(step.getCurrent()) + ' ', from.x - =
5, from.y);=0A=
=0A=
      step.next();=0A=
    }=0A=
    ctx.lineWidth =3D 1;=0A=
    from =3D this._convert3Dto2D(new Point3d(xText, yText, this.zMin));=0A=
    to =3D this._convert3Dto2D(new Point3d(xText, yText, this.zMax));=0A=
    ctx.strokeStyle =3D this.axisColor;=0A=
    ctx.beginPath();=0A=
    ctx.moveTo(from.x, from.y);=0A=
    ctx.lineTo(to.x, to.y);=0A=
    ctx.stroke();=0A=
=0A=
    // draw x-axis=0A=
    ctx.lineWidth =3D 1;=0A=
    // line at yMin=0A=
    xMin2d =3D this._convert3Dto2D(new Point3d(this.xMin, this.yMin, =
this.zMin));=0A=
    xMax2d =3D this._convert3Dto2D(new Point3d(this.xMax, this.yMin, =
this.zMin));=0A=
    ctx.strokeStyle =3D this.axisColor;=0A=
    ctx.beginPath();=0A=
    ctx.moveTo(xMin2d.x, xMin2d.y);=0A=
    ctx.lineTo(xMax2d.x, xMax2d.y);=0A=
    ctx.stroke();=0A=
    // line at ymax=0A=
    xMin2d =3D this._convert3Dto2D(new Point3d(this.xMin, this.yMax, =
this.zMin));=0A=
    xMax2d =3D this._convert3Dto2D(new Point3d(this.xMax, this.yMax, =
this.zMin));=0A=
    ctx.strokeStyle =3D this.axisColor;=0A=
    ctx.beginPath();=0A=
    ctx.moveTo(xMin2d.x, xMin2d.y);=0A=
    ctx.lineTo(xMax2d.x, xMax2d.y);=0A=
    ctx.stroke();=0A=
=0A=
    // draw y-axis=0A=
    ctx.lineWidth =3D 1;=0A=
    // line at xMin=0A=
    from =3D this._convert3Dto2D(new Point3d(this.xMin, this.yMin, =
this.zMin));=0A=
    to =3D this._convert3Dto2D(new Point3d(this.xMin, this.yMax, =
this.zMin));=0A=
    ctx.strokeStyle =3D this.axisColor;=0A=
    ctx.beginPath();=0A=
    ctx.moveTo(from.x, from.y);=0A=
    ctx.lineTo(to.x, to.y);=0A=
    ctx.stroke();=0A=
    // line at xMax=0A=
    from =3D this._convert3Dto2D(new Point3d(this.xMax, this.yMin, =
this.zMin));=0A=
    to =3D this._convert3Dto2D(new Point3d(this.xMax, this.yMax, =
this.zMin));=0A=
    ctx.strokeStyle =3D this.axisColor;=0A=
    ctx.beginPath();=0A=
    ctx.moveTo(from.x, from.y);=0A=
    ctx.lineTo(to.x, to.y);=0A=
    ctx.stroke();=0A=
=0A=
    // draw x-label=0A=
    var xLabel =3D this.xLabel;=0A=
    if (xLabel.length > 0) {=0A=
      yOffset =3D 0.1 / this.scale.y;=0A=
      xText =3D (this.xMin + this.xMax) / 2;=0A=
      yText =3D Math.cos(armAngle) > 0 ? this.yMin - yOffset : this.yMax =
+ yOffset;=0A=
      text =3D this._convert3Dto2D(new Point3d(xText, yText, this.zMin));=0A=
      if (Math.cos(armAngle * 2) > 0) {=0A=
        ctx.textAlign =3D 'center';=0A=
        ctx.textBaseline =3D 'top';=0A=
      } else if (Math.sin(armAngle * 2) < 0) {=0A=
        ctx.textAlign =3D 'right';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      } else {=0A=
        ctx.textAlign =3D 'left';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      }=0A=
      ctx.fillStyle =3D this.axisColor;=0A=
      ctx.fillText(xLabel, text.x, text.y);=0A=
    }=0A=
=0A=
    // draw y-label=0A=
    var yLabel =3D this.yLabel;=0A=
    if (yLabel.length > 0) {=0A=
      xOffset =3D 0.1 / this.scale.x;=0A=
      xText =3D Math.sin(armAngle) > 0 ? this.xMin - xOffset : this.xMax =
+ xOffset;=0A=
      yText =3D (this.yMin + this.yMax) / 2;=0A=
      text =3D this._convert3Dto2D(new Point3d(xText, yText, this.zMin));=0A=
      if (Math.cos(armAngle * 2) < 0) {=0A=
        ctx.textAlign =3D 'center';=0A=
        ctx.textBaseline =3D 'top';=0A=
      } else if (Math.sin(armAngle * 2) > 0) {=0A=
        ctx.textAlign =3D 'right';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      } else {=0A=
        ctx.textAlign =3D 'left';=0A=
        ctx.textBaseline =3D 'middle';=0A=
      }=0A=
      ctx.fillStyle =3D this.axisColor;=0A=
      ctx.fillText(yLabel, text.x, text.y);=0A=
    }=0A=
=0A=
    // draw z-label=0A=
    var zLabel =3D this.zLabel;=0A=
    if (zLabel.length > 0) {=0A=
      offset =3D 30; // pixels.  // TODO: relate to the max width of the =
values on the z axis?=0A=
      xText =3D Math.cos(armAngle) > 0 ? this.xMin : this.xMax;=0A=
      yText =3D Math.sin(armAngle) < 0 ? this.yMin : this.yMax;=0A=
      zText =3D (this.zMin + this.zMax) / 2;=0A=
      text =3D this._convert3Dto2D(new Point3d(xText, yText, zText));=0A=
      ctx.textAlign =3D 'right';=0A=
      ctx.textBaseline =3D 'middle';=0A=
      ctx.fillStyle =3D this.axisColor;=0A=
      ctx.fillText(zLabel, text.x - offset, text.y);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the color based on the given value.=0A=
   * @param {Number} H   Hue, a value be between 0 and 360=0A=
   * @param {Number} S   Saturation, a value between 0 and 1=0A=
   * @param {Number} V   Value, a value between 0 and 1=0A=
   */=0A=
  Graph3d.prototype._hsv2rgb =3D function (H, S, V) {=0A=
    var R, G, B, C, Hi, X;=0A=
=0A=
    C =3D V * S;=0A=
    Hi =3D Math.floor(H / 60); // hi =3D 0,1,2,3,4,5=0A=
    X =3D C * (1 - Math.abs(H / 60 % 2 - 1));=0A=
=0A=
    switch (Hi) {=0A=
      case 0:=0A=
        R =3D C;G =3D X;B =3D 0;break;=0A=
      case 1:=0A=
        R =3D X;G =3D C;B =3D 0;break;=0A=
      case 2:=0A=
        R =3D 0;G =3D C;B =3D X;break;=0A=
      case 3:=0A=
        R =3D 0;G =3D X;B =3D C;break;=0A=
      case 4:=0A=
        R =3D X;G =3D 0;B =3D C;break;=0A=
      case 5:=0A=
        R =3D C;G =3D 0;B =3D X;break;=0A=
=0A=
      default:=0A=
        R =3D 0;G =3D 0;B =3D 0;break;=0A=
    }=0A=
=0A=
    return 'RGB(' + parseInt(R * 255) + ',' + parseInt(G * 255) + ',' + =
parseInt(B * 255) + ')';=0A=
  };=0A=
=0A=
  /**=0A=
   * Draw all datapoints as a grid=0A=
   * This function can be used when the style is 'grid'=0A=
   */=0A=
  Graph3d.prototype._redrawDataGrid =3D function () {=0A=
    var canvas =3D this.frame.canvas,=0A=
        ctx =3D canvas.getContext('2d'),=0A=
        point,=0A=
        right,=0A=
        top,=0A=
        cross,=0A=
        i,=0A=
        topSideVisible,=0A=
        fillStyle,=0A=
        strokeStyle,=0A=
        lineWidth,=0A=
        h,=0A=
        s,=0A=
        v,=0A=
        zAvg;=0A=
=0A=
    ctx.lineJoin =3D 'round';=0A=
    ctx.lineCap =3D 'round';=0A=
=0A=
    if (this.dataPoints =3D=3D=3D undefined || this.dataPoints.length =
<=3D 0) return; // TODO: throw exception?=0A=
=0A=
    // calculate the translations and screen position of all points=0A=
    for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
      var trans =3D =
this._convertPointToTranslation(this.dataPoints[i].point);=0A=
      var screen =3D this._convertTranslationToScreen(trans);=0A=
=0A=
      this.dataPoints[i].trans =3D trans;=0A=
      this.dataPoints[i].screen =3D screen;=0A=
=0A=
      // calculate the translation of the point at the bottom (needed =
for sorting)=0A=
      var transBottom =3D =
this._convertPointToTranslation(this.dataPoints[i].bottom);=0A=
      this.dataPoints[i].dist =3D this.showPerspective ? =
transBottom.length() : -transBottom.z;=0A=
    }=0A=
=0A=
    // sort the points on depth of their (x,y) position (not on z)=0A=
    var sortDepth =3D function sortDepth(a, b) {=0A=
      return b.dist - a.dist;=0A=
    };=0A=
    this.dataPoints.sort(sortDepth);=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.SURFACE) {=0A=
      for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
        point =3D this.dataPoints[i];=0A=
        right =3D this.dataPoints[i].pointRight;=0A=
        top =3D this.dataPoints[i].pointTop;=0A=
        cross =3D this.dataPoints[i].pointCross;=0A=
=0A=
        if (point !=3D=3D undefined && right !=3D=3D undefined && top =
!=3D=3D undefined && cross !=3D=3D undefined) {=0A=
=0A=
          if (this.showGrayBottom || this.showShadow) {=0A=
            // calculate the cross product of the two vectors from center=0A=
            // to left and right, in order to know whether we are =
looking at the=0A=
            // bottom or at the top side. We can also use the cross =
product=0A=
            // for calculating light intensity=0A=
            var aDiff =3D Point3d.subtract(cross.trans, point.trans);=0A=
            var bDiff =3D Point3d.subtract(top.trans, right.trans);=0A=
            var crossproduct =3D Point3d.crossProduct(aDiff, bDiff);=0A=
            var len =3D crossproduct.length();=0A=
            // FIXME: there is a bug with determining the surface side =
(shadow or colored)=0A=
=0A=
            topSideVisible =3D crossproduct.z > 0;=0A=
          } else {=0A=
            topSideVisible =3D true;=0A=
          }=0A=
=0A=
          if (topSideVisible) {=0A=
            // calculate Hue from the current value. At zMin the hue is =
240, at zMax the hue is 0=0A=
            zAvg =3D (point.point.z + right.point.z + top.point.z + =
cross.point.z) / 4;=0A=
            h =3D (1 - (zAvg - this.zMin) * this.scale.z / =
this.verticalRatio) * 240;=0A=
            s =3D 1; // saturation=0A=
=0A=
            if (this.showShadow) {=0A=
              v =3D Math.min(1 + crossproduct.x / len / 2, 1); // value. =
TODO: scale=0A=
              fillStyle =3D this._hsv2rgb(h, s, v);=0A=
              strokeStyle =3D fillStyle;=0A=
            } else {=0A=
              v =3D 1;=0A=
              fillStyle =3D this._hsv2rgb(h, s, v);=0A=
              strokeStyle =3D this.axisColor; // TODO: should be =
customizable=0A=
            }=0A=
          } else {=0A=
            fillStyle =3D 'gray';=0A=
            strokeStyle =3D this.axisColor;=0A=
          }=0A=
=0A=
          ctx.lineWidth =3D this._getStrokeWidth(point);=0A=
          ctx.fillStyle =3D fillStyle;=0A=
          ctx.strokeStyle =3D strokeStyle;=0A=
          ctx.beginPath();=0A=
          ctx.moveTo(point.screen.x, point.screen.y);=0A=
          ctx.lineTo(right.screen.x, right.screen.y);=0A=
          ctx.lineTo(cross.screen.x, cross.screen.y);=0A=
          ctx.lineTo(top.screen.x, top.screen.y);=0A=
          ctx.closePath();=0A=
          ctx.fill();=0A=
          ctx.stroke(); // TODO: only draw stroke when strokeWidth > 0=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // grid style=0A=
      for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
        point =3D this.dataPoints[i];=0A=
        right =3D this.dataPoints[i].pointRight;=0A=
        top =3D this.dataPoints[i].pointTop;=0A=
=0A=
        if (point !=3D=3D undefined && right !=3D=3D undefined) {=0A=
          // calculate Hue from the current value. At zMin the hue is =
240, at zMax the hue is 0=0A=
          zAvg =3D (point.point.z + right.point.z) / 2;=0A=
          h =3D (1 - (zAvg - this.zMin) * this.scale.z / =
this.verticalRatio) * 240;=0A=
=0A=
          ctx.lineWidth =3D this._getStrokeWidth(point) * 2;=0A=
          ctx.strokeStyle =3D this._hsv2rgb(h, 1, 1);=0A=
          ctx.beginPath();=0A=
          ctx.moveTo(point.screen.x, point.screen.y);=0A=
          ctx.lineTo(right.screen.x, right.screen.y);=0A=
          ctx.stroke();=0A=
        }=0A=
=0A=
        if (point !=3D=3D undefined && top !=3D=3D undefined) {=0A=
          // calculate Hue from the current value. At zMin the hue is =
240, at zMax the hue is 0=0A=
          zAvg =3D (point.point.z + top.point.z) / 2;=0A=
          h =3D (1 - (zAvg - this.zMin) * this.scale.z / =
this.verticalRatio) * 240;=0A=
=0A=
          ctx.lineWidth =3D this._getStrokeWidth(point) * 2;=0A=
          ctx.strokeStyle =3D this._hsv2rgb(h, 1, 1);=0A=
          ctx.beginPath();=0A=
          ctx.moveTo(point.screen.x, point.screen.y);=0A=
          ctx.lineTo(top.screen.x, top.screen.y);=0A=
          ctx.stroke();=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  Graph3d.prototype._getStrokeWidth =3D function (point) {=0A=
    if (point !=3D=3D undefined) {=0A=
      if (this.showPerspective) {=0A=
        return 1 / -point.trans.z * this.dataColor.strokeWidth;=0A=
      } else {=0A=
        return -(this.eye.z / this.camera.getArmLength()) * =
this.dataColor.strokeWidth;=0A=
      }=0A=
    }=0A=
=0A=
    return this.dataColor.strokeWidth;=0A=
  };=0A=
=0A=
  /**=0A=
   * Draw all datapoints as dots.=0A=
   * This function can be used when the style is 'dot' or 'dot-line'=0A=
   */=0A=
  Graph3d.prototype._redrawDataDot =3D function () {=0A=
    var canvas =3D this.frame.canvas;=0A=
    var ctx =3D canvas.getContext('2d');=0A=
    var i;=0A=
=0A=
    if (this.dataPoints =3D=3D=3D undefined || this.dataPoints.length =
<=3D 0) return; // TODO: throw exception?=0A=
=0A=
    // calculate the translations of all points=0A=
    for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
      var trans =3D =
this._convertPointToTranslation(this.dataPoints[i].point);=0A=
      var screen =3D this._convertTranslationToScreen(trans);=0A=
      this.dataPoints[i].trans =3D trans;=0A=
      this.dataPoints[i].screen =3D screen;=0A=
=0A=
      // calculate the distance from the point at the bottom to the =
camera=0A=
      var transBottom =3D =
this._convertPointToTranslation(this.dataPoints[i].bottom);=0A=
      this.dataPoints[i].dist =3D this.showPerspective ? =
transBottom.length() : -transBottom.z;=0A=
    }=0A=
=0A=
    // order the translated points by depth=0A=
    var sortDepth =3D function sortDepth(a, b) {=0A=
      return b.dist - a.dist;=0A=
    };=0A=
    this.dataPoints.sort(sortDepth);=0A=
=0A=
    // draw the datapoints as colored circles=0A=
    var dotSize =3D this.frame.clientWidth * 0.02; // px=0A=
    for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
      var point =3D this.dataPoints[i];=0A=
=0A=
      if (this.style =3D=3D=3D Graph3d.STYLE.DOTLINE) {=0A=
        // draw a vertical line from the bottom to the graph value=0A=
        //var from =3D this._convert3Dto2D(new Point3d(point.point.x, =
point.point.y, this.zMin));=0A=
        var from =3D this._convert3Dto2D(point.bottom);=0A=
        ctx.lineWidth =3D 1;=0A=
        ctx.strokeStyle =3D this.gridColor;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(from.x, from.y);=0A=
        ctx.lineTo(point.screen.x, point.screen.y);=0A=
        ctx.stroke();=0A=
      }=0A=
=0A=
      // calculate radius for the circle=0A=
      var size;=0A=
      if (this.style =3D=3D=3D Graph3d.STYLE.DOTSIZE) {=0A=
        size =3D dotSize / 2 + 2 * dotSize * (point.point.value - =
this.valueMin) / (this.valueMax - this.valueMin);=0A=
      } else {=0A=
        size =3D dotSize;=0A=
      }=0A=
=0A=
      var radius;=0A=
      if (this.showPerspective) {=0A=
        radius =3D size / -point.trans.z;=0A=
      } else {=0A=
        radius =3D size * -(this.eye.z / this.camera.getArmLength());=0A=
      }=0A=
      if (radius < 0) {=0A=
        radius =3D 0;=0A=
      }=0A=
=0A=
      var hue, color, borderColor;=0A=
      if (this.style =3D=3D=3D Graph3d.STYLE.DOTCOLOR) {=0A=
        // calculate the color based on the value=0A=
        hue =3D (1 - (point.point.value - this.valueMin) * =
this.scale.value) * 240;=0A=
        color =3D this._hsv2rgb(hue, 1, 1);=0A=
        borderColor =3D this._hsv2rgb(hue, 1, 0.8);=0A=
      } else if (this.style =3D=3D=3D Graph3d.STYLE.DOTSIZE) {=0A=
        color =3D this.dataColor.fill;=0A=
        borderColor =3D this.dataColor.stroke;=0A=
      } else {=0A=
        // calculate Hue from the current value. At zMin the hue is 240, =
at zMax the hue is 0=0A=
        hue =3D (1 - (point.point.z - this.zMin) * this.scale.z / =
this.verticalRatio) * 240;=0A=
        color =3D this._hsv2rgb(hue, 1, 1);=0A=
        borderColor =3D this._hsv2rgb(hue, 1, 0.8);=0A=
      }=0A=
=0A=
      // draw the circle=0A=
      ctx.lineWidth =3D this._getStrokeWidth(point);=0A=
      ctx.strokeStyle =3D borderColor;=0A=
      ctx.fillStyle =3D color;=0A=
      ctx.beginPath();=0A=
      ctx.arc(point.screen.x, point.screen.y, radius, 0, Math.PI * 2, =
true);=0A=
      ctx.fill();=0A=
      ctx.stroke();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Draw all datapoints as bars.=0A=
   * This function can be used when the style is 'bar', 'bar-color', or =
'bar-size'=0A=
   */=0A=
  Graph3d.prototype._redrawDataBar =3D function () {=0A=
    var canvas =3D this.frame.canvas;=0A=
    var ctx =3D canvas.getContext('2d');=0A=
    var i, j, surface, corners;=0A=
=0A=
    if (this.dataPoints =3D=3D=3D undefined || this.dataPoints.length =
<=3D 0) return; // TODO: throw exception?=0A=
=0A=
    // calculate the translations of all points=0A=
    for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
      var trans =3D =
this._convertPointToTranslation(this.dataPoints[i].point);=0A=
      var screen =3D this._convertTranslationToScreen(trans);=0A=
      this.dataPoints[i].trans =3D trans;=0A=
      this.dataPoints[i].screen =3D screen;=0A=
=0A=
      // calculate the distance from the point at the bottom to the =
camera=0A=
      var transBottom =3D =
this._convertPointToTranslation(this.dataPoints[i].bottom);=0A=
      this.dataPoints[i].dist =3D this.showPerspective ? =
transBottom.length() : -transBottom.z;=0A=
    }=0A=
=0A=
    // order the translated points by depth=0A=
    var sortDepth =3D function sortDepth(a, b) {=0A=
      return b.dist - a.dist;=0A=
    };=0A=
    this.dataPoints.sort(sortDepth);=0A=
=0A=
    ctx.lineJoin =3D 'round';=0A=
    ctx.lineCap =3D 'round';=0A=
=0A=
    // draw the datapoints as bars=0A=
    var xWidth =3D this.xBarWidth / 2;=0A=
    var yWidth =3D this.yBarWidth / 2;=0A=
    for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
      var point =3D this.dataPoints[i];=0A=
=0A=
      // determine color=0A=
      var hue, color, borderColor;=0A=
      if (this.style =3D=3D=3D Graph3d.STYLE.BARCOLOR) {=0A=
        // calculate the color based on the value=0A=
        hue =3D (1 - (point.point.value - this.valueMin) * =
this.scale.value) * 240;=0A=
        color =3D this._hsv2rgb(hue, 1, 1);=0A=
        borderColor =3D this._hsv2rgb(hue, 1, 0.8);=0A=
      } else if (this.style =3D=3D=3D Graph3d.STYLE.BARSIZE) {=0A=
        color =3D this.dataColor.fill;=0A=
        borderColor =3D this.dataColor.stroke;=0A=
      } else {=0A=
        // calculate Hue from the current value. At zMin the hue is 240, =
at zMax the hue is 0=0A=
        hue =3D (1 - (point.point.z - this.zMin) * this.scale.z / =
this.verticalRatio) * 240;=0A=
        color =3D this._hsv2rgb(hue, 1, 1);=0A=
        borderColor =3D this._hsv2rgb(hue, 1, 0.8);=0A=
      }=0A=
=0A=
      // calculate size for the bar=0A=
      if (this.style =3D=3D=3D Graph3d.STYLE.BARSIZE) {=0A=
        xWidth =3D this.xBarWidth / 2 * ((point.point.value - =
this.valueMin) / (this.valueMax - this.valueMin) * 0.8 + 0.2);=0A=
        yWidth =3D this.yBarWidth / 2 * ((point.point.value - =
this.valueMin) / (this.valueMax - this.valueMin) * 0.8 + 0.2);=0A=
      }=0A=
=0A=
      // calculate all corner points=0A=
      var me =3D this;=0A=
      var point3d =3D point.point;=0A=
      var top =3D [{ point: new Point3d(point3d.x - xWidth, point3d.y - =
yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y =
- yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, =
point3d.y + yWidth, point3d.z) }, { point: new Point3d(point3d.x - =
xWidth, point3d.y + yWidth, point3d.z) }];=0A=
      var bottom =3D [{ point: new Point3d(point3d.x - xWidth, point3d.y =
- yWidth, this.zMin) }, { point: new Point3d(point3d.x + xWidth, =
point3d.y - yWidth, this.zMin) }, { point: new Point3d(point3d.x + =
xWidth, point3d.y + yWidth, this.zMin) }, { point: new Point3d(point3d.x =
- xWidth, point3d.y + yWidth, this.zMin) }];=0A=
=0A=
      // calculate screen location of the points=0A=
      top.forEach(function (obj) {=0A=
        obj.screen =3D me._convert3Dto2D(obj.point);=0A=
      });=0A=
      bottom.forEach(function (obj) {=0A=
        obj.screen =3D me._convert3Dto2D(obj.point);=0A=
      });=0A=
=0A=
      // create five sides, calculate both corner points and center =
points=0A=
      var surfaces =3D [{ corners: top, center: =
Point3d.avg(bottom[0].point, bottom[2].point) }, { corners: [top[0], =
top[1], bottom[1], bottom[0]], center: Point3d.avg(bottom[1].point, =
bottom[0].point) }, { corners: [top[1], top[2], bottom[2], bottom[1]], =
center: Point3d.avg(bottom[2].point, bottom[1].point) }, { corners: =
[top[2], top[3], bottom[3], bottom[2]], center: =
Point3d.avg(bottom[3].point, bottom[2].point) }, { corners: [top[3], =
top[0], bottom[0], bottom[3]], center: Point3d.avg(bottom[0].point, =
bottom[3].point) }];=0A=
      point.surfaces =3D surfaces;=0A=
=0A=
      // calculate the distance of each of the surface centers to the =
camera=0A=
      for (j =3D 0; j < surfaces.length; j++) {=0A=
        surface =3D surfaces[j];=0A=
        var transCenter =3D =
this._convertPointToTranslation(surface.center);=0A=
        surface.dist =3D this.showPerspective ? transCenter.length() : =
-transCenter.z;=0A=
        // TODO: this dept calculation doesn't work 100% of the cases =
due to perspective,=0A=
        //     but the current solution is fast/simple and works in =
99.9% of all cases=0A=
        //     the issue is visible in example 14, with =
graph.setCameraPosition({horizontal: 2.97, vertical: 0.5, distance: 0.9})=0A=
      }=0A=
=0A=
      // order the surfaces by their (translated) depth=0A=
      surfaces.sort(function (a, b) {=0A=
        var diff =3D b.dist - a.dist;=0A=
        if (diff) return diff;=0A=
=0A=
        // if equal depth, sort the top surface last=0A=
        if (a.corners =3D=3D=3D top) return 1;=0A=
        if (b.corners =3D=3D=3D top) return -1;=0A=
=0A=
        // both are equal=0A=
        return 0;=0A=
      });=0A=
=0A=
      // draw the ordered surfaces=0A=
      ctx.lineWidth =3D this._getStrokeWidth(point);=0A=
      ctx.strokeStyle =3D borderColor;=0A=
      ctx.fillStyle =3D color;=0A=
      // NOTE: we start at j=3D2 instead of j=3D0 as we don't need to =
draw the two surfaces at the backside=0A=
      for (j =3D 2; j < surfaces.length; j++) {=0A=
        surface =3D surfaces[j];=0A=
        corners =3D surface.corners;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(corners[3].screen.x, corners[3].screen.y);=0A=
        ctx.lineTo(corners[0].screen.x, corners[0].screen.y);=0A=
        ctx.lineTo(corners[1].screen.x, corners[1].screen.y);=0A=
        ctx.lineTo(corners[2].screen.x, corners[2].screen.y);=0A=
        ctx.lineTo(corners[3].screen.x, corners[3].screen.y);=0A=
        ctx.fill();=0A=
        ctx.stroke();=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Draw a line through all datapoints.=0A=
   * This function can be used when the style is 'line'=0A=
   */=0A=
  Graph3d.prototype._redrawDataLine =3D function () {=0A=
    var canvas =3D this.frame.canvas,=0A=
        ctx =3D canvas.getContext('2d'),=0A=
        point,=0A=
        i;=0A=
=0A=
    if (this.dataPoints =3D=3D=3D undefined || this.dataPoints.length =
<=3D 0) return; // TODO: throw exception?=0A=
=0A=
    // calculate the translations of all points=0A=
    for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
      var trans =3D =
this._convertPointToTranslation(this.dataPoints[i].point);=0A=
      var screen =3D this._convertTranslationToScreen(trans);=0A=
=0A=
      this.dataPoints[i].trans =3D trans;=0A=
      this.dataPoints[i].screen =3D screen;=0A=
    }=0A=
=0A=
    // start the line=0A=
    if (this.dataPoints.length > 0) {=0A=
      point =3D this.dataPoints[0];=0A=
=0A=
      ctx.lineWidth =3D this._getStrokeWidth(point);=0A=
      ctx.lineJoin =3D 'round';=0A=
      ctx.lineCap =3D 'round';=0A=
      ctx.strokeStyle =3D this.dataColor.stroke;=0A=
      ctx.beginPath();=0A=
      ctx.moveTo(point.screen.x, point.screen.y);=0A=
=0A=
      // draw the datapoints as colored circles=0A=
      for (i =3D 1; i < this.dataPoints.length; i++) {=0A=
        point =3D this.dataPoints[i];=0A=
        ctx.lineTo(point.screen.x, point.screen.y);=0A=
      }=0A=
=0A=
      // finish the line=0A=
      ctx.stroke();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Start a moving operation inside the provided parent element=0A=
   * @param {Event}     event     The event that occurred (required for=0A=
   *                  retrieving the  mouse position)=0A=
   */=0A=
  Graph3d.prototype._onMouseDown =3D function (event) {=0A=
    event =3D event || window.event;=0A=
=0A=
    // check if mouse is still down (may be up when focus is lost for =
example=0A=
    // in an iframe)=0A=
    if (this.leftButtonDown) {=0A=
      this._onMouseUp(event);=0A=
    }=0A=
=0A=
    // only react on left mouse button down=0A=
    this.leftButtonDown =3D event.which ? event.which =3D=3D=3D 1 : =
event.button =3D=3D=3D 1;=0A=
    if (!this.leftButtonDown && !this.touchDown) return;=0A=
=0A=
    // get mouse position (different code for IE and all other browsers)=0A=
    this.startMouseX =3D getMouseX(event);=0A=
    this.startMouseY =3D getMouseY(event);=0A=
=0A=
    this.startStart =3D new Date(this.start);=0A=
    this.startEnd =3D new Date(this.end);=0A=
    this.startArmRotation =3D this.camera.getArmRotation();=0A=
=0A=
    this.frame.style.cursor =3D 'move';=0A=
=0A=
    // add event listeners to handle moving the contents=0A=
    // we store the function onmousemove and onmouseup in the graph, so =
we can=0A=
    // remove the eventlisteners lateron in the function mouseUp()=0A=
    var me =3D this;=0A=
    this.onmousemove =3D function (event) {=0A=
      me._onMouseMove(event);=0A=
    };=0A=
    this.onmouseup =3D function (event) {=0A=
      me._onMouseUp(event);=0A=
    };=0A=
    util.addEventListener(document, 'mousemove', me.onmousemove);=0A=
    util.addEventListener(document, 'mouseup', me.onmouseup);=0A=
    util.preventDefault(event);=0A=
  };=0A=
=0A=
  /**=0A=
   * Perform moving operating.=0A=
   * This function activated from within the funcion Graph.mouseDown().=0A=
   * @param {Event}   event  Well, eehh, the event=0A=
   */=0A=
  Graph3d.prototype._onMouseMove =3D function (event) {=0A=
    event =3D event || window.event;=0A=
=0A=
    // calculate change in mouse position=0A=
    var diffX =3D parseFloat(getMouseX(event)) - this.startMouseX;=0A=
    var diffY =3D parseFloat(getMouseY(event)) - this.startMouseY;=0A=
=0A=
    var horizontalNew =3D this.startArmRotation.horizontal + diffX / 200;=0A=
    var verticalNew =3D this.startArmRotation.vertical + diffY / 200;=0A=
=0A=
    var snapAngle =3D 4; // degrees=0A=
    var snapValue =3D Math.sin(snapAngle / 360 * 2 * Math.PI);=0A=
=0A=
    // snap horizontally to nice angles at 0pi, 0.5pi, 1pi, 1.5pi, etc...=0A=
    // the -0.001 is to take care that the vertical axis is always drawn =
at the left front corner=0A=
    if (Math.abs(Math.sin(horizontalNew)) < snapValue) {=0A=
      horizontalNew =3D Math.round(horizontalNew / Math.PI) * Math.PI - =
0.001;=0A=
    }=0A=
    if (Math.abs(Math.cos(horizontalNew)) < snapValue) {=0A=
      horizontalNew =3D (Math.round(horizontalNew / Math.PI - 0.5) + =
0.5) * Math.PI - 0.001;=0A=
    }=0A=
=0A=
    // snap vertically to nice angles=0A=
    if (Math.abs(Math.sin(verticalNew)) < snapValue) {=0A=
      verticalNew =3D Math.round(verticalNew / Math.PI) * Math.PI;=0A=
    }=0A=
    if (Math.abs(Math.cos(verticalNew)) < snapValue) {=0A=
      verticalNew =3D (Math.round(verticalNew / Math.PI - 0.5) + 0.5) * =
Math.PI;=0A=
    }=0A=
=0A=
    this.camera.setArmRotation(horizontalNew, verticalNew);=0A=
    this.redraw();=0A=
=0A=
    // fire a cameraPositionChange event=0A=
    var parameters =3D this.getCameraPosition();=0A=
    this.emit('cameraPositionChange', parameters);=0A=
=0A=
    util.preventDefault(event);=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop moving operating.=0A=
   * This function activated from within the funcion Graph.mouseDown().=0A=
   * @param {event}  event   The event=0A=
   */=0A=
  Graph3d.prototype._onMouseUp =3D function (event) {=0A=
    this.frame.style.cursor =3D 'auto';=0A=
    this.leftButtonDown =3D false;=0A=
=0A=
    // remove event listeners here=0A=
    util.removeEventListener(document, 'mousemove', this.onmousemove);=0A=
    util.removeEventListener(document, 'mouseup', this.onmouseup);=0A=
    util.preventDefault(event);=0A=
  };=0A=
=0A=
  /**=0A=
   * After having moved the mouse, a tooltip should pop up when the =
mouse is resting on a data point=0A=
   * @param {Event}  event   A mouse move event=0A=
   */=0A=
  Graph3d.prototype._onTooltip =3D function (event) {=0A=
    var delay =3D 300; // ms=0A=
    var boundingRect =3D this.frame.getBoundingClientRect();=0A=
    var mouseX =3D getMouseX(event) - boundingRect.left;=0A=
    var mouseY =3D getMouseY(event) - boundingRect.top;=0A=
=0A=
    if (!this.showTooltip) {=0A=
      return;=0A=
    }=0A=
=0A=
    if (this.tooltipTimeout) {=0A=
      clearTimeout(this.tooltipTimeout);=0A=
    }=0A=
=0A=
    // (delayed) display of a tooltip only if no mouse button is down=0A=
    if (this.leftButtonDown) {=0A=
      this._hideTooltip();=0A=
      return;=0A=
    }=0A=
=0A=
    if (this.tooltip && this.tooltip.dataPoint) {=0A=
      // tooltip is currently visible=0A=
      var dataPoint =3D this._dataPointFromXY(mouseX, mouseY);=0A=
      if (dataPoint !=3D=3D this.tooltip.dataPoint) {=0A=
        // datapoint changed=0A=
        if (dataPoint) {=0A=
          this._showTooltip(dataPoint);=0A=
        } else {=0A=
          this._hideTooltip();=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // tooltip is currently not visible=0A=
      var me =3D this;=0A=
      this.tooltipTimeout =3D setTimeout(function () {=0A=
        me.tooltipTimeout =3D null;=0A=
=0A=
        // show a tooltip if we have a data point=0A=
        var dataPoint =3D me._dataPointFromXY(mouseX, mouseY);=0A=
        if (dataPoint) {=0A=
          me._showTooltip(dataPoint);=0A=
        }=0A=
      }, delay);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Event handler for touchstart event on mobile devices=0A=
   */=0A=
  Graph3d.prototype._onTouchStart =3D function (event) {=0A=
    this.touchDown =3D true;=0A=
=0A=
    var me =3D this;=0A=
    this.ontouchmove =3D function (event) {=0A=
      me._onTouchMove(event);=0A=
    };=0A=
    this.ontouchend =3D function (event) {=0A=
      me._onTouchEnd(event);=0A=
    };=0A=
    util.addEventListener(document, 'touchmove', me.ontouchmove);=0A=
    util.addEventListener(document, 'touchend', me.ontouchend);=0A=
=0A=
    this._onMouseDown(event);=0A=
  };=0A=
=0A=
  /**=0A=
   * Event handler for touchmove event on mobile devices=0A=
   */=0A=
  Graph3d.prototype._onTouchMove =3D function (event) {=0A=
    this._onMouseMove(event);=0A=
  };=0A=
=0A=
  /**=0A=
   * Event handler for touchend event on mobile devices=0A=
   */=0A=
  Graph3d.prototype._onTouchEnd =3D function (event) {=0A=
    this.touchDown =3D false;=0A=
=0A=
    util.removeEventListener(document, 'touchmove', this.ontouchmove);=0A=
    util.removeEventListener(document, 'touchend', this.ontouchend);=0A=
=0A=
    this._onMouseUp(event);=0A=
  };=0A=
=0A=
  /**=0A=
   * Event handler for mouse wheel event, used to zoom the graph=0A=
   * Code from http://adomas.org/javascript-mouse-wheel/=0A=
   * @param {event}  event   The event=0A=
   */=0A=
  Graph3d.prototype._onWheel =3D function (event) {=0A=
    if (!event) /* For IE. */=0A=
      event =3D window.event;=0A=
=0A=
    // retrieve delta=0A=
    var delta =3D 0;=0A=
    if (event.wheelDelta) {=0A=
      /* IE/Opera. */=0A=
      delta =3D event.wheelDelta / 120;=0A=
    } else if (event.detail) {=0A=
      /* Mozilla case. */=0A=
      // In Mozilla, sign of delta is different than in IE.=0A=
      // Also, delta is multiple of 3.=0A=
      delta =3D -event.detail / 3;=0A=
    }=0A=
=0A=
    // If delta is nonzero, handle it.=0A=
    // Basically, delta is now positive if wheel was scrolled up,=0A=
    // and negative, if wheel was scrolled down.=0A=
    if (delta) {=0A=
      var oldLength =3D this.camera.getArmLength();=0A=
      var newLength =3D oldLength * (1 - delta / 10);=0A=
=0A=
      this.camera.setArmLength(newLength);=0A=
      this.redraw();=0A=
=0A=
      this._hideTooltip();=0A=
    }=0A=
=0A=
    // fire a cameraPositionChange event=0A=
    var parameters =3D this.getCameraPosition();=0A=
    this.emit('cameraPositionChange', parameters);=0A=
=0A=
    // Prevent default actions caused by mouse wheel.=0A=
    // That might be ugly, but we handle scrolls somehow=0A=
    // anyway, so don't bother here..=0A=
    util.preventDefault(event);=0A=
  };=0A=
=0A=
  /**=0A=
   * Test whether a point lies inside given 2D triangle=0A=
   * @param {Point2d} point=0A=
   * @param {Point2d[]} triangle=0A=
   * @return {boolean} Returns true if given point lies inside or on the =
edge of the triangle=0A=
   * @private=0A=
   */=0A=
  Graph3d.prototype._insideTriangle =3D function (point, triangle) {=0A=
    var a =3D triangle[0],=0A=
        b =3D triangle[1],=0A=
        c =3D triangle[2];=0A=
=0A=
    function sign(x) {=0A=
      return x > 0 ? 1 : x < 0 ? -1 : 0;=0A=
    }=0A=
=0A=
    var as =3D sign((b.x - a.x) * (point.y - a.y) - (b.y - a.y) * =
(point.x - a.x));=0A=
    var bs =3D sign((c.x - b.x) * (point.y - b.y) - (c.y - b.y) * =
(point.x - b.x));=0A=
    var cs =3D sign((a.x - c.x) * (point.y - c.y) - (a.y - c.y) * =
(point.x - c.x));=0A=
=0A=
    // each of the three signs must be either equal to each other or zero=0A=
    return (as =3D=3D 0 || bs =3D=3D 0 || as =3D=3D bs) && (bs =3D=3D 0 =
|| cs =3D=3D 0 || bs =3D=3D cs) && (as =3D=3D 0 || cs =3D=3D 0 || as =
=3D=3D cs);=0A=
  };=0A=
=0A=
  /**=0A=
   * Find a data point close to given screen position (x, y)=0A=
   * @param {Number} x=0A=
   * @param {Number} y=0A=
   * @return {Object | null} The closest data point or null if not close =
to any data point=0A=
   * @private=0A=
   */=0A=
  Graph3d.prototype._dataPointFromXY =3D function (x, y) {=0A=
    var i,=0A=
        distMax =3D 100,=0A=
        // px=0A=
    dataPoint =3D null,=0A=
        closestDataPoint =3D null,=0A=
        closestDist =3D null,=0A=
        center =3D new Point2d(x, y);=0A=
=0A=
    if (this.style =3D=3D=3D Graph3d.STYLE.BAR || this.style =3D=3D=3D =
Graph3d.STYLE.BARCOLOR || this.style =3D=3D=3D Graph3d.STYLE.BARSIZE) {=0A=
      // the data points are ordered from far away to closest=0A=
      for (i =3D this.dataPoints.length - 1; i >=3D 0; i--) {=0A=
        dataPoint =3D this.dataPoints[i];=0A=
        var surfaces =3D dataPoint.surfaces;=0A=
        if (surfaces) {=0A=
          for (var s =3D surfaces.length - 1; s >=3D 0; s--) {=0A=
            // split each surface in two triangles, and see if the =
center point is inside one of these=0A=
            var surface =3D surfaces[s];=0A=
            var corners =3D surface.corners;=0A=
            var triangle1 =3D [corners[0].screen, corners[1].screen, =
corners[2].screen];=0A=
            var triangle2 =3D [corners[2].screen, corners[3].screen, =
corners[0].screen];=0A=
            if (this._insideTriangle(center, triangle1) || =
this._insideTriangle(center, triangle2)) {=0A=
              // return immediately at the first hit=0A=
              return dataPoint;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // find the closest data point, using distance to the center of =
the point on 2d screen=0A=
      for (i =3D 0; i < this.dataPoints.length; i++) {=0A=
        dataPoint =3D this.dataPoints[i];=0A=
        var point =3D dataPoint.screen;=0A=
        if (point) {=0A=
          var distX =3D Math.abs(x - point.x);=0A=
          var distY =3D Math.abs(y - point.y);=0A=
          var dist =3D Math.sqrt(distX * distX + distY * distY);=0A=
=0A=
          if ((closestDist =3D=3D=3D null || dist < closestDist) && dist =
< distMax) {=0A=
            closestDist =3D dist;=0A=
            closestDataPoint =3D dataPoint;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return closestDataPoint;=0A=
  };=0A=
=0A=
  /**=0A=
   * Display a tooltip for given data point=0A=
   * @param {Object} dataPoint=0A=
   * @private=0A=
   */=0A=
  Graph3d.prototype._showTooltip =3D function (dataPoint) {=0A=
    var content, line, dot;=0A=
=0A=
    if (!this.tooltip) {=0A=
      content =3D document.createElement('div');=0A=
      content.style.position =3D 'absolute';=0A=
      content.style.padding =3D '10px';=0A=
      content.style.border =3D '1px solid #4d4d4d';=0A=
      content.style.color =3D '#1a1a1a';=0A=
      content.style.background =3D 'rgba(255,255,255,0.7)';=0A=
      content.style.borderRadius =3D '2px';=0A=
      content.style.boxShadow =3D '5px 5px 10px rgba(128,128,128,0.5)';=0A=
=0A=
      line =3D document.createElement('div');=0A=
      line.style.position =3D 'absolute';=0A=
      line.style.height =3D '40px';=0A=
      line.style.width =3D '0';=0A=
      line.style.borderLeft =3D '1px solid #4d4d4d';=0A=
=0A=
      dot =3D document.createElement('div');=0A=
      dot.style.position =3D 'absolute';=0A=
      dot.style.height =3D '0';=0A=
      dot.style.width =3D '0';=0A=
      dot.style.border =3D '5px solid #4d4d4d';=0A=
      dot.style.borderRadius =3D '5px';=0A=
=0A=
      this.tooltip =3D {=0A=
        dataPoint: null,=0A=
        dom: {=0A=
          content: content,=0A=
          line: line,=0A=
          dot: dot=0A=
        }=0A=
      };=0A=
    } else {=0A=
      content =3D this.tooltip.dom.content;=0A=
      line =3D this.tooltip.dom.line;=0A=
      dot =3D this.tooltip.dom.dot;=0A=
    }=0A=
=0A=
    this._hideTooltip();=0A=
=0A=
    this.tooltip.dataPoint =3D dataPoint;=0A=
    if (typeof this.showTooltip =3D=3D=3D 'function') {=0A=
      content.innerHTML =3D this.showTooltip(dataPoint.point);=0A=
    } else {=0A=
      content.innerHTML =3D '<table>' + '<tr><td>x:</td><td>' + =
dataPoint.point.x + '</td></tr>' + '<tr><td>y:</td><td>' + =
dataPoint.point.y + '</td></tr>' + '<tr><td>z:</td><td>' + =
dataPoint.point.z + '</td></tr>' + '</table>';=0A=
    }=0A=
=0A=
    content.style.left =3D '0';=0A=
    content.style.top =3D '0';=0A=
    this.frame.appendChild(content);=0A=
    this.frame.appendChild(line);=0A=
    this.frame.appendChild(dot);=0A=
=0A=
    // calculate sizes=0A=
    var contentWidth =3D content.offsetWidth;=0A=
    var contentHeight =3D content.offsetHeight;=0A=
    var lineHeight =3D line.offsetHeight;=0A=
    var dotWidth =3D dot.offsetWidth;=0A=
    var dotHeight =3D dot.offsetHeight;=0A=
=0A=
    var left =3D dataPoint.screen.x - contentWidth / 2;=0A=
    left =3D Math.min(Math.max(left, 10), this.frame.clientWidth - 10 - =
contentWidth);=0A=
=0A=
    line.style.left =3D dataPoint.screen.x + 'px';=0A=
    line.style.top =3D dataPoint.screen.y - lineHeight + 'px';=0A=
    content.style.left =3D left + 'px';=0A=
    content.style.top =3D dataPoint.screen.y - lineHeight - =
contentHeight + 'px';=0A=
    dot.style.left =3D dataPoint.screen.x - dotWidth / 2 + 'px';=0A=
    dot.style.top =3D dataPoint.screen.y - dotHeight / 2 + 'px';=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the tooltip when displayed=0A=
   * @private=0A=
   */=0A=
  Graph3d.prototype._hideTooltip =3D function () {=0A=
    if (this.tooltip) {=0A=
      this.tooltip.dataPoint =3D null;=0A=
=0A=
      for (var prop in this.tooltip.dom) {=0A=
        if (this.tooltip.dom.hasOwnProperty(prop)) {=0A=
          var elem =3D this.tooltip.dom[prop];=0A=
          if (elem && elem.parentNode) {=0A=
            elem.parentNode.removeChild(elem);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  =
/**----------------------------------------------------------------------=
----**/=0A=
=0A=
  /**=0A=
   * Get the horizontal mouse position from a mouse event=0A=
   * @param {Event} event=0A=
   * @return {Number} mouse x=0A=
   */=0A=
  function getMouseX(event) {=0A=
    if ('clientX' in event) return event.clientX;=0A=
    return event.targetTouches[0] && event.targetTouches[0].clientX || 0;=0A=
  }=0A=
=0A=
  /**=0A=
   * Get the vertical mouse position from a mouse event=0A=
   * @param {Event} event=0A=
   * @return {Number} mouse y=0A=
   */=0A=
  function getMouseY(event) {=0A=
    if ('clientY' in event) return event.clientY;=0A=
    return event.targetTouches[0] && event.targetTouches[0].clientY || 0;=0A=
  }=0A=
=0A=
  module.exports =3D Graph3d;=0A=
=0A=
  // use use defaults=0A=
=0A=
/***/ },=0A=
/* 18 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * @prototype Point2d=0A=
   * @param {Number} [x]=0A=
   * @param {Number} [y]=0A=
   */=0A=
  "use strict";=0A=
=0A=
  function Point2d(x, y) {=0A=
    this.x =3D x !=3D=3D undefined ? x : 0;=0A=
    this.y =3D y !=3D=3D undefined ? y : 0;=0A=
  }=0A=
=0A=
  module.exports =3D Point2d;=0A=
=0A=
/***/ },=0A=
/* 19 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  =0A=
  /**=0A=
   * Expose `Emitter`.=0A=
   */=0A=
=0A=
  module.exports =3D Emitter;=0A=
=0A=
  /**=0A=
   * Initialize a new `Emitter`.=0A=
   *=0A=
   * @api public=0A=
   */=0A=
=0A=
  function Emitter(obj) {=0A=
    if (obj) return mixin(obj);=0A=
  };=0A=
=0A=
  /**=0A=
   * Mixin the emitter properties.=0A=
   *=0A=
   * @param {Object} obj=0A=
   * @return {Object}=0A=
   * @api private=0A=
   */=0A=
=0A=
  function mixin(obj) {=0A=
    for (var key in Emitter.prototype) {=0A=
      obj[key] =3D Emitter.prototype[key];=0A=
    }=0A=
    return obj;=0A=
  }=0A=
=0A=
  /**=0A=
   * Listen on the given `event` with `fn`.=0A=
   *=0A=
   * @param {String} event=0A=
   * @param {Function} fn=0A=
   * @return {Emitter}=0A=
   * @api public=0A=
   */=0A=
=0A=
  Emitter.prototype.on =3D=0A=
  Emitter.prototype.addEventListener =3D function(event, fn){=0A=
    this._callbacks =3D this._callbacks || {};=0A=
    (this._callbacks[event] =3D this._callbacks[event] || [])=0A=
      .push(fn);=0A=
    return this;=0A=
  };=0A=
=0A=
  /**=0A=
   * Adds an `event` listener that will be invoked a single=0A=
   * time then automatically removed.=0A=
   *=0A=
   * @param {String} event=0A=
   * @param {Function} fn=0A=
   * @return {Emitter}=0A=
   * @api public=0A=
   */=0A=
=0A=
  Emitter.prototype.once =3D function(event, fn){=0A=
    var self =3D this;=0A=
    this._callbacks =3D this._callbacks || {};=0A=
=0A=
    function on() {=0A=
      self.off(event, on);=0A=
      fn.apply(this, arguments);=0A=
    }=0A=
=0A=
    on.fn =3D fn;=0A=
    this.on(event, on);=0A=
    return this;=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove the given callback for `event` or all=0A=
   * registered callbacks.=0A=
   *=0A=
   * @param {String} event=0A=
   * @param {Function} fn=0A=
   * @return {Emitter}=0A=
   * @api public=0A=
   */=0A=
=0A=
  Emitter.prototype.off =3D=0A=
  Emitter.prototype.removeListener =3D=0A=
  Emitter.prototype.removeAllListeners =3D=0A=
  Emitter.prototype.removeEventListener =3D function(event, fn){=0A=
    this._callbacks =3D this._callbacks || {};=0A=
=0A=
    // all=0A=
    if (0 =3D=3D arguments.length) {=0A=
      this._callbacks =3D {};=0A=
      return this;=0A=
    }=0A=
=0A=
    // specific event=0A=
    var callbacks =3D this._callbacks[event];=0A=
    if (!callbacks) return this;=0A=
=0A=
    // remove all handlers=0A=
    if (1 =3D=3D arguments.length) {=0A=
      delete this._callbacks[event];=0A=
      return this;=0A=
    }=0A=
=0A=
    // remove specific handler=0A=
    var cb;=0A=
    for (var i =3D 0; i < callbacks.length; i++) {=0A=
      cb =3D callbacks[i];=0A=
      if (cb =3D=3D=3D fn || cb.fn =3D=3D=3D fn) {=0A=
        callbacks.splice(i, 1);=0A=
        break;=0A=
      }=0A=
    }=0A=
    return this;=0A=
  };=0A=
=0A=
  /**=0A=
   * Emit `event` with the given args.=0A=
   *=0A=
   * @param {String} event=0A=
   * @param {Mixed} ...=0A=
   * @return {Emitter}=0A=
   */=0A=
=0A=
  Emitter.prototype.emit =3D function(event){=0A=
    this._callbacks =3D this._callbacks || {};=0A=
    var args =3D [].slice.call(arguments, 1)=0A=
      , callbacks =3D this._callbacks[event];=0A=
=0A=
    if (callbacks) {=0A=
      callbacks =3D callbacks.slice(0);=0A=
      for (var i =3D 0, len =3D callbacks.length; i < len; ++i) {=0A=
        callbacks[i].apply(this, args);=0A=
      }=0A=
    }=0A=
=0A=
    return this;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return array of callbacks for `event`.=0A=
   *=0A=
   * @param {String} event=0A=
   * @return {Array}=0A=
   * @api public=0A=
   */=0A=
=0A=
  Emitter.prototype.listeners =3D function(event){=0A=
    this._callbacks =3D this._callbacks || {};=0A=
    return this._callbacks[event] || [];=0A=
  };=0A=
=0A=
  /**=0A=
   * Check if this emitter has `event` handlers.=0A=
   *=0A=
   * @param {String} event=0A=
   * @return {Boolean}=0A=
   * @api public=0A=
   */=0A=
=0A=
  Emitter.prototype.hasListeners =3D function(event){=0A=
    return !! this.listeners(event).length;=0A=
  };=0A=
=0A=
=0A=
/***/ },=0A=
/* 20 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * @prototype Point3d=0A=
   * @param {Number} [x]=0A=
   * @param {Number} [y]=0A=
   * @param {Number} [z]=0A=
   */=0A=
  "use strict";=0A=
=0A=
  function Point3d(x, y, z) {=0A=
    this.x =3D x !=3D=3D undefined ? x : 0;=0A=
    this.y =3D y !=3D=3D undefined ? y : 0;=0A=
    this.z =3D z !=3D=3D undefined ? z : 0;=0A=
  };=0A=
=0A=
  /**=0A=
   * Subtract the two provided points, returns a-b=0A=
   * @param {Point3d} a=0A=
   * @param {Point3d} b=0A=
   * @return {Point3d} a-b=0A=
   */=0A=
  Point3d.subtract =3D function (a, b) {=0A=
    var sub =3D new Point3d();=0A=
    sub.x =3D a.x - b.x;=0A=
    sub.y =3D a.y - b.y;=0A=
    sub.z =3D a.z - b.z;=0A=
    return sub;=0A=
  };=0A=
=0A=
  /**=0A=
   * Add the two provided points, returns a+b=0A=
   * @param {Point3d} a=0A=
   * @param {Point3d} b=0A=
   * @return {Point3d} a+b=0A=
   */=0A=
  Point3d.add =3D function (a, b) {=0A=
    var sum =3D new Point3d();=0A=
    sum.x =3D a.x + b.x;=0A=
    sum.y =3D a.y + b.y;=0A=
    sum.z =3D a.z + b.z;=0A=
    return sum;=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the average of two 3d points=0A=
   * @param {Point3d} a=0A=
   * @param {Point3d} b=0A=
   * @return {Point3d} The average, (a+b)/2=0A=
   */=0A=
  Point3d.avg =3D function (a, b) {=0A=
    return new Point3d((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / =
2);=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the cross product of the two provided points, returns axb=0A=
   * Documentation: http://en.wikipedia.org/wiki/Cross_product=0A=
   * @param {Point3d} a=0A=
   * @param {Point3d} b=0A=
   * @return {Point3d} cross product axb=0A=
   */=0A=
  Point3d.crossProduct =3D function (a, b) {=0A=
    var crossproduct =3D new Point3d();=0A=
=0A=
    crossproduct.x =3D a.y * b.z - a.z * b.y;=0A=
    crossproduct.y =3D a.z * b.x - a.x * b.z;=0A=
    crossproduct.z =3D a.x * b.y - a.y * b.x;=0A=
=0A=
    return crossproduct;=0A=
  };=0A=
=0A=
  /**=0A=
   * Rtrieve the length of the vector (or the distance from this point =
to the origin=0A=
   * @return {Number}  length=0A=
   */=0A=
  Point3d.prototype.length =3D function () {=0A=
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * =
this.z);=0A=
  };=0A=
=0A=
  module.exports =3D Point3d;=0A=
=0A=
/***/ },=0A=
/* 21 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Point3d =3D __webpack_require__(20);=0A=
=0A=
  /**=0A=
   * @class Camera=0A=
   * The camera is mounted on a (virtual) camera arm. The camera arm can =
rotate=0A=
   * The camera is always looking in the direction of the origin of the =
arm.=0A=
   * This way, the camera always rotates around one fixed point, the =
location=0A=
   * of the camera arm.=0A=
   *=0A=
   * Documentation:=0A=
   *   http://en.wikipedia.org/wiki/3D_projection=0A=
   */=0A=
  function Camera() {=0A=
    this.armLocation =3D new Point3d();=0A=
    this.armRotation =3D {};=0A=
    this.armRotation.horizontal =3D 0;=0A=
    this.armRotation.vertical =3D 0;=0A=
    this.armLength =3D 1.7;=0A=
=0A=
    this.cameraLocation =3D new Point3d();=0A=
    this.cameraRotation =3D new Point3d(0.5 * Math.PI, 0, 0);=0A=
=0A=
    this.calculateCameraOrientation();=0A=
  }=0A=
=0A=
  /**=0A=
   * Set the location (origin) of the arm=0A=
   * @param {Number} x  Normalized value of x=0A=
   * @param {Number} y  Normalized value of y=0A=
   * @param {Number} z  Normalized value of z=0A=
   */=0A=
  Camera.prototype.setArmLocation =3D function (x, y, z) {=0A=
    this.armLocation.x =3D x;=0A=
    this.armLocation.y =3D y;=0A=
    this.armLocation.z =3D z;=0A=
=0A=
    this.calculateCameraOrientation();=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the rotation of the camera arm=0A=
   * @param {Number} horizontal   The horizontal rotation, between 0 and =
2*PI.=0A=
   *                Optional, can be left undefined.=0A=
   * @param {Number} vertical   The vertical rotation, between 0 and =
0.5*PI=0A=
   *                if vertical=3D0.5*PI, the graph is shown from the=0A=
   *                top. Optional, can be left undefined.=0A=
   */=0A=
  Camera.prototype.setArmRotation =3D function (horizontal, vertical) {=0A=
    if (horizontal !=3D=3D undefined) {=0A=
      this.armRotation.horizontal =3D horizontal;=0A=
    }=0A=
=0A=
    if (vertical !=3D=3D undefined) {=0A=
      this.armRotation.vertical =3D vertical;=0A=
      if (this.armRotation.vertical < 0) this.armRotation.vertical =3D 0;=0A=
      if (this.armRotation.vertical > 0.5 * Math.PI) =
this.armRotation.vertical =3D 0.5 * Math.PI;=0A=
    }=0A=
=0A=
    if (horizontal !=3D=3D undefined || vertical !=3D=3D undefined) {=0A=
      this.calculateCameraOrientation();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the current arm rotation=0A=
   * @return {object}   An object with parameters horizontal and vertical=0A=
   */=0A=
  Camera.prototype.getArmRotation =3D function () {=0A=
    var rot =3D {};=0A=
    rot.horizontal =3D this.armRotation.horizontal;=0A=
    rot.vertical =3D this.armRotation.vertical;=0A=
=0A=
    return rot;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the (normalized) length of the camera arm.=0A=
   * @param {Number} length A length between 0.71 and 5.0=0A=
   */=0A=
  Camera.prototype.setArmLength =3D function (length) {=0A=
    if (length =3D=3D=3D undefined) return;=0A=
=0A=
    this.armLength =3D length;=0A=
=0A=
    // Radius must be larger than the corner of the graph,=0A=
    // which has a distance of sqrt(0.5^2+0.5^2) =3D 0.71 from the =
center of the=0A=
    // graph=0A=
    if (this.armLength < 0.71) this.armLength =3D 0.71;=0A=
    if (this.armLength > 5.0) this.armLength =3D 5.0;=0A=
=0A=
    this.calculateCameraOrientation();=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the arm length=0A=
   * @return {Number} length=0A=
   */=0A=
  Camera.prototype.getArmLength =3D function () {=0A=
    return this.armLength;=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the camera location=0A=
   * @return {Point3d} cameraLocation=0A=
   */=0A=
  Camera.prototype.getCameraLocation =3D function () {=0A=
    return this.cameraLocation;=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the camera rotation=0A=
   * @return {Point3d} cameraRotation=0A=
   */=0A=
  Camera.prototype.getCameraRotation =3D function () {=0A=
    return this.cameraRotation;=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the location and rotation of the camera based on the=0A=
   * position and orientation of the camera arm=0A=
   */=0A=
  Camera.prototype.calculateCameraOrientation =3D function () {=0A=
    // calculate location of the camera=0A=
    this.cameraLocation.x =3D this.armLocation.x - this.armLength * =
Math.sin(this.armRotation.horizontal) * =
Math.cos(this.armRotation.vertical);=0A=
    this.cameraLocation.y =3D this.armLocation.y - this.armLength * =
Math.cos(this.armRotation.horizontal) * =
Math.cos(this.armRotation.vertical);=0A=
    this.cameraLocation.z =3D this.armLocation.z + this.armLength * =
Math.sin(this.armRotation.vertical);=0A=
=0A=
    // calculate rotation of the camera=0A=
    this.cameraRotation.x =3D Math.PI / 2 - this.armRotation.vertical;=0A=
    this.cameraRotation.y =3D 0;=0A=
    this.cameraRotation.z =3D -this.armRotation.horizontal;=0A=
  };=0A=
=0A=
  module.exports =3D Camera;=0A=
=0A=
/***/ },=0A=
/* 22 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var DataView =3D __webpack_require__(16);=0A=
=0A=
  /**=0A=
   * @class Filter=0A=
   *=0A=
   * @param {DataSet} data The google data table=0A=
   * @param {Number}  column             The index of the column to be =
filtered=0A=
   * @param {Graph} graph           The graph=0A=
   */=0A=
  function Filter(data, column, graph) {=0A=
    this.data =3D data;=0A=
    this.column =3D column;=0A=
    this.graph =3D graph; // the parent graph=0A=
=0A=
    this.index =3D undefined;=0A=
    this.value =3D undefined;=0A=
=0A=
    // read all distinct values and select the first one=0A=
    this.values =3D graph.getDistinctValues(data.get(), this.column);=0A=
=0A=
    // sort both numeric and string values correctly=0A=
    this.values.sort(function (a, b) {=0A=
      return a > b ? 1 : a < b ? -1 : 0;=0A=
    });=0A=
=0A=
    if (this.values.length > 0) {=0A=
      this.selectValue(0);=0A=
    }=0A=
=0A=
    // create an array with the filtered datapoints. this will be loaded =
afterwards=0A=
    this.dataPoints =3D [];=0A=
=0A=
    this.loaded =3D false;=0A=
    this.onLoadCallback =3D undefined;=0A=
=0A=
    if (graph.animationPreload) {=0A=
      this.loaded =3D false;=0A=
      this.loadInBackground();=0A=
    } else {=0A=
      this.loaded =3D true;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the label=0A=
   * @return {string} label=0A=
   */=0A=
  Filter.prototype.isLoaded =3D function () {=0A=
    return this.loaded;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the loaded progress=0A=
   * @return {Number} percentage between 0 and 100=0A=
   */=0A=
  Filter.prototype.getLoadedProgress =3D function () {=0A=
    var len =3D this.values.length;=0A=
=0A=
    var i =3D 0;=0A=
    while (this.dataPoints[i]) {=0A=
      i++;=0A=
    }=0A=
=0A=
    return Math.round(i / len * 100);=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the label=0A=
   * @return {string} label=0A=
   */=0A=
  Filter.prototype.getLabel =3D function () {=0A=
    return this.graph.filterLabel;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the columnIndex of the filter=0A=
   * @return {Number} columnIndex=0A=
   */=0A=
  Filter.prototype.getColumn =3D function () {=0A=
    return this.column;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the currently selected value. Returns undefined if there is =
no selection=0A=
   * @return {*} value=0A=
   */=0A=
  Filter.prototype.getSelectedValue =3D function () {=0A=
    if (this.index =3D=3D=3D undefined) return undefined;=0A=
=0A=
    return this.values[this.index];=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve all values of the filter=0A=
   * @return {Array} values=0A=
   */=0A=
  Filter.prototype.getValues =3D function () {=0A=
    return this.values;=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve one value of the filter=0A=
   * @param {Number}  index=0A=
   * @return {*} value=0A=
   */=0A=
  Filter.prototype.getValue =3D function (index) {=0A=
    if (index >=3D this.values.length) throw 'Error: index out of range';=0A=
=0A=
    return this.values[index];=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the (filtered) dataPoints for the currently selected =
filter index=0A=
   * @param {Number} [index] (optional)=0A=
   * @return {Array} dataPoints=0A=
   */=0A=
  Filter.prototype._getDataPoints =3D function (index) {=0A=
    if (index =3D=3D=3D undefined) index =3D this.index;=0A=
=0A=
    if (index =3D=3D=3D undefined) return [];=0A=
=0A=
    var dataPoints;=0A=
    if (this.dataPoints[index]) {=0A=
      dataPoints =3D this.dataPoints[index];=0A=
    } else {=0A=
      var f =3D {};=0A=
      f.column =3D this.column;=0A=
      f.value =3D this.values[index];=0A=
=0A=
      var dataView =3D new DataView(this.data, { filter: function =
filter(item) {=0A=
          return item[f.column] =3D=3D f.value;=0A=
        } }).get();=0A=
      dataPoints =3D this.graph._getDataPoints(dataView);=0A=
=0A=
      this.dataPoints[index] =3D dataPoints;=0A=
    }=0A=
=0A=
    return dataPoints;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a callback function when the filter is fully loaded.=0A=
   */=0A=
  Filter.prototype.setOnLoadCallback =3D function (callback) {=0A=
    this.onLoadCallback =3D callback;=0A=
  };=0A=
=0A=
  /**=0A=
   * Add a value to the list with available values for this filter=0A=
   * No double entries will be created.=0A=
   * @param {Number} index=0A=
   */=0A=
  Filter.prototype.selectValue =3D function (index) {=0A=
    if (index >=3D this.values.length) throw 'Error: index out of range';=0A=
=0A=
    this.index =3D index;=0A=
    this.value =3D this.values[index];=0A=
  };=0A=
=0A=
  /**=0A=
   * Load all filtered rows in the background one by one=0A=
   * Start this method without providing an index!=0A=
   */=0A=
  Filter.prototype.loadInBackground =3D function (index) {=0A=
    if (index =3D=3D=3D undefined) index =3D 0;=0A=
=0A=
    var frame =3D this.graph.frame;=0A=
=0A=
    if (index < this.values.length) {=0A=
      var dataPointsTemp =3D this._getDataPoints(index);=0A=
      //this.graph.redrawInfo(); // TODO: not neat=0A=
=0A=
      // create a progress box=0A=
      if (frame.progress =3D=3D=3D undefined) {=0A=
        frame.progress =3D document.createElement('DIV');=0A=
        frame.progress.style.position =3D 'absolute';=0A=
        frame.progress.style.color =3D 'gray';=0A=
        frame.appendChild(frame.progress);=0A=
      }=0A=
      var progress =3D this.getLoadedProgress();=0A=
      frame.progress.innerHTML =3D 'Loading animation... ' + progress + =
'%';=0A=
      // TODO: this is no nice solution...=0A=
      frame.progress.style.bottom =3D 60 + 'px'; // TODO: use height of =
slider=0A=
      frame.progress.style.left =3D 10 + 'px';=0A=
=0A=
      var me =3D this;=0A=
      setTimeout(function () {=0A=
        me.loadInBackground(index + 1);=0A=
      }, 10);=0A=
      this.loaded =3D false;=0A=
    } else {=0A=
      this.loaded =3D true;=0A=
=0A=
      // remove the progress box=0A=
      if (frame.progress !=3D=3D undefined) {=0A=
        frame.removeChild(frame.progress);=0A=
        frame.progress =3D undefined;=0A=
      }=0A=
=0A=
      if (this.onLoadCallback) this.onLoadCallback();=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D Filter;=0A=
=0A=
/***/ },=0A=
/* 23 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * @constructor Slider=0A=
   *=0A=
   * An html slider control with start/stop/prev/next buttons=0A=
   * @param {Element} container  The element where the slider will be =
created=0A=
   * @param {Object} options   Available options:=0A=
   *                 {boolean} visible   If true (default) the=0A=
   *                           slider is visible.=0A=
   */=0A=
  function Slider(container, options) {=0A=
    if (container =3D=3D=3D undefined) {=0A=
      throw 'Error: No container element defined';=0A=
    }=0A=
    this.container =3D container;=0A=
    this.visible =3D options && options.visible !=3D undefined ? =
options.visible : true;=0A=
=0A=
    if (this.visible) {=0A=
      this.frame =3D document.createElement('DIV');=0A=
      //this.frame.style.backgroundColor =3D '#E5E5E5';=0A=
      this.frame.style.width =3D '100%';=0A=
      this.frame.style.position =3D 'relative';=0A=
      this.container.appendChild(this.frame);=0A=
=0A=
      this.frame.prev =3D document.createElement('INPUT');=0A=
      this.frame.prev.type =3D 'BUTTON';=0A=
      this.frame.prev.value =3D 'Prev';=0A=
      this.frame.appendChild(this.frame.prev);=0A=
=0A=
      this.frame.play =3D document.createElement('INPUT');=0A=
      this.frame.play.type =3D 'BUTTON';=0A=
      this.frame.play.value =3D 'Play';=0A=
      this.frame.appendChild(this.frame.play);=0A=
=0A=
      this.frame.next =3D document.createElement('INPUT');=0A=
      this.frame.next.type =3D 'BUTTON';=0A=
      this.frame.next.value =3D 'Next';=0A=
      this.frame.appendChild(this.frame.next);=0A=
=0A=
      this.frame.bar =3D document.createElement('INPUT');=0A=
      this.frame.bar.type =3D 'BUTTON';=0A=
      this.frame.bar.style.position =3D 'absolute';=0A=
      this.frame.bar.style.border =3D '1px solid red';=0A=
      this.frame.bar.style.width =3D '100px';=0A=
      this.frame.bar.style.height =3D '6px';=0A=
      this.frame.bar.style.borderRadius =3D '2px';=0A=
      this.frame.bar.style.MozBorderRadius =3D '2px';=0A=
      this.frame.bar.style.border =3D '1px solid #7F7F7F';=0A=
      this.frame.bar.style.backgroundColor =3D '#E5E5E5';=0A=
      this.frame.appendChild(this.frame.bar);=0A=
=0A=
      this.frame.slide =3D document.createElement('INPUT');=0A=
      this.frame.slide.type =3D 'BUTTON';=0A=
      this.frame.slide.style.margin =3D '0px';=0A=
      this.frame.slide.value =3D ' ';=0A=
      this.frame.slide.style.position =3D 'relative';=0A=
      this.frame.slide.style.left =3D '-100px';=0A=
      this.frame.appendChild(this.frame.slide);=0A=
=0A=
      // create events=0A=
      var me =3D this;=0A=
      this.frame.slide.onmousedown =3D function (event) {=0A=
        me._onMouseDown(event);=0A=
      };=0A=
      this.frame.prev.onclick =3D function (event) {=0A=
        me.prev(event);=0A=
      };=0A=
      this.frame.play.onclick =3D function (event) {=0A=
        me.togglePlay(event);=0A=
      };=0A=
      this.frame.next.onclick =3D function (event) {=0A=
        me.next(event);=0A=
      };=0A=
    }=0A=
=0A=
    this.onChangeCallback =3D undefined;=0A=
=0A=
    this.values =3D [];=0A=
    this.index =3D undefined;=0A=
=0A=
    this.playTimeout =3D undefined;=0A=
    this.playInterval =3D 1000; // milliseconds=0A=
    this.playLoop =3D true;=0A=
  }=0A=
=0A=
  /**=0A=
   * Select the previous index=0A=
   */=0A=
  Slider.prototype.prev =3D function () {=0A=
    var index =3D this.getIndex();=0A=
    if (index > 0) {=0A=
      index--;=0A=
      this.setIndex(index);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Select the next index=0A=
   */=0A=
  Slider.prototype.next =3D function () {=0A=
    var index =3D this.getIndex();=0A=
    if (index < this.values.length - 1) {=0A=
      index++;=0A=
      this.setIndex(index);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Select the next index=0A=
   */=0A=
  Slider.prototype.playNext =3D function () {=0A=
    var start =3D new Date();=0A=
=0A=
    var index =3D this.getIndex();=0A=
    if (index < this.values.length - 1) {=0A=
      index++;=0A=
      this.setIndex(index);=0A=
    } else if (this.playLoop) {=0A=
      // jump to the start=0A=
      index =3D 0;=0A=
      this.setIndex(index);=0A=
    }=0A=
=0A=
    var end =3D new Date();=0A=
    var diff =3D end - start;=0A=
=0A=
    // calculate how much time it to to set the index and to execute the =
callback=0A=
    // function.=0A=
    var interval =3D Math.max(this.playInterval - diff, 0);=0A=
    // document.title =3D diff // TODO: cleanup=0A=
=0A=
    var me =3D this;=0A=
    this.playTimeout =3D setTimeout(function () {=0A=
      me.playNext();=0A=
    }, interval);=0A=
  };=0A=
=0A=
  /**=0A=
   * Toggle start or stop playing=0A=
   */=0A=
  Slider.prototype.togglePlay =3D function () {=0A=
    if (this.playTimeout =3D=3D=3D undefined) {=0A=
      this.play();=0A=
    } else {=0A=
      this.stop();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Start playing=0A=
   */=0A=
  Slider.prototype.play =3D function () {=0A=
    // Test whether already playing=0A=
    if (this.playTimeout) return;=0A=
=0A=
    this.playNext();=0A=
=0A=
    if (this.frame) {=0A=
      this.frame.play.value =3D 'Stop';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop playing=0A=
   */=0A=
  Slider.prototype.stop =3D function () {=0A=
    clearInterval(this.playTimeout);=0A=
    this.playTimeout =3D undefined;=0A=
=0A=
    if (this.frame) {=0A=
      this.frame.play.value =3D 'Play';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a callback function which will be triggered when the value of =
the=0A=
   * slider bar has changed.=0A=
   */=0A=
  Slider.prototype.setOnChangeCallback =3D function (callback) {=0A=
    this.onChangeCallback =3D callback;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the interval for playing the list=0A=
   * @param {Number} interval   The interval in milliseconds=0A=
   */=0A=
  Slider.prototype.setPlayInterval =3D function (interval) {=0A=
    this.playInterval =3D interval;=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the current play interval=0A=
   * @return {Number} interval   The interval in milliseconds=0A=
   */=0A=
  Slider.prototype.getPlayInterval =3D function (interval) {=0A=
    return this.playInterval;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set looping on or off=0A=
   * @pararm {boolean} doLoop  If true, the slider will jump to the =
start when=0A=
   *               the end is passed, and will jump to the end=0A=
   *               when the start is passed.=0A=
   */=0A=
  Slider.prototype.setPlayLoop =3D function (doLoop) {=0A=
    this.playLoop =3D doLoop;=0A=
  };=0A=
=0A=
  /**=0A=
   * Execute the onchange callback function=0A=
   */=0A=
  Slider.prototype.onChange =3D function () {=0A=
    if (this.onChangeCallback !=3D=3D undefined) {=0A=
      this.onChangeCallback();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * redraw the slider on the correct place=0A=
   */=0A=
  Slider.prototype.redraw =3D function () {=0A=
    if (this.frame) {=0A=
      // resize the bar=0A=
      this.frame.bar.style.top =3D this.frame.clientHeight / 2 - =
this.frame.bar.offsetHeight / 2 + 'px';=0A=
      this.frame.bar.style.width =3D this.frame.clientWidth - =
this.frame.prev.clientWidth - this.frame.play.clientWidth - =
this.frame.next.clientWidth - 30 + 'px';=0A=
=0A=
      // position the slider button=0A=
      var left =3D this.indexToLeft(this.index);=0A=
      this.frame.slide.style.left =3D left + 'px';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the list with values for the slider=0A=
   * @param {Array} values   A javascript array with values (any type)=0A=
   */=0A=
  Slider.prototype.setValues =3D function (values) {=0A=
    this.values =3D values;=0A=
=0A=
    if (this.values.length > 0) this.setIndex(0);else this.index =3D =
undefined;=0A=
  };=0A=
=0A=
  /**=0A=
   * Select a value by its index=0A=
   * @param {Number} index=0A=
   */=0A=
  Slider.prototype.setIndex =3D function (index) {=0A=
    if (index < this.values.length) {=0A=
      this.index =3D index;=0A=
=0A=
      this.redraw();=0A=
      this.onChange();=0A=
    } else {=0A=
      throw 'Error: index out of range';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * retrieve the index of the currently selected vaue=0A=
   * @return {Number} index=0A=
   */=0A=
  Slider.prototype.getIndex =3D function () {=0A=
    return this.index;=0A=
  };=0A=
=0A=
  /**=0A=
   * retrieve the currently selected value=0A=
   * @return {*} value=0A=
   */=0A=
  Slider.prototype.get =3D function () {=0A=
    return this.values[this.index];=0A=
  };=0A=
=0A=
  Slider.prototype._onMouseDown =3D function (event) {=0A=
    // only react on left mouse button down=0A=
    var leftButtonDown =3D event.which ? event.which =3D=3D=3D 1 : =
event.button =3D=3D=3D 1;=0A=
    if (!leftButtonDown) return;=0A=
=0A=
    this.startClientX =3D event.clientX;=0A=
    this.startSlideX =3D parseFloat(this.frame.slide.style.left);=0A=
=0A=
    this.frame.style.cursor =3D 'move';=0A=
=0A=
    // add event listeners to handle moving the contents=0A=
    // we store the function onmousemove and onmouseup in the graph, so =
we can=0A=
    // remove the eventlisteners lateron in the function mouseUp()=0A=
    var me =3D this;=0A=
    this.onmousemove =3D function (event) {=0A=
      me._onMouseMove(event);=0A=
    };=0A=
    this.onmouseup =3D function (event) {=0A=
      me._onMouseUp(event);=0A=
    };=0A=
    util.addEventListener(document, 'mousemove', this.onmousemove);=0A=
    util.addEventListener(document, 'mouseup', this.onmouseup);=0A=
    util.preventDefault(event);=0A=
  };=0A=
=0A=
  Slider.prototype.leftToIndex =3D function (left) {=0A=
    var width =3D parseFloat(this.frame.bar.style.width) - =
this.frame.slide.clientWidth - 10;=0A=
    var x =3D left - 3;=0A=
=0A=
    var index =3D Math.round(x / width * (this.values.length - 1));=0A=
    if (index < 0) index =3D 0;=0A=
    if (index > this.values.length - 1) index =3D this.values.length - 1;=0A=
=0A=
    return index;=0A=
  };=0A=
=0A=
  Slider.prototype.indexToLeft =3D function (index) {=0A=
    var width =3D parseFloat(this.frame.bar.style.width) - =
this.frame.slide.clientWidth - 10;=0A=
=0A=
    var x =3D index / (this.values.length - 1) * width;=0A=
    var left =3D x + 3;=0A=
=0A=
    return left;=0A=
  };=0A=
=0A=
  Slider.prototype._onMouseMove =3D function (event) {=0A=
    var diff =3D event.clientX - this.startClientX;=0A=
    var x =3D this.startSlideX + diff;=0A=
=0A=
    var index =3D this.leftToIndex(x);=0A=
=0A=
    this.setIndex(index);=0A=
=0A=
    util.preventDefault();=0A=
  };=0A=
=0A=
  Slider.prototype._onMouseUp =3D function (event) {=0A=
    this.frame.style.cursor =3D 'auto';=0A=
=0A=
    // remove event listeners=0A=
    util.removeEventListener(document, 'mousemove', this.onmousemove);=0A=
    util.removeEventListener(document, 'mouseup', this.onmouseup);=0A=
=0A=
    util.preventDefault();=0A=
  };=0A=
=0A=
  module.exports =3D Slider;=0A=
=0A=
/***/ },=0A=
/* 24 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * @prototype StepNumber=0A=
   * The class StepNumber is an iterator for Numbers. You provide a =
start and end=0A=
   * value, and a best step size. StepNumber itself rounds to fixed =
values and=0A=
   * a finds the step that best fits the provided step.=0A=
   *=0A=
   * If prettyStep is true, the step size is chosen as close as possible =
to the=0A=
   * provided step, but being a round value like 1, 2, 5, 10, 20, 50, =
....=0A=
   *=0A=
   * Example usage:=0A=
   *   var step =3D new StepNumber(0, 10, 2.5, true);=0A=
   *   step.start();=0A=
   *   while (!step.end()) {=0A=
   *   alert(step.getCurrent());=0A=
   *   step.next();=0A=
   *   }=0A=
   *=0A=
   * Version: 1.0=0A=
   *=0A=
   * @param {Number} start     The start value=0A=
   * @param {Number} end     The end value=0A=
   * @param {Number} step    Optional. Step size. Must be a positive =
value.=0A=
   * @param {boolean} prettyStep Optional. If true, the step size is =
rounded=0A=
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)=0A=
   */=0A=
  "use strict";=0A=
=0A=
  function StepNumber(start, end, step, prettyStep) {=0A=
    // set default values=0A=
    this._start =3D 0;=0A=
    this._end =3D 0;=0A=
    this._step =3D 1;=0A=
    this.prettyStep =3D true;=0A=
    this.precision =3D 5;=0A=
=0A=
    this._current =3D 0;=0A=
    this.setRange(start, end, step, prettyStep);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a new range: start, end and step.=0A=
   *=0A=
   * @param {Number} start     The start value=0A=
   * @param {Number} end     The end value=0A=
   * @param {Number} step    Optional. Step size. Must be a positive =
value.=0A=
   * @param {boolean} prettyStep Optional. If true, the step size is =
rounded=0A=
   *               To a pretty step size (like 1, 2, 5, 10, 20, 50, ...)=0A=
   */=0A=
  StepNumber.prototype.setRange =3D function (start, end, step, =
prettyStep) {=0A=
    this._start =3D start ? start : 0;=0A=
    this._end =3D end ? end : 0;=0A=
=0A=
    this.setStep(step, prettyStep);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a new step size=0A=
   * @param {Number} step    New step size. Must be a positive value=0A=
   * @param {boolean} prettyStep Optional. If true, the provided step is =
rounded=0A=
   *               to a pretty step size (like 1, 2, 5, 10, 20, 50, ...)=0A=
   */=0A=
  StepNumber.prototype.setStep =3D function (step, prettyStep) {=0A=
    if (step =3D=3D=3D undefined || step <=3D 0) return;=0A=
=0A=
    if (prettyStep !=3D=3D undefined) this.prettyStep =3D prettyStep;=0A=
=0A=
    if (this.prettyStep =3D=3D=3D true) this._step =3D =
StepNumber.calculatePrettyStep(step);else this._step =3D step;=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate a nice step size, closest to the desired step size.=0A=
   * Returns a value in one of the ranges 1*10^n, 2*10^n, or 5*10^n, =
where n is an=0A=
   * integer Number. For example 1, 2, 5, 10, 20, 50, etc...=0A=
   * @param {Number}  step  Desired step size=0A=
   * @return {Number}     Nice step size=0A=
   */=0A=
  StepNumber.calculatePrettyStep =3D function (step) {=0A=
    var log10 =3D function log10(x) {=0A=
      return Math.log(x) / Math.LN10;=0A=
    };=0A=
=0A=
    // try three steps (multiple of 1, 2, or 5=0A=
    var step1 =3D Math.pow(10, Math.round(log10(step))),=0A=
        step2 =3D 2 * Math.pow(10, Math.round(log10(step / 2))),=0A=
        step5 =3D 5 * Math.pow(10, Math.round(log10(step / 5)));=0A=
=0A=
    // choose the best step (closest to minimum step)=0A=
    var prettyStep =3D step1;=0A=
    if (Math.abs(step2 - step) <=3D Math.abs(prettyStep - step)) =
prettyStep =3D step2;=0A=
    if (Math.abs(step5 - step) <=3D Math.abs(prettyStep - step)) =
prettyStep =3D step5;=0A=
=0A=
    // for safety=0A=
    if (prettyStep <=3D 0) {=0A=
      prettyStep =3D 1;=0A=
    }=0A=
=0A=
    return prettyStep;=0A=
  };=0A=
=0A=
  /**=0A=
   * returns the current value of the step=0A=
   * @return {Number} current value=0A=
   */=0A=
  StepNumber.prototype.getCurrent =3D function () {=0A=
    return parseFloat(this._current.toPrecision(this.precision));=0A=
  };=0A=
=0A=
  /**=0A=
   * returns the current step size=0A=
   * @return {Number} current step size=0A=
   */=0A=
  StepNumber.prototype.getStep =3D function () {=0A=
    return this._step;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the current value to the largest value smaller than start, which=0A=
   * is a multiple of the step size=0A=
   */=0A=
  StepNumber.prototype.start =3D function () {=0A=
    this._current =3D this._start - this._start % this._step;=0A=
  };=0A=
=0A=
  /**=0A=
   * Do a step, add the step size to the current value=0A=
   */=0A=
  StepNumber.prototype.next =3D function () {=0A=
    this._current +=3D this._step;=0A=
  };=0A=
=0A=
  /**=0A=
   * Returns true whether the end is reached=0A=
   * @return {boolean}  True if the current value has passed the end =
value.=0A=
   */=0A=
  StepNumber.prototype.end =3D function () {=0A=
    return this._current > this._end;=0A=
  };=0A=
=0A=
  module.exports =3D StepNumber;=0A=
=0A=
/***/ },=0A=
/* 25 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Emitter =3D __webpack_require__(19);=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var moment =3D __webpack_require__(8);=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
  var Range =3D __webpack_require__(26);=0A=
  var Core =3D __webpack_require__(30);=0A=
  var TimeAxis =3D __webpack_require__(39);=0A=
  var CurrentTime =3D __webpack_require__(44);=0A=
  var CustomTime =3D __webpack_require__(42);=0A=
  var ItemSet =3D __webpack_require__(31);=0A=
=0A=
  var Configurator =3D __webpack_require__(45);=0A=
  var Validator =3D __webpack_require__(47)['default'];=0A=
  var printStyle =3D __webpack_require__(47).printStyle;=0A=
  var allOptions =3D __webpack_require__(48).allOptions;=0A=
  var configureOptions =3D __webpack_require__(48).configureOptions;=0A=
=0A=
  /**=0A=
   * Create a timeline visualization=0A=
   * @param {HTMLElement} container=0A=
   * @param {vis.DataSet | vis.DataView | Array} [items]=0A=
   * @param {vis.DataSet | vis.DataView | Array} [groups]=0A=
   * @param {Object} [options]  See Timeline.setOptions for the =
available options.=0A=
   * @constructor=0A=
   * @extends Core=0A=
   */=0A=
  function Timeline(container, items, groups, options) {=0A=
    if (!(this instanceof Timeline)) {=0A=
      throw new SyntaxError('Constructor must be called with the new =
operator');=0A=
    }=0A=
=0A=
    // if the third element is options, the forth is groups (optionally);=0A=
    if (!(Array.isArray(groups) || groups instanceof DataSet || groups =
instanceof DataView) && groups instanceof Object) {=0A=
      var forthArgument =3D options;=0A=
      options =3D groups;=0A=
      groups =3D forthArgument;=0A=
    }=0A=
=0A=
    var me =3D this;=0A=
    this.defaultOptions =3D {=0A=
      start: null,=0A=
      end: null,=0A=
=0A=
      autoResize: true,=0A=
=0A=
      orientation: {=0A=
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'=0A=
        item: 'bottom' // not relevant=0A=
      },=0A=
=0A=
      moment: moment,=0A=
=0A=
      width: null,=0A=
      height: null,=0A=
      maxHeight: null,=0A=
      minHeight: null=0A=
    };=0A=
    this.options =3D util.deepExtend({}, this.defaultOptions);=0A=
=0A=
    // Create the DOM, props, and emitter=0A=
    this._create(container);=0A=
=0A=
    // all components listed here will be repainted automatically=0A=
    this.components =3D [];=0A=
=0A=
    this.body =3D {=0A=
      dom: this.dom,=0A=
      domProps: this.props,=0A=
      emitter: {=0A=
        on: this.on.bind(this),=0A=
        off: this.off.bind(this),=0A=
        emit: this.emit.bind(this)=0A=
      },=0A=
      hiddenDates: [],=0A=
      util: {=0A=
        getScale: function getScale() {=0A=
          return me.timeAxis.step.scale;=0A=
        },=0A=
        getStep: function getStep() {=0A=
          return me.timeAxis.step.step;=0A=
        },=0A=
=0A=
        toScreen: me._toScreen.bind(me),=0A=
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to =
the root.width=0A=
        toTime: me._toTime.bind(me),=0A=
        toGlobalTime: me._toGlobalTime.bind(me)=0A=
      }=0A=
    };=0A=
=0A=
    // range=0A=
    this.range =3D new Range(this.body);=0A=
    this.components.push(this.range);=0A=
    this.body.range =3D this.range;=0A=
=0A=
    // time axis=0A=
    this.timeAxis =3D new TimeAxis(this.body);=0A=
    this.timeAxis2 =3D null; // used in case of orientation option 'both'=0A=
    this.components.push(this.timeAxis);=0A=
=0A=
    // current time bar=0A=
    this.currentTime =3D new CurrentTime(this.body);=0A=
    this.components.push(this.currentTime);=0A=
=0A=
    // item set=0A=
    this.itemSet =3D new ItemSet(this.body);=0A=
    this.components.push(this.itemSet);=0A=
=0A=
    this.itemsData =3D null; // DataSet=0A=
    this.groupsData =3D null; // DataSet=0A=
=0A=
    this.on('tap', function (event) {=0A=
      me.emit('click', me.getEventProperties(event));=0A=
    });=0A=
    this.on('doubletap', function (event) {=0A=
      me.emit('doubleClick', me.getEventProperties(event));=0A=
    });=0A=
    this.dom.root.oncontextmenu =3D function (event) {=0A=
      me.emit('contextmenu', me.getEventProperties(event));=0A=
    };=0A=
=0A=
    // apply options=0A=
    if (options) {=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!=0A=
    if (groups) {=0A=
      this.setGroups(groups);=0A=
    }=0A=
=0A=
    // create itemset=0A=
    if (items) {=0A=
      this.setItems(items);=0A=
    } else {=0A=
      this._redraw();=0A=
    }=0A=
  }=0A=
=0A=
  // Extend the functionality from Core=0A=
  Timeline.prototype =3D new Core();=0A=
=0A=
  /**=0A=
   * Load a configurator=0A=
   * @return {Object}=0A=
   * @private=0A=
   */=0A=
  Timeline.prototype._createConfigurator =3D function () {=0A=
    return new Configurator(this, this.dom.container, configureOptions);=0A=
  };=0A=
=0A=
  /**=0A=
   * Force a redraw. The size of all items will be recalculated.=0A=
   * Can be useful to manually redraw when option autoResize=3Dfalse and =
the window=0A=
   * has been resized, or when the items CSS has been changed.=0A=
   */=0A=
  Timeline.prototype.redraw =3D function () {=0A=
    this.itemSet && this.itemSet.markDirty({ refreshItems: true });=0A=
    this._redraw();=0A=
  };=0A=
=0A=
  Timeline.prototype.setOptions =3D function (options) {=0A=
    // validate options=0A=
    var errorFound =3D Validator.validate(options, allOptions);=0A=
    if (errorFound =3D=3D=3D true) {=0A=
      console.log('%cErrors have been found in the supplied options =
object.', printStyle);=0A=
    }=0A=
=0A=
    Core.prototype.setOptions.call(this, options);=0A=
=0A=
    if ('type' in options) {=0A=
      if (options.type !=3D=3D this.options.type) {=0A=
        this.options.type =3D options.type;=0A=
=0A=
        // force recreation of all items=0A=
        var itemsData =3D this.itemsData;=0A=
        if (itemsData) {=0A=
          var selection =3D this.getSelection();=0A=
          this.setItems(null); // remove all=0A=
          this.setItems(itemsData); // add all=0A=
          this.setSelection(selection); // restore selection=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set items=0A=
   * @param {vis.DataSet | Array | null} items=0A=
   */=0A=
  Timeline.prototype.setItems =3D function (items) {=0A=
    var initialLoad =3D this.itemsData =3D=3D null;=0A=
=0A=
    // convert to type DataSet when needed=0A=
    var newDataSet;=0A=
    if (!items) {=0A=
      newDataSet =3D null;=0A=
    } else if (items instanceof DataSet || items instanceof DataView) {=0A=
      newDataSet =3D items;=0A=
    } else {=0A=
      // turn an array into a dataset=0A=
      newDataSet =3D new DataSet(items, {=0A=
        type: {=0A=
          start: 'Date',=0A=
          end: 'Date'=0A=
        }=0A=
      });=0A=
    }=0A=
=0A=
    // set items=0A=
    this.itemsData =3D newDataSet;=0A=
    this.itemSet && this.itemSet.setItems(newDataSet);=0A=
=0A=
    if (initialLoad) {=0A=
      if (this.options.start !=3D undefined || this.options.end !=3D =
undefined) {=0A=
        if (this.options.start =3D=3D undefined || this.options.end =
=3D=3D undefined) {=0A=
          var range =3D this.getItemRange();=0A=
        }=0A=
=0A=
        var start =3D this.options.start !=3D undefined ? =
this.options.start : range.min;=0A=
        var end =3D this.options.end !=3D undefined ? this.options.end : =
range.max;=0A=
=0A=
        this.setWindow(start, end, { animation: false });=0A=
      } else {=0A=
        this.fit({ animation: false });=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set groups=0A=
   * @param {vis.DataSet | Array} groups=0A=
   */=0A=
  Timeline.prototype.setGroups =3D function (groups) {=0A=
    // convert to type DataSet when needed=0A=
    var newDataSet;=0A=
    if (!groups) {=0A=
      newDataSet =3D null;=0A=
    } else if (groups instanceof DataSet || groups instanceof DataView) {=0A=
      newDataSet =3D groups;=0A=
    } else {=0A=
      // turn an array into a dataset=0A=
      newDataSet =3D new DataSet(groups);=0A=
    }=0A=
=0A=
    this.groupsData =3D newDataSet;=0A=
    this.itemSet.setGroups(newDataSet);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set both items and groups in one go=0A=
   * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} =
data=0A=
   */=0A=
  Timeline.prototype.setData =3D function (data) {=0A=
    if (data && data.groups) {=0A=
      this.setGroups(data.groups);=0A=
    }=0A=
=0A=
    if (data && data.items) {=0A=
      this.setItems(data.items);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set selected items by their id. Replaces the current selection=0A=
   * Unknown id's are silently ignored.=0A=
   * @param {string[] | string} [ids]  An array with zero or more id's =
of the items to be=0A=
   *                                selected. If ids is an empty array, =
all items will be=0A=
   *                                unselected.=0A=
   * @param {Object} [options]      Available options:=0A=
   *                                `focus: boolean`=0A=
   *                                    If true, focus will be set to =
the selected item(s)=0A=
   *                                `animation: boolean | {duration: =
number, easingFunction: string}`=0A=
   *                                    If true (default), the range is =
animated=0A=
   *                                    smoothly to the new window. An =
object can be=0A=
   *                                    provided to specify duration and =
easing function.=0A=
   *                                    Default duration is 500 ms, and =
default easing=0A=
   *                                    function is 'easeInOutQuad'.=0A=
   *                                    Only applicable when option =
focus is true.=0A=
   */=0A=
  Timeline.prototype.setSelection =3D function (ids, options) {=0A=
    this.itemSet && this.itemSet.setSelection(ids);=0A=
=0A=
    if (options && options.focus) {=0A=
      this.focus(ids, options);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the selected items by their id=0A=
   * @return {Array} ids  The ids of the selected items=0A=
   */=0A=
  Timeline.prototype.getSelection =3D function () {=0A=
    return this.itemSet && this.itemSet.getSelection() || [];=0A=
  };=0A=
=0A=
  /**=0A=
   * Adjust the visible window such that the selected item (or multiple =
items)=0A=
   * are centered on screen.=0A=
   * @param {String | String[]} id     An item id or array with item ids=0A=
   * @param {Object} [options]      Available options:=0A=
   *                                `animation: boolean | {duration: =
number, easingFunction: string}`=0A=
   *                                    If true (default), the range is =
animated=0A=
   *                                    smoothly to the new window. An =
object can be=0A=
   *                                    provided to specify duration and =
easing function.=0A=
   *                                    Default duration is 500 ms, and =
default easing=0A=
   *                                    function is 'easeInOutQuad'.=0A=
   */=0A=
  Timeline.prototype.focus =3D function (id, options) {=0A=
    if (!this.itemsData || id =3D=3D undefined) return;=0A=
=0A=
    var ids =3D Array.isArray(id) ? id : [id];=0A=
=0A=
    // get the specified item(s)=0A=
    var itemsData =3D this.itemsData.getDataSet().get(ids, {=0A=
      type: {=0A=
        start: 'Date',=0A=
        end: 'Date'=0A=
      }=0A=
    });=0A=
=0A=
    // calculate minimum start and maximum end of specified items=0A=
    var start =3D null;=0A=
    var end =3D null;=0A=
    itemsData.forEach(function (itemData) {=0A=
      var s =3D itemData.start.valueOf();=0A=
      var e =3D 'end' in itemData ? itemData.end.valueOf() : =
itemData.start.valueOf();=0A=
=0A=
      if (start =3D=3D=3D null || s < start) {=0A=
        start =3D s;=0A=
      }=0A=
=0A=
      if (end =3D=3D=3D null || e > end) {=0A=
        end =3D e;=0A=
      }=0A=
    });=0A=
=0A=
    if (start !=3D=3D null && end !=3D=3D null) {=0A=
      // calculate the new middle and interval for the window=0A=
      var middle =3D (start + end) / 2;=0A=
      var interval =3D Math.max(this.range.end - this.range.start, (end =
- start) * 1.1);=0A=
=0A=
      var animation =3D options && options.animation !=3D=3D undefined ? =
options.animation : true;=0A=
      this.range.setRange(middle - interval / 2, middle + interval / 2, =
animation);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set Timeline window such that it fits all items=0A=
   * @param {Object} [options]  Available options:=0A=
   *                                `animation: boolean | {duration: =
number, easingFunction: string}`=0A=
   *                                    If true (default), the range is =
animated=0A=
   *                                    smoothly to the new window. An =
object can be=0A=
   *                                    provided to specify duration and =
easing function.=0A=
   *                                    Default duration is 500 ms, and =
default easing=0A=
   *                                    function is 'easeInOutQuad'.=0A=
   */=0A=
  Timeline.prototype.fit =3D function (options) {=0A=
    var animation =3D options && options.animation !=3D=3D undefined ? =
options.animation : true;=0A=
    var range =3D this.getItemRange();=0A=
    this.range.setRange(range.min, range.max, animation);=0A=
  };=0A=
=0A=
  /**=0A=
   * Determine the range of the items, taking into account their actual =
width=0A=
   * and a margin of 10 pixels on both sides.=0A=
   * @return {{min: Date | null, max: Date | null}}=0A=
   */=0A=
  Timeline.prototype.getItemRange =3D function () {=0A=
    var _this =3D this;=0A=
=0A=
    // get a rough approximation for the range based on the items start =
and end dates=0A=
    var range =3D this.getDataRange();=0A=
    var min =3D range.min;=0A=
    var max =3D range.max;=0A=
    var minItem =3D null;=0A=
    var maxItem =3D null;=0A=
=0A=
    if (min !=3D null && max !=3D null) {=0A=
      var interval;=0A=
      var factor;=0A=
      var lhs;=0A=
      var rhs;=0A=
      var delta;=0A=
=0A=
      (function () {=0A=
        var getStart =3D function getStart(item) {=0A=
          return util.convert(item.data.start, 'Date').valueOf();=0A=
        };=0A=
=0A=
        var getEnd =3D function getEnd(item) {=0A=
          var end =3D item.data.end !=3D undefined ? item.data.end : =
item.data.start;=0A=
          return util.convert(end, 'Date').valueOf();=0A=
        };=0A=
=0A=
        interval =3D max - min;=0A=
        // ms=0A=
        if (interval <=3D 0) {=0A=
          interval =3D 10;=0A=
        }=0A=
        factor =3D interval / _this.props.center.width;=0A=
=0A=
        // calculate the date of the left side and right side of the =
items given=0A=
        util.forEach(_this.itemSet.items, (function (item) {=0A=
          item.show();=0A=
=0A=
          var start =3D getStart(item);=0A=
          var end =3D getEnd(item);=0A=
=0A=
          var left =3D new Date(start - (item.getWidthLeft() + 10) * =
factor);=0A=
          var right =3D new Date(end + (item.getWidthRight() + 10) * =
factor);=0A=
=0A=
          if (left < min) {=0A=
            min =3D left;=0A=
            minItem =3D item;=0A=
          }=0A=
          if (right > max) {=0A=
            max =3D right;=0A=
            maxItem =3D item;=0A=
          }=0A=
        }).bind(_this));=0A=
=0A=
        if (minItem && maxItem) {=0A=
          lhs =3D minItem.getWidthLeft() + 10;=0A=
          rhs =3D maxItem.getWidthRight() + 10;=0A=
          delta =3D _this.props.center.width - lhs - rhs;=0A=
          // px=0A=
=0A=
          if (delta > 0) {=0A=
            min =3D getStart(minItem) - lhs * interval / delta; // ms=0A=
            max =3D getEnd(maxItem) + rhs * interval / delta; // ms=0A=
          }=0A=
        }=0A=
      })();=0A=
    }=0A=
=0A=
    return {=0A=
      min: min !=3D null ? new Date(min) : null,=0A=
      max: max !=3D null ? new Date(max) : null=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the data range of the items start and end dates=0A=
   * @returns {{min: Date | null, max: Date | null}}=0A=
   */=0A=
  Timeline.prototype.getDataRange =3D function () {=0A=
    var min =3D null;=0A=
    var max =3D null;=0A=
=0A=
    var dataset =3D this.itemsData && this.itemsData.getDataSet();=0A=
    if (dataset) {=0A=
      dataset.forEach(function (item) {=0A=
        var start =3D util.convert(item.start, 'Date').valueOf();=0A=
        var end =3D util.convert(item.end !=3D undefined ? item.end : =
item.start, 'Date').valueOf();=0A=
        if (min =3D=3D=3D null || start < min) {=0A=
          min =3D start;=0A=
        }=0A=
        if (max =3D=3D=3D null || end > max) {=0A=
          max =3D start;=0A=
        }=0A=
      });=0A=
    }=0A=
=0A=
    return {=0A=
      min: min !=3D null ? new Date(min) : null,=0A=
      max: max !=3D null ? new Date(max) : null=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Generate Timeline related information from an event=0A=
   * @param {Event} event=0A=
   * @return {Object} An object with related information, like on which =
area=0A=
   *                  The event happened, whether clicked on an item, =
etc.=0A=
   */=0A=
  Timeline.prototype.getEventProperties =3D function (event) {=0A=
    var clientX =3D event.center ? event.center.x : event.clientX;=0A=
    var clientY =3D event.center ? event.center.y : event.clientY;=0A=
    var x =3D clientX - util.getAbsoluteLeft(this.dom.centerContainer);=0A=
    var y =3D clientY - util.getAbsoluteTop(this.dom.centerContainer);=0A=
=0A=
    var item =3D this.itemSet.itemFromTarget(event);=0A=
    var group =3D this.itemSet.groupFromTarget(event);=0A=
    var customTime =3D CustomTime.customTimeFromTarget(event);=0A=
=0A=
    var snap =3D this.itemSet.options.snap || null;=0A=
    var scale =3D this.body.util.getScale();=0A=
    var step =3D this.body.util.getStep();=0A=
    var time =3D this._toTime(x);=0A=
    var snappedTime =3D snap ? snap(time, scale, step) : time;=0A=
=0A=
    var element =3D util.getTarget(event);=0A=
    var what =3D null;=0A=
    if (item !=3D null) {=0A=
      what =3D 'item';=0A=
    } else if (customTime !=3D null) {=0A=
      what =3D 'custom-time';=0A=
    } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {=0A=
      what =3D 'axis';=0A=
    } else if (this.timeAxis2 && util.hasParent(element, =
this.timeAxis2.dom.foreground)) {=0A=
      what =3D 'axis';=0A=
    } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {=0A=
      what =3D 'group-label';=0A=
    } else if (util.hasParent(element, this.currentTime.bar)) {=0A=
      what =3D 'current-time';=0A=
    } else if (util.hasParent(element, this.dom.center)) {=0A=
      what =3D 'background';=0A=
    }=0A=
=0A=
    return {=0A=
      event: event,=0A=
      item: item ? item.id : null,=0A=
      group: group ? group.groupId : null,=0A=
      what: what,=0A=
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,=0A=
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,=0A=
      x: x,=0A=
      y: y,=0A=
      time: time,=0A=
      snappedTime: snappedTime=0A=
    };=0A=
  };=0A=
=0A=
  module.exports =3D Timeline;=0A=
=0A=
/***/ },=0A=
/* 26 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var hammerUtil =3D __webpack_require__(27);=0A=
  var moment =3D __webpack_require__(8);=0A=
  var Component =3D __webpack_require__(28);=0A=
  var DateUtil =3D __webpack_require__(29);=0A=
=0A=
  /**=0A=
   * @constructor Range=0A=
   * A Range controls a numeric range with a start and end value.=0A=
   * The Range adjusts the range based on mouse events or programmatic =
changes,=0A=
   * and triggers events when the range is changing or has been changed.=0A=
   * @param {{dom: Object, domProps: Object, emitter: Emitter}} body=0A=
   * @param {Object} [options]    See description at Range.setOptions=0A=
   */=0A=
  function Range(body, options) {=0A=
    var now =3D moment().hours(0).minutes(0).seconds(0).milliseconds(0);=0A=
    this.start =3D now.clone().add(-3, 'days').valueOf(); // Number=0A=
    this.end =3D now.clone().add(4, 'days').valueOf(); // Number=0A=
=0A=
    this.body =3D body;=0A=
    this.deltaDifference =3D 0;=0A=
    this.scaleOffset =3D 0;=0A=
    this.startToFront =3D false;=0A=
    this.endToFront =3D true;=0A=
=0A=
    // default options=0A=
    this.defaultOptions =3D {=0A=
      start: null,=0A=
      end: null,=0A=
      moment: moment,=0A=
      direction: 'horizontal', // 'horizontal' or 'vertical'=0A=
      moveable: true,=0A=
      zoomable: true,=0A=
      min: null,=0A=
      max: null,=0A=
      zoomMin: 10, // milliseconds=0A=
      zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds=0A=
    };=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
=0A=
    this.props =3D {=0A=
      touch: {}=0A=
    };=0A=
    this.animationTimer =3D null;=0A=
=0A=
    // drag listeners for dragging=0A=
    this.body.emitter.on('panstart', this._onDragStart.bind(this));=0A=
    this.body.emitter.on('panmove', this._onDrag.bind(this));=0A=
    this.body.emitter.on('panend', this._onDragEnd.bind(this));=0A=
=0A=
    // mouse wheel for zooming=0A=
    this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));=0A=
=0A=
    // pinch to zoom=0A=
    this.body.emitter.on('touch', this._onTouch.bind(this));=0A=
    this.body.emitter.on('pinch', this._onPinch.bind(this));=0A=
=0A=
    this.setOptions(options);=0A=
  }=0A=
=0A=
  Range.prototype =3D new Component();=0A=
=0A=
  /**=0A=
   * Set options for the range controller=0A=
   * @param {Object} options      Available options:=0A=
   *                              {Number | Date | String} start  Start =
date for the range=0A=
   *                              {Number | Date | String} end    End =
date for the range=0A=
   *                              {Number} min    Minimum value for start=0A=
   *                              {Number} max    Maximum value for end=0A=
   *                              {Number} zoomMin    Set a minimum =
value for=0A=
   *                                                  (end - start).=0A=
   *                              {Number} zoomMax    Set a maximum =
value for=0A=
   *                                                  (end - start).=0A=
   *                              {Boolean} moveable Enable moving of =
the range=0A=
   *                                                 by dragging. True =
by default=0A=
   *                              {Boolean} zoomable Enable zooming of =
the range=0A=
   *                                                 by =
pinching/scrolling. True by default=0A=
   */=0A=
  Range.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      // copy the options that we know=0A=
      var fields =3D ['direction', 'min', 'max', 'zoomMin', 'zoomMax', =
'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey'];=0A=
      util.selectiveExtend(fields, this.options, options);=0A=
=0A=
      if ('start' in options || 'end' in options) {=0A=
        // apply a new range. both start and end are optional=0A=
        this.setRange(options.start, options.end);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Test whether direction has a valid value=0A=
   * @param {String} direction    'horizontal' or 'vertical'=0A=
   */=0A=
  function validateDirection(direction) {=0A=
    if (direction !=3D 'horizontal' && direction !=3D 'vertical') {=0A=
      throw new TypeError('Unknown direction "' + direction + '". ' + =
'Choose "horizontal" or "vertical".');=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Set a new start and end range=0A=
   * @param {Date | Number | String} [start]=0A=
   * @param {Date | Number | String} [end]=0A=
   * @param {boolean | {duration: number, easingFunction: string}} =
[animation=3Dfalse]=0A=
   *                                    If true (default), the range is =
animated=0A=
   *                                    smoothly to the new window. An =
object can be=0A=
   *                                    provided to specify duration and =
easing function.=0A=
   *                                    Default duration is 500 ms, and =
default easing=0A=
   *                                    function is 'easeInOutQuad'.=0A=
   * @param {Boolean} [byUser=3Dfalse]=0A=
   *=0A=
   */=0A=
  Range.prototype.setRange =3D function (start, end, animation, byUser) {=0A=
    if (byUser !=3D=3D true) {=0A=
      byUser =3D false;=0A=
    }=0A=
    var finalStart =3D start !=3D undefined ? util.convert(start, =
'Date').valueOf() : null;=0A=
    var finalEnd =3D end !=3D undefined ? util.convert(end, =
'Date').valueOf() : null;=0A=
    this._cancelAnimation();=0A=
=0A=
    if (animation) {=0A=
      // true or an Object=0A=
      var me =3D this;=0A=
      var initStart =3D this.start;=0A=
      var initEnd =3D this.end;=0A=
      var duration =3D typeof animation =3D=3D=3D 'object' && 'duration' =
in animation ? animation.duration : 500;=0A=
      var easingName =3D typeof animation =3D=3D=3D 'object' && =
'easingFunction' in animation ? animation.easingFunction : =
'easeInOutQuad';=0A=
      var easingFunction =3D util.easingFunctions[easingName];=0A=
      if (!easingFunction) {=0A=
        throw new Error('Unknown easing function ' + =
JSON.stringify(easingName) + '. ' + 'Choose from: ' + =
Object.keys(util.easingFunctions).join(', '));=0A=
      }=0A=
=0A=
      var initTime =3D new Date().valueOf();=0A=
      var anyChanged =3D false;=0A=
=0A=
      var next =3D function next() {=0A=
        if (!me.props.touch.dragging) {=0A=
          var now =3D new Date().valueOf();=0A=
          var time =3D now - initTime;=0A=
          var ease =3D easingFunction(time / duration);=0A=
          var done =3D time > duration;=0A=
          var s =3D done || finalStart =3D=3D=3D null ? finalStart : =
initStart + (finalStart - initStart) * ease;=0A=
          var e =3D done || finalEnd =3D=3D=3D null ? finalEnd : initEnd =
+ (finalEnd - initEnd) * ease;=0A=
=0A=
          changed =3D me._applyRange(s, e);=0A=
          DateUtil.updateHiddenDates(me.options.moment, me.body, =
me.options.hiddenDates);=0A=
          anyChanged =3D anyChanged || changed;=0A=
          if (changed) {=0A=
            me.body.emitter.emit('rangechange', { start: new =
Date(me.start), end: new Date(me.end), byUser: byUser });=0A=
          }=0A=
=0A=
          if (done) {=0A=
            if (anyChanged) {=0A=
              me.body.emitter.emit('rangechanged', { start: new =
Date(me.start), end: new Date(me.end), byUser: byUser });=0A=
            }=0A=
          } else {=0A=
            // animate with as high as possible frame rate, leave 20 ms =
in between=0A=
            // each to prevent the browser from blocking=0A=
            me.animationTimer =3D setTimeout(next, 20);=0A=
          }=0A=
        }=0A=
      };=0A=
=0A=
      return next();=0A=
    } else {=0A=
      var changed =3D this._applyRange(finalStart, finalEnd);=0A=
      DateUtil.updateHiddenDates(this.options.moment, this.body, =
this.options.hiddenDates);=0A=
      if (changed) {=0A=
        var params =3D { start: new Date(this.start), end: new =
Date(this.end), byUser: byUser };=0A=
        this.body.emitter.emit('rangechange', params);=0A=
        this.body.emitter.emit('rangechanged', params);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop an animation=0A=
   * @private=0A=
   */=0A=
  Range.prototype._cancelAnimation =3D function () {=0A=
    if (this.animationTimer) {=0A=
      clearTimeout(this.animationTimer);=0A=
      this.animationTimer =3D null;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a new start and end range. This method is the same as setRange, =
but=0A=
   * does not trigger a range change and range changed event, and it =
returns=0A=
   * true when the range is changed=0A=
   * @param {Number} [start]=0A=
   * @param {Number} [end]=0A=
   * @return {Boolean} changed=0A=
   * @private=0A=
   */=0A=
  Range.prototype._applyRange =3D function (start, end) {=0A=
    var newStart =3D start !=3D null ? util.convert(start, =
'Date').valueOf() : this.start,=0A=
        newEnd =3D end !=3D null ? util.convert(end, 'Date').valueOf() : =
this.end,=0A=
        max =3D this.options.max !=3D null ? =
util.convert(this.options.max, 'Date').valueOf() : null,=0A=
        min =3D this.options.min !=3D null ? =
util.convert(this.options.min, 'Date').valueOf() : null,=0A=
        diff;=0A=
=0A=
    // check for valid number=0A=
    if (isNaN(newStart) || newStart =3D=3D=3D null) {=0A=
      throw new Error('Invalid start "' + start + '"');=0A=
    }=0A=
    if (isNaN(newEnd) || newEnd =3D=3D=3D null) {=0A=
      throw new Error('Invalid end "' + end + '"');=0A=
    }=0A=
=0A=
    // prevent start < end=0A=
    if (newEnd < newStart) {=0A=
      newEnd =3D newStart;=0A=
    }=0A=
=0A=
    // prevent start < min=0A=
    if (min !=3D=3D null) {=0A=
      if (newStart < min) {=0A=
        diff =3D min - newStart;=0A=
        newStart +=3D diff;=0A=
        newEnd +=3D diff;=0A=
=0A=
        // prevent end > max=0A=
        if (max !=3D null) {=0A=
          if (newEnd > max) {=0A=
            newEnd =3D max;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // prevent end > max=0A=
    if (max !=3D=3D null) {=0A=
      if (newEnd > max) {=0A=
        diff =3D newEnd - max;=0A=
        newStart -=3D diff;=0A=
        newEnd -=3D diff;=0A=
=0A=
        // prevent start < min=0A=
        if (min !=3D null) {=0A=
          if (newStart < min) {=0A=
            newStart =3D min;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // prevent (end-start) < zoomMin=0A=
    if (this.options.zoomMin !=3D=3D null) {=0A=
      var zoomMin =3D parseFloat(this.options.zoomMin);=0A=
      if (zoomMin < 0) {=0A=
        zoomMin =3D 0;=0A=
      }=0A=
      if (newEnd - newStart < zoomMin) {=0A=
        if (this.end - this.start =3D=3D=3D zoomMin && newStart > =
this.start && newEnd < this.end) {=0A=
          // ignore this action, we are already zoomed to the minimum=0A=
          newStart =3D this.start;=0A=
          newEnd =3D this.end;=0A=
        } else {=0A=
          // zoom to the minimum=0A=
          diff =3D zoomMin - (newEnd - newStart);=0A=
          newStart -=3D diff / 2;=0A=
          newEnd +=3D diff / 2;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // prevent (end-start) > zoomMax=0A=
    if (this.options.zoomMax !=3D=3D null) {=0A=
      var zoomMax =3D parseFloat(this.options.zoomMax);=0A=
      if (zoomMax < 0) {=0A=
        zoomMax =3D 0;=0A=
      }=0A=
=0A=
      if (newEnd - newStart > zoomMax) {=0A=
        if (this.end - this.start =3D=3D=3D zoomMax && newStart < =
this.start && newEnd > this.end) {=0A=
          // ignore this action, we are already zoomed to the maximum=0A=
          newStart =3D this.start;=0A=
          newEnd =3D this.end;=0A=
        } else {=0A=
          // zoom to the maximum=0A=
          diff =3D newEnd - newStart - zoomMax;=0A=
          newStart +=3D diff / 2;=0A=
          newEnd -=3D diff / 2;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    var changed =3D this.start !=3D newStart || this.end !=3D newEnd;=0A=
=0A=
    // if the new range does NOT overlap with the old range, emit =
checkRangedItems to avoid not showing ranged items (ranged meaning has =
end time, not necessarily of type Range)=0A=
    if (!(newStart >=3D this.start && newStart <=3D this.end || newEnd =
>=3D this.start && newEnd <=3D this.end) && !(this.start >=3D newStart =
&& this.start <=3D newEnd || this.end >=3D newStart && this.end <=3D =
newEnd)) {=0A=
      this.body.emitter.emit('checkRangedItems');=0A=
    }=0A=
=0A=
    this.start =3D newStart;=0A=
    this.end =3D newEnd;=0A=
    return changed;=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the current range.=0A=
   * @return {Object} An object with start and end properties=0A=
   */=0A=
  Range.prototype.getRange =3D function () {=0A=
    return {=0A=
      start: this.start,=0A=
      end: this.end=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the conversion offset and scale for current range, based =
on=0A=
   * the provided width=0A=
   * @param {Number} width=0A=
   * @returns {{offset: number, scale: number}} conversion=0A=
   */=0A=
  Range.prototype.conversion =3D function (width, totalHidden) {=0A=
    return Range.conversion(this.start, this.end, width, totalHidden);=0A=
  };=0A=
=0A=
  /**=0A=
   * Static method to calculate the conversion offset and scale for a =
range,=0A=
   * based on the provided start, end, and width=0A=
   * @param {Number} start=0A=
   * @param {Number} end=0A=
   * @param {Number} width=0A=
   * @returns {{offset: number, scale: number}} conversion=0A=
   */=0A=
  Range.conversion =3D function (start, end, width, totalHidden) {=0A=
    if (totalHidden =3D=3D=3D undefined) {=0A=
      totalHidden =3D 0;=0A=
    }=0A=
    if (width !=3D 0 && end - start !=3D 0) {=0A=
      return {=0A=
        offset: start,=0A=
        scale: width / (end - start - totalHidden)=0A=
      };=0A=
    } else {=0A=
      return {=0A=
        offset: 0,=0A=
        scale: 1=0A=
      };=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Start dragging horizontally or vertically=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  Range.prototype._onDragStart =3D function (event) {=0A=
    this.deltaDifference =3D 0;=0A=
    this.previousDelta =3D 0;=0A=
=0A=
    // only allow dragging when configured as movable=0A=
    if (!this.options.moveable) return;=0A=
=0A=
    // only start dragging when the mouse is inside the current range=0A=
    if (!this._isInsideRange(event)) return;=0A=
=0A=
    // refuse to drag when we where pinching to prevent the timeline =
make a jump=0A=
    // when releasing the fingers in opposite order from the touch screen=0A=
    if (!this.props.touch.allowDragging) return;=0A=
=0A=
    this.props.touch.start =3D this.start;=0A=
    this.props.touch.end =3D this.end;=0A=
    this.props.touch.dragging =3D true;=0A=
=0A=
    if (this.body.dom.root) {=0A=
      this.body.dom.root.style.cursor =3D 'move';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Perform dragging operation=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  Range.prototype._onDrag =3D function (event) {=0A=
    if (!this.props.touch.dragging) return;=0A=
=0A=
    // only allow dragging when configured as movable=0A=
    if (!this.options.moveable) return;=0A=
=0A=
    // TODO: this may be redundant in hammerjs2=0A=
    // refuse to drag when we where pinching to prevent the timeline =
make a jump=0A=
    // when releasing the fingers in opposite order from the touch screen=0A=
    if (!this.props.touch.allowDragging) return;=0A=
=0A=
    var direction =3D this.options.direction;=0A=
    validateDirection(direction);=0A=
    var delta =3D direction =3D=3D 'horizontal' ? event.deltaX : =
event.deltaY;=0A=
    delta -=3D this.deltaDifference;=0A=
    var interval =3D this.props.touch.end - this.props.touch.start;=0A=
=0A=
    // normalize dragging speed if cutout is in between.=0A=
    var duration =3D =
DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, =
this.end);=0A=
    interval -=3D duration;=0A=
=0A=
    var width =3D direction =3D=3D 'horizontal' ? =
this.body.domProps.center.width : this.body.domProps.center.height;=0A=
    var diffRange =3D -delta / width * interval;=0A=
    var newStart =3D this.props.touch.start + diffRange;=0A=
    var newEnd =3D this.props.touch.end + diffRange;=0A=
=0A=
    // snapping times away from hidden zones=0A=
    var safeStart =3D DateUtil.snapAwayFromHidden(this.body.hiddenDates, =
newStart, this.previousDelta - delta, true);=0A=
    var safeEnd =3D DateUtil.snapAwayFromHidden(this.body.hiddenDates, =
newEnd, this.previousDelta - delta, true);=0A=
    if (safeStart !=3D newStart || safeEnd !=3D newEnd) {=0A=
      this.deltaDifference +=3D delta;=0A=
      this.props.touch.start =3D safeStart;=0A=
      this.props.touch.end =3D safeEnd;=0A=
      this._onDrag(event);=0A=
      return;=0A=
    }=0A=
=0A=
    this.previousDelta =3D delta;=0A=
    this._applyRange(newStart, newEnd);=0A=
=0A=
    // fire a rangechange event=0A=
    this.body.emitter.emit('rangechange', {=0A=
      start: new Date(this.start),=0A=
      end: new Date(this.end),=0A=
      byUser: true=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop dragging operation=0A=
   * @param {event} event=0A=
   * @private=0A=
   */=0A=
  Range.prototype._onDragEnd =3D function (event) {=0A=
    if (!this.props.touch.dragging) return;=0A=
=0A=
    // only allow dragging when configured as movable=0A=
    if (!this.options.moveable) return;=0A=
=0A=
    // TODO: this may be redundant in hammerjs2=0A=
    // refuse to drag when we where pinching to prevent the timeline =
make a jump=0A=
    // when releasing the fingers in opposite order from the touch screen=0A=
    if (!this.props.touch.allowDragging) return;=0A=
=0A=
    this.props.touch.dragging =3D false;=0A=
    if (this.body.dom.root) {=0A=
      this.body.dom.root.style.cursor =3D 'auto';=0A=
    }=0A=
=0A=
    // fire a rangechanged event=0A=
    this.body.emitter.emit('rangechanged', {=0A=
      start: new Date(this.start),=0A=
      end: new Date(this.end),=0A=
      byUser: true=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * Event handler for mouse wheel event, used to zoom=0A=
   * Code from http://adomas.org/javascript-mouse-wheel/=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  Range.prototype._onMouseWheel =3D function (event) {=0A=
    // only allow zooming when configured as zoomable and moveable=0A=
    if (!(this.options.zoomable && this.options.moveable)) return;=0A=
=0A=
    // only zoom when the mouse is inside the current range=0A=
    if (!this._isInsideRange(event)) return;=0A=
=0A=
    // only zoom when the according key is pressed and the zoomKey =
option is set=0A=
    if (this.options.zoomKey && !event[this.options.zoomKey]) return;=0A=
=0A=
    // retrieve delta=0A=
    var delta =3D 0;=0A=
    if (event.wheelDelta) {=0A=
      /* IE/Opera. */=0A=
      delta =3D event.wheelDelta / 120;=0A=
    } else if (event.detail) {=0A=
      /* Mozilla case. */=0A=
      // In Mozilla, sign of delta is different than in IE.=0A=
      // Also, delta is multiple of 3.=0A=
      delta =3D -event.detail / 3;=0A=
    }=0A=
=0A=
    // If delta is nonzero, handle it.=0A=
    // Basically, delta is now positive if wheel was scrolled up,=0A=
    // and negative, if wheel was scrolled down.=0A=
    if (delta) {=0A=
      // perform the zoom action. Delta is normally 1 or -1=0A=
=0A=
      // adjust a negative delta such that zooming in with delta 0.1=0A=
      // equals zooming out with a delta -0.1=0A=
      var scale;=0A=
      if (delta < 0) {=0A=
        scale =3D 1 - delta / 5;=0A=
      } else {=0A=
        scale =3D 1 / (1 + delta / 5);=0A=
      }=0A=
=0A=
      // calculate center, the date to zoom around=0A=
      var pointer =3D getPointer({ x: event.clientX, y: event.clientY }, =
this.body.dom.center);=0A=
      var pointerDate =3D this._pointerToDate(pointer);=0A=
=0A=
      this.zoom(scale, pointerDate, delta);=0A=
    }=0A=
=0A=
    // Prevent default actions caused by mouse wheel=0A=
    // (else the page and timeline both zoom and scroll)=0A=
    event.preventDefault();=0A=
  };=0A=
=0A=
  /**=0A=
   * Start of a touch gesture=0A=
   * @private=0A=
   */=0A=
  Range.prototype._onTouch =3D function (event) {=0A=
    this.props.touch.start =3D this.start;=0A=
    this.props.touch.end =3D this.end;=0A=
    this.props.touch.allowDragging =3D true;=0A=
    this.props.touch.center =3D null;=0A=
    this.scaleOffset =3D 0;=0A=
    this.deltaDifference =3D 0;=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle pinch event=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  Range.prototype._onPinch =3D function (event) {=0A=
    // only allow zooming when configured as zoomable and moveable=0A=
    if (!(this.options.zoomable && this.options.moveable)) return;=0A=
=0A=
    this.props.touch.allowDragging =3D false;=0A=
=0A=
    if (!this.props.touch.center) {=0A=
      this.props.touch.center =3D getPointer(event.center, =
this.body.dom.center);=0A=
    }=0A=
=0A=
    var scale =3D 1 / (event.scale + this.scaleOffset);=0A=
    var centerDate =3D this._pointerToDate(this.props.touch.center);=0A=
=0A=
    var hiddenDuration =3D =
DateUtil.getHiddenDurationBetween(this.options.moment, =
this.body.hiddenDates, this.start, this.end);=0A=
    var hiddenDurationBefore =3D =
DateUtil.getHiddenDurationBefore(this.options.moment, =
this.body.hiddenDates, this, centerDate);=0A=
    var hiddenDurationAfter =3D hiddenDuration - hiddenDurationBefore;=0A=
=0A=
    // calculate new start and end=0A=
    var newStart =3D centerDate - hiddenDurationBefore + =
(this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;=0A=
    var newEnd =3D centerDate + hiddenDurationAfter + =
(this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;=0A=
=0A=
    // snapping times away from hidden zones=0A=
    this.startToFront =3D 1 - scale <=3D 0; // used to do the right auto =
correction with periodic hidden times=0A=
    this.endToFront =3D scale - 1 <=3D 0; // used to do the right auto =
correction with periodic hidden times=0A=
=0A=
    var safeStart =3D DateUtil.snapAwayFromHidden(this.body.hiddenDates, =
newStart, 1 - scale, true);=0A=
    var safeEnd =3D DateUtil.snapAwayFromHidden(this.body.hiddenDates, =
newEnd, scale - 1, true);=0A=
    if (safeStart !=3D newStart || safeEnd !=3D newEnd) {=0A=
      this.props.touch.start =3D safeStart;=0A=
      this.props.touch.end =3D safeEnd;=0A=
      this.scaleOffset =3D 1 - event.scale;=0A=
      newStart =3D safeStart;=0A=
      newEnd =3D safeEnd;=0A=
    }=0A=
=0A=
    this.setRange(newStart, newEnd, false, true);=0A=
=0A=
    this.startToFront =3D false; // revert to default=0A=
    this.endToFront =3D true; // revert to default=0A=
  };=0A=
=0A=
  /**=0A=
   * Test whether the mouse from a mouse event is inside the visible =
window,=0A=
   * between the current start and end date=0A=
   * @param {Object} event=0A=
   * @return {boolean} Returns true when inside the visible window=0A=
   * @private=0A=
   */=0A=
  Range.prototype._isInsideRange =3D function (event) {=0A=
    // calculate the time where the mouse is, check whether inside=0A=
    // and no scroll action should happen.=0A=
    var clientX =3D event.center ? event.center.x : event.clientX;=0A=
    var x =3D clientX - =
util.getAbsoluteLeft(this.body.dom.centerContainer);=0A=
    var time =3D this.body.util.toTime(x);=0A=
=0A=
    return time >=3D this.start && time <=3D this.end;=0A=
  };=0A=
=0A=
  /**=0A=
   * Helper function to calculate the center date for zooming=0A=
   * @param {{x: Number, y: Number}} pointer=0A=
   * @return {number} date=0A=
   * @private=0A=
   */=0A=
  Range.prototype._pointerToDate =3D function (pointer) {=0A=
    var conversion;=0A=
    var direction =3D this.options.direction;=0A=
=0A=
    validateDirection(direction);=0A=
=0A=
    if (direction =3D=3D 'horizontal') {=0A=
      return this.body.util.toTime(pointer.x).valueOf();=0A=
    } else {=0A=
      var height =3D this.body.domProps.center.height;=0A=
      conversion =3D this.conversion(height);=0A=
      return pointer.y / conversion.scale + conversion.offset;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the pointer location relative to the location of the dom element=0A=
   * @param {{x: Number, y: Number}} touch=0A=
   * @param {Element} element   HTML DOM element=0A=
   * @return {{x: Number, y: Number}} pointer=0A=
   * @private=0A=
   */=0A=
  function getPointer(touch, element) {=0A=
    return {=0A=
      x: touch.x - util.getAbsoluteLeft(element),=0A=
      y: touch.y - util.getAbsoluteTop(element)=0A=
    };=0A=
  }=0A=
=0A=
  /**=0A=
   * Zoom the range the given scale in or out. Start and end date will=0A=
   * be adjusted, and the timeline will be redrawn. You can optionally =
give a=0A=
   * date around which to zoom.=0A=
   * For example, try scale =3D 0.9 or 1.1=0A=
   * @param {Number} scale      Scaling factor. Values above 1 will zoom =
out,=0A=
   *                            values below 1 will zoom in.=0A=
   * @param {Number} [center]   Value representing a date around which =
will=0A=
   *                            be zoomed.=0A=
   */=0A=
  Range.prototype.zoom =3D function (scale, center, delta) {=0A=
    // if centerDate is not provided, take it half between start Date =
and end Date=0A=
    if (center =3D=3D null) {=0A=
      center =3D (this.start + this.end) / 2;=0A=
    }=0A=
=0A=
    var hiddenDuration =3D =
DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, =
this.end);=0A=
    var hiddenDurationBefore =3D =
DateUtil.getHiddenDurationBefore(this.options.moment, =
this.body.hiddenDates, this, center);=0A=
    var hiddenDurationAfter =3D hiddenDuration - hiddenDurationBefore;=0A=
=0A=
    // calculate new start and end=0A=
    var newStart =3D center - hiddenDurationBefore + (this.start - =
(center - hiddenDurationBefore)) * scale;=0A=
    var newEnd =3D center + hiddenDurationAfter + (this.end - (center + =
hiddenDurationAfter)) * scale;=0A=
=0A=
    // snapping times away from hidden zones=0A=
    this.startToFront =3D delta > 0 ? false : true; // used to do the =
right autocorrection with periodic hidden times=0A=
    this.endToFront =3D -delta > 0 ? false : true; // used to do the =
right autocorrection with periodic hidden times=0A=
    var safeStart =3D DateUtil.snapAwayFromHidden(this.body.hiddenDates, =
newStart, delta, true);=0A=
    var safeEnd =3D DateUtil.snapAwayFromHidden(this.body.hiddenDates, =
newEnd, -delta, true);=0A=
    if (safeStart !=3D newStart || safeEnd !=3D newEnd) {=0A=
      newStart =3D safeStart;=0A=
      newEnd =3D safeEnd;=0A=
    }=0A=
=0A=
    this.setRange(newStart, newEnd, false, true);=0A=
=0A=
    this.startToFront =3D false; // revert to default=0A=
    this.endToFront =3D true; // revert to default=0A=
  };=0A=
=0A=
  /**=0A=
   * Move the range with a given delta to the left or right. Start and =
end=0A=
   * value will be adjusted. For example, try delta =3D 0.1 or -0.1=0A=
   * @param {Number}  delta     Moving amount. Positive value will move =
right,=0A=
   *                            negative value will move left=0A=
   */=0A=
  Range.prototype.move =3D function (delta) {=0A=
    // zoom start Date and end Date relative to the centerDate=0A=
    var diff =3D this.end - this.start;=0A=
=0A=
    // apply new values=0A=
    var newStart =3D this.start + diff * delta;=0A=
    var newEnd =3D this.end + diff * delta;=0A=
=0A=
    // TODO: reckon with min and max range=0A=
=0A=
    this.start =3D newStart;=0A=
    this.end =3D newEnd;=0A=
  };=0A=
=0A=
  /**=0A=
   * Move the range to a new center point=0A=
   * @param {Number} moveTo      New center point of the range=0A=
   */=0A=
  Range.prototype.moveTo =3D function (moveTo) {=0A=
    var center =3D (this.start + this.end) / 2;=0A=
=0A=
    var diff =3D center - moveTo;=0A=
=0A=
    // calculate new start and end=0A=
    var newStart =3D this.start - diff;=0A=
    var newEnd =3D this.end - diff;=0A=
=0A=
    this.setRange(newStart, newEnd);=0A=
  };=0A=
=0A=
  module.exports =3D Range;=0A=
=0A=
/***/ },=0A=
/* 27 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
=0A=
  /**=0A=
   * Register a touch event, taking place before a gesture=0A=
   * @param {Hammer} hammer       A hammer instance=0A=
   * @param {function} callback   Callback, called as callback(event)=0A=
   */=0A=
  exports.onTouch =3D function (hammer, callback) {=0A=
    callback.inputHandler =3D function (event) {=0A=
      if (event.isFirst && !isTouching) {=0A=
        callback(event);=0A=
=0A=
        isTouching =3D true;=0A=
        setTimeout(function () {=0A=
          isTouching =3D false;=0A=
        }, 0);=0A=
      }=0A=
    };=0A=
=0A=
    hammer.on('hammer.input', callback.inputHandler);=0A=
  };=0A=
=0A=
  // isTouching is true while a touch action is being emitted=0A=
  // this is a hack to prevent `touch` from being fired twice=0A=
  var isTouching =3D false;=0A=
=0A=
  /**=0A=
   * Register a release event, taking place after a gesture=0A=
   * @param {Hammer} hammer       A hammer instance=0A=
   * @param {function} callback   Callback, called as callback(event)=0A=
   */=0A=
  exports.onRelease =3D function (hammer, callback) {=0A=
    callback.inputHandler =3D function (event) {=0A=
      if (event.isFinal && !isReleasing) {=0A=
        callback(event);=0A=
=0A=
        isReleasing =3D true;=0A=
        setTimeout(function () {=0A=
          isReleasing =3D false;=0A=
        }, 0);=0A=
      }=0A=
    };=0A=
=0A=
    return hammer.on('hammer.input', callback.inputHandler);=0A=
  };=0A=
=0A=
  // isReleasing is true while a release action is being emitted=0A=
  // this is a hack to prevent `release` from being fired twice=0A=
  var isReleasing =3D false;=0A=
=0A=
  /**=0A=
   * Unregister a touch event, taking place before a gesture=0A=
   * @param {Hammer} hammer       A hammer instance=0A=
   * @param {function} callback   Callback, called as callback(event)=0A=
   */=0A=
  exports.offTouch =3D function (hammer, callback) {=0A=
    hammer.off('hammer.input', callback.inputHandler);=0A=
  };=0A=
=0A=
  /**=0A=
   * Unregister a release event, taking place before a gesture=0A=
   * @param {Hammer} hammer       A hammer instance=0A=
   * @param {function} callback   Callback, called as callback(event)=0A=
   */=0A=
  exports.offRelease =3D exports.offTouch;=0A=
=0A=
/***/ },=0A=
/* 28 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * Prototype for visual components=0A=
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: =
Range}} [body]=0A=
   * @param {Object} [options]=0A=
   */=0A=
  "use strict";=0A=
=0A=
  function Component(body, options) {=0A=
    this.options =3D null;=0A=
    this.props =3D null;=0A=
  }=0A=
=0A=
  /**=0A=
   * Set options for the component. The new options will be merged into =
the=0A=
   * current options.=0A=
   * @param {Object} options=0A=
   */=0A=
  Component.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      util.extend(this.options, options);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the component=0A=
   * @return {boolean} Returns true if the component is resized=0A=
   */=0A=
  Component.prototype.redraw =3D function () {=0A=
    // should be implemented by the component=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Destroy the component. Cleanup DOM and event listeners=0A=
   */=0A=
  Component.prototype.destroy =3D function () {};=0A=
=0A=
  /**=0A=
   * Test whether the component is resized since the last time =
_isResized() was=0A=
   * called.=0A=
   * @return {Boolean} Returns true if the component is resized=0A=
   * @protected=0A=
   */=0A=
  Component.prototype._isResized =3D function () {=0A=
    var resized =3D this.props._previousWidth !=3D=3D this.props.width =
|| this.props._previousHeight !=3D=3D this.props.height;=0A=
=0A=
    this.props._previousWidth =3D this.props.width;=0A=
    this.props._previousHeight =3D this.props.height;=0A=
=0A=
    return resized;=0A=
  };=0A=
=0A=
  module.exports =3D Component;=0A=
=0A=
  // should be implemented by the component=0A=
=0A=
/***/ },=0A=
/* 29 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  =0A=
  /**=0A=
   * used in Core to convert the options into a volatile variable=0A=
   * =0A=
   * @param {function} moment=0A=
   * @param {Object} body=0A=
   * @param {Array} hiddenDates=0A=
   */=0A=
  "use strict";=0A=
=0A=
  exports.convertHiddenOptions =3D function (moment, body, hiddenDates) {=0A=
    body.hiddenDates =3D [];=0A=
    if (hiddenDates) {=0A=
      if (Array.isArray(hiddenDates) =3D=3D true) {=0A=
        for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
          if (hiddenDates[i].repeat =3D=3D=3D undefined) {=0A=
            var dateItem =3D {};=0A=
            dateItem.start =3D =
moment(hiddenDates[i].start).toDate().valueOf();=0A=
            dateItem.end =3D =
moment(hiddenDates[i].end).toDate().valueOf();=0A=
            body.hiddenDates.push(dateItem);=0A=
          }=0A=
        }=0A=
        body.hiddenDates.sort(function (a, b) {=0A=
          return a.start - b.start;=0A=
        }); // sort by start time=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * create new entrees for the repeating hidden dates=0A=
   * @param {function} moment=0A=
   * @param {Object} body=0A=
   * @param {Array} hiddenDates=0A=
   */=0A=
  exports.updateHiddenDates =3D function (moment, body, hiddenDates) {=0A=
    if (hiddenDates && body.domProps.centerContainer.width !=3D=3D =
undefined) {=0A=
      exports.convertHiddenOptions(moment, body, hiddenDates);=0A=
=0A=
      var start =3D moment(body.range.start);=0A=
      var end =3D moment(body.range.end);=0A=
=0A=
      var totalRange =3D body.range.end - body.range.start;=0A=
      var pixelTime =3D totalRange / body.domProps.centerContainer.width;=0A=
=0A=
      for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
        if (hiddenDates[i].repeat !=3D=3D undefined) {=0A=
          var startDate =3D moment(hiddenDates[i].start);=0A=
          var endDate =3D moment(hiddenDates[i].end);=0A=
=0A=
          if (startDate._d =3D=3D "Invalid Date") {=0A=
            throw new Error("Supplied start date is not valid: " + =
hiddenDates[i].start);=0A=
          }=0A=
          if (endDate._d =3D=3D "Invalid Date") {=0A=
            throw new Error("Supplied end date is not valid: " + =
hiddenDates[i].end);=0A=
          }=0A=
=0A=
          var duration =3D endDate - startDate;=0A=
          if (duration >=3D 4 * pixelTime) {=0A=
=0A=
            var offset =3D 0;=0A=
            var runUntil =3D end.clone();=0A=
            switch (hiddenDates[i].repeat) {=0A=
              case "daily":=0A=
                // case of time=0A=
                if (startDate.day() !=3D endDate.day()) {=0A=
                  offset =3D 1;=0A=
                }=0A=
                startDate.dayOfYear(start.dayOfYear());=0A=
                startDate.year(start.year());=0A=
                startDate.subtract(7, "days");=0A=
=0A=
                endDate.dayOfYear(start.dayOfYear());=0A=
                endDate.year(start.year());=0A=
                endDate.subtract(7 - offset, "days");=0A=
=0A=
                runUntil.add(1, "weeks");=0A=
                break;=0A=
              case "weekly":=0A=
                var dayOffset =3D endDate.diff(startDate, "days");=0A=
                var day =3D startDate.day();=0A=
=0A=
                // set the start date to the range.start=0A=
                startDate.date(start.date());=0A=
                startDate.month(start.month());=0A=
                startDate.year(start.year());=0A=
                endDate =3D startDate.clone();=0A=
=0A=
                // force=0A=
                startDate.day(day);=0A=
                endDate.day(day);=0A=
                endDate.add(dayOffset, "days");=0A=
=0A=
                startDate.subtract(1, "weeks");=0A=
                endDate.subtract(1, "weeks");=0A=
=0A=
                runUntil.add(1, "weeks");=0A=
                break;=0A=
              case "monthly":=0A=
                if (startDate.month() !=3D endDate.month()) {=0A=
                  offset =3D 1;=0A=
                }=0A=
                startDate.month(start.month());=0A=
                startDate.year(start.year());=0A=
                startDate.subtract(1, "months");=0A=
=0A=
                endDate.month(start.month());=0A=
                endDate.year(start.year());=0A=
                endDate.subtract(1, "months");=0A=
                endDate.add(offset, "months");=0A=
=0A=
                runUntil.add(1, "months");=0A=
                break;=0A=
              case "yearly":=0A=
                if (startDate.year() !=3D endDate.year()) {=0A=
                  offset =3D 1;=0A=
                }=0A=
                startDate.year(start.year());=0A=
                startDate.subtract(1, "years");=0A=
                endDate.year(start.year());=0A=
                endDate.subtract(1, "years");=0A=
                endDate.add(offset, "years");=0A=
=0A=
                runUntil.add(1, "years");=0A=
                break;=0A=
              default:=0A=
                console.log("Wrong repeat format, allowed are: daily, =
weekly, monthly, yearly. Given:", hiddenDates[i].repeat);=0A=
                return;=0A=
            }=0A=
            while (startDate < runUntil) {=0A=
              body.hiddenDates.push({ start: startDate.valueOf(), end: =
endDate.valueOf() });=0A=
              switch (hiddenDates[i].repeat) {=0A=
                case "daily":=0A=
                  startDate.add(1, "days");=0A=
                  endDate.add(1, "days");=0A=
                  break;=0A=
                case "weekly":=0A=
                  startDate.add(1, "weeks");=0A=
                  endDate.add(1, "weeks");=0A=
                  break;=0A=
                case "monthly":=0A=
                  startDate.add(1, "months");=0A=
                  endDate.add(1, "months");=0A=
                  break;=0A=
                case "yearly":=0A=
                  startDate.add(1, "y");=0A=
                  endDate.add(1, "y");=0A=
                  break;=0A=
                default:=0A=
                  console.log("Wrong repeat format, allowed are: daily, =
weekly, monthly, yearly. Given:", hiddenDates[i].repeat);=0A=
                  return;=0A=
              }=0A=
            }=0A=
            body.hiddenDates.push({ start: startDate.valueOf(), end: =
endDate.valueOf() });=0A=
          }=0A=
        }=0A=
      }=0A=
      // remove duplicates, merge where possible=0A=
      exports.removeDuplicates(body);=0A=
      // ensure the new positions are not on hidden dates=0A=
      var startHidden =3D exports.isHidden(body.range.start, =
body.hiddenDates);=0A=
      var endHidden =3D exports.isHidden(body.range.end, =
body.hiddenDates);=0A=
      var rangeStart =3D body.range.start;=0A=
      var rangeEnd =3D body.range.end;=0A=
      if (startHidden.hidden =3D=3D true) {=0A=
        rangeStart =3D body.range.startToFront =3D=3D true ? =
startHidden.startDate - 1 : startHidden.endDate + 1;=0A=
      }=0A=
      if (endHidden.hidden =3D=3D true) {=0A=
        rangeEnd =3D body.range.endToFront =3D=3D true ? =
endHidden.startDate - 1 : endHidden.endDate + 1;=0A=
      }=0A=
      if (startHidden.hidden =3D=3D true || endHidden.hidden =3D=3D =
true) {=0A=
        body.range._applyRange(rangeStart, rangeEnd);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * remove duplicates from the hidden dates list. Duplicates are evil. =
They mess everything up.=0A=
   * Scales with N^2=0A=
   * @param body=0A=
   */=0A=
  exports.removeDuplicates =3D function (body) {=0A=
    var hiddenDates =3D body.hiddenDates;=0A=
    var safeDates =3D [];=0A=
    for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
      for (var j =3D 0; j < hiddenDates.length; j++) {=0A=
        if (i !=3D j && hiddenDates[j].remove !=3D true && =
hiddenDates[i].remove !=3D true) {=0A=
          // j inside i=0A=
          if (hiddenDates[j].start >=3D hiddenDates[i].start && =
hiddenDates[j].end <=3D hiddenDates[i].end) {=0A=
            hiddenDates[j].remove =3D true;=0A=
          }=0A=
          // j start inside i=0A=
          else if (hiddenDates[j].start >=3D hiddenDates[i].start && =
hiddenDates[j].start <=3D hiddenDates[i].end) {=0A=
            hiddenDates[i].end =3D hiddenDates[j].end;=0A=
            hiddenDates[j].remove =3D true;=0A=
          }=0A=
          // j end inside i=0A=
          else if (hiddenDates[j].end >=3D hiddenDates[i].start && =
hiddenDates[j].end <=3D hiddenDates[i].end) {=0A=
            hiddenDates[i].start =3D hiddenDates[j].start;=0A=
            hiddenDates[j].remove =3D true;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
      if (hiddenDates[i].remove !=3D=3D true) {=0A=
        safeDates.push(hiddenDates[i]);=0A=
      }=0A=
    }=0A=
=0A=
    body.hiddenDates =3D safeDates;=0A=
    body.hiddenDates.sort(function (a, b) {=0A=
      return a.start - b.start;=0A=
    }); // sort by start time=0A=
  };=0A=
=0A=
  exports.printDates =3D function (dates) {=0A=
    for (var i =3D 0; i < dates.length; i++) {=0A=
      console.log(i, new Date(dates[i].start), new Date(dates[i].end), =
dates[i].start, dates[i].end, dates[i].remove);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Used in TimeStep to avoid the hidden times.=0A=
   * @param {function} moment=0A=
   * @param {TimeStep} timeStep=0A=
   * @param previousTime=0A=
   */=0A=
  exports.stepOverHiddenDates =3D function (moment, timeStep, =
previousTime) {=0A=
    var stepInHidden =3D false;=0A=
    var currentValue =3D timeStep.current.valueOf();=0A=
    for (var i =3D 0; i < timeStep.hiddenDates.length; i++) {=0A=
      var startDate =3D timeStep.hiddenDates[i].start;=0A=
      var endDate =3D timeStep.hiddenDates[i].end;=0A=
      if (currentValue >=3D startDate && currentValue < endDate) {=0A=
        stepInHidden =3D true;=0A=
        break;=0A=
      }=0A=
    }=0A=
=0A=
    if (stepInHidden =3D=3D true && currentValue < =
timeStep._end.valueOf() && currentValue !=3D previousTime) {=0A=
      var prevValue =3D moment(previousTime);=0A=
      var newValue =3D moment(endDate);=0A=
      //check if the next step should be major=0A=
      if (prevValue.year() !=3D newValue.year()) {=0A=
        timeStep.switchedYear =3D true;=0A=
      } else if (prevValue.month() !=3D newValue.month()) {=0A=
        timeStep.switchedMonth =3D true;=0A=
      } else if (prevValue.dayOfYear() !=3D newValue.dayOfYear()) {=0A=
        timeStep.switchedDay =3D true;=0A=
      }=0A=
=0A=
      timeStep.current =3D newValue;=0A=
    }=0A=
  };=0A=
=0A=
  ///**=0A=
  // * Used in TimeStep to avoid the hidden times.=0A=
  // * @param timeStep=0A=
  // * @param previousTime=0A=
  // */=0A=
  //exports.checkFirstStep =3D function(timeStep) {=0A=
  //  var stepInHidden =3D false;=0A=
  //  var currentValue =3D timeStep.current.valueOf();=0A=
  //  for (var i =3D 0; i < timeStep.hiddenDates.length; i++) {=0A=
  //    var startDate =3D timeStep.hiddenDates[i].start;=0A=
  //    var endDate =3D timeStep.hiddenDates[i].end;=0A=
  //    if (currentValue >=3D startDate && currentValue < endDate) {=0A=
  //      stepInHidden =3D true;=0A=
  //      break;=0A=
  //    }=0A=
  //  }=0A=
  //=0A=
  //  if (stepInHidden =3D=3D true && currentValue <=3D =
timeStep._end.valueOf()) {=0A=
  //    var newValue =3D moment(endDate);=0A=
  //    timeStep.current =3D newValue.toDate();=0A=
  //  }=0A=
  //};=0A=
=0A=
  /**=0A=
   * replaces the Core toScreen methods=0A=
   * @param Core=0A=
   * @param time=0A=
   * @param width=0A=
   * @returns {number}=0A=
   */=0A=
  exports.toScreen =3D function (Core, time, width) {=0A=
    if (Core.body.hiddenDates.length =3D=3D 0) {=0A=
      var conversion =3D Core.range.conversion(width);=0A=
      return (time.valueOf() - conversion.offset) * conversion.scale;=0A=
    } else {=0A=
      var hidden =3D exports.isHidden(time, Core.body.hiddenDates);=0A=
      if (hidden.hidden =3D=3D true) {=0A=
        time =3D hidden.startDate;=0A=
      }=0A=
=0A=
      var duration =3D =
exports.getHiddenDurationBetween(Core.body.hiddenDates, =
Core.range.start, Core.range.end);=0A=
      time =3D exports.correctTimeForHidden(Core.options.moment, =
Core.body.hiddenDates, Core.range, time);=0A=
=0A=
      var conversion =3D Core.range.conversion(width, duration);=0A=
      return (time.valueOf() - conversion.offset) * conversion.scale;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Replaces the core toTime methods=0A=
   * @param body=0A=
   * @param range=0A=
   * @param x=0A=
   * @param width=0A=
   * @returns {Date}=0A=
   */=0A=
  exports.toTime =3D function (Core, x, width) {=0A=
    if (Core.body.hiddenDates.length =3D=3D 0) {=0A=
      var conversion =3D Core.range.conversion(width);=0A=
      return new Date(x / conversion.scale + conversion.offset);=0A=
    } else {=0A=
      var hiddenDuration =3D =
exports.getHiddenDurationBetween(Core.body.hiddenDates, =
Core.range.start, Core.range.end);=0A=
      var totalDuration =3D Core.range.end - Core.range.start - =
hiddenDuration;=0A=
      var partialDuration =3D totalDuration * x / width;=0A=
      var accumulatedHiddenDuration =3D =
exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, =
partialDuration);=0A=
=0A=
      var newTime =3D new Date(accumulatedHiddenDuration + =
partialDuration + Core.range.start);=0A=
      return newTime;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Support function=0A=
   *=0A=
   * @param hiddenDates=0A=
   * @param range=0A=
   * @returns {number}=0A=
   */=0A=
  exports.getHiddenDurationBetween =3D function (hiddenDates, start, =
end) {=0A=
    var duration =3D 0;=0A=
    for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
      var startDate =3D hiddenDates[i].start;=0A=
      var endDate =3D hiddenDates[i].end;=0A=
      // if time after the cutout, and the=0A=
      if (startDate >=3D start && endDate < end) {=0A=
        duration +=3D endDate - startDate;=0A=
      }=0A=
    }=0A=
    return duration;=0A=
  };=0A=
=0A=
  /**=0A=
   * Support function=0A=
   * @param moment=0A=
   * @param hiddenDates=0A=
   * @param range=0A=
   * @param time=0A=
   * @returns {{duration: number, time: *, offset: number}}=0A=
   */=0A=
  exports.correctTimeForHidden =3D function (moment, hiddenDates, range, =
time) {=0A=
    time =3D moment(time).toDate().valueOf();=0A=
    time -=3D exports.getHiddenDurationBefore(moment, hiddenDates, =
range, time);=0A=
    return time;=0A=
  };=0A=
=0A=
  exports.getHiddenDurationBefore =3D function (moment, hiddenDates, =
range, time) {=0A=
    var timeOffset =3D 0;=0A=
    time =3D moment(time).toDate().valueOf();=0A=
=0A=
    for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
      var startDate =3D hiddenDates[i].start;=0A=
      var endDate =3D hiddenDates[i].end;=0A=
      // if time after the cutout, and the=0A=
      if (startDate >=3D range.start && endDate < range.end) {=0A=
        if (time >=3D endDate) {=0A=
          timeOffset +=3D endDate - startDate;=0A=
        }=0A=
      }=0A=
    }=0A=
    return timeOffset;=0A=
  };=0A=
=0A=
  /**=0A=
   * sum the duration from start to finish, including the hidden =
duration,=0A=
   * until the required amount has been reached, return the accumulated =
hidden duration=0A=
   * @param hiddenDates=0A=
   * @param range=0A=
   * @param time=0A=
   * @returns {{duration: number, time: *, offset: number}}=0A=
   */=0A=
  exports.getAccumulatedHiddenDuration =3D function (hiddenDates, range, =
requiredDuration) {=0A=
    var hiddenDuration =3D 0;=0A=
    var duration =3D 0;=0A=
    var previousPoint =3D range.start;=0A=
    //exports.printDates(hiddenDates)=0A=
    for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
      var startDate =3D hiddenDates[i].start;=0A=
      var endDate =3D hiddenDates[i].end;=0A=
      // if time after the cutout, and the=0A=
      if (startDate >=3D range.start && endDate < range.end) {=0A=
        duration +=3D startDate - previousPoint;=0A=
        previousPoint =3D endDate;=0A=
        if (duration >=3D requiredDuration) {=0A=
          break;=0A=
        } else {=0A=
          hiddenDuration +=3D endDate - startDate;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return hiddenDuration;=0A=
  };=0A=
=0A=
  /**=0A=
   * used to step over to either side of a hidden block. Correction is =
disabled on tablets, might be set to true=0A=
   * @param hiddenDates=0A=
   * @param time=0A=
   * @param direction=0A=
   * @param correctionEnabled=0A=
   * @returns {*}=0A=
   */=0A=
  exports.snapAwayFromHidden =3D function (hiddenDates, time, direction, =
correctionEnabled) {=0A=
    var isHidden =3D exports.isHidden(time, hiddenDates);=0A=
    if (isHidden.hidden =3D=3D true) {=0A=
      if (direction < 0) {=0A=
        if (correctionEnabled =3D=3D true) {=0A=
          return isHidden.startDate - (isHidden.endDate - time) - 1;=0A=
        } else {=0A=
          return isHidden.startDate - 1;=0A=
        }=0A=
      } else {=0A=
        if (correctionEnabled =3D=3D true) {=0A=
          return isHidden.endDate + (time - isHidden.startDate) + 1;=0A=
        } else {=0A=
          return isHidden.endDate + 1;=0A=
        }=0A=
      }=0A=
    } else {=0A=
      return time;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Check if a time is hidden=0A=
   *=0A=
   * @param time=0A=
   * @param hiddenDates=0A=
   * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}=0A=
   */=0A=
  exports.isHidden =3D function (time, hiddenDates) {=0A=
    for (var i =3D 0; i < hiddenDates.length; i++) {=0A=
      var startDate =3D hiddenDates[i].start;=0A=
      var endDate =3D hiddenDates[i].end;=0A=
=0A=
      if (time >=3D startDate && time < endDate) {=0A=
        // if the start is entering a hidden zone=0A=
        return { hidden: true, startDate: startDate, endDate: endDate };=0A=
        break;=0A=
      }=0A=
    }=0A=
    return { hidden: false, startDate: startDate, endDate: endDate };=0A=
  };=0A=
=0A=
/***/ },=0A=
/* 30 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Emitter =3D __webpack_require__(19);=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var hammerUtil =3D __webpack_require__(27);=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
  var Range =3D __webpack_require__(26);=0A=
  var ItemSet =3D __webpack_require__(31);=0A=
  var TimeAxis =3D __webpack_require__(39);=0A=
  var Activator =3D __webpack_require__(40);=0A=
  var DateUtil =3D __webpack_require__(29);=0A=
  var CustomTime =3D __webpack_require__(42);=0A=
=0A=
  /**=0A=
   * Create a timeline visualization=0A=
   * @constructor=0A=
   */=0A=
  function Core() {}=0A=
=0A=
  // turn Core into an event emitter=0A=
  Emitter(Core.prototype);=0A=
=0A=
  /**=0A=
   * Create the main DOM for the Core: a root panel containing left, =
right,=0A=
   * top, bottom, content, and background panel.=0A=
   * @param {Element} container  The container element where the Core =
will=0A=
   *                             be attached.=0A=
   * @protected=0A=
   */=0A=
  Core.prototype._create =3D function (container) {=0A=
    this.dom =3D {};=0A=
=0A=
    this.dom.container =3D container;=0A=
=0A=
    this.dom.root =3D document.createElement('div');=0A=
    this.dom.background =3D document.createElement('div');=0A=
    this.dom.backgroundVertical =3D document.createElement('div');=0A=
    this.dom.backgroundHorizontal =3D document.createElement('div');=0A=
    this.dom.centerContainer =3D document.createElement('div');=0A=
    this.dom.leftContainer =3D document.createElement('div');=0A=
    this.dom.rightContainer =3D document.createElement('div');=0A=
    this.dom.center =3D document.createElement('div');=0A=
    this.dom.left =3D document.createElement('div');=0A=
    this.dom.right =3D document.createElement('div');=0A=
    this.dom.top =3D document.createElement('div');=0A=
    this.dom.bottom =3D document.createElement('div');=0A=
    this.dom.shadowTop =3D document.createElement('div');=0A=
    this.dom.shadowBottom =3D document.createElement('div');=0A=
    this.dom.shadowTopLeft =3D document.createElement('div');=0A=
    this.dom.shadowBottomLeft =3D document.createElement('div');=0A=
    this.dom.shadowTopRight =3D document.createElement('div');=0A=
    this.dom.shadowBottomRight =3D document.createElement('div');=0A=
=0A=
    this.dom.root.className =3D 'vis-timeline';=0A=
    this.dom.background.className =3D 'vis-panel vis-background';=0A=
    this.dom.backgroundVertical.className =3D 'vis-panel vis-background =
vis-vertical';=0A=
    this.dom.backgroundHorizontal.className =3D 'vis-panel =
vis-background vis-horizontal';=0A=
    this.dom.centerContainer.className =3D 'vis-panel vis-center';=0A=
    this.dom.leftContainer.className =3D 'vis-panel vis-left';=0A=
    this.dom.rightContainer.className =3D 'vis-panel vis-right';=0A=
    this.dom.top.className =3D 'vis-panel vis-top';=0A=
    this.dom.bottom.className =3D 'vis-panel vis-bottom';=0A=
    this.dom.left.className =3D 'vis-content';=0A=
    this.dom.center.className =3D 'vis-content';=0A=
    this.dom.right.className =3D 'vis-content';=0A=
    this.dom.shadowTop.className =3D 'vis-shadow vis-top';=0A=
    this.dom.shadowBottom.className =3D 'vis-shadow vis-bottom';=0A=
    this.dom.shadowTopLeft.className =3D 'vis-shadow vis-top';=0A=
    this.dom.shadowBottomLeft.className =3D 'vis-shadow vis-bottom';=0A=
    this.dom.shadowTopRight.className =3D 'vis-shadow vis-top';=0A=
    this.dom.shadowBottomRight.className =3D 'vis-shadow vis-bottom';=0A=
=0A=
    this.dom.root.appendChild(this.dom.background);=0A=
    this.dom.root.appendChild(this.dom.backgroundVertical);=0A=
    this.dom.root.appendChild(this.dom.backgroundHorizontal);=0A=
    this.dom.root.appendChild(this.dom.centerContainer);=0A=
    this.dom.root.appendChild(this.dom.leftContainer);=0A=
    this.dom.root.appendChild(this.dom.rightContainer);=0A=
    this.dom.root.appendChild(this.dom.top);=0A=
    this.dom.root.appendChild(this.dom.bottom);=0A=
=0A=
    this.dom.centerContainer.appendChild(this.dom.center);=0A=
    this.dom.leftContainer.appendChild(this.dom.left);=0A=
    this.dom.rightContainer.appendChild(this.dom.right);=0A=
=0A=
    this.dom.centerContainer.appendChild(this.dom.shadowTop);=0A=
    this.dom.centerContainer.appendChild(this.dom.shadowBottom);=0A=
    this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);=0A=
    this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);=0A=
    this.dom.rightContainer.appendChild(this.dom.shadowTopRight);=0A=
    this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);=0A=
=0A=
    this.on('rangechange', this.redraw.bind(this));=0A=
    this.on('touch', this._onTouch.bind(this));=0A=
    this.on('pan', this._onDrag.bind(this));=0A=
=0A=
    var me =3D this;=0A=
    this.on('change', function (properties) {=0A=
      if (properties && properties.queue =3D=3D true) {=0A=
        // redraw once on next tick=0A=
        if (!me._redrawTimer) {=0A=
          me._redrawTimer =3D setTimeout(function () {=0A=
            me._redrawTimer =3D null;=0A=
            me._redraw();=0A=
          }, 0);=0A=
        }=0A=
      } else {=0A=
        // redraw immediately=0A=
        me._redraw();=0A=
      }=0A=
    });=0A=
=0A=
    // create event listeners for all interesting events, these events =
will be=0A=
    // emitted via emitter=0A=
    this.hammer =3D new Hammer(this.dom.root);=0A=
    this.hammer.get('pinch').set({ enable: true });=0A=
    this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 =
is ALL_DIRECTIONS in hammer.=0A=
    this.listeners =3D {};=0A=
=0A=
    var events =3D ['tap', 'doubletap', 'press', 'pinch', 'pan', =
'panstart', 'panmove', 'panend'=0A=
    // TODO: cleanup=0A=
    //'touch', 'pinch',=0A=
    //'tap', 'doubletap', 'hold',=0A=
    //'dragstart', 'drag', 'dragend',=0A=
    //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for =
Firefox=0A=
    ];=0A=
    events.forEach(function (type) {=0A=
      var listener =3D function listener(event) {=0A=
        if (me.isActive()) {=0A=
          me.emit(type, event);=0A=
        }=0A=
      };=0A=
      me.hammer.on(type, listener);=0A=
      me.listeners[type] =3D listener;=0A=
    });=0A=
=0A=
    // emulate a touch event (emitted before the start of a pan, pinch, =
tap, or press)=0A=
    hammerUtil.onTouch(this.hammer, (function (event) {=0A=
      me.emit('touch', event);=0A=
    }).bind(this));=0A=
=0A=
    // emulate a release event (emitted after a pan, pinch, tap, or =
press)=0A=
    hammerUtil.onRelease(this.hammer, (function (event) {=0A=
      me.emit('release', event);=0A=
    }).bind(this));=0A=
=0A=
    function onMouseWheel(event) {=0A=
      if (me.isActive()) {=0A=
        me.emit('mousewheel', event);=0A=
      }=0A=
    }=0A=
    this.dom.root.addEventListener('mousewheel', onMouseWheel);=0A=
    this.dom.root.addEventListener('DOMMouseScroll', onMouseWheel);=0A=
=0A=
    // size properties of each of the panels=0A=
    this.props =3D {=0A=
      root: {},=0A=
      background: {},=0A=
      centerContainer: {},=0A=
      leftContainer: {},=0A=
      rightContainer: {},=0A=
      center: {},=0A=
      left: {},=0A=
      right: {},=0A=
      top: {},=0A=
      bottom: {},=0A=
      border: {},=0A=
      scrollTop: 0,=0A=
      scrollTopMin: 0=0A=
    };=0A=
=0A=
    this.customTimes =3D [];=0A=
=0A=
    // store state information needed for touch events=0A=
    this.touch =3D {};=0A=
=0A=
    this.redrawCount =3D 0;=0A=
=0A=
    // attach the root panel to the provided container=0A=
    if (!container) throw new Error('No container provided');=0A=
    container.appendChild(this.dom.root);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set options. Options will be passed to all components loaded in the =
Timeline.=0A=
   * @param {Object} [options]=0A=
   *                           {String} orientation=0A=
   *                              Vertical orientation for the Timeline,=0A=
   *                              can be 'bottom' (default) or 'top'.=0A=
   *                           {String | Number} width=0A=
   *                              Width for the timeline, a number in =
pixels or=0A=
   *                              a css string like '1000px' or '75%'. =
'100%' by default.=0A=
   *                           {String | Number} height=0A=
   *                              Fixed height for the Timeline, a =
number in pixels or=0A=
   *                              a css string like '400px' or '75%'. If =
undefined,=0A=
   *                              The Timeline will automatically size =
such that=0A=
   *                              its contents fit.=0A=
   *                           {String | Number} minHeight=0A=
   *                              Minimum height for the Timeline, a =
number in pixels or=0A=
   *                              a css string like '400px' or '75%'.=0A=
   *                           {String | Number} maxHeight=0A=
   *                              Maximum height for the Timeline, a =
number in pixels or=0A=
   *                              a css string like '400px' or '75%'.=0A=
   *                           {Number | Date | String} start=0A=
   *                              Start date for the visible window=0A=
   *                           {Number | Date | String} end=0A=
   *                              End date for the visible window=0A=
   */=0A=
  Core.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      // copy the known options=0A=
      var fields =3D ['width', 'height', 'minHeight', 'maxHeight', =
'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', =
'hiddenDates', 'locale', 'locales', 'moment'];=0A=
      util.selectiveExtend(fields, this.options, options);=0A=
=0A=
      if ('orientation' in options) {=0A=
        if (typeof options.orientation =3D=3D=3D 'string') {=0A=
          this.options.orientation =3D {=0A=
            item: options.orientation,=0A=
            axis: options.orientation=0A=
          };=0A=
        } else if (typeof options.orientation =3D=3D=3D 'object') {=0A=
          if ('item' in options.orientation) {=0A=
            this.options.orientation.item =3D options.orientation.item;=0A=
          }=0A=
          if ('axis' in options.orientation) {=0A=
            this.options.orientation.axis =3D options.orientation.axis;=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if (this.options.orientation.axis =3D=3D=3D 'both') {=0A=
        if (!this.timeAxis2) {=0A=
          var timeAxis2 =3D this.timeAxis2 =3D new TimeAxis(this.body);=0A=
          timeAxis2.setOptions =3D function (options) {=0A=
            var _options =3D options ? util.extend({}, options) : {};=0A=
            _options.orientation =3D 'top'; // override the orientation =
option, always top=0A=
            TimeAxis.prototype.setOptions.call(timeAxis2, _options);=0A=
          };=0A=
          this.components.push(timeAxis2);=0A=
        }=0A=
      } else {=0A=
        if (this.timeAxis2) {=0A=
          var index =3D this.components.indexOf(this.timeAxis2);=0A=
          if (index !=3D=3D -1) {=0A=
            this.components.splice(index, 1);=0A=
          }=0A=
          this.timeAxis2.destroy();=0A=
          this.timeAxis2 =3D null;=0A=
        }=0A=
      }=0A=
=0A=
      // if the graph2d's drawPoints is a function delegate the callback =
to the onRender property=0A=
      if (typeof options.drawPoints =3D=3D 'function') {=0A=
        options.drawPoints =3D {=0A=
          onRender: options.drawPoints=0A=
        };=0A=
      }=0A=
=0A=
      if ('hiddenDates' in this.options) {=0A=
        DateUtil.convertHiddenOptions(this.options.moment, this.body, =
this.options.hiddenDates);=0A=
      }=0A=
=0A=
      if ('clickToUse' in options) {=0A=
        if (options.clickToUse) {=0A=
          if (!this.activator) {=0A=
            this.activator =3D new Activator(this.dom.root);=0A=
          }=0A=
        } else {=0A=
          if (this.activator) {=0A=
            this.activator.destroy();=0A=
            delete this.activator;=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if ('showCustomTime' in options) {=0A=
        throw new Error('Option `showCustomTime` is deprecated. Create a =
custom time bar via timeline.addCustomTime(time [, id])');=0A=
      }=0A=
=0A=
      // enable/disable autoResize=0A=
      this._initAutoResize();=0A=
    }=0A=
=0A=
    // propagate options to all components=0A=
    this.components.forEach(function (component) {=0A=
      return component.setOptions(options);=0A=
    });=0A=
=0A=
    // enable/disable configure=0A=
    if ('configure' in options) {=0A=
      if (!this.configurator) {=0A=
        this.configurator =3D this._createConfigurator();=0A=
      }=0A=
=0A=
      this.configurator.setOptions(options.configure);=0A=
=0A=
      // collect the settings of all components, and pass them to the =
configuration system=0A=
      var appliedOptions =3D util.deepExtend({}, this.options);=0A=
      this.components.forEach(function (component) {=0A=
        util.deepExtend(appliedOptions, component.options);=0A=
      });=0A=
      this.configurator.setModuleOptions({ global: appliedOptions });=0A=
    }=0A=
=0A=
    // redraw everything=0A=
    this._redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Returns true when the Timeline is active.=0A=
   * @returns {boolean}=0A=
   */=0A=
  Core.prototype.isActive =3D function () {=0A=
    return !this.activator || this.activator.active;=0A=
  };=0A=
=0A=
  /**=0A=
   * Destroy the Core, clean up all DOM elements and event listeners.=0A=
   */=0A=
  Core.prototype.destroy =3D function () {=0A=
    // unbind datasets=0A=
    this.setItems(null);=0A=
    this.setGroups(null);=0A=
=0A=
    // remove all event listeners=0A=
    this.off();=0A=
=0A=
    // stop checking for changed size=0A=
    this._stopAutoResize();=0A=
=0A=
    // remove from DOM=0A=
    if (this.dom.root.parentNode) {=0A=
      this.dom.root.parentNode.removeChild(this.dom.root);=0A=
    }=0A=
    this.dom =3D null;=0A=
=0A=
    // remove Activator=0A=
    if (this.activator) {=0A=
      this.activator.destroy();=0A=
      delete this.activator;=0A=
    }=0A=
=0A=
    // cleanup hammer touch events=0A=
    for (var event in this.listeners) {=0A=
      if (this.listeners.hasOwnProperty(event)) {=0A=
        delete this.listeners[event];=0A=
      }=0A=
    }=0A=
    this.listeners =3D null;=0A=
    this.hammer =3D null;=0A=
=0A=
    // give all components the opportunity to cleanup=0A=
    this.components.forEach(function (component) {=0A=
      return component.destroy();=0A=
    });=0A=
=0A=
    this.body =3D null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a custom time bar=0A=
   * @param {Date} time=0A=
   * @param {number} [id=3Dundefined] Optional id of the custom time bar =
to be adjusted.=0A=
   */=0A=
  Core.prototype.setCustomTime =3D function (time, id) {=0A=
    var customTimes =3D this.customTimes.filter(function (component) {=0A=
      return id =3D=3D=3D component.options.id;=0A=
    });=0A=
=0A=
    if (customTimes.length =3D=3D=3D 0) {=0A=
      throw new Error('No custom time bar found with id ' + =
JSON.stringify(id));=0A=
    }=0A=
=0A=
    if (customTimes.length > 0) {=0A=
      customTimes[0].setCustomTime(time);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the current custom time.=0A=
   * @param {number} [id=3Dundefined]    Id of the custom time bar.=0A=
   * @return {Date | undefined} customTime=0A=
   */=0A=
  Core.prototype.getCustomTime =3D function (id) {=0A=
    var customTimes =3D this.customTimes.filter(function (component) {=0A=
      return component.options.id =3D=3D=3D id;=0A=
    });=0A=
=0A=
    if (customTimes.length =3D=3D=3D 0) {=0A=
      throw new Error('No custom time bar found with id ' + =
JSON.stringify(id));=0A=
    }=0A=
    return customTimes[0].getCustomTime();=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve meta information from an event.=0A=
   * Should be overridden by classes extending Core=0A=
   * @param {Event} event=0A=
   * @return {Object} An object with related information.=0A=
   */=0A=
  Core.prototype.getEventProperties =3D function (event) {=0A=
    return { event: event };=0A=
  };=0A=
=0A=
  /**=0A=
   * Add custom vertical bar=0A=
   * @param {Date | String | Number} [time]  A Date, unix timestamp, or=0A=
   *                                         ISO date string. Time point =
where=0A=
   *                                         the new bar should be =
placed.=0A=
   *                                         If not provided, `new =
Date()` will=0A=
   *                                         be used.=0A=
   * @param {Number | String} [id=3Dundefined] Id of the new bar. =
Optional=0A=
   * @return {Number | String}               Returns the id of the new =
bar=0A=
   */=0A=
  Core.prototype.addCustomTime =3D function (time, id) {=0A=
    var timestamp =3D time !=3D=3D undefined ? util.convert(time, =
'Date').valueOf() : new Date();=0A=
=0A=
    var exists =3D this.customTimes.some(function (customTime) {=0A=
      return customTime.options.id =3D=3D=3D id;=0A=
    });=0A=
    if (exists) {=0A=
      throw new Error('A custom time with id ' + JSON.stringify(id) + ' =
already exists');=0A=
    }=0A=
=0A=
    var customTime =3D new CustomTime(this.body, util.extend({}, =
this.options, {=0A=
      time: timestamp,=0A=
      id: id=0A=
    }));=0A=
=0A=
    this.customTimes.push(customTime);=0A=
    this.components.push(customTime);=0A=
    this.redraw();=0A=
=0A=
    return id;=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove previously added custom bar=0A=
   * @param {int} id ID of the custom bar to be removed=0A=
   * @return {boolean} True if the bar exists and is removed, false =
otherwise=0A=
   */=0A=
  Core.prototype.removeCustomTime =3D function (id) {=0A=
    var customTimes =3D this.customTimes.filter(function (bar) {=0A=
      return bar.options.id =3D=3D=3D id;=0A=
    });=0A=
=0A=
    if (customTimes.length =3D=3D=3D 0) {=0A=
      throw new Error('No custom time bar found with id ' + =
JSON.stringify(id));=0A=
    }=0A=
=0A=
    customTimes.forEach((function (customTime) {=0A=
      this.customTimes.splice(this.customTimes.indexOf(customTime), 1);=0A=
      this.components.splice(this.components.indexOf(customTime), 1);=0A=
      customTime.destroy();=0A=
    }).bind(this));=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the id's of the currently visible items.=0A=
   * @returns {Array} The ids of the visible items=0A=
   */=0A=
  Core.prototype.getVisibleItems =3D function () {=0A=
    return this.itemSet && this.itemSet.getVisibleItems() || [];=0A=
  };=0A=
=0A=
  /**=0A=
   * Set Core window such that it fits all items=0A=
   * @param {Object} [options]  Available options:=0A=
   *                                `animation: boolean | {duration: =
number, easingFunction: string}`=0A=
   *                                    If true (default), the range is =
animated=0A=
   *                                    smoothly to the new window. An =
object can be=0A=
   *                                    provided to specify duration and =
easing function.=0A=
   *                                    Default duration is 500 ms, and =
default easing=0A=
   *                                    function is 'easeInOutQuad'.=0A=
   */=0A=
  Core.prototype.fit =3D function (options) {=0A=
    var range =3D this.getDataRange();=0A=
=0A=
    // skip range set if there is no min and max date=0A=
    if (range.min =3D=3D=3D null && range.max =3D=3D=3D null) {=0A=
      return;=0A=
    }=0A=
=0A=
    // apply a margin of 1% left and right of the data=0A=
    var interval =3D range.max - range.min;=0A=
    var min =3D new Date(range.min.valueOf() - interval * 0.01);=0A=
    var max =3D new Date(range.max.valueOf() + interval * 0.01);=0A=
=0A=
    var animation =3D options && options.animation !=3D=3D undefined ? =
options.animation : true;=0A=
    this.range.setRange(min, max, animation);=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the data range of the items start and end dates=0A=
   * @returns {{min: Date | null, max: Date | null}}=0A=
   * @protected=0A=
   */=0A=
  Core.prototype.getDataRange =3D function () {=0A=
    // must be implemented by Timeline and Graph2d=0A=
    throw new Error('Cannot invoke abstract method getDataRange');=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the visible window. Both parameters are optional, you can =
change only=0A=
   * start or only end. Syntax:=0A=
   *=0A=
   *     TimeLine.setWindow(start, end)=0A=
   *     TimeLine.setWindow(start, end, options)=0A=
   *     TimeLine.setWindow(range)=0A=
   *=0A=
   * Where start and end can be a Date, number, or string, and range is =
an=0A=
   * object with properties start and end.=0A=
   *=0A=
   * @param {Date | Number | String | Object} [start] Start date of =
visible window=0A=
   * @param {Date | Number | String} [end]            End date of =
visible window=0A=
   * @param {Object} [options]  Available options:=0A=
   *                                `animation: boolean | {duration: =
number, easingFunction: string}`=0A=
   *                                    If true (default), the range is =
animated=0A=
   *                                    smoothly to the new window. An =
object can be=0A=
   *                                    provided to specify duration and =
easing function.=0A=
   *                                    Default duration is 500 ms, and =
default easing=0A=
   *                                    function is 'easeInOutQuad'.=0A=
   */=0A=
  Core.prototype.setWindow =3D function (start, end, options) {=0A=
    var animation;=0A=
    if (arguments.length =3D=3D 1) {=0A=
      var range =3D arguments[0];=0A=
      animation =3D range.animation !=3D=3D undefined ? range.animation =
: true;=0A=
      this.range.setRange(range.start, range.end, animation);=0A=
    } else {=0A=
      animation =3D options && options.animation !=3D=3D undefined ? =
options.animation : true;=0A=
      this.range.setRange(start, end, animation);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Move the window such that given time is centered on screen.=0A=
   * @param {Date | Number | String} time=0A=
   * @param {Object} [options]  Available options:=0A=
   *                                `animation: boolean | {duration: =
number, easingFunction: string}`=0A=
   *                                    If true (default), the range is =
animated=0A=
   *                                    smoothly to the new window. An =
object can be=0A=
   *                                    provided to specify duration and =
easing function.=0A=
   *                                    Default duration is 500 ms, and =
default easing=0A=
   *                                    function is 'easeInOutQuad'.=0A=
   */=0A=
  Core.prototype.moveTo =3D function (time, options) {=0A=
    var interval =3D this.range.end - this.range.start;=0A=
    var t =3D util.convert(time, 'Date').valueOf();=0A=
=0A=
    var start =3D t - interval / 2;=0A=
    var end =3D t + interval / 2;=0A=
    var animation =3D options && options.animation !=3D=3D undefined ? =
options.animation : true;=0A=
=0A=
    this.range.setRange(start, end, animation);=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the visible window=0A=
   * @return {{start: Date, end: Date}}   Visible range=0A=
   */=0A=
  Core.prototype.getWindow =3D function () {=0A=
    var range =3D this.range.getRange();=0A=
    return {=0A=
      start: new Date(range.start),=0A=
      end: new Date(range.end)=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Force a redraw. Can be overridden by implementations of Core=0A=
   */=0A=
  Core.prototype.redraw =3D function () {=0A=
    this._redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw for internal use. Redraws all components. See also the public=0A=
   * method redraw.=0A=
   * @protected=0A=
   */=0A=
  Core.prototype._redraw =3D function () {=0A=
    var resized =3D false;=0A=
    var options =3D this.options;=0A=
    var props =3D this.props;=0A=
    var dom =3D this.dom;=0A=
=0A=
    if (!dom) return; // when destroyed=0A=
=0A=
    DateUtil.updateHiddenDates(this.options.moment, this.body, =
this.options.hiddenDates);=0A=
=0A=
    // update class names=0A=
    if (options.orientation =3D=3D 'top') {=0A=
      util.addClassName(dom.root, 'vis-top');=0A=
      util.removeClassName(dom.root, 'vis-bottom');=0A=
    } else {=0A=
      util.removeClassName(dom.root, 'vis-top');=0A=
      util.addClassName(dom.root, 'vis-bottom');=0A=
    }=0A=
=0A=
    // update root width and height options=0A=
    dom.root.style.maxHeight =3D util.option.asSize(options.maxHeight, =
'');=0A=
    dom.root.style.minHeight =3D util.option.asSize(options.minHeight, =
'');=0A=
    dom.root.style.width =3D util.option.asSize(options.width, '');=0A=
=0A=
    // calculate border widths=0A=
    props.border.left =3D (dom.centerContainer.offsetWidth - =
dom.centerContainer.clientWidth) / 2;=0A=
    props.border.right =3D props.border.left;=0A=
    props.border.top =3D (dom.centerContainer.offsetHeight - =
dom.centerContainer.clientHeight) / 2;=0A=
    props.border.bottom =3D props.border.top;=0A=
    var borderRootHeight =3D dom.root.offsetHeight - =
dom.root.clientHeight;=0A=
    var borderRootWidth =3D dom.root.offsetWidth - dom.root.clientWidth;=0A=
=0A=
    // workaround for a bug in IE: the clientWidth of an element with=0A=
    // a height:0px and overflow:hidden is not calculated and always has =
value 0=0A=
    if (dom.centerContainer.clientHeight =3D=3D=3D 0) {=0A=
      props.border.left =3D props.border.top;=0A=
      props.border.right =3D props.border.left;=0A=
    }=0A=
    if (dom.root.clientHeight =3D=3D=3D 0) {=0A=
      borderRootWidth =3D borderRootHeight;=0A=
    }=0A=
=0A=
    // calculate the heights. If any of the side panels is empty, we set =
the height to=0A=
    // minus the border width, such that the border will be invisible=0A=
    props.center.height =3D dom.center.offsetHeight;=0A=
    props.left.height =3D dom.left.offsetHeight;=0A=
    props.right.height =3D dom.right.offsetHeight;=0A=
    props.top.height =3D dom.top.clientHeight || -props.border.top;=0A=
    props.bottom.height =3D dom.bottom.clientHeight || =
-props.border.bottom;=0A=
=0A=
    // TODO: compensate borders when any of the panels is empty.=0A=
=0A=
    // apply auto height=0A=
    // TODO: only calculate autoHeight when needed (else we cause an =
extra reflow/repaint of the DOM)=0A=
    var contentHeight =3D Math.max(props.left.height, =
props.center.height, props.right.height);=0A=
    var autoHeight =3D props.top.height + contentHeight + =
props.bottom.height + borderRootHeight + props.border.top + =
props.border.bottom;=0A=
    dom.root.style.height =3D util.option.asSize(options.height, =
autoHeight + 'px');=0A=
=0A=
    // calculate heights of the content panels=0A=
    props.root.height =3D dom.root.offsetHeight;=0A=
    props.background.height =3D props.root.height - borderRootHeight;=0A=
    var containerHeight =3D props.root.height - props.top.height - =
props.bottom.height - borderRootHeight;=0A=
    props.centerContainer.height =3D containerHeight;=0A=
    props.leftContainer.height =3D containerHeight;=0A=
    props.rightContainer.height =3D props.leftContainer.height;=0A=
=0A=
    // calculate the widths of the panels=0A=
    props.root.width =3D dom.root.offsetWidth;=0A=
    props.background.width =3D props.root.width - borderRootWidth;=0A=
    props.left.width =3D dom.leftContainer.clientWidth || =
-props.border.left;=0A=
    props.leftContainer.width =3D props.left.width;=0A=
    props.right.width =3D dom.rightContainer.clientWidth || =
-props.border.right;=0A=
    props.rightContainer.width =3D props.right.width;=0A=
    var centerWidth =3D props.root.width - props.left.width - =
props.right.width - borderRootWidth;=0A=
    props.center.width =3D centerWidth;=0A=
    props.centerContainer.width =3D centerWidth;=0A=
    props.top.width =3D centerWidth;=0A=
    props.bottom.width =3D centerWidth;=0A=
=0A=
    // resize the panels=0A=
    dom.background.style.height =3D props.background.height + 'px';=0A=
    dom.backgroundVertical.style.height =3D props.background.height + =
'px';=0A=
    dom.backgroundHorizontal.style.height =3D =
props.centerContainer.height + 'px';=0A=
    dom.centerContainer.style.height =3D props.centerContainer.height + =
'px';=0A=
    dom.leftContainer.style.height =3D props.leftContainer.height + 'px';=0A=
    dom.rightContainer.style.height =3D props.rightContainer.height + =
'px';=0A=
=0A=
    dom.background.style.width =3D props.background.width + 'px';=0A=
    dom.backgroundVertical.style.width =3D props.centerContainer.width + =
'px';=0A=
    dom.backgroundHorizontal.style.width =3D props.background.width + =
'px';=0A=
    dom.centerContainer.style.width =3D props.center.width + 'px';=0A=
    dom.top.style.width =3D props.top.width + 'px';=0A=
    dom.bottom.style.width =3D props.bottom.width + 'px';=0A=
=0A=
    // reposition the panels=0A=
    dom.background.style.left =3D '0';=0A=
    dom.background.style.top =3D '0';=0A=
    dom.backgroundVertical.style.left =3D props.left.width + =
props.border.left + 'px';=0A=
    dom.backgroundVertical.style.top =3D '0';=0A=
    dom.backgroundHorizontal.style.left =3D '0';=0A=
    dom.backgroundHorizontal.style.top =3D props.top.height + 'px';=0A=
    dom.centerContainer.style.left =3D props.left.width + 'px';=0A=
    dom.centerContainer.style.top =3D props.top.height + 'px';=0A=
    dom.leftContainer.style.left =3D '0';=0A=
    dom.leftContainer.style.top =3D props.top.height + 'px';=0A=
    dom.rightContainer.style.left =3D props.left.width + =
props.center.width + 'px';=0A=
    dom.rightContainer.style.top =3D props.top.height + 'px';=0A=
    dom.top.style.left =3D props.left.width + 'px';=0A=
    dom.top.style.top =3D '0';=0A=
    dom.bottom.style.left =3D props.left.width + 'px';=0A=
    dom.bottom.style.top =3D props.top.height + =
props.centerContainer.height + 'px';=0A=
=0A=
    // update the scrollTop, feasible range for the offset can be changed=0A=
    // when the height of the Core or of the contents of the center =
changed=0A=
    this._updateScrollTop();=0A=
=0A=
    // reposition the scrollable contents=0A=
    var offset =3D this.props.scrollTop;=0A=
    if (options.orientation.item !=3D 'top') {=0A=
      offset +=3D Math.max(this.props.centerContainer.height - =
this.props.center.height - this.props.border.top - =
this.props.border.bottom, 0);=0A=
    }=0A=
    dom.center.style.left =3D '0';=0A=
    dom.center.style.top =3D offset + 'px';=0A=
    dom.left.style.left =3D '0';=0A=
    dom.left.style.top =3D offset + 'px';=0A=
    dom.right.style.left =3D '0';=0A=
    dom.right.style.top =3D offset + 'px';=0A=
=0A=
    // show shadows when vertical scrolling is available=0A=
    var visibilityTop =3D this.props.scrollTop =3D=3D 0 ? 'hidden' : '';=0A=
    var visibilityBottom =3D this.props.scrollTop =3D=3D =
this.props.scrollTopMin ? 'hidden' : '';=0A=
    dom.shadowTop.style.visibility =3D visibilityTop;=0A=
    dom.shadowBottom.style.visibility =3D visibilityBottom;=0A=
    dom.shadowTopLeft.style.visibility =3D visibilityTop;=0A=
    dom.shadowBottomLeft.style.visibility =3D visibilityBottom;=0A=
    dom.shadowTopRight.style.visibility =3D visibilityTop;=0A=
    dom.shadowBottomRight.style.visibility =3D visibilityBottom;=0A=
=0A=
    // redraw all components=0A=
    this.components.forEach(function (component) {=0A=
      resized =3D component.redraw() || resized;=0A=
    });=0A=
    if (resized) {=0A=
      // keep repainting until all sizes are settled=0A=
      var MAX_REDRAWS =3D 3; // maximum number of consecutive redraws=0A=
      if (this.redrawCount < MAX_REDRAWS) {=0A=
        this.redrawCount++;=0A=
        this._redraw();=0A=
      } else {=0A=
        console.log('WARNING: infinite loop in redraw?');=0A=
      }=0A=
      this.redrawCount =3D 0;=0A=
    }=0A=
  };=0A=
=0A=
  // TODO: deprecated since version 1.1.0, remove some day=0A=
  Core.prototype.repaint =3D function () {=0A=
    throw new Error('Function repaint is deprecated. Use redraw =
instead.');=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a current time. This can be used for example to ensure that a =
client's=0A=
   * time is synchronized with a shared server time.=0A=
   * Only applicable when option `showCurrentTime` is true.=0A=
   * @param {Date | String | Number} time     A Date, unix timestamp, or=0A=
   *                                          ISO date string.=0A=
   */=0A=
  Core.prototype.setCurrentTime =3D function (time) {=0A=
    if (!this.currentTime) {=0A=
      throw new Error('Option showCurrentTime must be true');=0A=
    }=0A=
=0A=
    this.currentTime.setCurrentTime(time);=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the current time.=0A=
   * Only applicable when option `showCurrentTime` is true.=0A=
   * @return {Date} Returns the current time.=0A=
   */=0A=
  Core.prototype.getCurrentTime =3D function () {=0A=
    if (!this.currentTime) {=0A=
      throw new Error('Option showCurrentTime must be true');=0A=
    }=0A=
=0A=
    return this.currentTime.getCurrentTime();=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a position on screen (pixels) to a datetime=0A=
   * @param {int}     x    Position on the screen in pixels=0A=
   * @return {Date}   time The datetime the corresponds with given =
position x=0A=
   * @protected=0A=
   */=0A=
  // TODO: move this function to Range=0A=
  Core.prototype._toTime =3D function (x) {=0A=
    return DateUtil.toTime(this, x, this.props.center.width);=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a position on the global screen (pixels) to a datetime=0A=
   * @param {int}     x    Position on the screen in pixels=0A=
   * @return {Date}   time The datetime the corresponds with given =
position x=0A=
   * @protected=0A=
   */=0A=
  // TODO: move this function to Range=0A=
  Core.prototype._toGlobalTime =3D function (x) {=0A=
    return DateUtil.toTime(this, x, this.props.root.width);=0A=
    //var conversion =3D this.range.conversion(this.props.root.width);=0A=
    //return new Date(x / conversion.scale + conversion.offset);=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a datetime (Date object) into a position on the screen=0A=
   * @param {Date}   time A date=0A=
   * @return {int}   x    The position on the screen in pixels which =
corresponds=0A=
   *                      with the given date.=0A=
   * @protected=0A=
   */=0A=
  // TODO: move this function to Range=0A=
  Core.prototype._toScreen =3D function (time) {=0A=
    return DateUtil.toScreen(this, time, this.props.center.width);=0A=
  };=0A=
=0A=
  /**=0A=
   * Convert a datetime (Date object) into a position on the root=0A=
   * This is used to get the pixel density estimate for the screen, not =
the center panel=0A=
   * @param {Date}   time A date=0A=
   * @return {int}   x    The position on root in pixels which =
corresponds=0A=
   *                      with the given date.=0A=
   * @protected=0A=
   */=0A=
  // TODO: move this function to Range=0A=
  Core.prototype._toGlobalScreen =3D function (time) {=0A=
    return DateUtil.toScreen(this, time, this.props.root.width);=0A=
    //var conversion =3D this.range.conversion(this.props.root.width);=0A=
    //return (time.valueOf() - conversion.offset) * conversion.scale;=0A=
  };=0A=
=0A=
  /**=0A=
   * Initialize watching when option autoResize is true=0A=
   * @private=0A=
   */=0A=
  Core.prototype._initAutoResize =3D function () {=0A=
    if (this.options.autoResize =3D=3D true) {=0A=
      this._startAutoResize();=0A=
    } else {=0A=
      this._stopAutoResize();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Watch for changes in the size of the container. On resize, the =
Panel will=0A=
   * automatically redraw itself.=0A=
   * @private=0A=
   */=0A=
  Core.prototype._startAutoResize =3D function () {=0A=
    var me =3D this;=0A=
=0A=
    this._stopAutoResize();=0A=
=0A=
    this._onResize =3D function () {=0A=
      if (me.options.autoResize !=3D true) {=0A=
        // stop watching when the option autoResize is changed to false=0A=
        me._stopAutoResize();=0A=
        return;=0A=
      }=0A=
=0A=
      if (me.dom.root) {=0A=
        // check whether the frame is resized=0A=
        // Note: we compare offsetWidth here, not clientWidth. For some =
reason,=0A=
        // IE does not restore the clientWidth from 0 to the actual =
width after=0A=
        // changing the timeline's container display style from none to =
visible=0A=
        if (me.dom.root.offsetWidth !=3D me.props.lastWidth || =
me.dom.root.offsetHeight !=3D me.props.lastHeight) {=0A=
          me.props.lastWidth =3D me.dom.root.offsetWidth;=0A=
          me.props.lastHeight =3D me.dom.root.offsetHeight;=0A=
=0A=
          me.emit('change');=0A=
        }=0A=
      }=0A=
    };=0A=
=0A=
    // add event listener to window resize=0A=
    util.addEventListener(window, 'resize', this._onResize);=0A=
=0A=
    this.watchTimer =3D setInterval(this._onResize, 1000);=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop watching for a resize of the frame.=0A=
   * @private=0A=
   */=0A=
  Core.prototype._stopAutoResize =3D function () {=0A=
    if (this.watchTimer) {=0A=
      clearInterval(this.watchTimer);=0A=
      this.watchTimer =3D undefined;=0A=
    }=0A=
=0A=
    // remove event listener on window.resize=0A=
    util.removeEventListener(window, 'resize', this._onResize);=0A=
    this._onResize =3D null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Start moving the timeline vertically=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  Core.prototype._onTouch =3D function (event) {=0A=
    this.touch.allowDragging =3D true;=0A=
    this.touch.initialScrollTop =3D this.props.scrollTop;=0A=
  };=0A=
=0A=
  /**=0A=
   * Start moving the timeline vertically=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  Core.prototype._onPinch =3D function (event) {=0A=
    this.touch.allowDragging =3D false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Move the timeline vertically=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  Core.prototype._onDrag =3D function (event) {=0A=
    // refuse to drag when we where pinching to prevent the timeline =
make a jump=0A=
    // when releasing the fingers in opposite order from the touch screen=0A=
    if (!this.touch.allowDragging) return;=0A=
=0A=
    var delta =3D event.deltaY;=0A=
=0A=
    var oldScrollTop =3D this._getScrollTop();=0A=
    var newScrollTop =3D this._setScrollTop(this.touch.initialScrollTop =
+ delta);=0A=
=0A=
    if (newScrollTop !=3D oldScrollTop) {=0A=
      this._redraw(); // TODO: this causes two redraws when dragging, =
the other is triggered by rangechange already=0A=
      this.emit('verticalDrag');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Apply a scrollTop=0A=
   * @param {Number} scrollTop=0A=
   * @returns {Number} scrollTop  Returns the applied scrollTop=0A=
   * @private=0A=
   */=0A=
  Core.prototype._setScrollTop =3D function (scrollTop) {=0A=
    this.props.scrollTop =3D scrollTop;=0A=
    this._updateScrollTop();=0A=
    return this.props.scrollTop;=0A=
  };=0A=
=0A=
  /**=0A=
   * Update the current scrollTop when the height of  the containers has =
been changed=0A=
   * @returns {Number} scrollTop  Returns the applied scrollTop=0A=
   * @private=0A=
   */=0A=
  Core.prototype._updateScrollTop =3D function () {=0A=
    // recalculate the scrollTopMin=0A=
    var scrollTopMin =3D Math.min(this.props.centerContainer.height - =
this.props.center.height, 0); // is negative or zero=0A=
    if (scrollTopMin !=3D this.props.scrollTopMin) {=0A=
      // in case of bottom orientation, change the scrollTop such that =
the contents=0A=
      // do not move relative to the time axis at the bottom=0A=
      if (this.options.orientation.item !=3D 'top') {=0A=
        this.props.scrollTop +=3D scrollTopMin - this.props.scrollTopMin;=0A=
      }=0A=
      this.props.scrollTopMin =3D scrollTopMin;=0A=
    }=0A=
=0A=
    // limit the scrollTop to the feasible scroll range=0A=
    if (this.props.scrollTop > 0) this.props.scrollTop =3D 0;=0A=
    if (this.props.scrollTop < scrollTopMin) this.props.scrollTop =3D =
scrollTopMin;=0A=
=0A=
    return this.props.scrollTop;=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the current scrollTop=0A=
   * @returns {number} scrollTop=0A=
   * @private=0A=
   */=0A=
  Core.prototype._getScrollTop =3D function () {=0A=
    return this.props.scrollTop;=0A=
  };=0A=
=0A=
  /**=0A=
   * Load a configurator=0A=
   * @return {Object}=0A=
   * @private=0A=
   */=0A=
  Core.prototype._createConfigurator =3D function () {=0A=
    throw new Error('Cannot invoke abstract method _createConfigurator');=0A=
  };=0A=
=0A=
  module.exports =3D Core;=0A=
=0A=
/***/ },=0A=
/* 31 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
  var TimeStep =3D __webpack_require__(35);=0A=
  var Component =3D __webpack_require__(28);=0A=
  var Group =3D __webpack_require__(32);=0A=
  var BackgroundGroup =3D __webpack_require__(36);=0A=
  var BoxItem =3D __webpack_require__(37);=0A=
  var PointItem =3D __webpack_require__(1);=0A=
  var RangeItem =3D __webpack_require__(34);=0A=
  var BackgroundItem =3D __webpack_require__(38);=0A=
=0A=
  var UNGROUPED =3D '__ungrouped__'; // reserved group id for ungrouped =
items=0A=
  var BACKGROUND =3D '__background__'; // reserved group id for =
background items without group=0A=
=0A=
  /**=0A=
   * An ItemSet holds a set of items and ranges which can be displayed =
in a=0A=
   * range. The width is determined by the parent of the ItemSet, and =
the height=0A=
   * is determined by the size of the items.=0A=
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: =
Range}} body=0A=
   * @param {Object} [options]      See ItemSet.setOptions for the =
available options.=0A=
   * @constructor ItemSet=0A=
   * @extends Component=0A=
   */=0A=
  function ItemSet(body, options) {=0A=
    this.body =3D body;=0A=
=0A=
    this.defaultOptions =3D {=0A=
      type: null, // 'box', 'point', 'range', 'background'=0A=
      orientation: {=0A=
        item: 'bottom' // item orientation: 'top' or 'bottom'=0A=
      },=0A=
      align: 'auto', // alignment of box items=0A=
      stack: true,=0A=
      groupOrder: null,=0A=
=0A=
      selectable: true,=0A=
      multiselect: false,=0A=
=0A=
      editable: {=0A=
        updateTime: false,=0A=
        updateGroup: false,=0A=
        add: false,=0A=
        remove: false=0A=
      },=0A=
=0A=
      snap: TimeStep.snap,=0A=
=0A=
      onAdd: function onAdd(item, callback) {=0A=
        callback(item);=0A=
      },=0A=
      onUpdate: function onUpdate(item, callback) {=0A=
        callback(item);=0A=
      },=0A=
      onMove: function onMove(item, callback) {=0A=
        callback(item);=0A=
      },=0A=
      onRemove: function onRemove(item, callback) {=0A=
        callback(item);=0A=
      },=0A=
      onMoving: function onMoving(item, callback) {=0A=
        callback(item);=0A=
      },=0A=
=0A=
      margin: {=0A=
        item: {=0A=
          horizontal: 10,=0A=
          vertical: 10=0A=
        },=0A=
        axis: 20=0A=
      }=0A=
    };=0A=
=0A=
    // options is shared by this ItemSet and all its items=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
=0A=
    // options for getting items from the DataSet with the correct type=0A=
    this.itemOptions =3D {=0A=
      type: { start: 'Date', end: 'Date' }=0A=
    };=0A=
=0A=
    this.conversion =3D {=0A=
      toScreen: body.util.toScreen,=0A=
      toTime: body.util.toTime=0A=
    };=0A=
    this.dom =3D {};=0A=
    this.props =3D {};=0A=
    this.hammer =3D null;=0A=
=0A=
    var me =3D this;=0A=
    this.itemsData =3D null; // DataSet=0A=
    this.groupsData =3D null; // DataSet=0A=
=0A=
    // listeners for the DataSet of the items=0A=
    this.itemListeners =3D {=0A=
      'add': function add(event, params, senderId) {=0A=
        me._onAdd(params.items);=0A=
      },=0A=
      'update': function update(event, params, senderId) {=0A=
        me._onUpdate(params.items);=0A=
      },=0A=
      'remove': function remove(event, params, senderId) {=0A=
        me._onRemove(params.items);=0A=
      }=0A=
    };=0A=
=0A=
    // listeners for the DataSet of the groups=0A=
    this.groupListeners =3D {=0A=
      'add': function add(event, params, senderId) {=0A=
        me._onAddGroups(params.items);=0A=
      },=0A=
      'update': function update(event, params, senderId) {=0A=
        me._onUpdateGroups(params.items);=0A=
      },=0A=
      'remove': function remove(event, params, senderId) {=0A=
        me._onRemoveGroups(params.items);=0A=
      }=0A=
    };=0A=
=0A=
    this.items =3D {}; // object with an Item for every data item=0A=
    this.groups =3D {}; // Group object for every group=0A=
    this.groupIds =3D [];=0A=
=0A=
    this.selection =3D []; // list with the ids of all selected nodes=0A=
    this.stackDirty =3D true; // if true, all items will be restacked on =
next redraw=0A=
=0A=
    this.touchParams =3D {}; // stores properties while dragging=0A=
    // create the HTML DOM=0A=
=0A=
    this._create();=0A=
=0A=
    this.setOptions(options);=0A=
  }=0A=
=0A=
  ItemSet.prototype =3D new Component();=0A=
=0A=
  // available item types will be registered here=0A=
  ItemSet.types =3D {=0A=
    background: BackgroundItem,=0A=
    box: BoxItem,=0A=
    range: RangeItem,=0A=
    point: PointItem=0A=
  };=0A=
=0A=
  /**=0A=
   * Create the HTML DOM for the ItemSet=0A=
   */=0A=
  ItemSet.prototype._create =3D function () {=0A=
    var frame =3D document.createElement('div');=0A=
    frame.className =3D 'vis-itemset';=0A=
    frame['timeline-itemset'] =3D this;=0A=
    this.dom.frame =3D frame;=0A=
=0A=
    // create background panel=0A=
    var background =3D document.createElement('div');=0A=
    background.className =3D 'vis-background';=0A=
    frame.appendChild(background);=0A=
    this.dom.background =3D background;=0A=
=0A=
    // create foreground panel=0A=
    var foreground =3D document.createElement('div');=0A=
    foreground.className =3D 'vis-foreground';=0A=
    frame.appendChild(foreground);=0A=
    this.dom.foreground =3D foreground;=0A=
=0A=
    // create axis panel=0A=
    var axis =3D document.createElement('div');=0A=
    axis.className =3D 'vis-axis';=0A=
    this.dom.axis =3D axis;=0A=
=0A=
    // create labelset=0A=
    var labelSet =3D document.createElement('div');=0A=
    labelSet.className =3D 'vis-labelset';=0A=
    this.dom.labelSet =3D labelSet;=0A=
=0A=
    // create ungrouped Group=0A=
    this._updateUngrouped();=0A=
=0A=
    // create background Group=0A=
    var backgroundGroup =3D new BackgroundGroup(BACKGROUND, null, this);=0A=
    backgroundGroup.show();=0A=
    this.groups[BACKGROUND] =3D backgroundGroup;=0A=
=0A=
    // attach event listeners=0A=
    // Note: we bind to the centerContainer for the case where the height=0A=
    //       of the center container is larger than of the ItemSet, so we=0A=
    //       can click in the empty area to create a new item or =
deselect an item.=0A=
    this.hammer =3D new Hammer(this.body.dom.centerContainer);=0A=
=0A=
    // drag items when selected=0A=
    this.hammer.on('hammer.input', (function (event) {=0A=
      if (event.isFirst) {=0A=
        this._onTouch(event);=0A=
      }=0A=
    }).bind(this));=0A=
    this.hammer.on('panstart', this._onDragStart.bind(this));=0A=
    this.hammer.on('panmove', this._onDrag.bind(this));=0A=
    this.hammer.on('panend', this._onDragEnd.bind(this));=0A=
    this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 =
is ALL_DIRECTIONS in hammer.=0A=
=0A=
    // single select (or unselect) when tapping an item=0A=
    this.hammer.on('tap', this._onSelectItem.bind(this));=0A=
=0A=
    // multi select when holding mouse/touch, or on ctrl+click=0A=
    this.hammer.on('press', this._onMultiSelectItem.bind(this));=0A=
=0A=
    // add item on doubletap=0A=
    this.hammer.on('doubletap', this._onAddItem.bind(this));=0A=
=0A=
    // attach to the DOM=0A=
    this.show();=0A=
  };=0A=
=0A=
  /**=0A=
   * Set options for the ItemSet. Existing options will be =
extended/overwritten.=0A=
   * @param {Object} [options] The following options are available:=0A=
   *                           {String} type=0A=
   *                              Default type for the items. Choose =
from 'box'=0A=
   *                              (default), 'point', 'range', or =
'background'.=0A=
   *                              The default style can be overwritten by=0A=
   *                              individual items.=0A=
   *                           {String} align=0A=
   *                              Alignment for the items, only =
applicable for=0A=
   *                              BoxItem. Choose 'center' (default), =
'left', or=0A=
   *                              'right'.=0A=
   *                           {String} orientation.item=0A=
   *                              Orientation of the item set. Choose =
'top' or=0A=
   *                              'bottom' (default).=0A=
   *                           {Function} groupOrder=0A=
   *                              A sorting function for ordering groups=0A=
   *                           {Boolean} stack=0A=
   *                              If true (default), items will be =
stacked on=0A=
   *                              top of each other.=0A=
   *                           {Number} margin.axis=0A=
   *                              Margin between the axis and the items =
in pixels.=0A=
   *                              Default is 20.=0A=
   *                           {Number} margin.item.horizontal=0A=
   *                              Horizontal margin between items in =
pixels.=0A=
   *                              Default is 10.=0A=
   *                           {Number} margin.item.vertical=0A=
   *                              Vertical Margin between items in =
pixels.=0A=
   *                              Default is 10.=0A=
   *                           {Number} margin.item=0A=
   *                              Margin between items in pixels in both =
horizontal=0A=
   *                              and vertical direction. Default is 10.=0A=
   *                           {Number} margin=0A=
   *                              Set margin for both axis and items in =
pixels.=0A=
   *                           {Boolean} selectable=0A=
   *                              If true (default), items can be =
selected.=0A=
   *                           {Boolean} multiselect=0A=
   *                              If true, multiple items can be =
selected.=0A=
   *                              False by default.=0A=
   *                           {Boolean} editable=0A=
   *                              Set all editable options to true or =
false=0A=
   *                           {Boolean} editable.updateTime=0A=
   *                              Allow dragging an item to an other =
moment in time=0A=
   *                           {Boolean} editable.updateGroup=0A=
   *                              Allow dragging an item to an other =
group=0A=
   *                           {Boolean} editable.add=0A=
   *                              Allow creating new items on double tap=0A=
   *                           {Boolean} editable.remove=0A=
   *                              Allow removing items by clicking the =
delete button=0A=
   *                              top right of a selected item.=0A=
   *                           {Function(item: Item, callback: =
Function)} onAdd=0A=
   *                              Callback function triggered when an =
item is about to be added:=0A=
   *                              when the user double taps an empty =
space in the Timeline.=0A=
   *                           {Function(item: Item, callback: =
Function)} onUpdate=0A=
   *                              Callback function fired when an item =
is about to be updated.=0A=
   *                              This function typically has to show a =
dialog where the user=0A=
   *                              change the item. If not implemented, =
nothing happens.=0A=
   *                           {Function(item: Item, callback: =
Function)} onMove=0A=
   *                              Fired when an item has been moved. If =
not implemented,=0A=
   *                              the move action will be accepted.=0A=
   *                           {Function(item: Item, callback: =
Function)} onRemove=0A=
   *                              Fired when an item is about to be =
deleted.=0A=
   *                              If not implemented, the item will be =
always removed.=0A=
   */=0A=
  ItemSet.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      // copy all options that we know=0A=
      var fields =3D ['type', 'align', 'order', 'stack', 'selectable', =
'multiselect', 'groupOrder', 'dataAttributes', 'template', =
'groupTemplate', 'hide', 'snap'];=0A=
      util.selectiveExtend(fields, this.options, options);=0A=
=0A=
      if ('orientation' in options) {=0A=
        if (typeof options.orientation =3D=3D=3D 'string') {=0A=
          this.options.orientation.item =3D options.orientation =
=3D=3D=3D 'top' ? 'top' : 'bottom';=0A=
        } else if (typeof options.orientation =3D=3D=3D 'object' && =
'item' in options.orientation) {=0A=
          this.options.orientation.item =3D options.orientation.item;=0A=
        }=0A=
      }=0A=
=0A=
      if ('margin' in options) {=0A=
        if (typeof options.margin =3D=3D=3D 'number') {=0A=
          this.options.margin.axis =3D options.margin;=0A=
          this.options.margin.item.horizontal =3D options.margin;=0A=
          this.options.margin.item.vertical =3D options.margin;=0A=
        } else if (typeof options.margin =3D=3D=3D 'object') {=0A=
          util.selectiveExtend(['axis'], this.options.margin, =
options.margin);=0A=
          if ('item' in options.margin) {=0A=
            if (typeof options.margin.item =3D=3D=3D 'number') {=0A=
              this.options.margin.item.horizontal =3D =
options.margin.item;=0A=
              this.options.margin.item.vertical =3D options.margin.item;=0A=
            } else if (typeof options.margin.item =3D=3D=3D 'object') {=0A=
              util.selectiveExtend(['horizontal', 'vertical'], =
this.options.margin.item, options.margin.item);=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if ('editable' in options) {=0A=
        if (typeof options.editable =3D=3D=3D 'boolean') {=0A=
          this.options.editable.updateTime =3D options.editable;=0A=
          this.options.editable.updateGroup =3D options.editable;=0A=
          this.options.editable.add =3D options.editable;=0A=
          this.options.editable.remove =3D options.editable;=0A=
        } else if (typeof options.editable =3D=3D=3D 'object') {=0A=
          util.selectiveExtend(['updateTime', 'updateGroup', 'add', =
'remove'], this.options.editable, options.editable);=0A=
        }=0A=
      }=0A=
=0A=
      // callback functions=0A=
      var addCallback =3D (function (name) {=0A=
        var fn =3D options[name];=0A=
        if (fn) {=0A=
          if (!(fn instanceof Function)) {=0A=
            throw new Error('option ' + name + ' must be a function ' + =
name + '(item, callback)');=0A=
          }=0A=
          this.options[name] =3D fn;=0A=
        }=0A=
      }).bind(this);=0A=
      ['onAdd', 'onUpdate', 'onRemove', 'onMove', =
'onMoving'].forEach(addCallback);=0A=
=0A=
      // force the itemSet to refresh: options like orientation and =
margins may be changed=0A=
      this.markDirty();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Mark the ItemSet dirty so it will refresh everything with next =
redraw.=0A=
   * Optionally, all items can be marked as dirty and be refreshed.=0A=
   * @param {{refreshItems: boolean}} [options]=0A=
   */=0A=
  ItemSet.prototype.markDirty =3D function (options) {=0A=
    this.groupIds =3D [];=0A=
    this.stackDirty =3D true;=0A=
=0A=
    if (options && options.refreshItems) {=0A=
      util.forEach(this.items, function (item) {=0A=
        item.dirty =3D true;=0A=
        if (item.displayed) item.redraw();=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Destroy the ItemSet=0A=
   */=0A=
  ItemSet.prototype.destroy =3D function () {=0A=
    this.hide();=0A=
    this.setItems(null);=0A=
    this.setGroups(null);=0A=
=0A=
    this.hammer =3D null;=0A=
=0A=
    this.body =3D null;=0A=
    this.conversion =3D null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the component from the DOM=0A=
   */=0A=
  ItemSet.prototype.hide =3D function () {=0A=
    // remove the frame containing the items=0A=
    if (this.dom.frame.parentNode) {=0A=
      this.dom.frame.parentNode.removeChild(this.dom.frame);=0A=
    }=0A=
=0A=
    // remove the axis with dots=0A=
    if (this.dom.axis.parentNode) {=0A=
      this.dom.axis.parentNode.removeChild(this.dom.axis);=0A=
    }=0A=
=0A=
    // remove the labelset containing all group labels=0A=
    if (this.dom.labelSet.parentNode) {=0A=
      this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the component in the DOM (when not already visible).=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  ItemSet.prototype.show =3D function () {=0A=
    // show frame containing the items=0A=
    if (!this.dom.frame.parentNode) {=0A=
      this.body.dom.center.appendChild(this.dom.frame);=0A=
    }=0A=
=0A=
    // show axis with dots=0A=
    if (!this.dom.axis.parentNode) {=0A=
      this.body.dom.backgroundVertical.appendChild(this.dom.axis);=0A=
    }=0A=
=0A=
    // show labelset containing labels=0A=
    if (!this.dom.labelSet.parentNode) {=0A=
      this.body.dom.left.appendChild(this.dom.labelSet);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set selected items by their id. Replaces the current selection=0A=
   * Unknown id's are silently ignored.=0A=
   * @param {string[] | string} [ids] An array with zero or more id's of =
the items to be=0A=
   *                                  selected, or a single item id. If =
ids is undefined=0A=
   *                                  or an empty array, all items will =
be unselected.=0A=
   */=0A=
  ItemSet.prototype.setSelection =3D function (ids) {=0A=
    var i, ii, id, item;=0A=
=0A=
    if (ids =3D=3D undefined) ids =3D [];=0A=
    if (!Array.isArray(ids)) ids =3D [ids];=0A=
=0A=
    // unselect currently selected items=0A=
    for (i =3D 0, ii =3D this.selection.length; i < ii; i++) {=0A=
      id =3D this.selection[i];=0A=
      item =3D this.items[id];=0A=
      if (item) item.unselect();=0A=
    }=0A=
=0A=
    // select items=0A=
    this.selection =3D [];=0A=
    for (i =3D 0, ii =3D ids.length; i < ii; i++) {=0A=
      id =3D ids[i];=0A=
      item =3D this.items[id];=0A=
      if (item) {=0A=
        this.selection.push(id);=0A=
        item.select();=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the selected items by their id=0A=
   * @return {Array} ids  The ids of the selected items=0A=
   */=0A=
  ItemSet.prototype.getSelection =3D function () {=0A=
    return this.selection.concat([]);=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the id's of the currently visible items.=0A=
   * @returns {Array} The ids of the visible items=0A=
   */=0A=
  ItemSet.prototype.getVisibleItems =3D function () {=0A=
    var range =3D this.body.range.getRange();=0A=
    var left =3D this.body.util.toScreen(range.start);=0A=
    var right =3D this.body.util.toScreen(range.end);=0A=
=0A=
    var ids =3D [];=0A=
    for (var groupId in this.groups) {=0A=
      if (this.groups.hasOwnProperty(groupId)) {=0A=
        var group =3D this.groups[groupId];=0A=
        var rawVisibleItems =3D group.visibleItems;=0A=
=0A=
        // filter the "raw" set with visibleItems into a set which is =
really=0A=
        // visible by pixels=0A=
        for (var i =3D 0; i < rawVisibleItems.length; i++) {=0A=
          var item =3D rawVisibleItems[i];=0A=
          // TODO: also check whether visible vertically=0A=
          if (item.left < right && item.left + item.width > left) {=0A=
            ids.push(item.id);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return ids;=0A=
  };=0A=
=0A=
  /**=0A=
   * Deselect a selected item=0A=
   * @param {String | Number} id=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._deselect =3D function (id) {=0A=
    var selection =3D this.selection;=0A=
    for (var i =3D 0, ii =3D selection.length; i < ii; i++) {=0A=
      if (selection[i] =3D=3D id) {=0A=
        // non-strict comparison!=0A=
        selection.splice(i, 1);=0A=
        break;=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the component=0A=
   * @return {boolean} Returns true if the component is resized=0A=
   */=0A=
  ItemSet.prototype.redraw =3D function () {=0A=
    var margin =3D this.options.margin,=0A=
        range =3D this.body.range,=0A=
        asSize =3D util.option.asSize,=0A=
        options =3D this.options,=0A=
        orientation =3D options.orientation.item,=0A=
        resized =3D false,=0A=
        frame =3D this.dom.frame;=0A=
=0A=
    // recalculate absolute position (before redrawing groups)=0A=
    this.props.top =3D this.body.domProps.top.height + =
this.body.domProps.border.top;=0A=
    this.props.left =3D this.body.domProps.left.width + =
this.body.domProps.border.left;=0A=
=0A=
    // update class name=0A=
    frame.className =3D 'vis-itemset';=0A=
=0A=
    // reorder the groups (if needed)=0A=
    resized =3D this._orderGroups() || resized;=0A=
=0A=
    // check whether zoomed (in that case we need to re-stack everything)=0A=
    // TODO: would be nicer to get this as a trigger from Range=0A=
    var visibleInterval =3D range.end - range.start;=0A=
    var zoomed =3D visibleInterval !=3D this.lastVisibleInterval || =
this.props.width !=3D this.props.lastWidth;=0A=
    if (zoomed) this.stackDirty =3D true;=0A=
    this.lastVisibleInterval =3D visibleInterval;=0A=
    this.props.lastWidth =3D this.props.width;=0A=
=0A=
    var restack =3D this.stackDirty;=0A=
    var firstGroup =3D this._firstGroup();=0A=
    var firstMargin =3D {=0A=
      item: margin.item,=0A=
      axis: margin.axis=0A=
    };=0A=
    var nonFirstMargin =3D {=0A=
      item: margin.item,=0A=
      axis: margin.item.vertical / 2=0A=
    };=0A=
    var height =3D 0;=0A=
    var minHeight =3D margin.axis + margin.item.vertical;=0A=
=0A=
    // redraw the background group=0A=
    this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);=0A=
=0A=
    // redraw all regular groups=0A=
    util.forEach(this.groups, function (group) {=0A=
      var groupMargin =3D group =3D=3D firstGroup ? firstMargin : =
nonFirstMargin;=0A=
      var groupResized =3D group.redraw(range, groupMargin, restack);=0A=
      resized =3D groupResized || resized;=0A=
      height +=3D group.height;=0A=
    });=0A=
    height =3D Math.max(height, minHeight);=0A=
    this.stackDirty =3D false;=0A=
=0A=
    // update frame height=0A=
    frame.style.height =3D asSize(height);=0A=
=0A=
    // calculate actual size=0A=
    this.props.width =3D frame.offsetWidth;=0A=
    this.props.height =3D height;=0A=
=0A=
    // reposition axis=0A=
    this.dom.axis.style.top =3D asSize(orientation =3D=3D 'top' ? =
this.body.domProps.top.height + this.body.domProps.border.top : =
this.body.domProps.top.height + =
this.body.domProps.centerContainer.height);=0A=
    this.dom.axis.style.left =3D '0';=0A=
=0A=
    // check if this component is resized=0A=
    resized =3D this._isResized() || resized;=0A=
=0A=
    return resized;=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the first group, aligned with the axis=0A=
   * @return {Group | null} firstGroup=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._firstGroup =3D function () {=0A=
    var firstGroupIndex =3D this.options.orientation.item =3D=3D 'top' ? =
0 : this.groupIds.length - 1;=0A=
    var firstGroupId =3D this.groupIds[firstGroupIndex];=0A=
    var firstGroup =3D this.groups[firstGroupId] || =
this.groups[UNGROUPED];=0A=
=0A=
    return firstGroup || null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Create or delete the group holding all ungrouped items. This group =
is used when=0A=
   * there are no groups specified.=0A=
   * @protected=0A=
   */=0A=
  ItemSet.prototype._updateUngrouped =3D function () {=0A=
    var ungrouped =3D this.groups[UNGROUPED];=0A=
    var background =3D this.groups[BACKGROUND];=0A=
    var item, itemId;=0A=
=0A=
    if (this.groupsData) {=0A=
      // remove the group holding all ungrouped items=0A=
      if (ungrouped) {=0A=
        ungrouped.hide();=0A=
        delete this.groups[UNGROUPED];=0A=
=0A=
        for (itemId in this.items) {=0A=
          if (this.items.hasOwnProperty(itemId)) {=0A=
            item =3D this.items[itemId];=0A=
            item.parent && item.parent.remove(item);=0A=
            var groupId =3D this._getGroupId(item.data);=0A=
            var group =3D this.groups[groupId];=0A=
            group && group.add(item) || item.hide();=0A=
          }=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // create a group holding all (unfiltered) items=0A=
      if (!ungrouped) {=0A=
        var id =3D null;=0A=
        var data =3D null;=0A=
        ungrouped =3D new Group(id, data, this);=0A=
        this.groups[UNGROUPED] =3D ungrouped;=0A=
=0A=
        for (itemId in this.items) {=0A=
          if (this.items.hasOwnProperty(itemId)) {=0A=
            item =3D this.items[itemId];=0A=
            ungrouped.add(item);=0A=
          }=0A=
        }=0A=
=0A=
        ungrouped.show();=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the element for the labelset=0A=
   * @return {HTMLElement} labelSet=0A=
   */=0A=
  ItemSet.prototype.getLabelSet =3D function () {=0A=
    return this.dom.labelSet;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set items=0A=
   * @param {vis.DataSet | null} items=0A=
   */=0A=
  ItemSet.prototype.setItems =3D function (items) {=0A=
    var me =3D this,=0A=
        ids,=0A=
        oldItemsData =3D this.itemsData;=0A=
=0A=
    // replace the dataset=0A=
    if (!items) {=0A=
      this.itemsData =3D null;=0A=
    } else if (items instanceof DataSet || items instanceof DataView) {=0A=
      this.itemsData =3D items;=0A=
    } else {=0A=
      throw new TypeError('Data must be an instance of DataSet or =
DataView');=0A=
    }=0A=
=0A=
    if (oldItemsData) {=0A=
      // unsubscribe from old dataset=0A=
      util.forEach(this.itemListeners, function (callback, event) {=0A=
        oldItemsData.off(event, callback);=0A=
      });=0A=
=0A=
      // remove all drawn items=0A=
      ids =3D oldItemsData.getIds();=0A=
      this._onRemove(ids);=0A=
    }=0A=
=0A=
    if (this.itemsData) {=0A=
      // subscribe to new dataset=0A=
      var id =3D this.id;=0A=
      util.forEach(this.itemListeners, function (callback, event) {=0A=
        me.itemsData.on(event, callback, id);=0A=
      });=0A=
=0A=
      // add all new items=0A=
      ids =3D this.itemsData.getIds();=0A=
      this._onAdd(ids);=0A=
=0A=
      // update the group holding all ungrouped items=0A=
      this._updateUngrouped();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the current items=0A=
   * @returns {vis.DataSet | null}=0A=
   */=0A=
  ItemSet.prototype.getItems =3D function () {=0A=
    return this.itemsData;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set groups=0A=
   * @param {vis.DataSet} groups=0A=
   */=0A=
  ItemSet.prototype.setGroups =3D function (groups) {=0A=
    var me =3D this,=0A=
        ids;=0A=
=0A=
    // unsubscribe from current dataset=0A=
    if (this.groupsData) {=0A=
      util.forEach(this.groupListeners, function (callback, event) {=0A=
        me.groupsData.off(event, callback);=0A=
      });=0A=
=0A=
      // remove all drawn groups=0A=
      ids =3D this.groupsData.getIds();=0A=
      this.groupsData =3D null;=0A=
      this._onRemoveGroups(ids); // note: this will cause a redraw=0A=
    }=0A=
=0A=
    // replace the dataset=0A=
    if (!groups) {=0A=
      this.groupsData =3D null;=0A=
    } else if (groups instanceof DataSet || groups instanceof DataView) {=0A=
      this.groupsData =3D groups;=0A=
    } else {=0A=
      throw new TypeError('Data must be an instance of DataSet or =
DataView');=0A=
    }=0A=
=0A=
    if (this.groupsData) {=0A=
      // subscribe to new dataset=0A=
      var id =3D this.id;=0A=
      util.forEach(this.groupListeners, function (callback, event) {=0A=
        me.groupsData.on(event, callback, id);=0A=
      });=0A=
=0A=
      // draw all ms=0A=
      ids =3D this.groupsData.getIds();=0A=
      this._onAddGroups(ids);=0A=
    }=0A=
=0A=
    // update the group holding all ungrouped items=0A=
    this._updateUngrouped();=0A=
=0A=
    // update the order of all items in each group=0A=
    this._order();=0A=
=0A=
    this.body.emitter.emit('change', { queue: true });=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the current groups=0A=
   * @returns {vis.DataSet | null} groups=0A=
   */=0A=
  ItemSet.prototype.getGroups =3D function () {=0A=
    return this.groupsData;=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove an item by its id=0A=
   * @param {String | Number} id=0A=
   */=0A=
  ItemSet.prototype.removeItem =3D function (id) {=0A=
    var item =3D this.itemsData.get(id),=0A=
        dataset =3D this.itemsData.getDataSet();=0A=
=0A=
    if (item) {=0A=
      // confirm deletion=0A=
      this.options.onRemove(item, function (item) {=0A=
        if (item) {=0A=
          // remove by id here, it is possible that an item has no id =
defined=0A=
          // itself, so better not delete by the item itself=0A=
          dataset.remove(id);=0A=
        }=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the time of an item based on it's data and options.type=0A=
   * @param {Object} itemData=0A=
   * @returns {string} Returns the type=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._getType =3D function (itemData) {=0A=
    return itemData.type || this.options.type || (itemData.end ? 'range' =
: 'box');=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the group id for an item=0A=
   * @param {Object} itemData=0A=
   * @returns {string} Returns the groupId=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._getGroupId =3D function (itemData) {=0A=
    var type =3D this._getType(itemData);=0A=
    if (type =3D=3D 'background' && itemData.group =3D=3D undefined) {=0A=
      return BACKGROUND;=0A=
    } else {=0A=
      return this.groupsData ? itemData.group : UNGROUPED;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle updated items=0A=
   * @param {Number[]} ids=0A=
   * @protected=0A=
   */=0A=
  ItemSet.prototype._onUpdate =3D function (ids) {=0A=
    var me =3D this;=0A=
=0A=
    ids.forEach((function (id) {=0A=
      var itemData =3D me.itemsData.get(id, me.itemOptions);=0A=
      var item =3D me.items[id];=0A=
      var type =3D me._getType(itemData);=0A=
=0A=
      var constructor =3D ItemSet.types[type];=0A=
      var selected;=0A=
=0A=
      if (item) {=0A=
        // update item=0A=
        if (!constructor || !(item instanceof constructor)) {=0A=
          // item type has changed, delete the item and recreate it=0A=
          selected =3D item.selected; // preserve selection of this item=0A=
          me._removeItem(item);=0A=
          item =3D null;=0A=
        } else {=0A=
          me._updateItem(item, itemData);=0A=
        }=0A=
      }=0A=
=0A=
      if (!item) {=0A=
        // create item=0A=
        if (constructor) {=0A=
          item =3D new constructor(itemData, me.conversion, me.options);=0A=
          item.id =3D id; // TODO: not so nice setting id afterwards=0A=
          me._addItem(item);=0A=
          if (selected) {=0A=
            this.selection.push(id);=0A=
            item.select();=0A=
          }=0A=
        } else if (type =3D=3D 'rangeoverflow') {=0A=
          // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup =
some day=0A=
          throw new TypeError('Item type "rangeoverflow" is deprecated. =
Use css styling instead: ' + '.vis-item.vis-range .vis-item-content =
{overflow: visible;}');=0A=
        } else {=0A=
          throw new TypeError('Unknown item type "' + type + '"');=0A=
        }=0A=
      }=0A=
    }).bind(this));=0A=
=0A=
    this._order();=0A=
    this.stackDirty =3D true; // force re-stacking of all items next =
redraw=0A=
    this.body.emitter.emit('change', { queue: true });=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle added items=0A=
   * @param {Number[]} ids=0A=
   * @protected=0A=
   */=0A=
  ItemSet.prototype._onAdd =3D ItemSet.prototype._onUpdate;=0A=
=0A=
  /**=0A=
   * Handle removed items=0A=
   * @param {Number[]} ids=0A=
   * @protected=0A=
   */=0A=
  ItemSet.prototype._onRemove =3D function (ids) {=0A=
    var count =3D 0;=0A=
    var me =3D this;=0A=
    ids.forEach(function (id) {=0A=
      var item =3D me.items[id];=0A=
      if (item) {=0A=
        count++;=0A=
        me._removeItem(item);=0A=
      }=0A=
    });=0A=
=0A=
    if (count) {=0A=
      // update order=0A=
      this._order();=0A=
      this.stackDirty =3D true; // force re-stacking of all items next =
redraw=0A=
      this.body.emitter.emit('change', { queue: true });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Update the order of item in all groups=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._order =3D function () {=0A=
    // reorder the items in all groups=0A=
    // TODO: optimization: only reorder groups affected by the changed =
items=0A=
    util.forEach(this.groups, function (group) {=0A=
      group.order();=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle updated groups=0A=
   * @param {Number[]} ids=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onUpdateGroups =3D function (ids) {=0A=
    this._onAddGroups(ids);=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle changed groups (added or updated)=0A=
   * @param {Number[]} ids=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onAddGroups =3D function (ids) {=0A=
    var me =3D this;=0A=
=0A=
    ids.forEach(function (id) {=0A=
      var groupData =3D me.groupsData.get(id);=0A=
      var group =3D me.groups[id];=0A=
=0A=
      if (!group) {=0A=
        // check for reserved ids=0A=
        if (id =3D=3D UNGROUPED || id =3D=3D BACKGROUND) {=0A=
          throw new Error('Illegal group id. ' + id + ' is a reserved =
id.');=0A=
        }=0A=
=0A=
        var groupOptions =3D Object.create(me.options);=0A=
        util.extend(groupOptions, {=0A=
          height: null=0A=
        });=0A=
=0A=
        group =3D new Group(id, groupData, me);=0A=
        me.groups[id] =3D group;=0A=
=0A=
        // add items with this groupId to the new group=0A=
        for (var itemId in me.items) {=0A=
          if (me.items.hasOwnProperty(itemId)) {=0A=
            var item =3D me.items[itemId];=0A=
            if (item.data.group =3D=3D id) {=0A=
              group.add(item);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        group.order();=0A=
        group.show();=0A=
      } else {=0A=
        // update group=0A=
        group.setData(groupData);=0A=
      }=0A=
    });=0A=
=0A=
    this.body.emitter.emit('change', { queue: true });=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle removed groups=0A=
   * @param {Number[]} ids=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onRemoveGroups =3D function (ids) {=0A=
    var groups =3D this.groups;=0A=
    ids.forEach(function (id) {=0A=
      var group =3D groups[id];=0A=
=0A=
      if (group) {=0A=
        group.hide();=0A=
        delete groups[id];=0A=
      }=0A=
    });=0A=
=0A=
    this.markDirty();=0A=
=0A=
    this.body.emitter.emit('change', { queue: true });=0A=
  };=0A=
=0A=
  /**=0A=
   * Reorder the groups if needed=0A=
   * @return {boolean} changed=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._orderGroups =3D function () {=0A=
    if (this.groupsData) {=0A=
      // reorder the groups=0A=
      var groupIds =3D this.groupsData.getIds({=0A=
        order: this.options.groupOrder=0A=
      });=0A=
=0A=
      var changed =3D !util.equalArray(groupIds, this.groupIds);=0A=
      if (changed) {=0A=
        // hide all groups, removes them from the DOM=0A=
        var groups =3D this.groups;=0A=
        groupIds.forEach(function (groupId) {=0A=
          groups[groupId].hide();=0A=
        });=0A=
=0A=
        // show the groups again, attach them to the DOM in correct order=0A=
        groupIds.forEach(function (groupId) {=0A=
          groups[groupId].show();=0A=
        });=0A=
=0A=
        this.groupIds =3D groupIds;=0A=
      }=0A=
=0A=
      return changed;=0A=
    } else {=0A=
      return false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Add a new item=0A=
   * @param {Item} item=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._addItem =3D function (item) {=0A=
    this.items[item.id] =3D item;=0A=
=0A=
    // add to group=0A=
    var groupId =3D this._getGroupId(item.data);=0A=
    var group =3D this.groups[groupId];=0A=
    if (group) group.add(item);=0A=
  };=0A=
=0A=
  /**=0A=
   * Update an existing item=0A=
   * @param {Item} item=0A=
   * @param {Object} itemData=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._updateItem =3D function (item, itemData) {=0A=
    var oldGroupId =3D item.data.group;=0A=
    var oldSubGroupId =3D item.data.subgroup;=0A=
=0A=
    // update the items data (will redraw the item when displayed)=0A=
    item.setData(itemData);=0A=
=0A=
    // update group=0A=
    if (oldGroupId !=3D item.data.group || oldSubGroupId !=3D =
item.data.subgroup) {=0A=
      var oldGroup =3D this.groups[oldGroupId];=0A=
      if (oldGroup) oldGroup.remove(item);=0A=
=0A=
      var groupId =3D this._getGroupId(item.data);=0A=
      var group =3D this.groups[groupId];=0A=
      if (group) group.add(item);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Delete an item from the ItemSet: remove it from the DOM, from the =
map=0A=
   * with items, and from the map with visible items, and from the =
selection=0A=
   * @param {Item} item=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._removeItem =3D function (item) {=0A=
    // remove from DOM=0A=
    item.hide();=0A=
=0A=
    // remove from items=0A=
    delete this.items[item.id];=0A=
=0A=
    // remove from selection=0A=
    var index =3D this.selection.indexOf(item.id);=0A=
    if (index !=3D -1) this.selection.splice(index, 1);=0A=
=0A=
    // remove from group=0A=
    item.parent && item.parent.remove(item);=0A=
  };=0A=
=0A=
  /**=0A=
   * Create an array containing all items being a range (having an end =
date)=0A=
   * @param array=0A=
   * @returns {Array}=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._constructByEndArray =3D function (array) {=0A=
    var endArray =3D [];=0A=
=0A=
    for (var i =3D 0; i < array.length; i++) {=0A=
      if (array[i] instanceof RangeItem) {=0A=
        endArray.push(array[i]);=0A=
      }=0A=
    }=0A=
    return endArray;=0A=
  };=0A=
=0A=
  /**=0A=
   * Register the clicked item on touch, before dragStart is initiated.=0A=
   *=0A=
   * dragStart is initiated from a mousemove event, AFTER the =
mouse/touch is=0A=
   * already moving. Therefore, the mouse/touch can sometimes be above =
an other=0A=
   * DOM element than the item itself.=0A=
   *=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onTouch =3D function (event) {=0A=
    // store the touched item, used in _onDragStart=0A=
    this.touchParams.item =3D this.itemFromTarget(event);=0A=
    this.touchParams.dragLeftItem =3D event.target.dragLeftItem || false;=0A=
    this.touchParams.dragRightItem =3D event.target.dragRightItem || =
false;=0A=
    this.touchParams.itemProps =3D null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Given an group id, returns the index it has.=0A=
   *=0A=
   * @param {Number} groupID=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._getGroupIndex =3D function (groupId) {=0A=
    for (var i =3D 0; i < this.groupIds.length; i++) {=0A=
      if (groupId =3D=3D this.groupIds[i]) return i;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Start dragging the selected events=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onDragStart =3D function (event) {=0A=
    var item =3D this.touchParams.item || null;=0A=
    var me =3D this;=0A=
    var props;=0A=
=0A=
    if (item && item.selected) {=0A=
=0A=
      if (!this.options.editable.updateTime && =
!this.options.editable.updateGroup && !item.editable) {=0A=
        return;=0A=
      }=0A=
=0A=
      // override options.editable=0A=
      if (item.editable =3D=3D=3D false) {=0A=
        return;=0A=
      }=0A=
=0A=
      var dragLeftItem =3D this.touchParams.dragLeftItem;=0A=
      var dragRightItem =3D this.touchParams.dragRightItem;=0A=
=0A=
      if (dragLeftItem) {=0A=
        props =3D {=0A=
          item: dragLeftItem,=0A=
          initialX: event.center.x,=0A=
          dragLeft: true,=0A=
          data: util.extend({}, item.data) // clone the items data=0A=
        };=0A=
=0A=
        this.touchParams.itemProps =3D [props];=0A=
      } else if (dragRightItem) {=0A=
        props =3D {=0A=
          item: dragRightItem,=0A=
          initialX: event.center.x,=0A=
          dragRight: true,=0A=
          data: util.extend({}, item.data) // clone the items data=0A=
        };=0A=
=0A=
        this.touchParams.itemProps =3D [props];=0A=
      } else {=0A=
        this.touchParams.selectedItem =3D item;=0A=
=0A=
        var baseGroupIndex =3D this._getGroupIndex(item.data.group);=0A=
=0A=
        this.touchParams.itemProps =3D this.getSelection().map(function =
(id) {=0A=
          var item =3D me.items[id];=0A=
          var groupIndex =3D me._getGroupIndex(item.data.group);=0A=
          var props =3D {=0A=
            item: item,=0A=
            initialX: event.center.x,=0A=
            groupOffset: baseGroupIndex - groupIndex,=0A=
            data: util.extend({}, item.data) // clone the items data=0A=
          };=0A=
=0A=
          return props;=0A=
        });=0A=
      }=0A=
=0A=
      event.stopPropagation();=0A=
    } else if (this.options.editable.add && (event.srcEvent.ctrlKey || =
event.srcEvent.metaKey)) {=0A=
      // create a new range item when dragging with ctrl key down=0A=
      this._onDragStartAddItem(event);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Start creating a new range item by dragging.=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onDragStartAddItem =3D function (event) {=0A=
    var snap =3D this.options.snap || null;=0A=
    var xAbs =3D util.getAbsoluteLeft(this.dom.frame);=0A=
    var x =3D event.center.x - xAbs - 10; // minus 10 to compensate for =
the drag starting as soon as you've moved 10px=0A=
    var time =3D this.body.util.toTime(x);=0A=
    var scale =3D this.body.util.getScale();=0A=
    var step =3D this.body.util.getStep();=0A=
    var start =3D snap ? snap(time, scale, step) : start;=0A=
    var end =3D start;=0A=
=0A=
    var itemData =3D {=0A=
      type: 'range',=0A=
      start: start,=0A=
      end: end,=0A=
      content: 'new item'=0A=
    };=0A=
=0A=
    var id =3D util.randomUUID();=0A=
    itemData[this.itemsData._fieldId] =3D id;=0A=
=0A=
    var group =3D this.groupFromTarget(event);=0A=
    if (group) {=0A=
      itemData.group =3D group.groupId;=0A=
    }=0A=
=0A=
    var newItem =3D new RangeItem(itemData, this.conversion, =
this.options);=0A=
    newItem.id =3D id; // TODO: not so nice setting id afterwards=0A=
    newItem.data =3D itemData;=0A=
    this._addItem(newItem);=0A=
=0A=
    var props =3D {=0A=
      item: newItem,=0A=
      dragRight: true,=0A=
      initialX: event.center.x,=0A=
      data: util.extend({}, itemData)=0A=
    };=0A=
    this.touchParams.itemProps =3D [props];=0A=
=0A=
    event.stopPropagation();=0A=
  };=0A=
=0A=
  /**=0A=
   * Drag selected items=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onDrag =3D function (event) {=0A=
    if (this.touchParams.itemProps) {=0A=
      event.stopPropagation();=0A=
=0A=
      var me =3D this;=0A=
      var snap =3D this.options.snap || null;=0A=
      var xOffset =3D this.body.dom.root.offsetLeft + =
this.body.domProps.left.width;=0A=
      var scale =3D this.body.util.getScale();=0A=
      var step =3D this.body.util.getStep();=0A=
=0A=
      //only calculate the new group for the item that's actually dragged=0A=
      var selectedItem =3D this.touchParams.selectedItem;=0A=
      var updateGroupAllowed =3D me.options.editable.updateGroup;=0A=
      var newGroupBase =3D null;=0A=
      if (updateGroupAllowed && selectedItem) {=0A=
        if (selectedItem.data.group !=3D undefined) {=0A=
          // drag from one group to another=0A=
          var group =3D me.groupFromTarget(event);=0A=
          if (group) {=0A=
            //we know the offset for all items, so the new group for all =
items=0A=
            //will be relative to this one.=0A=
            newGroupBase =3D this._getGroupIndex(group.groupId);=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      // move=0A=
      this.touchParams.itemProps.forEach(function (props) {=0A=
        var newProps =3D {};=0A=
        var current =3D me.body.util.toTime(event.center.x - xOffset);=0A=
        var initial =3D me.body.util.toTime(props.initialX - xOffset);=0A=
        var offset =3D current - initial;=0A=
=0A=
        var itemData =3D util.extend({}, props.item.data); // clone the =
data=0A=
=0A=
        if (props.item.editable =3D=3D=3D false) {=0A=
          return;=0A=
        }=0A=
=0A=
        var updateTimeAllowed =3D me.options.editable.updateTime || =
props.item.editable =3D=3D=3D true;=0A=
=0A=
        if (updateTimeAllowed) {=0A=
          if (props.dragLeft) {=0A=
            // drag left side of a range item=0A=
            if (itemData.start !=3D undefined) {=0A=
              var initialStart =3D util.convert(props.data.start, =
'Date');=0A=
              var start =3D new Date(initialStart.valueOf() + offset);=0A=
              itemData.start =3D snap ? snap(start, scale, step) : start;=0A=
            }=0A=
          } else if (props.dragRight) {=0A=
            // drag right side of a range item=0A=
            if (itemData.end !=3D undefined) {=0A=
              var initialEnd =3D util.convert(props.data.end, 'Date');=0A=
              var end =3D new Date(initialEnd.valueOf() + offset);=0A=
              itemData.end =3D snap ? snap(end, scale, step) : end;=0A=
            }=0A=
          } else {=0A=
            // drag both start and end=0A=
            if (itemData.start !=3D undefined) {=0A=
              var initialStart =3D util.convert(props.data.start, =
'Date').valueOf();=0A=
              var start =3D new Date(initialStart + offset);=0A=
=0A=
              if (itemData.end !=3D undefined) {=0A=
                var initialEnd =3D util.convert(props.data.end, 'Date');=0A=
                var duration =3D initialEnd.valueOf() - =
initialStart.valueOf();=0A=
=0A=
                itemData.start =3D snap ? snap(start, scale, step) : =
start;=0A=
                itemData.end =3D new Date(itemData.start.valueOf() + =
duration);=0A=
              } else {=0A=
                itemData.start =3D snap ? snap(start, scale, step) : =
start;=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        var updateGroupAllowed =3D me.options.editable.updateGroup || =
props.item.editable =3D=3D=3D true;=0A=
=0A=
        if (updateGroupAllowed && (!props.dragLeft && !props.dragRight) =
&& newGroupBase !=3D null) {=0A=
          if (itemData.group !=3D undefined) {=0A=
            var newOffset =3D newGroupBase - props.groupOffset;=0A=
=0A=
            //make sure we stay in bounds=0A=
            newOffset =3D Math.max(0, newOffset);=0A=
            newOffset =3D Math.min(me.groupIds.length - 1, newOffset);=0A=
=0A=
            itemData.group =3D me.groupIds[newOffset];=0A=
          }=0A=
        }=0A=
=0A=
        // confirm moving the item=0A=
        me.options.onMoving(itemData, function (itemData) {=0A=
          if (itemData) {=0A=
            props.item.setData(itemData);=0A=
          }=0A=
        });=0A=
      });=0A=
=0A=
      this.stackDirty =3D true; // force re-stacking of all items next =
redraw=0A=
      this.body.emitter.emit('change');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Move an item to another group=0A=
   * @param {Item} item=0A=
   * @param {String | Number} groupId=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._moveToGroup =3D function (item, groupId) {=0A=
    var group =3D this.groups[groupId];=0A=
    if (group && group.groupId !=3D item.data.group) {=0A=
      var oldGroup =3D item.parent;=0A=
      oldGroup.remove(item);=0A=
      oldGroup.order();=0A=
      group.add(item);=0A=
      group.order();=0A=
=0A=
      item.data.group =3D group.groupId;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * End of dragging selected items=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onDragEnd =3D function (event) {=0A=
    if (this.touchParams.itemProps) {=0A=
      event.stopPropagation();=0A=
=0A=
      var me =3D this;=0A=
      var dataset =3D this.itemsData.getDataSet();=0A=
      var itemProps =3D this.touchParams.itemProps;=0A=
      this.touchParams.itemProps =3D null;=0A=
=0A=
      itemProps.forEach(function (props) {=0A=
        var id =3D props.item.id;=0A=
        var exists =3D me.itemsData.get(id, me.itemOptions) !=3D null;=0A=
=0A=
        if (!exists) {=0A=
          // add a new item=0A=
          me.options.onAdd(props.item.data, function (itemData) {=0A=
            me._removeItem(props.item); // remove temporary item=0A=
            if (itemData) {=0A=
              me.itemsData.getDataSet().add(itemData);=0A=
            }=0A=
=0A=
            // force re-stacking of all items next redraw=0A=
            me.stackDirty =3D true;=0A=
            me.body.emitter.emit('change');=0A=
          });=0A=
        } else {=0A=
          // update existing item=0A=
          var itemData =3D util.extend({}, props.item.data); // clone =
the data=0A=
          me.options.onMove(itemData, function (itemData) {=0A=
            if (itemData) {=0A=
              // apply changes=0A=
              itemData[dataset._fieldId] =3D id; // ensure the item =
contains its id (can be undefined)=0A=
              dataset.update(itemData);=0A=
            } else {=0A=
              // restore original values=0A=
              props.item.setData(props.data);=0A=
=0A=
              me.stackDirty =3D true; // force re-stacking of all items =
next redraw=0A=
              me.body.emitter.emit('change');=0A=
            }=0A=
          });=0A=
        }=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle selecting/deselecting an item when tapping it=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onSelectItem =3D function (event) {=0A=
    if (!this.options.selectable) return;=0A=
=0A=
    var ctrlKey =3D event.srcEvent && (event.srcEvent.ctrlKey || =
event.srcEvent.metaKey);=0A=
    var shiftKey =3D event.srcEvent && event.srcEvent.shiftKey;=0A=
    if (ctrlKey || shiftKey) {=0A=
      this._onMultiSelectItem(event);=0A=
      return;=0A=
    }=0A=
=0A=
    var oldSelection =3D this.getSelection();=0A=
=0A=
    var item =3D this.itemFromTarget(event);=0A=
    var selection =3D item ? [item.id] : [];=0A=
    this.setSelection(selection);=0A=
=0A=
    var newSelection =3D this.getSelection();=0A=
=0A=
    // emit a select event,=0A=
    // except when old selection is empty and new selection is still =
empty=0A=
    if (newSelection.length > 0 || oldSelection.length > 0) {=0A=
      this.body.emitter.emit('select', {=0A=
        items: newSelection,=0A=
        event: event=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle creation and updates of an item on double tap=0A=
   * @param event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onAddItem =3D function (event) {=0A=
    if (!this.options.selectable) return;=0A=
    if (!this.options.editable.add) return;=0A=
=0A=
    var me =3D this;=0A=
    var snap =3D this.options.snap || null;=0A=
    var item =3D this.itemFromTarget(event);=0A=
=0A=
    event.stopPropagation();=0A=
=0A=
    if (item) {=0A=
      // update item=0A=
=0A=
      // execute async handler to update the item (or cancel it)=0A=
      var itemData =3D me.itemsData.get(item.id); // get a clone of the =
data from the dataset=0A=
      this.options.onUpdate(itemData, function (itemData) {=0A=
        if (itemData) {=0A=
          me.itemsData.getDataSet().update(itemData);=0A=
        }=0A=
      });=0A=
    } else {=0A=
      // add item=0A=
      var xAbs =3D util.getAbsoluteLeft(this.dom.frame);=0A=
      var x =3D event.center.x - xAbs;=0A=
      var start =3D this.body.util.toTime(x);=0A=
      var scale =3D this.body.util.getScale();=0A=
      var step =3D this.body.util.getStep();=0A=
=0A=
      var newItem =3D {=0A=
        start: snap ? snap(start, scale, step) : start,=0A=
        content: 'new item'=0A=
      };=0A=
=0A=
      // when default type is a range, add a default end date to the new =
item=0A=
      if (this.options.type =3D=3D=3D 'range') {=0A=
        var end =3D this.body.util.toTime(x + this.props.width / 5);=0A=
        newItem.end =3D snap ? snap(end, scale, step) : end;=0A=
      }=0A=
=0A=
      newItem[this.itemsData._fieldId] =3D util.randomUUID();=0A=
=0A=
      var group =3D this.groupFromTarget(event);=0A=
      if (group) {=0A=
        newItem.group =3D group.groupId;=0A=
      }=0A=
=0A=
      // execute async handler to customize (or cancel) adding an item=0A=
      this.options.onAdd(newItem, function (item) {=0A=
        if (item) {=0A=
          me.itemsData.getDataSet().add(item);=0A=
          // TODO: need to trigger a redraw?=0A=
        }=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle selecting/deselecting multiple items when holding an item=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  ItemSet.prototype._onMultiSelectItem =3D function (event) {=0A=
    if (!this.options.selectable) return;=0A=
=0A=
    var item =3D this.itemFromTarget(event);=0A=
=0A=
    if (item) {=0A=
      // multi select items (if allowed)=0A=
=0A=
      var selection =3D this.options.multiselect ? this.getSelection() =
// take current selection=0A=
      : []; // deselect current selection=0A=
=0A=
      var shiftKey =3D event.srcEvent && event.srcEvent.shiftKey || =
false;=0A=
=0A=
      if (shiftKey && this.options.multiselect) {=0A=
        // select all items between the old selection and the tapped item=0A=
=0A=
        // determine the selection range=0A=
        selection.push(item.id);=0A=
        var range =3D =
ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));=0A=
=0A=
        // select all items within the selection range=0A=
        selection =3D [];=0A=
        for (var id in this.items) {=0A=
          if (this.items.hasOwnProperty(id)) {=0A=
            var _item =3D this.items[id];=0A=
            var start =3D _item.data.start;=0A=
            var end =3D _item.data.end !=3D=3D undefined ? =
_item.data.end : start;=0A=
=0A=
            if (start >=3D range.min && end <=3D range.max && !(_item =
instanceof BackgroundItem)) {=0A=
              selection.push(_item.id); // do not use id but item.id, id =
itself is stringified=0A=
            }=0A=
          }=0A=
        }=0A=
      } else {=0A=
        // add/remove this item from the current selection=0A=
        var index =3D selection.indexOf(item.id);=0A=
        if (index =3D=3D -1) {=0A=
          // item is not yet selected -> select it=0A=
          selection.push(item.id);=0A=
        } else {=0A=
          // item is already selected -> deselect it=0A=
          selection.splice(index, 1);=0A=
        }=0A=
      }=0A=
=0A=
      this.setSelection(selection);=0A=
=0A=
      this.body.emitter.emit('select', {=0A=
        items: this.getSelection(),=0A=
        event: event=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Calculate the time range of a list of items=0A=
   * @param {Array.<Object>} itemsData=0A=
   * @return {{min: Date, max: Date}} Returns the range of the provided =
items=0A=
   * @private=0A=
   */=0A=
  ItemSet._getItemRange =3D function (itemsData) {=0A=
    var max =3D null;=0A=
    var min =3D null;=0A=
=0A=
    itemsData.forEach(function (data) {=0A=
      if (min =3D=3D null || data.start < min) {=0A=
        min =3D data.start;=0A=
      }=0A=
=0A=
      if (data.end !=3D undefined) {=0A=
        if (max =3D=3D null || data.end > max) {=0A=
          max =3D data.end;=0A=
        }=0A=
      } else {=0A=
        if (max =3D=3D null || data.start > max) {=0A=
          max =3D data.start;=0A=
        }=0A=
      }=0A=
    });=0A=
=0A=
    return {=0A=
      min: min,=0A=
      max: max=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Find an item from an event target:=0A=
   * searches for the attribute 'timeline-item' in the event target's =
element tree=0A=
   * @param {Event} event=0A=
   * @return {Item | null} item=0A=
   */=0A=
  ItemSet.prototype.itemFromTarget =3D function (event) {=0A=
    var target =3D event.target;=0A=
    while (target) {=0A=
      if (target.hasOwnProperty('timeline-item')) {=0A=
        return target['timeline-item'];=0A=
      }=0A=
      target =3D target.parentNode;=0A=
    }=0A=
=0A=
    return null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Find the Group from an event target:=0A=
   * searches for the attribute 'timeline-group' in the event target's =
element tree=0A=
   * @param {Event} event=0A=
   * @return {Group | null} group=0A=
   */=0A=
  ItemSet.prototype.groupFromTarget =3D function (event) {=0A=
    var clientY =3D event.center ? event.center.y : event.clientY;=0A=
    for (var i =3D 0; i < this.groupIds.length; i++) {=0A=
      var groupId =3D this.groupIds[i];=0A=
      var group =3D this.groups[groupId];=0A=
      var foreground =3D group.dom.foreground;=0A=
      var top =3D util.getAbsoluteTop(foreground);=0A=
      if (clientY > top && clientY < top + foreground.offsetHeight) {=0A=
        return group;=0A=
      }=0A=
=0A=
      if (this.options.orientation.item =3D=3D=3D 'top') {=0A=
        if (i =3D=3D=3D this.groupIds.length - 1 && clientY > top) {=0A=
          return group;=0A=
        }=0A=
      } else {=0A=
        if (i =3D=3D=3D 0 && clientY < top + foreground.offset) {=0A=
          return group;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Find the ItemSet from an event target:=0A=
   * searches for the attribute 'timeline-itemset' in the event target's =
element tree=0A=
   * @param {Event} event=0A=
   * @return {ItemSet | null} item=0A=
   */=0A=
  ItemSet.itemSetFromTarget =3D function (event) {=0A=
    var target =3D event.target;=0A=
    while (target) {=0A=
      if (target.hasOwnProperty('timeline-itemset')) {=0A=
        return target['timeline-itemset'];=0A=
      }=0A=
      target =3D target.parentNode;=0A=
    }=0A=
=0A=
    return null;=0A=
  };=0A=
=0A=
  module.exports =3D ItemSet;=0A=
=0A=
/***/ },=0A=
/* 32 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var stack =3D __webpack_require__(33);=0A=
  var RangeItem =3D __webpack_require__(34);=0A=
=0A=
  /**=0A=
   * @constructor Group=0A=
   * @param {Number | String} groupId=0A=
   * @param {Object} data=0A=
   * @param {ItemSet} itemSet=0A=
   */=0A=
  function Group(groupId, data, itemSet) {=0A=
    this.groupId =3D groupId;=0A=
    this.subgroups =3D {};=0A=
    this.subgroupIndex =3D 0;=0A=
    this.subgroupOrderer =3D data && data.subgroupOrder;=0A=
    this.itemSet =3D itemSet;=0A=
=0A=
    this.dom =3D {};=0A=
    this.props =3D {=0A=
      label: {=0A=
        width: 0,=0A=
        height: 0=0A=
      }=0A=
    };=0A=
    this.className =3D null;=0A=
=0A=
    this.items =3D {}; // items filtered by groupId of this group=0A=
    this.visibleItems =3D []; // items currently visible in window=0A=
    this.orderedItems =3D {=0A=
      byStart: [],=0A=
      byEnd: []=0A=
    };=0A=
    this.checkRangedItems =3D false; // needed to refresh the ranged =
items if the window is programatically changed with NO overlap.=0A=
    var me =3D this;=0A=
    this.itemSet.body.emitter.on('checkRangedItems', function () {=0A=
      me.checkRangedItems =3D true;=0A=
    });=0A=
=0A=
    this._create();=0A=
=0A=
    this.setData(data);=0A=
  }=0A=
=0A=
  /**=0A=
   * Create DOM elements for the group=0A=
   * @private=0A=
   */=0A=
  Group.prototype._create =3D function () {=0A=
    var label =3D document.createElement('div');=0A=
    label.className =3D 'vis-label';=0A=
    this.dom.label =3D label;=0A=
=0A=
    var inner =3D document.createElement('div');=0A=
    inner.className =3D 'vis-inner';=0A=
    label.appendChild(inner);=0A=
    this.dom.inner =3D inner;=0A=
=0A=
    var foreground =3D document.createElement('div');=0A=
    foreground.className =3D 'vis-group';=0A=
    foreground['timeline-group'] =3D this;=0A=
    this.dom.foreground =3D foreground;=0A=
=0A=
    this.dom.background =3D document.createElement('div');=0A=
    this.dom.background.className =3D 'vis-group';=0A=
=0A=
    this.dom.axis =3D document.createElement('div');=0A=
    this.dom.axis.className =3D 'vis-group';=0A=
=0A=
    // create a hidden marker to detect when the Timelines container is =
attached=0A=
    // to the DOM, or the style of a parent of the Timeline is changed =
from=0A=
    // display:none is changed to visible.=0A=
    this.dom.marker =3D document.createElement('div');=0A=
    this.dom.marker.style.visibility =3D 'hidden';=0A=
    this.dom.marker.innerHTML =3D '?';=0A=
    this.dom.background.appendChild(this.dom.marker);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the group data for this group=0A=
   * @param {Object} data   Group data, can contain properties content =
and className=0A=
   */=0A=
  Group.prototype.setData =3D function (data) {=0A=
    // update contents=0A=
    var content;=0A=
    if (this.itemSet.options && this.itemSet.options.groupTemplate) {=0A=
      content =3D this.itemSet.options.groupTemplate(data);=0A=
    } else {=0A=
      content =3D data && data.content;=0A=
    }=0A=
=0A=
    if (content instanceof Element) {=0A=
      this.dom.inner.appendChild(content);=0A=
      while (this.dom.inner.firstChild) {=0A=
        this.dom.inner.removeChild(this.dom.inner.firstChild);=0A=
      }=0A=
      this.dom.inner.appendChild(content);=0A=
    } else if (content !=3D=3D undefined && content !=3D=3D null) {=0A=
      this.dom.inner.innerHTML =3D content;=0A=
    } else {=0A=
      this.dom.inner.innerHTML =3D this.groupId || ''; // groupId can be =
null=0A=
    }=0A=
=0A=
    // update title=0A=
    this.dom.label.title =3D data && data.title || '';=0A=
=0A=
    if (!this.dom.inner.firstChild) {=0A=
      util.addClassName(this.dom.inner, 'vis-hidden');=0A=
    } else {=0A=
      util.removeClassName(this.dom.inner, 'vis-hidden');=0A=
    }=0A=
=0A=
    // update className=0A=
    var className =3D data && data.className || null;=0A=
    if (className !=3D this.className) {=0A=
      if (this.className) {=0A=
        util.removeClassName(this.dom.label, this.className);=0A=
        util.removeClassName(this.dom.foreground, this.className);=0A=
        util.removeClassName(this.dom.background, this.className);=0A=
        util.removeClassName(this.dom.axis, this.className);=0A=
      }=0A=
      util.addClassName(this.dom.label, className);=0A=
      util.addClassName(this.dom.foreground, className);=0A=
      util.addClassName(this.dom.background, className);=0A=
      util.addClassName(this.dom.axis, className);=0A=
      this.className =3D className;=0A=
    }=0A=
=0A=
    // update style=0A=
    if (this.style) {=0A=
      util.removeCssText(this.dom.label, this.style);=0A=
      this.style =3D null;=0A=
    }=0A=
    if (data && data.style) {=0A=
      util.addCssText(this.dom.label, data.style);=0A=
      this.style =3D data.style;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the width of the group label=0A=
   * @return {number} width=0A=
   */=0A=
  Group.prototype.getLabelWidth =3D function () {=0A=
    return this.props.label.width;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint this group=0A=
   * @param {{start: number, end: number}} range=0A=
   * @param {{item: {horizontal: number, vertical: number}, axis: =
number}} margin=0A=
   * @param {boolean} [restack=3Dfalse]  Force restacking of all items=0A=
   * @return {boolean} Returns true if the group is resized=0A=
   */=0A=
  Group.prototype.redraw =3D function (range, margin, restack) {=0A=
    var resized =3D false;=0A=
=0A=
    // force recalculation of the height of the items when the marker =
height changed=0A=
    // (due to the Timeline being attached to the DOM or changed from =
display:none to visible)=0A=
    var markerHeight =3D this.dom.marker.clientHeight;=0A=
    if (markerHeight !=3D this.lastMarkerHeight) {=0A=
      this.lastMarkerHeight =3D markerHeight;=0A=
=0A=
      util.forEach(this.items, function (item) {=0A=
        item.dirty =3D true;=0A=
        if (item.displayed) item.redraw();=0A=
      });=0A=
=0A=
      restack =3D true;=0A=
    }=0A=
=0A=
    // reposition visible items vertically=0A=
    if (typeof this.itemSet.options.order =3D=3D=3D 'function') {=0A=
      // a custom order function=0A=
=0A=
      if (restack) {=0A=
        // brute force restack of all items=0A=
=0A=
        // show all items=0A=
        var me =3D this;=0A=
        var limitSize =3D false;=0A=
        util.forEach(this.items, function (item) {=0A=
          if (!item.displayed) {=0A=
            item.redraw();=0A=
            me.visibleItems.push(item);=0A=
          }=0A=
          item.repositionX(limitSize);=0A=
        });=0A=
=0A=
        // order all items and force a restacking=0A=
        var customOrderedItems =3D =
this.orderedItems.byStart.slice().sort(function (a, b) {=0A=
          return me.itemSet.options.order(a.data, b.data);=0A=
        });=0A=
        stack.stack(customOrderedItems, margin, true /* restack=3Dtrue =
*/);=0A=
      }=0A=
=0A=
      this.visibleItems =3D this._updateVisibleItems(this.orderedItems, =
this.visibleItems, range);=0A=
    } else {=0A=
      // no custom order function, lazy stacking=0A=
      this.visibleItems =3D this._updateVisibleItems(this.orderedItems, =
this.visibleItems, range);=0A=
=0A=
      if (this.itemSet.options.stack) {=0A=
        // TODO: ugly way to access options...=0A=
        stack.stack(this.visibleItems, margin, restack);=0A=
      } else {=0A=
        // no stacking=0A=
        stack.nostack(this.visibleItems, margin, this.subgroups);=0A=
      }=0A=
    }=0A=
=0A=
    // recalculate the height of the group=0A=
    var height =3D this._calculateHeight(margin);=0A=
=0A=
    // calculate actual size and position=0A=
    var foreground =3D this.dom.foreground;=0A=
    this.top =3D foreground.offsetTop;=0A=
    this.left =3D foreground.offsetLeft;=0A=
    this.width =3D foreground.offsetWidth;=0A=
    resized =3D util.updateProperty(this, 'height', height) || resized;=0A=
=0A=
    // recalculate size of label=0A=
    resized =3D util.updateProperty(this.props.label, 'width', =
this.dom.inner.clientWidth) || resized;=0A=
    resized =3D util.updateProperty(this.props.label, 'height', =
this.dom.inner.clientHeight) || resized;=0A=
=0A=
    // apply new height=0A=
    this.dom.background.style.height =3D height + 'px';=0A=
    this.dom.foreground.style.height =3D height + 'px';=0A=
    this.dom.label.style.height =3D height + 'px';=0A=
=0A=
    // update vertical position of items after they are re-stacked and =
the height of the group is calculated=0A=
    for (var i =3D 0, ii =3D this.visibleItems.length; i < ii; i++) {=0A=
      var item =3D this.visibleItems[i];=0A=
      item.repositionY(margin);=0A=
    }=0A=
=0A=
    return resized;=0A=
  };=0A=
=0A=
  /**=0A=
   * recalculate the height of the group=0A=
   * @param {{item: {horizontal: number, vertical: number}, axis: =
number}} margin=0A=
   * @returns {number} Returns the height=0A=
   * @private=0A=
   */=0A=
  Group.prototype._calculateHeight =3D function (margin) {=0A=
    // recalculate the height of the group=0A=
    var height;=0A=
    var visibleItems =3D this.visibleItems;=0A=
    //var visibleSubgroups =3D [];=0A=
    //this.visibleSubgroups =3D 0;=0A=
    this.resetSubgroups();=0A=
    var me =3D this;=0A=
    if (visibleItems.length > 0) {=0A=
      var min =3D visibleItems[0].top;=0A=
      var max =3D visibleItems[0].top + visibleItems[0].height;=0A=
      util.forEach(visibleItems, function (item) {=0A=
        min =3D Math.min(min, item.top);=0A=
        max =3D Math.max(max, item.top + item.height);=0A=
        if (item.data.subgroup !=3D=3D undefined) {=0A=
          me.subgroups[item.data.subgroup].height =3D =
Math.max(me.subgroups[item.data.subgroup].height, item.height);=0A=
          me.subgroups[item.data.subgroup].visible =3D true;=0A=
        }=0A=
      });=0A=
      if (min > margin.axis) {=0A=
        // there is an empty gap between the lowest item and the axis=0A=
        var offset =3D min - margin.axis;=0A=
        max -=3D offset;=0A=
        util.forEach(visibleItems, function (item) {=0A=
          item.top -=3D offset;=0A=
        });=0A=
      }=0A=
      height =3D max + margin.item.vertical / 2;=0A=
    } else {=0A=
      height =3D 0;=0A=
    }=0A=
    height =3D Math.max(height, this.props.label.height);=0A=
=0A=
    return height;=0A=
  };=0A=
=0A=
  /**=0A=
   * Show this group: attach to the DOM=0A=
   */=0A=
  Group.prototype.show =3D function () {=0A=
    if (!this.dom.label.parentNode) {=0A=
      this.itemSet.dom.labelSet.appendChild(this.dom.label);=0A=
    }=0A=
=0A=
    if (!this.dom.foreground.parentNode) {=0A=
      this.itemSet.dom.foreground.appendChild(this.dom.foreground);=0A=
    }=0A=
=0A=
    if (!this.dom.background.parentNode) {=0A=
      this.itemSet.dom.background.appendChild(this.dom.background);=0A=
    }=0A=
=0A=
    if (!this.dom.axis.parentNode) {=0A=
      this.itemSet.dom.axis.appendChild(this.dom.axis);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide this group: remove from the DOM=0A=
   */=0A=
  Group.prototype.hide =3D function () {=0A=
    var label =3D this.dom.label;=0A=
    if (label.parentNode) {=0A=
      label.parentNode.removeChild(label);=0A=
    }=0A=
=0A=
    var foreground =3D this.dom.foreground;=0A=
    if (foreground.parentNode) {=0A=
      foreground.parentNode.removeChild(foreground);=0A=
    }=0A=
=0A=
    var background =3D this.dom.background;=0A=
    if (background.parentNode) {=0A=
      background.parentNode.removeChild(background);=0A=
    }=0A=
=0A=
    var axis =3D this.dom.axis;=0A=
    if (axis.parentNode) {=0A=
      axis.parentNode.removeChild(axis);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Add an item to the group=0A=
   * @param {Item} item=0A=
   */=0A=
  Group.prototype.add =3D function (item) {=0A=
    this.items[item.id] =3D item;=0A=
    item.setParent(this);=0A=
=0A=
    // add to=0A=
    if (item.data.subgroup !=3D=3D undefined) {=0A=
      if (this.subgroups[item.data.subgroup] =3D=3D=3D undefined) {=0A=
        this.subgroups[item.data.subgroup] =3D { height: 0, visible: =
false, index: this.subgroupIndex, items: [] };=0A=
        this.subgroupIndex++;=0A=
      }=0A=
      this.subgroups[item.data.subgroup].items.push(item);=0A=
    }=0A=
    this.orderSubgroups();=0A=
=0A=
    if (this.visibleItems.indexOf(item) =3D=3D -1) {=0A=
      var range =3D this.itemSet.body.range; // TODO: not nice accessing =
the range like this=0A=
      this._checkIfVisible(item, this.visibleItems, range);=0A=
    }=0A=
  };=0A=
=0A=
  Group.prototype.orderSubgroups =3D function () {=0A=
    if (this.subgroupOrderer !=3D=3D undefined) {=0A=
      var sortArray =3D [];=0A=
      if (typeof this.subgroupOrderer =3D=3D 'string') {=0A=
        for (var subgroup in this.subgroups) {=0A=
          sortArray.push({ subgroup: subgroup, sortField: =
this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });=0A=
        }=0A=
        sortArray.sort(function (a, b) {=0A=
          return a.sortField - b.sortField;=0A=
        });=0A=
      } else if (typeof this.subgroupOrderer =3D=3D 'function') {=0A=
        for (var subgroup in this.subgroups) {=0A=
          sortArray.push(this.subgroups[subgroup].items[0].data);=0A=
        }=0A=
        sortArray.sort(this.subgroupOrderer);=0A=
      }=0A=
=0A=
      if (sortArray.length > 0) {=0A=
        for (var i =3D 0; i < sortArray.length; i++) {=0A=
          this.subgroups[sortArray[i].subgroup].index =3D i;=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  Group.prototype.resetSubgroups =3D function () {=0A=
    for (var subgroup in this.subgroups) {=0A=
      if (this.subgroups.hasOwnProperty(subgroup)) {=0A=
        this.subgroups[subgroup].visible =3D false;=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove an item from the group=0A=
   * @param {Item} item=0A=
   */=0A=
  Group.prototype.remove =3D function (item) {=0A=
    delete this.items[item.id];=0A=
    item.setParent(null);=0A=
=0A=
    // remove from visible items=0A=
    var index =3D this.visibleItems.indexOf(item);=0A=
    if (index !=3D -1) this.visibleItems.splice(index, 1);=0A=
=0A=
    if (item.data.subgroup !=3D=3D undefined) {=0A=
      var subgroup =3D this.subgroups[item.data.subgroup];=0A=
      if (subgroup) {=0A=
        var itemIndex =3D subgroup.items.indexOf(item);=0A=
        subgroup.items.splice(itemIndex, 1);=0A=
        if (!subgroup.items.length) {=0A=
          delete this.subgroups[item.data.subgroup];=0A=
          this.subgroupIndex--;=0A=
        }=0A=
        this.orderSubgroups();=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove an item from the corresponding DataSet=0A=
   * @param {Item} item=0A=
   */=0A=
  Group.prototype.removeFromDataSet =3D function (item) {=0A=
    this.itemSet.removeItem(item.id);=0A=
  };=0A=
=0A=
  /**=0A=
   * Reorder the items=0A=
   */=0A=
  Group.prototype.order =3D function () {=0A=
    var array =3D util.toArray(this.items);=0A=
    var startArray =3D [];=0A=
    var endArray =3D [];=0A=
=0A=
    for (var i =3D 0; i < array.length; i++) {=0A=
      if (array[i].data.end !=3D=3D undefined) {=0A=
        endArray.push(array[i]);=0A=
      }=0A=
      startArray.push(array[i]);=0A=
    }=0A=
    this.orderedItems =3D {=0A=
      byStart: startArray,=0A=
      byEnd: endArray=0A=
    };=0A=
=0A=
    stack.orderByStart(this.orderedItems.byStart);=0A=
    stack.orderByEnd(this.orderedItems.byEnd);=0A=
  };=0A=
=0A=
  /**=0A=
   * Update the visible items=0A=
   * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items =
ordered by start date and by end date=0A=
   * @param {Item[]} visibleItems                             The =
previously visible items.=0A=
   * @param {{start: number, end: number}} range              Visible =
range=0A=
   * @return {Item[]} visibleItems                            The new =
visible items.=0A=
   * @private=0A=
   */=0A=
  Group.prototype._updateVisibleItems =3D function (orderedItems, =
oldVisibleItems, range) {=0A=
    var visibleItems =3D [];=0A=
    var visibleItemsLookup =3D {}; // we keep this to quickly look up if =
an item already exists in the list without using indexOf on visibleItems=0A=
    var interval =3D (range.end - range.start) / 4;=0A=
    var lowerBound =3D range.start - interval;=0A=
    var upperBound =3D range.end + interval;=0A=
    var item, i;=0A=
=0A=
    // this function is used to do the binary search.=0A=
    var searchFunction =3D function searchFunction(value) {=0A=
      if (value < lowerBound) {=0A=
        return -1;=0A=
      } else if (value <=3D upperBound) {=0A=
        return 0;=0A=
      } else {=0A=
        return 1;=0A=
      }=0A=
    };=0A=
=0A=
    // first check if the items that were in view previously are still =
in view.=0A=
    // IMPORTANT: this handles the case for the items with startdate =
before the window and enddate after the window!=0A=
    // also cleans up invisible items.=0A=
    if (oldVisibleItems.length > 0) {=0A=
      for (i =3D 0; i < oldVisibleItems.length; i++) {=0A=
        this._checkIfVisibleWithReference(oldVisibleItems[i], =
visibleItems, visibleItemsLookup, range);=0A=
      }=0A=
    }=0A=
=0A=
    // we do a binary search for the items that have only start values.=0A=
    var initialPosByStart =3D =
util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', =
'start');=0A=
=0A=
    // trace the visible items from the inital start pos both ways until =
an invisible item is found, we only look at the start values.=0A=
    this._traceVisible(initialPosByStart, orderedItems.byStart, =
visibleItems, visibleItemsLookup, function (item) {=0A=
      return item.data.start < lowerBound || item.data.start > =
upperBound;=0A=
    });=0A=
=0A=
    // if the window has changed programmatically without overlapping =
the old window, the ranged items with start < lowerBound and end > =
upperbound are not shown.=0A=
    // We therefore have to brute force check all items in the byEnd list=0A=
    if (this.checkRangedItems =3D=3D true) {=0A=
      this.checkRangedItems =3D false;=0A=
      for (i =3D 0; i < orderedItems.byEnd.length; i++) {=0A=
        this._checkIfVisibleWithReference(orderedItems.byEnd[i], =
visibleItems, visibleItemsLookup, range);=0A=
      }=0A=
    } else {=0A=
      // we do a binary search for the items that have defined end times.=0A=
      var initialPosByEnd =3D =
util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', =
'end');=0A=
=0A=
      // trace the visible items from the inital start pos both ways =
until an invisible item is found, we only look at the end values.=0A=
      this._traceVisible(initialPosByEnd, orderedItems.byEnd, =
visibleItems, visibleItemsLookup, function (item) {=0A=
        return item.data.end < lowerBound || item.data.end > upperBound;=0A=
      });=0A=
    }=0A=
=0A=
    // finally, we reposition all the visible items.=0A=
    for (i =3D 0; i < visibleItems.length; i++) {=0A=
      item =3D visibleItems[i];=0A=
      if (!item.displayed) item.show();=0A=
      // reposition item horizontally=0A=
      item.repositionX();=0A=
    }=0A=
=0A=
    // debug=0A=
    //console.log("new line")=0A=
    //if (this.groupId =3D=3D null) {=0A=
    //  for (i =3D 0; i < orderedItems.byStart.length; i++) {=0A=
    //    item =3D orderedItems.byStart[i].data;=0A=
    //    console.log('start',i,initialPosByStart, item.start.valueOf(), =
item.content, item.start >=3D lowerBound && item.start <=3D upperBound,i =
=3D=3D initialPosByStart ? "<------------------- HEREEEE" : "")=0A=
    //  }=0A=
    //  for (i =3D 0; i < orderedItems.byEnd.length; i++) {=0A=
    //    item =3D orderedItems.byEnd[i].data;=0A=
    //    console.log('rangeEnd',i,initialPosByEnd, item.end.valueOf(), =
item.content, item.end >=3D range.start && item.end <=3D range.end,i =
=3D=3D initialPosByEnd ? "<------------------- HEREEEE" : "")=0A=
    //  }=0A=
    //}=0A=
=0A=
    return visibleItems;=0A=
  };=0A=
=0A=
  Group.prototype._traceVisible =3D function (initialPos, items, =
visibleItems, visibleItemsLookup, breakCondition) {=0A=
    var item;=0A=
    var i;=0A=
=0A=
    if (initialPos !=3D -1) {=0A=
      for (i =3D initialPos; i >=3D 0; i--) {=0A=
        item =3D items[i];=0A=
        if (breakCondition(item)) {=0A=
          break;=0A=
        } else {=0A=
          if (visibleItemsLookup[item.id] =3D=3D=3D undefined) {=0A=
            visibleItemsLookup[item.id] =3D true;=0A=
            visibleItems.push(item);=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      for (i =3D initialPos + 1; i < items.length; i++) {=0A=
        item =3D items[i];=0A=
        if (breakCondition(item)) {=0A=
          break;=0A=
        } else {=0A=
          if (visibleItemsLookup[item.id] =3D=3D=3D undefined) {=0A=
            visibleItemsLookup[item.id] =3D true;=0A=
            visibleItems.push(item);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this function is very similar to the _checkIfInvisible() but it =
does not=0A=
   * return booleans, hides the item if it should not be seen and always =
adds to=0A=
   * the visibleItems.=0A=
   * this one is for brute forcing and hiding.=0A=
   *=0A=
   * @param {Item} item=0A=
   * @param {Array} visibleItems=0A=
   * @param {{start:number, end:number}} range=0A=
   * @private=0A=
   */=0A=
  Group.prototype._checkIfVisible =3D function (item, visibleItems, =
range) {=0A=
    if (item.isVisible(range)) {=0A=
      if (!item.displayed) item.show();=0A=
      // reposition item horizontally=0A=
      item.repositionX();=0A=
      visibleItems.push(item);=0A=
    } else {=0A=
      if (item.displayed) item.hide();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this function is very similar to the _checkIfInvisible() but it =
does not=0A=
   * return booleans, hides the item if it should not be seen and always =
adds to=0A=
   * the visibleItems.=0A=
   * this one is for brute forcing and hiding.=0A=
   *=0A=
   * @param {Item} item=0A=
   * @param {Array} visibleItems=0A=
   * @param {{start:number, end:number}} range=0A=
   * @private=0A=
   */=0A=
  Group.prototype._checkIfVisibleWithReference =3D function (item, =
visibleItems, visibleItemsLookup, range) {=0A=
    if (item.isVisible(range)) {=0A=
      if (visibleItemsLookup[item.id] =3D=3D=3D undefined) {=0A=
        visibleItemsLookup[item.id] =3D true;=0A=
        visibleItems.push(item);=0A=
      }=0A=
    } else {=0A=
      if (item.displayed) item.hide();=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D Group;=0A=
=0A=
/***/ },=0A=
/* 33 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  // Utility functions for ordering and stacking of items=0A=
  'use strict';=0A=
=0A=
  var EPSILON =3D 0.001; // used when checking collisions, to prevent =
round-off errors=0A=
=0A=
  /**=0A=
   * Order items by their start data=0A=
   * @param {Item[]} items=0A=
   */=0A=
  exports.orderByStart =3D function (items) {=0A=
    items.sort(function (a, b) {=0A=
      return a.data.start - b.data.start;=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * Order items by their end date. If they have no end date, their =
start date=0A=
   * is used.=0A=
   * @param {Item[]} items=0A=
   */=0A=
  exports.orderByEnd =3D function (items) {=0A=
    items.sort(function (a, b) {=0A=
      var aTime =3D 'end' in a.data ? a.data.end : a.data.start,=0A=
          bTime =3D 'end' in b.data ? b.data.end : b.data.start;=0A=
=0A=
      return aTime - bTime;=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * Adjust vertical positions of the items such that they don't overlap =
each=0A=
   * other.=0A=
   * @param {Item[]} items=0A=
   *            All visible items=0A=
   * @param {{item: {horizontal: number, vertical: number}, axis: =
number}} margin=0A=
   *            Margins between items and between items and the axis.=0A=
   * @param {boolean} [force=3Dfalse]=0A=
   *            If true, all items will be repositioned. If false =
(default), only=0A=
   *            items having a top=3D=3D=3Dnull will be re-stacked=0A=
   */=0A=
  exports.stack =3D function (items, margin, force) {=0A=
    var i, iMax;=0A=
=0A=
    if (force) {=0A=
      // reset top position of all items=0A=
      for (i =3D 0, iMax =3D items.length; i < iMax; i++) {=0A=
        items[i].top =3D null;=0A=
      }=0A=
    }=0A=
=0A=
    // calculate new, non-overlapping positions=0A=
    for (i =3D 0, iMax =3D items.length; i < iMax; i++) {=0A=
      var item =3D items[i];=0A=
      if (item.stack && item.top =3D=3D=3D null) {=0A=
        // initialize top position=0A=
        item.top =3D margin.axis;=0A=
=0A=
        do {=0A=
          // TODO: optimize checking for overlap. when there is a gap =
without items,=0A=
          //       you only need to check for items from the next item =
on, not from zero=0A=
          var collidingItem =3D null;=0A=
          for (var j =3D 0, jj =3D items.length; j < jj; j++) {=0A=
            var other =3D items[j];=0A=
            if (other.top !=3D=3D null && other !=3D=3D item && =
other.stack && exports.collision(item, other, margin.item)) {=0A=
              collidingItem =3D other;=0A=
              break;=0A=
            }=0A=
          }=0A=
=0A=
          if (collidingItem !=3D null) {=0A=
            // There is a collision. Reposition the items above the =
colliding element=0A=
            item.top =3D collidingItem.top + collidingItem.height + =
margin.item.vertical;=0A=
          }=0A=
        } while (collidingItem);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Adjust vertical positions of the items without stacking them=0A=
   * @param {Item[]} items=0A=
   *            All visible items=0A=
   * @param {{item: {horizontal: number, vertical: number}, axis: =
number}} margin=0A=
   *            Margins between items and between items and the axis.=0A=
   */=0A=
  exports.nostack =3D function (items, margin, subgroups) {=0A=
    var i, iMax, newTop;=0A=
=0A=
    // reset top position of all items=0A=
    for (i =3D 0, iMax =3D items.length; i < iMax; i++) {=0A=
      if (items[i].data.subgroup !=3D=3D undefined) {=0A=
        newTop =3D margin.axis;=0A=
        for (var subgroup in subgroups) {=0A=
          if (subgroups.hasOwnProperty(subgroup)) {=0A=
            if (subgroups[subgroup].visible =3D=3D true && =
subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {=0A=
              newTop +=3D subgroups[subgroup].height + =
margin.item.vertical;=0A=
            }=0A=
          }=0A=
        }=0A=
        items[i].top =3D newTop;=0A=
      } else {=0A=
        items[i].top =3D margin.axis;=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Test if the two provided items collide=0A=
   * The items must have parameters left, width, top, and height.=0A=
   * @param {Item} a          The first item=0A=
   * @param {Item} b          The second item=0A=
   * @param {{horizontal: number, vertical: number}} margin=0A=
   *                          An object containing a horizontal and =
vertical=0A=
   *                          minimum required margin.=0A=
   * @return {boolean}        true if a and b collide, else false=0A=
   */=0A=
  exports.collision =3D function (a, b, margin) {=0A=
    return a.left - margin.horizontal + EPSILON < b.left + b.width && =
a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - =
margin.vertical + EPSILON < b.top + b.height && a.top + a.height + =
margin.vertical - EPSILON > b.top;=0A=
  };=0A=
=0A=
/***/ },=0A=
/* 34 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var Item =3D __webpack_require__(2);=0A=
=0A=
  /**=0A=
   * @constructor RangeItem=0A=
   * @extends Item=0A=
   * @param {Object} data             Object containing parameters =
start, end=0A=
   *                                  content, className.=0A=
   * @param {{toScreen: function, toTime: function}} conversion=0A=
   *                                  Conversion functions from time to =
screen and vice versa=0A=
   * @param {Object} [options]        Configuration options=0A=
   *                                  // TODO: describe options=0A=
   */=0A=
  function RangeItem(data, conversion, options) {=0A=
    this.props =3D {=0A=
      content: {=0A=
        width: 0=0A=
      }=0A=
    };=0A=
    this.overflow =3D false; // if contents can overflow (css styling), =
this flag is set to true=0A=
=0A=
    // validate data=0A=
    if (data) {=0A=
      if (data.start =3D=3D undefined) {=0A=
        throw new Error('Property "start" missing in item ' + data.id);=0A=
      }=0A=
      if (data.end =3D=3D undefined) {=0A=
        throw new Error('Property "end" missing in item ' + data.id);=0A=
      }=0A=
    }=0A=
=0A=
    Item.call(this, data, conversion, options);=0A=
  }=0A=
=0A=
  RangeItem.prototype =3D new Item(null, null, null);=0A=
=0A=
  RangeItem.prototype.baseClassName =3D 'vis-item vis-range';=0A=
=0A=
  /**=0A=
   * Check whether this item is visible inside given range=0A=
   * @returns {{start: Number, end: Number}} range with a timestamp for =
start and end=0A=
   * @returns {boolean} True if visible=0A=
   */=0A=
  RangeItem.prototype.isVisible =3D function (range) {=0A=
    // determine visibility=0A=
    return this.data.start < range.end && this.data.end > range.start;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the item=0A=
   */=0A=
  RangeItem.prototype.redraw =3D function () {=0A=
    var dom =3D this.dom;=0A=
    if (!dom) {=0A=
      // create DOM=0A=
      this.dom =3D {};=0A=
      dom =3D this.dom;=0A=
=0A=
      // background box=0A=
      dom.box =3D document.createElement('div');=0A=
      // className is updated in redraw()=0A=
=0A=
      // frame box (to prevent the item contents from overflowing=0A=
      dom.frame =3D document.createElement('div');=0A=
      dom.frame.className =3D 'vis-item-overflow';=0A=
      dom.box.appendChild(dom.frame);=0A=
=0A=
      // contents box=0A=
      dom.content =3D document.createElement('div');=0A=
      dom.content.className =3D 'vis-item-content';=0A=
      dom.frame.appendChild(dom.content);=0A=
=0A=
      // attach this item as attribute=0A=
      dom.box['timeline-item'] =3D this;=0A=
=0A=
      this.dirty =3D true;=0A=
    }=0A=
=0A=
    // append DOM to parent DOM=0A=
    if (!this.parent) {=0A=
      throw new Error('Cannot redraw item: no parent attached');=0A=
    }=0A=
    if (!dom.box.parentNode) {=0A=
      var foreground =3D this.parent.dom.foreground;=0A=
      if (!foreground) {=0A=
        throw new Error('Cannot redraw item: parent has no foreground =
container element');=0A=
      }=0A=
      foreground.appendChild(dom.box);=0A=
    }=0A=
    this.displayed =3D true;=0A=
=0A=
    // Update DOM when item is marked dirty. An item is marked dirty =
when:=0A=
    // - the item is not yet rendered=0A=
    // - the item's data is changed=0A=
    // - the item is selected/deselected=0A=
    if (this.dirty) {=0A=
      this._updateContents(this.dom.content);=0A=
      this._updateTitle(this.dom.box);=0A=
      this._updateDataAttributes(this.dom.box);=0A=
      this._updateStyle(this.dom.box);=0A=
=0A=
      var editable =3D (this.options.editable.updateTime || =
this.options.editable.updateGroup || this.editable =3D=3D=3D true) && =
this.editable !=3D=3D false;=0A=
=0A=
      // update class=0A=
      var className =3D (this.data.className ? ' ' + this.data.className =
: '') + (this.selected ? ' vis-selected' : '') + (editable ? ' =
vis-editable' : ' vis-readonly');=0A=
      dom.box.className =3D this.baseClassName + className;=0A=
=0A=
      // determine from css whether this box has overflow=0A=
      this.overflow =3D window.getComputedStyle(dom.frame).overflow =
!=3D=3D 'hidden';=0A=
=0A=
      // recalculate size=0A=
      // turn off max-width to be able to calculate the real width=0A=
      // this causes an extra browser repaint/reflow, but so be it=0A=
      this.dom.content.style.maxWidth =3D 'none';=0A=
      this.props.content.width =3D this.dom.content.offsetWidth;=0A=
      this.height =3D this.dom.box.offsetHeight;=0A=
      this.dom.content.style.maxWidth =3D '';=0A=
=0A=
      this.dirty =3D false;=0A=
    }=0A=
=0A=
    this._repaintDeleteButton(dom.box);=0A=
    this._repaintDragLeft();=0A=
    this._repaintDragRight();=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the item in the DOM (when not already visible). The items DOM =
will=0A=
   * be created when needed.=0A=
   */=0A=
  RangeItem.prototype.show =3D function () {=0A=
    if (!this.displayed) {=0A=
      this.redraw();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the item from the DOM (when visible)=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  RangeItem.prototype.hide =3D function () {=0A=
    if (this.displayed) {=0A=
      var box =3D this.dom.box;=0A=
=0A=
      if (box.parentNode) {=0A=
        box.parentNode.removeChild(box);=0A=
      }=0A=
=0A=
      this.displayed =3D false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Reposition the item horizontally=0A=
   * @param {boolean} [limitSize=3Dtrue] If true (default), the width of =
the range=0A=
   *                                   item will be limited, as the =
browser cannot=0A=
   *                                   display very wide divs. This =
means though=0A=
   *                                   that the applied left and width =
may=0A=
   *                                   not correspond to the ranges =
start and end=0A=
   * @Override=0A=
   */=0A=
  RangeItem.prototype.repositionX =3D function (limitSize) {=0A=
    var parentWidth =3D this.parent.width;=0A=
    var start =3D this.conversion.toScreen(this.data.start);=0A=
    var end =3D this.conversion.toScreen(this.data.end);=0A=
    var contentLeft;=0A=
    var contentWidth;=0A=
=0A=
    // limit the width of the range, as browsers cannot draw very wide =
divs=0A=
    if (limitSize =3D=3D=3D undefined || limitSize =3D=3D=3D true) {=0A=
      if (start < -parentWidth) {=0A=
        start =3D -parentWidth;=0A=
      }=0A=
      if (end > 2 * parentWidth) {=0A=
        end =3D 2 * parentWidth;=0A=
      }=0A=
    }=0A=
    var boxWidth =3D Math.max(end - start, 1);=0A=
=0A=
    if (this.overflow) {=0A=
      this.left =3D start;=0A=
      this.width =3D boxWidth + this.props.content.width;=0A=
      contentWidth =3D this.props.content.width;=0A=
=0A=
      // Note: The calculation of width is an optimistic calculation, =
giving=0A=
      //       a width which will not change when moving the Timeline=0A=
      //       So no re-stacking needed, which is nicer for the eye;=0A=
    } else {=0A=
      this.left =3D start;=0A=
      this.width =3D boxWidth;=0A=
      contentWidth =3D Math.min(end - start, this.props.content.width);=0A=
    }=0A=
=0A=
    this.dom.box.style.left =3D this.left + 'px';=0A=
    this.dom.box.style.width =3D boxWidth + 'px';=0A=
=0A=
    switch (this.options.align) {=0A=
      case 'left':=0A=
        this.dom.content.style.left =3D '0';=0A=
        break;=0A=
=0A=
      case 'right':=0A=
        this.dom.content.style.left =3D Math.max(boxWidth - =
contentWidth, 0) + 'px';=0A=
        break;=0A=
=0A=
      case 'center':=0A=
        this.dom.content.style.left =3D Math.max((boxWidth - =
contentWidth) / 2, 0) + 'px';=0A=
        break;=0A=
=0A=
      default:=0A=
        // 'auto'=0A=
        // when range exceeds left of the window, position the contents =
at the left of the visible area=0A=
        if (this.overflow) {=0A=
          if (end > 0) {=0A=
            contentLeft =3D Math.max(-start, 0);=0A=
          } else {=0A=
            contentLeft =3D -contentWidth; // ensure it's not visible =
anymore=0A=
          }=0A=
        } else {=0A=
          if (start < 0) {=0A=
            contentLeft =3D -start;=0A=
          } else {=0A=
            contentLeft =3D 0;=0A=
          }=0A=
        }=0A=
        this.dom.content.style.left =3D contentLeft + 'px';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Reposition the item vertically=0A=
   * @Override=0A=
   */=0A=
  RangeItem.prototype.repositionY =3D function () {=0A=
    var orientation =3D this.options.orientation.item;=0A=
    var box =3D this.dom.box;=0A=
=0A=
    if (orientation =3D=3D 'top') {=0A=
      box.style.top =3D this.top + 'px';=0A=
    } else {=0A=
      box.style.top =3D this.parent.height - this.top - this.height + =
'px';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint a drag area on the left side of the range when the range is =
selected=0A=
   * @protected=0A=
   */=0A=
  RangeItem.prototype._repaintDragLeft =3D function () {=0A=
    if (this.selected && this.options.editable.updateTime && =
!this.dom.dragLeft) {=0A=
      // create and show drag area=0A=
      var dragLeft =3D document.createElement('div');=0A=
      dragLeft.className =3D 'vis-drag-left';=0A=
      dragLeft.dragLeftItem =3D this;=0A=
=0A=
      this.dom.box.appendChild(dragLeft);=0A=
      this.dom.dragLeft =3D dragLeft;=0A=
    } else if (!this.selected && this.dom.dragLeft) {=0A=
      // delete drag area=0A=
      if (this.dom.dragLeft.parentNode) {=0A=
        this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);=0A=
      }=0A=
      this.dom.dragLeft =3D null;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint a drag area on the right side of the range when the range =
is selected=0A=
   * @protected=0A=
   */=0A=
  RangeItem.prototype._repaintDragRight =3D function () {=0A=
    if (this.selected && this.options.editable.updateTime && =
!this.dom.dragRight) {=0A=
      // create and show drag area=0A=
      var dragRight =3D document.createElement('div');=0A=
      dragRight.className =3D 'vis-drag-right';=0A=
      dragRight.dragRightItem =3D this;=0A=
=0A=
      this.dom.box.appendChild(dragRight);=0A=
      this.dom.dragRight =3D dragRight;=0A=
    } else if (!this.selected && this.dom.dragRight) {=0A=
      // delete drag area=0A=
      if (this.dom.dragRight.parentNode) {=0A=
        this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);=0A=
      }=0A=
      this.dom.dragRight =3D null;=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D RangeItem;=0A=
=0A=
/***/ },=0A=
/* 35 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var moment =3D __webpack_require__(8);=0A=
  var DateUtil =3D __webpack_require__(29);=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * @constructor  TimeStep=0A=
   * The class TimeStep is an iterator for dates. You provide a start =
date and an=0A=
   * end date. The class itself determines the best scale (step size) =
based on the=0A=
   * provided start Date, end Date, and minimumStep.=0A=
   *=0A=
   * If minimumStep is provided, the step size is chosen as close as =
possible=0A=
   * to the minimumStep but larger than minimumStep. If minimumStep is =
not=0A=
   * provided, the scale is set to 1 DAY.=0A=
   * The minimumStep should correspond with the onscreen size of about 6 =
characters=0A=
   *=0A=
   * Alternatively, you can set a scale by hand.=0A=
   * After creation, you can initialize the class by executing first(). =
Then you=0A=
   * can iterate from the start date to the end date via next(). You can =
check if=0A=
   * the end date is reached with the function hasNext(). After each =
step, you can=0A=
   * retrieve the current date via getCurrent().=0A=
   * The TimeStep has scales ranging from milliseconds, seconds, =
minutes, hours,=0A=
   * days, to years.=0A=
   *=0A=
   * Version: 1.2=0A=
   *=0A=
   * @param {Date} [start]         The start date, for example new =
Date(2010, 9, 21)=0A=
   *                               or new Date(2010, 9, 21, 23, 45, 00)=0A=
   * @param {Date} [end]           The end date=0A=
   * @param {Number} [minimumStep] Optional. Minimum step size in =
milliseconds=0A=
   */=0A=
  function TimeStep(start, end, minimumStep, hiddenDates) {=0A=
    this.moment =3D moment;=0A=
=0A=
    // variables=0A=
    this.current =3D this.moment();=0A=
    this._start =3D this.moment();=0A=
    this._end =3D this.moment();=0A=
=0A=
    this.autoScale =3D true;=0A=
    this.scale =3D 'day';=0A=
    this.step =3D 1;=0A=
=0A=
    // initialize the range=0A=
    this.setRange(start, end, minimumStep);=0A=
=0A=
    // hidden Dates options=0A=
    this.switchedDay =3D false;=0A=
    this.switchedMonth =3D false;=0A=
    this.switchedYear =3D false;=0A=
    this.hiddenDates =3D hiddenDates;=0A=
    if (hiddenDates =3D=3D=3D undefined) {=0A=
      this.hiddenDates =3D [];=0A=
    }=0A=
=0A=
    this.format =3D TimeStep.FORMAT; // default formatting=0A=
  }=0A=
=0A=
  // Time formatting=0A=
  TimeStep.FORMAT =3D {=0A=
    minorLabels: {=0A=
      millisecond: 'SSS',=0A=
      second: 's',=0A=
      minute: 'HH:mm',=0A=
      hour: 'HH:mm',=0A=
      weekday: 'ddd D',=0A=
      day: 'D',=0A=
      month: 'MMM',=0A=
      year: 'YYYY'=0A=
    },=0A=
    majorLabels: {=0A=
      millisecond: 'HH:mm:ss',=0A=
      second: 'D MMMM HH:mm',=0A=
      minute: 'ddd D MMMM',=0A=
      hour: 'ddd D MMMM',=0A=
      weekday: 'MMMM YYYY',=0A=
      day: 'MMMM YYYY',=0A=
      month: 'YYYY',=0A=
      year: ''=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set custom constructor function for moment. Can be used to set dates=0A=
   * to UTC or to set a utcOffset.=0A=
   * @param {function} moment=0A=
   */=0A=
  TimeStep.prototype.setMoment =3D function (moment) {=0A=
    this.moment =3D moment;=0A=
=0A=
    // update the date properties, can have a new utcOffset=0A=
    this.current =3D this.moment(this.current);=0A=
    this._start =3D this.moment(this._start);=0A=
    this._end =3D this.moment(this._end);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set custom formatting for the minor an major labels of the TimeStep.=0A=
   * Both `minorLabels` and `majorLabels` are an Object with properties:=0A=
   * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', =
'month', 'year'.=0A=
   * @param {{minorLabels: Object, majorLabels: Object}} format=0A=
   */=0A=
  TimeStep.prototype.setFormat =3D function (format) {=0A=
    var defaultFormat =3D util.deepExtend({}, TimeStep.FORMAT);=0A=
    this.format =3D util.deepExtend(defaultFormat, format);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a new range=0A=
   * If minimumStep is provided, the step size is chosen as close as =
possible=0A=
   * to the minimumStep but larger than minimumStep. If minimumStep is =
not=0A=
   * provided, the scale is set to 1 DAY.=0A=
   * The minimumStep should correspond with the onscreen size of about 6 =
characters=0A=
   * @param {Date} [start]      The start date and time.=0A=
   * @param {Date} [end]        The end date and time.=0A=
   * @param {int} [minimumStep] Optional. Minimum step size in =
milliseconds=0A=
   */=0A=
  TimeStep.prototype.setRange =3D function (start, end, minimumStep) {=0A=
    if (!(start instanceof Date) || !(end instanceof Date)) {=0A=
      throw 'No legal start or end date in method setRange';=0A=
    }=0A=
=0A=
    this._start =3D start !=3D undefined ? this.moment(start.valueOf()) =
: new Date();=0A=
    this._end =3D end !=3D undefined ? this.moment(end.valueOf()) : new =
Date();=0A=
=0A=
    if (this.autoScale) {=0A=
      this.setMinimumStep(minimumStep);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set the range iterator to the start date.=0A=
   */=0A=
  TimeStep.prototype.start =3D function () {=0A=
    this.current =3D this._start.clone();=0A=
    this.roundToMinor();=0A=
  };=0A=
=0A=
  /**=0A=
   * Round the current date to the first minor date value=0A=
   * This must be executed once when the current date is set to start =
Date=0A=
   */=0A=
  TimeStep.prototype.roundToMinor =3D function () {=0A=
    // round to floor=0A=
    // IMPORTANT: we have no breaks in this switch! (this is no bug)=0A=
    // noinspection FallThroughInSwitchStatementJS=0A=
    switch (this.scale) {=0A=
      case 'year':=0A=
        this.current.year(this.step * Math.floor(this.current.year() / =
this.step));=0A=
        this.current.month(0);=0A=
      case 'month':=0A=
        this.current.date(1);=0A=
      case 'day': // intentional fall through=0A=
      case 'weekday':=0A=
        this.current.hours(0);=0A=
      case 'hour':=0A=
        this.current.minutes(0);=0A=
      case 'minute':=0A=
        this.current.seconds(0);=0A=
      case 'second':=0A=
        this.current.milliseconds(0);=0A=
        //case 'millisecond': // nothing to do for milliseconds=0A=
    }=0A=
=0A=
    if (this.step !=3D 1) {=0A=
      // round down to the first minor value that is a multiple of the =
current step size=0A=
      switch (this.scale) {=0A=
        case 'millisecond':=0A=
          this.current.subtract(this.current.milliseconds() % this.step, =
'milliseconds');break;=0A=
        case 'second':=0A=
          this.current.subtract(this.current.seconds() % this.step, =
'seconds');break;=0A=
        case 'minute':=0A=
          this.current.subtract(this.current.minutes() % this.step, =
'minutes');break;=0A=
        case 'hour':=0A=
          this.current.subtract(this.current.hours() % this.step, =
'hours');break;=0A=
        case 'weekday': // intentional fall through=0A=
        case 'day':=0A=
          this.current.subtract((this.current.date() - 1) % this.step, =
'day');break;=0A=
        case 'month':=0A=
          this.current.subtract(this.current.month() % this.step, =
'month');break;=0A=
        case 'year':=0A=
          this.current.subtract(this.current.year() % this.step, =
'year');break;=0A=
        default:=0A=
          break;=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Check if the there is a next step=0A=
   * @return {boolean}  true if the current date has not passed the end =
date=0A=
   */=0A=
  TimeStep.prototype.hasNext =3D function () {=0A=
    return this.current.valueOf() <=3D this._end.valueOf();=0A=
  };=0A=
=0A=
  /**=0A=
   * Do the next step=0A=
   */=0A=
  TimeStep.prototype.next =3D function () {=0A=
    var prev =3D this.current.valueOf();=0A=
=0A=
    // Two cases, needed to prevent issues with switching daylight =
savings=0A=
    // (end of March and end of October)=0A=
    if (this.current.month() < 6) {=0A=
      switch (this.scale) {=0A=
        case 'millisecond':=0A=
          this.current.add(this.step, 'millisecond');break;=0A=
        case 'second':=0A=
          this.current.add(this.step, 'second');break;=0A=
        case 'minute':=0A=
          this.current.add(this.step, 'minute');break;=0A=
        case 'hour':=0A=
          this.current.add(this.step, 'hour');=0A=
          // in case of skipping an hour for daylight savings, adjust =
the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)=0A=
          // TODO: is this still needed now we use the function of =
moment.js?=0A=
          this.current.subtract(this.current.hours() % this.step, =
'hour');=0A=
          break;=0A=
        case 'weekday': // intentional fall through=0A=
        case 'day':=0A=
          this.current.add(this.step, 'day');break;=0A=
        case 'month':=0A=
          this.current.add(this.step, 'month');break;=0A=
        case 'year':=0A=
          this.current.add(this.step, 'year');break;=0A=
        default:=0A=
          break;=0A=
      }=0A=
    } else {=0A=
      switch (this.scale) {=0A=
        case 'millisecond':=0A=
          this.current.add(this.step, 'millisecond');break;=0A=
        case 'second':=0A=
          this.current.add(this.step, 'second');break;=0A=
        case 'minute':=0A=
          this.current.add(this.step, 'minute');break;=0A=
        case 'hour':=0A=
          this.current.add(this.step, 'hour');break;=0A=
        case 'weekday': // intentional fall through=0A=
        case 'day':=0A=
          this.current.add(this.step, 'day');break;=0A=
        case 'month':=0A=
          this.current.add(this.step, 'month');break;=0A=
        case 'year':=0A=
          this.current.add(this.step, 'year');break;=0A=
        default:=0A=
          break;=0A=
      }=0A=
    }=0A=
=0A=
    if (this.step !=3D 1) {=0A=
      // round down to the correct major value=0A=
      switch (this.scale) {=0A=
        case 'millisecond':=0A=
          if (this.current.milliseconds() < this.step) =
this.current.milliseconds(0);break;=0A=
        case 'second':=0A=
          if (this.current.seconds() < this.step) =
this.current.seconds(0);break;=0A=
        case 'minute':=0A=
          if (this.current.minutes() < this.step) =
this.current.minutes(0);break;=0A=
        case 'hour':=0A=
          if (this.current.hours() < this.step) =
this.current.hours(0);break;=0A=
        case 'weekday': // intentional fall through=0A=
        case 'day':=0A=
          if (this.current.date() < this.step + 1) =
this.current.date(1);break;=0A=
        case 'month':=0A=
          if (this.current.month() < this.step) =
this.current.month(0);break;=0A=
        case 'year':=0A=
          break; // nothing to do for year=0A=
        default:=0A=
          break;=0A=
      }=0A=
    }=0A=
=0A=
    // safety mechanism: if current time is still unchanged, move to the =
end=0A=
    if (this.current.valueOf() =3D=3D prev) {=0A=
      this.current =3D this._end.clone();=0A=
    }=0A=
=0A=
    DateUtil.stepOverHiddenDates(this.moment, this, prev);=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the current datetime=0A=
   * @return {Moment}  current The current date=0A=
   */=0A=
  TimeStep.prototype.getCurrent =3D function () {=0A=
    return this.current;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a custom scale. Autoscaling will be disabled.=0A=
   * For example setScale('minute', 5) will result=0A=
   * in minor steps of 5 minutes, and major steps of an hour.=0A=
   *=0A=
   * @param {{scale: string, step: number}} params=0A=
   *                               An object containing two properties:=0A=
   *                               - A string 'scale'. Choose from =
'millisecond', 'second',=0A=
   *                                 'minute', 'hour', 'weekday', 'day', =
'month', 'year'.=0A=
   *                               - A number 'step'. A step size, by =
default 1.=0A=
   *                                 Choose for example 1, 2, 5, or 10.=0A=
   */=0A=
  TimeStep.prototype.setScale =3D function (params) {=0A=
    if (params && typeof params.scale =3D=3D 'string') {=0A=
      this.scale =3D params.scale;=0A=
      this.step =3D params.step > 0 ? params.step : 1;=0A=
      this.autoScale =3D false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Enable or disable autoscaling=0A=
   * @param {boolean} enable  If true, autoascaling is set true=0A=
   */=0A=
  TimeStep.prototype.setAutoScale =3D function (enable) {=0A=
    this.autoScale =3D enable;=0A=
  };=0A=
=0A=
  /**=0A=
   * Automatically determine the scale that bests fits the provided =
minimum step=0A=
   * @param {Number} [minimumStep]  The minimum step size in milliseconds=0A=
   */=0A=
  TimeStep.prototype.setMinimumStep =3D function (minimumStep) {=0A=
    if (minimumStep =3D=3D undefined) {=0A=
      return;=0A=
    }=0A=
=0A=
    //var b =3D asc + ds;=0A=
=0A=
    var stepYear =3D 1000 * 60 * 60 * 24 * 30 * 12;=0A=
    var stepMonth =3D 1000 * 60 * 60 * 24 * 30;=0A=
    var stepDay =3D 1000 * 60 * 60 * 24;=0A=
    var stepHour =3D 1000 * 60 * 60;=0A=
    var stepMinute =3D 1000 * 60;=0A=
    var stepSecond =3D 1000;=0A=
    var stepMillisecond =3D 1;=0A=
=0A=
    // find the smallest step that is larger than the provided =
minimumStep=0A=
    if (stepYear * 1000 > minimumStep) {=0A=
      this.scale =3D 'year';this.step =3D 1000;=0A=
    }=0A=
    if (stepYear * 500 > minimumStep) {=0A=
      this.scale =3D 'year';this.step =3D 500;=0A=
    }=0A=
    if (stepYear * 100 > minimumStep) {=0A=
      this.scale =3D 'year';this.step =3D 100;=0A=
    }=0A=
    if (stepYear * 50 > minimumStep) {=0A=
      this.scale =3D 'year';this.step =3D 50;=0A=
    }=0A=
    if (stepYear * 10 > minimumStep) {=0A=
      this.scale =3D 'year';this.step =3D 10;=0A=
    }=0A=
    if (stepYear * 5 > minimumStep) {=0A=
      this.scale =3D 'year';this.step =3D 5;=0A=
    }=0A=
    if (stepYear > minimumStep) {=0A=
      this.scale =3D 'year';this.step =3D 1;=0A=
    }=0A=
    if (stepMonth * 3 > minimumStep) {=0A=
      this.scale =3D 'month';this.step =3D 3;=0A=
    }=0A=
    if (stepMonth > minimumStep) {=0A=
      this.scale =3D 'month';this.step =3D 1;=0A=
    }=0A=
    if (stepDay * 5 > minimumStep) {=0A=
      this.scale =3D 'day';this.step =3D 5;=0A=
    }=0A=
    if (stepDay * 2 > minimumStep) {=0A=
      this.scale =3D 'day';this.step =3D 2;=0A=
    }=0A=
    if (stepDay > minimumStep) {=0A=
      this.scale =3D 'day';this.step =3D 1;=0A=
    }=0A=
    if (stepDay / 2 > minimumStep) {=0A=
      this.scale =3D 'weekday';this.step =3D 1;=0A=
    }=0A=
    if (stepHour * 4 > minimumStep) {=0A=
      this.scale =3D 'hour';this.step =3D 4;=0A=
    }=0A=
    if (stepHour > minimumStep) {=0A=
      this.scale =3D 'hour';this.step =3D 1;=0A=
    }=0A=
    if (stepMinute * 15 > minimumStep) {=0A=
      this.scale =3D 'minute';this.step =3D 15;=0A=
    }=0A=
    if (stepMinute * 10 > minimumStep) {=0A=
      this.scale =3D 'minute';this.step =3D 10;=0A=
    }=0A=
    if (stepMinute * 5 > minimumStep) {=0A=
      this.scale =3D 'minute';this.step =3D 5;=0A=
    }=0A=
    if (stepMinute > minimumStep) {=0A=
      this.scale =3D 'minute';this.step =3D 1;=0A=
    }=0A=
    if (stepSecond * 15 > minimumStep) {=0A=
      this.scale =3D 'second';this.step =3D 15;=0A=
    }=0A=
    if (stepSecond * 10 > minimumStep) {=0A=
      this.scale =3D 'second';this.step =3D 10;=0A=
    }=0A=
    if (stepSecond * 5 > minimumStep) {=0A=
      this.scale =3D 'second';this.step =3D 5;=0A=
    }=0A=
    if (stepSecond > minimumStep) {=0A=
      this.scale =3D 'second';this.step =3D 1;=0A=
    }=0A=
    if (stepMillisecond * 200 > minimumStep) {=0A=
      this.scale =3D 'millisecond';this.step =3D 200;=0A=
    }=0A=
    if (stepMillisecond * 100 > minimumStep) {=0A=
      this.scale =3D 'millisecond';this.step =3D 100;=0A=
    }=0A=
    if (stepMillisecond * 50 > minimumStep) {=0A=
      this.scale =3D 'millisecond';this.step =3D 50;=0A=
    }=0A=
    if (stepMillisecond * 10 > minimumStep) {=0A=
      this.scale =3D 'millisecond';this.step =3D 10;=0A=
    }=0A=
    if (stepMillisecond * 5 > minimumStep) {=0A=
      this.scale =3D 'millisecond';this.step =3D 5;=0A=
    }=0A=
    if (stepMillisecond > minimumStep) {=0A=
      this.scale =3D 'millisecond';this.step =3D 1;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Snap a date to a rounded value.=0A=
   * The snap intervals are dependent on the current scale and step.=0A=
   * Static function=0A=
   * @param {Date} date    the date to be snapped.=0A=
   * @param {string} scale Current scale, can be 'millisecond', 'second',=0A=
   *                       'minute', 'hour', 'weekday, 'day', 'month', =
'year'.=0A=
   * @param {number} step  Current step (1, 2, 4, 5, ...=0A=
   * @return {Date} snappedDate=0A=
   */=0A=
  TimeStep.snap =3D function (date, scale, step) {=0A=
    var clone =3D moment(date);=0A=
=0A=
    if (scale =3D=3D 'year') {=0A=
      var year =3D clone.year() + Math.round(clone.month() / 12);=0A=
      clone.year(Math.round(year / step) * step);=0A=
      clone.month(0);=0A=
      clone.date(0);=0A=
      clone.hours(0);=0A=
      clone.minutes(0);=0A=
      clone.seconds(0);=0A=
      clone.mlliseconds(0);=0A=
    } else if (scale =3D=3D 'month') {=0A=
      if (clone.date() > 15) {=0A=
        clone.date(1);=0A=
        clone.add(1, 'month');=0A=
        // important: first set Date to 1, after that change the month.=0A=
      } else {=0A=
        clone.date(1);=0A=
      }=0A=
=0A=
      clone.hours(0);=0A=
      clone.minutes(0);=0A=
      clone.seconds(0);=0A=
      clone.milliseconds(0);=0A=
    } else if (scale =3D=3D 'day') {=0A=
      //noinspection FallthroughInSwitchStatementJS=0A=
      switch (step) {=0A=
        case 5:=0A=
        case 2:=0A=
          clone.hours(Math.round(clone.hours() / 24) * 24);break;=0A=
        default:=0A=
          clone.hours(Math.round(clone.hours() / 12) * 12);break;=0A=
      }=0A=
      clone.minutes(0);=0A=
      clone.seconds(0);=0A=
      clone.milliseconds(0);=0A=
    } else if (scale =3D=3D 'weekday') {=0A=
      //noinspection FallthroughInSwitchStatementJS=0A=
      switch (step) {=0A=
        case 5:=0A=
        case 2:=0A=
          clone.hours(Math.round(clone.hours() / 12) * 12);break;=0A=
        default:=0A=
          clone.hours(Math.round(clone.hours() / 6) * 6);break;=0A=
      }=0A=
      clone.minutes(0);=0A=
      clone.seconds(0);=0A=
      clone.milliseconds(0);=0A=
    } else if (scale =3D=3D 'hour') {=0A=
      switch (step) {=0A=
        case 4:=0A=
          clone.minutes(Math.round(clone.minutes() / 60) * 60);break;=0A=
        default:=0A=
          clone.minutes(Math.round(clone.minutes() / 30) * 30);break;=0A=
      }=0A=
      clone.seconds(0);=0A=
      clone.milliseconds(0);=0A=
    } else if (scale =3D=3D 'minute') {=0A=
      //noinspection FallthroughInSwitchStatementJS=0A=
      switch (step) {=0A=
        case 15:=0A=
        case 10:=0A=
          clone.minutes(Math.round(clone.minutes() / 5) * 5);=0A=
          clone.seconds(0);=0A=
          break;=0A=
        case 5:=0A=
          clone.seconds(Math.round(clone.seconds() / 60) * 60);break;=0A=
        default:=0A=
          clone.seconds(Math.round(clone.seconds() / 30) * 30);break;=0A=
      }=0A=
      clone.milliseconds(0);=0A=
    } else if (scale =3D=3D 'second') {=0A=
      //noinspection FallthroughInSwitchStatementJS=0A=
      switch (step) {=0A=
        case 15:=0A=
        case 10:=0A=
          clone.seconds(Math.round(clone.seconds() / 5) * 5);=0A=
          clone.milliseconds(0);=0A=
          break;=0A=
        case 5:=0A=
          clone.milliseconds(Math.round(clone.milliseconds() / 1000) * =
1000);break;=0A=
        default:=0A=
          clone.milliseconds(Math.round(clone.milliseconds() / 500) * =
500);break;=0A=
      }=0A=
    } else if (scale =3D=3D 'millisecond') {=0A=
      var _step =3D step > 5 ? step / 2 : 1;=0A=
      clone.milliseconds(Math.round(clone.milliseconds() / _step) * =
_step);=0A=
    }=0A=
=0A=
    return clone;=0A=
  };=0A=
=0A=
  /**=0A=
   * Check if the current value is a major value (for example when the =
step=0A=
   * is DAY, a major value is each first day of the MONTH)=0A=
   * @return {boolean} true if current date is major, else false.=0A=
   */=0A=
  TimeStep.prototype.isMajor =3D function () {=0A=
    if (this.switchedYear =3D=3D true) {=0A=
      this.switchedYear =3D false;=0A=
      switch (this.scale) {=0A=
        case 'year':=0A=
        case 'month':=0A=
        case 'weekday':=0A=
        case 'day':=0A=
        case 'hour':=0A=
        case 'minute':=0A=
        case 'second':=0A=
        case 'millisecond':=0A=
          return true;=0A=
        default:=0A=
          return false;=0A=
      }=0A=
    } else if (this.switchedMonth =3D=3D true) {=0A=
      this.switchedMonth =3D false;=0A=
      switch (this.scale) {=0A=
        case 'weekday':=0A=
        case 'day':=0A=
        case 'hour':=0A=
        case 'minute':=0A=
        case 'second':=0A=
        case 'millisecond':=0A=
          return true;=0A=
        default:=0A=
          return false;=0A=
      }=0A=
    } else if (this.switchedDay =3D=3D true) {=0A=
      this.switchedDay =3D false;=0A=
      switch (this.scale) {=0A=
        case 'millisecond':=0A=
        case 'second':=0A=
        case 'minute':=0A=
        case 'hour':=0A=
          return true;=0A=
        default:=0A=
          return false;=0A=
      }=0A=
    }=0A=
=0A=
    var date =3D this.moment(this.current);=0A=
    switch (this.scale) {=0A=
      case 'millisecond':=0A=
        return date.milliseconds() =3D=3D 0;=0A=
      case 'second':=0A=
        return date.seconds() =3D=3D 0;=0A=
      case 'minute':=0A=
        return date.hours() =3D=3D 0 && date.minutes() =3D=3D 0;=0A=
      case 'hour':=0A=
        return date.hours() =3D=3D 0;=0A=
      case 'weekday': // intentional fall through=0A=
      case 'day':=0A=
        return date.date() =3D=3D 1;=0A=
      case 'month':=0A=
        return date.month() =3D=3D 0;=0A=
      case 'year':=0A=
        return false;=0A=
      default:=0A=
        return false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Returns formatted text for the minor axislabel, depending on the =
current=0A=
   * date and the scale. For example when scale is MINUTE, the current =
time is=0A=
   * formatted as "hh:mm".=0A=
   * @param {Date} [date] custom date. if not provided, current date is =
taken=0A=
   */=0A=
  TimeStep.prototype.getLabelMinor =3D function (date) {=0A=
    if (date =3D=3D undefined) {=0A=
      date =3D this.current;=0A=
    }=0A=
=0A=
    var format =3D this.format.minorLabels[this.scale];=0A=
    return format && format.length > 0 ? =
this.moment(date).format(format) : '';=0A=
  };=0A=
=0A=
  /**=0A=
   * Returns formatted text for the major axis label, depending on the =
current=0A=
   * date and the scale. For example when scale is MINUTE, the major =
scale is=0A=
   * hours, and the hour will be formatted as "hh".=0A=
   * @param {Date} [date] custom date. if not provided, current date is =
taken=0A=
   */=0A=
  TimeStep.prototype.getLabelMajor =3D function (date) {=0A=
    if (date =3D=3D undefined) {=0A=
      date =3D this.current;=0A=
    }=0A=
=0A=
    var format =3D this.format.majorLabels[this.scale];=0A=
    return format && format.length > 0 ? =
this.moment(date).format(format) : '';=0A=
  };=0A=
=0A=
  TimeStep.prototype.getClassName =3D function () {=0A=
    var _moment =3D this.moment;=0A=
    var m =3D this.moment(this.current);=0A=
    var current =3D m.locale ? m.locale('en') : m.lang('en'); // old =
versions of moment have .lang() function=0A=
    var step =3D this.step;=0A=
=0A=
    function even(value) {=0A=
      return value / step % 2 =3D=3D 0 ? ' vis-even' : ' vis-odd';=0A=
    }=0A=
=0A=
    function today(date) {=0A=
      if (date.isSame(new Date(), 'day')) {=0A=
        return ' vis-today';=0A=
      }=0A=
      if (date.isSame(_moment().add(1, 'day'), 'day')) {=0A=
        return ' vis-tomorrow';=0A=
      }=0A=
      if (date.isSame(_moment().add(-1, 'day'), 'day')) {=0A=
        return ' vis-yesterday';=0A=
      }=0A=
      return '';=0A=
    }=0A=
=0A=
    function currentWeek(date) {=0A=
      return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';=0A=
    }=0A=
=0A=
    function currentMonth(date) {=0A=
      return date.isSame(new Date(), 'month') ? ' vis-current-month' : =
'';=0A=
    }=0A=
=0A=
    function currentYear(date) {=0A=
      return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';=0A=
    }=0A=
=0A=
    switch (this.scale) {=0A=
      case 'millisecond':=0A=
        return even(current.milliseconds()).trim();=0A=
=0A=
      case 'second':=0A=
        return even(current.seconds()).trim();=0A=
=0A=
      case 'minute':=0A=
        return even(current.minutes()).trim();=0A=
=0A=
      case 'hour':=0A=
        var hours =3D current.hours();=0A=
        if (this.step =3D=3D 4) {=0A=
          hours =3D hours + '-h' + (hours + 4);=0A=
        }=0A=
        return 'vis-h' + hours + today(current) + even(current.hours());=0A=
=0A=
      case 'weekday':=0A=
        return 'vis-' + current.format('dddd').toLowerCase() + =
today(current) + currentWeek(current) + even(current.date());=0A=
=0A=
      case 'day':=0A=
        var day =3D current.date();=0A=
        var month =3D current.format('MMMM').toLowerCase();=0A=
        return 'vis-day' + day + ' vis-' + month + currentMonth(current) =
+ even(day - 1);=0A=
=0A=
      case 'month':=0A=
        return 'vis-' + current.format('MMMM').toLowerCase() + =
currentMonth(current) + even(current.month());=0A=
=0A=
      case 'year':=0A=
        var year =3D current.year();=0A=
        return 'vis-year' + year + currentYear(current) + even(year);=0A=
=0A=
      default:=0A=
        return '';=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D TimeStep;=0A=
=0A=
/***/ },=0A=
/* 36 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var Group =3D __webpack_require__(32);=0A=
=0A=
  /**=0A=
   * @constructor BackgroundGroup=0A=
   * @param {Number | String} groupId=0A=
   * @param {Object} data=0A=
   * @param {ItemSet} itemSet=0A=
   */=0A=
  function BackgroundGroup(groupId, data, itemSet) {=0A=
    Group.call(this, groupId, data, itemSet);=0A=
=0A=
    this.width =3D 0;=0A=
    this.height =3D 0;=0A=
    this.top =3D 0;=0A=
    this.left =3D 0;=0A=
  }=0A=
=0A=
  BackgroundGroup.prototype =3D Object.create(Group.prototype);=0A=
=0A=
  /**=0A=
   * Repaint this group=0A=
   * @param {{start: number, end: number}} range=0A=
   * @param {{item: {horizontal: number, vertical: number}, axis: =
number}} margin=0A=
   * @param {boolean} [restack=3Dfalse]  Force restacking of all items=0A=
   * @return {boolean} Returns true if the group is resized=0A=
   */=0A=
  BackgroundGroup.prototype.redraw =3D function (range, margin, restack) =
{=0A=
    var resized =3D false;=0A=
=0A=
    this.visibleItems =3D this._updateVisibleItems(this.orderedItems, =
this.visibleItems, range);=0A=
=0A=
    // calculate actual size=0A=
    this.width =3D this.dom.background.offsetWidth;=0A=
=0A=
    // apply new height (just always zero for BackgroundGroup=0A=
    this.dom.background.style.height =3D '0';=0A=
=0A=
    // update vertical position of items after they are re-stacked and =
the height of the group is calculated=0A=
    for (var i =3D 0, ii =3D this.visibleItems.length; i < ii; i++) {=0A=
      var item =3D this.visibleItems[i];=0A=
      item.repositionY(margin);=0A=
    }=0A=
=0A=
    return resized;=0A=
  };=0A=
=0A=
  /**=0A=
   * Show this group: attach to the DOM=0A=
   */=0A=
  BackgroundGroup.prototype.show =3D function () {=0A=
    if (!this.dom.background.parentNode) {=0A=
      this.itemSet.dom.background.appendChild(this.dom.background);=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D BackgroundGroup;=0A=
=0A=
/***/ },=0A=
/* 37 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Item =3D __webpack_require__(2);=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * @constructor BoxItem=0A=
   * @extends Item=0A=
   * @param {Object} data             Object containing parameters start=0A=
   *                                  content, className.=0A=
   * @param {{toScreen: function, toTime: function}} conversion=0A=
   *                                  Conversion functions from time to =
screen and vice versa=0A=
   * @param {Object} [options]        Configuration options=0A=
   *                                  // TODO: describe available options=0A=
   */=0A=
  function BoxItem(data, conversion, options) {=0A=
    this.props =3D {=0A=
      dot: {=0A=
        width: 0,=0A=
        height: 0=0A=
      },=0A=
      line: {=0A=
        width: 0,=0A=
        height: 0=0A=
      }=0A=
    };=0A=
=0A=
    // validate data=0A=
    if (data) {=0A=
      if (data.start =3D=3D undefined) {=0A=
        throw new Error('Property "start" missing in item ' + data);=0A=
      }=0A=
    }=0A=
=0A=
    Item.call(this, data, conversion, options);=0A=
  }=0A=
=0A=
  BoxItem.prototype =3D new Item(null, null, null);=0A=
=0A=
  /**=0A=
   * Check whether this item is visible inside given range=0A=
   * @returns {{start: Number, end: Number}} range with a timestamp for =
start and end=0A=
   * @returns {boolean} True if visible=0A=
   */=0A=
  BoxItem.prototype.isVisible =3D function (range) {=0A=
    // determine visibility=0A=
    // TODO: account for the real width of the item. Right now we just =
add 1/4 to the window=0A=
    var interval =3D (range.end - range.start) / 4;=0A=
    return this.data.start > range.start - interval && this.data.start < =
range.end + interval;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the item=0A=
   */=0A=
  BoxItem.prototype.redraw =3D function () {=0A=
    var dom =3D this.dom;=0A=
    if (!dom) {=0A=
      // create DOM=0A=
      this.dom =3D {};=0A=
      dom =3D this.dom;=0A=
=0A=
      // create main box=0A=
      dom.box =3D document.createElement('DIV');=0A=
=0A=
      // contents box (inside the background box). used for making =
margins=0A=
      dom.content =3D document.createElement('DIV');=0A=
      dom.content.className =3D 'vis-item-content';=0A=
      dom.box.appendChild(dom.content);=0A=
=0A=
      // line to axis=0A=
      dom.line =3D document.createElement('DIV');=0A=
      dom.line.className =3D 'vis-line';=0A=
=0A=
      // dot on axis=0A=
      dom.dot =3D document.createElement('DIV');=0A=
      dom.dot.className =3D 'vis-dot';=0A=
=0A=
      // attach this item as attribute=0A=
      dom.box['timeline-item'] =3D this;=0A=
=0A=
      this.dirty =3D true;=0A=
    }=0A=
=0A=
    // append DOM to parent DOM=0A=
    if (!this.parent) {=0A=
      throw new Error('Cannot redraw item: no parent attached');=0A=
    }=0A=
    if (!dom.box.parentNode) {=0A=
      var foreground =3D this.parent.dom.foreground;=0A=
      if (!foreground) throw new Error('Cannot redraw item: parent has =
no foreground container element');=0A=
      foreground.appendChild(dom.box);=0A=
    }=0A=
    if (!dom.line.parentNode) {=0A=
      var background =3D this.parent.dom.background;=0A=
      if (!background) throw new Error('Cannot redraw item: parent has =
no background container element');=0A=
      background.appendChild(dom.line);=0A=
    }=0A=
    if (!dom.dot.parentNode) {=0A=
      var axis =3D this.parent.dom.axis;=0A=
      if (!background) throw new Error('Cannot redraw item: parent has =
no axis container element');=0A=
      axis.appendChild(dom.dot);=0A=
    }=0A=
    this.displayed =3D true;=0A=
=0A=
    // Update DOM when item is marked dirty. An item is marked dirty =
when:=0A=
    // - the item is not yet rendered=0A=
    // - the item's data is changed=0A=
    // - the item is selected/deselected=0A=
    if (this.dirty) {=0A=
      this._updateContents(this.dom.content);=0A=
      this._updateTitle(this.dom.box);=0A=
      this._updateDataAttributes(this.dom.box);=0A=
      this._updateStyle(this.dom.box);=0A=
=0A=
      var editable =3D (this.options.editable.updateTime || =
this.options.editable.updateGroup || this.editable =3D=3D=3D true) && =
this.editable !=3D=3D false;=0A=
=0A=
      // update class=0A=
      var className =3D (this.data.className ? ' ' + this.data.className =
: '') + (this.selected ? ' vis-selected' : '') + (editable ? ' =
vis-editable' : ' vis-readonly');=0A=
      dom.box.className =3D 'vis-item vis-box' + className;=0A=
      dom.line.className =3D 'vis-item vis-line' + className;=0A=
      dom.dot.className =3D 'vis-item vis-dot' + className;=0A=
=0A=
      // recalculate size=0A=
      this.props.dot.height =3D dom.dot.offsetHeight;=0A=
      this.props.dot.width =3D dom.dot.offsetWidth;=0A=
      this.props.line.width =3D dom.line.offsetWidth;=0A=
      this.width =3D dom.box.offsetWidth;=0A=
      this.height =3D dom.box.offsetHeight;=0A=
=0A=
      this.dirty =3D false;=0A=
    }=0A=
=0A=
    this._repaintDeleteButton(dom.box);=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the item in the DOM (when not already displayed). The items =
DOM will=0A=
   * be created when needed.=0A=
   */=0A=
  BoxItem.prototype.show =3D function () {=0A=
    if (!this.displayed) {=0A=
      this.redraw();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the item from the DOM (when visible)=0A=
   */=0A=
  BoxItem.prototype.hide =3D function () {=0A=
    if (this.displayed) {=0A=
      var dom =3D this.dom;=0A=
=0A=
      if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);=0A=
      if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);=0A=
      if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);=0A=
=0A=
      this.displayed =3D false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Reposition the item horizontally=0A=
   * @Override=0A=
   */=0A=
  BoxItem.prototype.repositionX =3D function () {=0A=
    var start =3D this.conversion.toScreen(this.data.start);=0A=
    var align =3D this.options.align;=0A=
    var left;=0A=
=0A=
    // calculate left position of the box=0A=
    if (align =3D=3D 'right') {=0A=
      this.left =3D start - this.width;=0A=
    } else if (align =3D=3D 'left') {=0A=
      this.left =3D start;=0A=
    } else {=0A=
      // default or 'center'=0A=
      this.left =3D start - this.width / 2;=0A=
    }=0A=
=0A=
    // reposition box=0A=
    this.dom.box.style.left =3D this.left + 'px';=0A=
=0A=
    // reposition line=0A=
    this.dom.line.style.left =3D start - this.props.line.width / 2 + =
'px';=0A=
=0A=
    // reposition dot=0A=
    this.dom.dot.style.left =3D start - this.props.dot.width / 2 + 'px';=0A=
  };=0A=
=0A=
  /**=0A=
   * Reposition the item vertically=0A=
   * @Override=0A=
   */=0A=
  BoxItem.prototype.repositionY =3D function () {=0A=
    var orientation =3D this.options.orientation.item;=0A=
    var box =3D this.dom.box;=0A=
    var line =3D this.dom.line;=0A=
    var dot =3D this.dom.dot;=0A=
=0A=
    if (orientation =3D=3D 'top') {=0A=
      box.style.top =3D (this.top || 0) + 'px';=0A=
=0A=
      line.style.top =3D '0';=0A=
      line.style.height =3D this.parent.top + this.top + 1 + 'px';=0A=
      line.style.bottom =3D '';=0A=
    } else {=0A=
      // orientation 'bottom'=0A=
      var itemSetHeight =3D this.parent.itemSet.props.height; // TODO: =
this is nasty=0A=
      var lineHeight =3D itemSetHeight - this.parent.top - =
this.parent.height + this.top;=0A=
=0A=
      box.style.top =3D (this.parent.height - this.top - this.height || =
0) + 'px';=0A=
      line.style.top =3D itemSetHeight - lineHeight + 'px';=0A=
      line.style.bottom =3D '0';=0A=
    }=0A=
=0A=
    dot.style.top =3D -this.props.dot.height / 2 + 'px';=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the width of the item left from its start date=0A=
   * @return {number}=0A=
   */=0A=
  BoxItem.prototype.getWidthLeft =3D function () {=0A=
    return this.width / 2;=0A=
  };=0A=
=0A=
  /**=0A=
   * Return the width of the item right from its start date=0A=
   * @return {number}=0A=
   */=0A=
  BoxItem.prototype.getWidthRight =3D function () {=0A=
    return this.width / 2;=0A=
  };=0A=
=0A=
  module.exports =3D BoxItem;=0A=
=0A=
/***/ },=0A=
/* 38 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var Item =3D __webpack_require__(2);=0A=
  var BackgroundGroup =3D __webpack_require__(36);=0A=
  var RangeItem =3D __webpack_require__(34);=0A=
=0A=
  /**=0A=
   * @constructor BackgroundItem=0A=
   * @extends Item=0A=
   * @param {Object} data             Object containing parameters =
start, end=0A=
   *                                  content, className.=0A=
   * @param {{toScreen: function, toTime: function}} conversion=0A=
   *                                  Conversion functions from time to =
screen and vice versa=0A=
   * @param {Object} [options]        Configuration options=0A=
   *                                  // TODO: describe options=0A=
   */=0A=
  // TODO: implement support for the BackgroundItem just having a start, =
then being displayed as a sort of an annotation=0A=
  function BackgroundItem(data, conversion, options) {=0A=
    this.props =3D {=0A=
      content: {=0A=
        width: 0=0A=
      }=0A=
    };=0A=
    this.overflow =3D false; // if contents can overflow (css styling), =
this flag is set to true=0A=
=0A=
    // validate data=0A=
    if (data) {=0A=
      if (data.start =3D=3D undefined) {=0A=
        throw new Error('Property "start" missing in item ' + data.id);=0A=
      }=0A=
      if (data.end =3D=3D undefined) {=0A=
        throw new Error('Property "end" missing in item ' + data.id);=0A=
      }=0A=
    }=0A=
=0A=
    Item.call(this, data, conversion, options);=0A=
  }=0A=
=0A=
  BackgroundItem.prototype =3D new Item(null, null, null);=0A=
=0A=
  BackgroundItem.prototype.baseClassName =3D 'vis-item vis-background';=0A=
  BackgroundItem.prototype.stack =3D false;=0A=
=0A=
  /**=0A=
   * Check whether this item is visible inside given range=0A=
   * @returns {{start: Number, end: Number}} range with a timestamp for =
start and end=0A=
   * @returns {boolean} True if visible=0A=
   */=0A=
  BackgroundItem.prototype.isVisible =3D function (range) {=0A=
    // determine visibility=0A=
    return this.data.start < range.end && this.data.end > range.start;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the item=0A=
   */=0A=
  BackgroundItem.prototype.redraw =3D function () {=0A=
    var dom =3D this.dom;=0A=
    if (!dom) {=0A=
      // create DOM=0A=
      this.dom =3D {};=0A=
      dom =3D this.dom;=0A=
=0A=
      // background box=0A=
      dom.box =3D document.createElement('div');=0A=
      // className is updated in redraw()=0A=
=0A=
      // frame box (to prevent the item contents from overflowing=0A=
      dom.frame =3D document.createElement('div');=0A=
      dom.frame.className =3D 'vis-item-overflow';=0A=
      dom.box.appendChild(dom.frame);=0A=
=0A=
      // contents box=0A=
      dom.content =3D document.createElement('div');=0A=
      dom.content.className =3D 'vis-item-content';=0A=
      dom.frame.appendChild(dom.content);=0A=
=0A=
      // Note: we do NOT attach this item as attribute to the DOM,=0A=
      //       such that background items cannot be selected=0A=
      //dom.box['timeline-item'] =3D this;=0A=
=0A=
      this.dirty =3D true;=0A=
    }=0A=
=0A=
    // append DOM to parent DOM=0A=
    if (!this.parent) {=0A=
      throw new Error('Cannot redraw item: no parent attached');=0A=
    }=0A=
    if (!dom.box.parentNode) {=0A=
      var background =3D this.parent.dom.background;=0A=
      if (!background) {=0A=
        throw new Error('Cannot redraw item: parent has no background =
container element');=0A=
      }=0A=
      background.appendChild(dom.box);=0A=
    }=0A=
    this.displayed =3D true;=0A=
=0A=
    // Update DOM when item is marked dirty. An item is marked dirty =
when:=0A=
    // - the item is not yet rendered=0A=
    // - the item's data is changed=0A=
    // - the item is selected/deselected=0A=
    if (this.dirty) {=0A=
      this._updateContents(this.dom.content);=0A=
      this._updateTitle(this.dom.content);=0A=
      this._updateDataAttributes(this.dom.content);=0A=
      this._updateStyle(this.dom.box);=0A=
=0A=
      // update class=0A=
      var className =3D (this.data.className ? ' ' + this.data.className =
: '') + (this.selected ? ' vis-selected' : '');=0A=
      dom.box.className =3D this.baseClassName + className;=0A=
=0A=
      // determine from css whether this box has overflow=0A=
      this.overflow =3D window.getComputedStyle(dom.content).overflow =
!=3D=3D 'hidden';=0A=
=0A=
      // recalculate size=0A=
      this.props.content.width =3D this.dom.content.offsetWidth;=0A=
      this.height =3D 0; // set height zero, so this item will be =
ignored when stacking items=0A=
=0A=
      this.dirty =3D false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the item in the DOM (when not already visible). The items DOM =
will=0A=
   * be created when needed.=0A=
   */=0A=
  BackgroundItem.prototype.show =3D RangeItem.prototype.show;=0A=
=0A=
  /**=0A=
   * Hide the item from the DOM (when visible)=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  BackgroundItem.prototype.hide =3D RangeItem.prototype.hide;=0A=
=0A=
  /**=0A=
   * Reposition the item horizontally=0A=
   * @Override=0A=
   */=0A=
  BackgroundItem.prototype.repositionX =3D =
RangeItem.prototype.repositionX;=0A=
=0A=
  /**=0A=
   * Reposition the item vertically=0A=
   * @Override=0A=
   */=0A=
  BackgroundItem.prototype.repositionY =3D function (margin) {=0A=
    var onTop =3D this.options.orientation.item =3D=3D=3D 'top';=0A=
    this.dom.content.style.top =3D onTop ? '' : '0';=0A=
    this.dom.content.style.bottom =3D onTop ? '0' : '';=0A=
    var height;=0A=
=0A=
    // special positioning for subgroups=0A=
    if (this.data.subgroup !=3D=3D undefined) {=0A=
      // TODO: instead of calculating the top position of the subgroups =
here for every BackgroundItem, calculate the top of the subgroup once in =
Itemset=0A=
=0A=
      var itemSubgroup =3D this.data.subgroup;=0A=
      var subgroups =3D this.parent.subgroups;=0A=
      var subgroupIndex =3D subgroups[itemSubgroup].index;=0A=
      // if the orientation is top, we need to take the difference in =
height into account.=0A=
      if (onTop =3D=3D true) {=0A=
        // the first subgroup will have to account for the distance from =
the top to the first item.=0A=
        height =3D this.parent.subgroups[itemSubgroup].height + =
margin.item.vertical;=0A=
        height +=3D subgroupIndex =3D=3D 0 ? margin.axis - 0.5 * =
margin.item.vertical : 0;=0A=
        var newTop =3D this.parent.top;=0A=
        for (var subgroup in subgroups) {=0A=
          if (subgroups.hasOwnProperty(subgroup)) {=0A=
            if (subgroups[subgroup].visible =3D=3D true && =
subgroups[subgroup].index < subgroupIndex) {=0A=
              newTop +=3D subgroups[subgroup].height + =
margin.item.vertical;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // the others will have to be offset downwards with this same =
distance.=0A=
        newTop +=3D subgroupIndex !=3D 0 ? margin.axis - 0.5 * =
margin.item.vertical : 0;=0A=
        this.dom.box.style.top =3D newTop + 'px';=0A=
        this.dom.box.style.bottom =3D '';=0A=
      }=0A=
      // and when the orientation is bottom:=0A=
      else {=0A=
        var newTop =3D this.parent.top;=0A=
        var totalHeight =3D 0;=0A=
        for (var subgroup in subgroups) {=0A=
          if (subgroups.hasOwnProperty(subgroup)) {=0A=
            if (subgroups[subgroup].visible =3D=3D true) {=0A=
              var newHeight =3D subgroups[subgroup].height + =
margin.item.vertical;=0A=
              totalHeight +=3D newHeight;=0A=
              if (subgroups[subgroup].index > subgroupIndex) {=0A=
                newTop +=3D newHeight;=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
        height =3D this.parent.subgroups[itemSubgroup].height + =
margin.item.vertical;=0A=
        this.dom.box.style.top =3D this.parent.height - totalHeight + =
newTop + 'px';=0A=
        this.dom.box.style.bottom =3D '';=0A=
      }=0A=
    }=0A=
    // and in the case of no subgroups:=0A=
    else {=0A=
      // we want backgrounds with groups to only show in groups.=0A=
      if (this.parent instanceof BackgroundGroup) {=0A=
        // if the item is not in a group:=0A=
        height =3D Math.max(this.parent.height, =
this.parent.itemSet.body.domProps.center.height, =
this.parent.itemSet.body.domProps.centerContainer.height);=0A=
        this.dom.box.style.top =3D onTop ? '0' : '';=0A=
        this.dom.box.style.bottom =3D onTop ? '' : '0';=0A=
      } else {=0A=
        height =3D this.parent.height;=0A=
        // same alignment for items when orientation is top or bottom=0A=
        this.dom.box.style.top =3D this.parent.top + 'px';=0A=
        this.dom.box.style.bottom =3D '';=0A=
      }=0A=
    }=0A=
    this.dom.box.style.height =3D height + 'px';=0A=
  };=0A=
=0A=
  module.exports =3D BackgroundItem;=0A=
=0A=
/***/ },=0A=
/* 39 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var Component =3D __webpack_require__(28);=0A=
  var TimeStep =3D __webpack_require__(35);=0A=
  var DateUtil =3D __webpack_require__(29);=0A=
  var moment =3D __webpack_require__(8);=0A=
=0A=
  /**=0A=
   * A horizontal time axis=0A=
   * @param {{dom: Object, domProps: Object, emitter: Emitter, range: =
Range}} body=0A=
   * @param {Object} [options]        See TimeAxis.setOptions for the =
available=0A=
   *                                  options.=0A=
   * @constructor TimeAxis=0A=
   * @extends Component=0A=
   */=0A=
  function TimeAxis(body, options) {=0A=
    this.dom =3D {=0A=
      foreground: null,=0A=
      lines: [],=0A=
      majorTexts: [],=0A=
      minorTexts: [],=0A=
      redundant: {=0A=
        lines: [],=0A=
        majorTexts: [],=0A=
        minorTexts: []=0A=
      }=0A=
    };=0A=
    this.props =3D {=0A=
      range: {=0A=
        start: 0,=0A=
        end: 0,=0A=
        minimumStep: 0=0A=
      },=0A=
      lineTop: 0=0A=
    };=0A=
=0A=
    this.defaultOptions =3D {=0A=
      orientation: {=0A=
        axis: 'bottom'=0A=
      }, // axis orientation: 'top' or 'bottom'=0A=
      showMinorLabels: true,=0A=
      showMajorLabels: true,=0A=
      format: TimeStep.FORMAT,=0A=
      moment: moment,=0A=
      timeAxis: null=0A=
    };=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
=0A=
    this.body =3D body;=0A=
=0A=
    // create the HTML DOM=0A=
    this._create();=0A=
=0A=
    this.setOptions(options);=0A=
  }=0A=
=0A=
  TimeAxis.prototype =3D new Component();=0A=
=0A=
  /**=0A=
   * Set options for the TimeAxis.=0A=
   * Parameters will be merged in current options.=0A=
   * @param {Object} options  Available options:=0A=
   *                          {string} [orientation.axis]=0A=
   *                          {boolean} [showMinorLabels]=0A=
   *                          {boolean} [showMajorLabels]=0A=
   */=0A=
  TimeAxis.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      // copy all options that we know=0A=
      util.selectiveExtend(['showMinorLabels', 'showMajorLabels', =
'hiddenDates', 'timeAxis', 'moment'], this.options, options);=0A=
=0A=
      // deep copy the format options=0A=
      util.selectiveDeepExtend(['format'], this.options, options);=0A=
=0A=
      if ('orientation' in options) {=0A=
        if (typeof options.orientation =3D=3D=3D 'string') {=0A=
          this.options.orientation.axis =3D options.orientation;=0A=
        } else if (typeof options.orientation =3D=3D=3D 'object' && =
'axis' in options.orientation) {=0A=
          this.options.orientation.axis =3D options.orientation.axis;=0A=
        }=0A=
      }=0A=
=0A=
      // apply locale to moment.js=0A=
      // TODO: not so nice, this is applied globally to moment.js=0A=
      if ('locale' in options) {=0A=
        if (typeof moment.locale =3D=3D=3D 'function') {=0A=
          // moment.js 2.8.1+=0A=
          moment.locale(options.locale);=0A=
        } else {=0A=
          moment.lang(options.locale);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create the HTML DOM for the TimeAxis=0A=
   */=0A=
  TimeAxis.prototype._create =3D function () {=0A=
    this.dom.foreground =3D document.createElement('div');=0A=
    this.dom.background =3D document.createElement('div');=0A=
=0A=
    this.dom.foreground.className =3D 'vis-time-axis vis-foreground';=0A=
    this.dom.background.className =3D 'vis-time-axis vis-background';=0A=
  };=0A=
=0A=
  /**=0A=
   * Destroy the TimeAxis=0A=
   */=0A=
  TimeAxis.prototype.destroy =3D function () {=0A=
    // remove from DOM=0A=
    if (this.dom.foreground.parentNode) {=0A=
      this.dom.foreground.parentNode.removeChild(this.dom.foreground);=0A=
    }=0A=
    if (this.dom.background.parentNode) {=0A=
      this.dom.background.parentNode.removeChild(this.dom.background);=0A=
    }=0A=
=0A=
    this.body =3D null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the component=0A=
   * @return {boolean} Returns true if the component is resized=0A=
   */=0A=
  TimeAxis.prototype.redraw =3D function () {=0A=
    var props =3D this.props;=0A=
    var foreground =3D this.dom.foreground;=0A=
    var background =3D this.dom.background;=0A=
=0A=
    // determine the correct parent DOM element (depending on option =
orientation)=0A=
    var parent =3D this.options.orientation.axis =3D=3D 'top' ? =
this.body.dom.top : this.body.dom.bottom;=0A=
    var parentChanged =3D foreground.parentNode !=3D=3D parent;=0A=
=0A=
    // calculate character width and height=0A=
    this._calculateCharSize();=0A=
=0A=
    // TODO: recalculate sizes only needed when parent is resized or =
options is changed=0A=
    var showMinorLabels =3D this.options.showMinorLabels && =
this.options.orientation.axis !=3D=3D 'none';=0A=
    var showMajorLabels =3D this.options.showMajorLabels && =
this.options.orientation.axis !=3D=3D 'none';=0A=
=0A=
    // determine the width and height of the elemens for the axis=0A=
    props.minorLabelHeight =3D showMinorLabels ? props.minorCharHeight : =
0;=0A=
    props.majorLabelHeight =3D showMajorLabels ? props.majorCharHeight : =
0;=0A=
    props.height =3D props.minorLabelHeight + props.majorLabelHeight;=0A=
    props.width =3D foreground.offsetWidth;=0A=
=0A=
    props.minorLineHeight =3D this.body.domProps.root.height - =
props.majorLabelHeight - (this.options.orientation.axis =3D=3D 'top' ? =
this.body.domProps.bottom.height : this.body.domProps.top.height);=0A=
    props.minorLineWidth =3D 1; // TODO: really calculate width=0A=
    props.majorLineHeight =3D props.minorLineHeight + =
props.majorLabelHeight;=0A=
    props.majorLineWidth =3D 1; // TODO: really calculate width=0A=
=0A=
    //  take foreground and background offline while updating (is almost =
twice as fast)=0A=
    var foregroundNextSibling =3D foreground.nextSibling;=0A=
    var backgroundNextSibling =3D background.nextSibling;=0A=
    foreground.parentNode && =
foreground.parentNode.removeChild(foreground);=0A=
    background.parentNode && =
background.parentNode.removeChild(background);=0A=
=0A=
    foreground.style.height =3D this.props.height + 'px';=0A=
=0A=
    this._repaintLabels();=0A=
=0A=
    // put DOM online again (at the same place)=0A=
    if (foregroundNextSibling) {=0A=
      parent.insertBefore(foreground, foregroundNextSibling);=0A=
    } else {=0A=
      parent.appendChild(foreground);=0A=
    }=0A=
    if (backgroundNextSibling) {=0A=
      this.body.dom.backgroundVertical.insertBefore(background, =
backgroundNextSibling);=0A=
    } else {=0A=
      this.body.dom.backgroundVertical.appendChild(background);=0A=
    }=0A=
=0A=
    return this._isResized() || parentChanged;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint major and minor text labels and vertical grid lines=0A=
   * @private=0A=
   */=0A=
  TimeAxis.prototype._repaintLabels =3D function () {=0A=
    var orientation =3D this.options.orientation.axis;=0A=
=0A=
    // calculate range and step (step such that we have space for 7 =
characters per label)=0A=
    var start =3D util.convert(this.body.range.start, 'Number');=0A=
    var end =3D util.convert(this.body.range.end, 'Number');=0A=
    var timeLabelsize =3D =
this.body.util.toTime((this.props.minorCharWidth || 10) * 7).valueOf();=0A=
    var minimumStep =3D timeLabelsize - =
DateUtil.getHiddenDurationBefore(this.options.moment, =
this.body.hiddenDates, this.body.range, timeLabelsize);=0A=
    minimumStep -=3D this.body.util.toTime(0).valueOf();=0A=
=0A=
    var step =3D new TimeStep(new Date(start), new Date(end), =
minimumStep, this.body.hiddenDates);=0A=
    step.setMoment(this.options.moment);=0A=
    if (this.options.format) {=0A=
      step.setFormat(this.options.format);=0A=
    }=0A=
    if (this.options.timeAxis) {=0A=
      step.setScale(this.options.timeAxis);=0A=
    }=0A=
    this.step =3D step;=0A=
=0A=
    // Move all DOM elements to a "redundant" list, where they=0A=
    // can be picked for re-use, and clear the lists with lines and =
texts.=0A=
    // At the end of the function _repaintLabels, left over elements =
will be cleaned up=0A=
    var dom =3D this.dom;=0A=
    dom.redundant.lines =3D dom.lines;=0A=
    dom.redundant.majorTexts =3D dom.majorTexts;=0A=
    dom.redundant.minorTexts =3D dom.minorTexts;=0A=
    dom.lines =3D [];=0A=
    dom.majorTexts =3D [];=0A=
    dom.minorTexts =3D [];=0A=
=0A=
    var current;=0A=
    var next;=0A=
    var x;=0A=
    var xNext;=0A=
    var isMajor;=0A=
    var width;=0A=
    var line;=0A=
    var labelMinor;=0A=
    var xFirstMajorLabel =3D undefined;=0A=
    var max =3D 0;=0A=
    var className;=0A=
=0A=
    step.start();=0A=
    next =3D step.getCurrent();=0A=
    xNext =3D this.body.util.toScreen(next);=0A=
    while (step.hasNext() && max < 1000) {=0A=
      max++;=0A=
=0A=
      isMajor =3D step.isMajor();=0A=
      className =3D step.getClassName();=0A=
      labelMinor =3D step.getLabelMinor();=0A=
=0A=
      current =3D next;=0A=
      x =3D xNext;=0A=
=0A=
      step.next();=0A=
      next =3D step.getCurrent();=0A=
      xNext =3D this.body.util.toScreen(next);=0A=
=0A=
      width =3D xNext - x;=0A=
      var labelFits =3D (labelMinor.length + 1) * =
this.props.minorCharWidth < width;=0A=
=0A=
      if (this.options.showMinorLabels && labelFits) {=0A=
        this._repaintMinorText(x, labelMinor, orientation, className);=0A=
      }=0A=
=0A=
      if (isMajor && this.options.showMajorLabels) {=0A=
        if (x > 0) {=0A=
          if (xFirstMajorLabel =3D=3D undefined) {=0A=
            xFirstMajorLabel =3D x;=0A=
          }=0A=
          this._repaintMajorText(x, step.getLabelMajor(), orientation, =
className);=0A=
        }=0A=
        line =3D this._repaintMajorLine(x, width, orientation, =
className);=0A=
      } else {=0A=
        if (labelFits) {=0A=
          line =3D this._repaintMinorLine(x, width, orientation, =
className);=0A=
        } else {=0A=
          if (line) {=0A=
            line.style.width =3D parseInt(line.style.width) + width + =
'px';=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // create a major label on the left when needed=0A=
    if (this.options.showMajorLabels) {=0A=
      var leftTime =3D this.body.util.toTime(0),=0A=
          leftText =3D step.getLabelMajor(leftTime),=0A=
          widthText =3D leftText.length * (this.props.majorCharWidth || =
10) + 10; // upper bound estimation=0A=
=0A=
      if (xFirstMajorLabel =3D=3D undefined || widthText < =
xFirstMajorLabel) {=0A=
        this._repaintMajorText(0, leftText, orientation, className);=0A=
      }=0A=
    }=0A=
=0A=
    // Cleanup leftover DOM elements from the redundant list=0A=
    util.forEach(this.dom.redundant, function (arr) {=0A=
      while (arr.length) {=0A=
        var elem =3D arr.pop();=0A=
        if (elem && elem.parentNode) {=0A=
          elem.parentNode.removeChild(elem);=0A=
        }=0A=
      }=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a minor label for the axis at position x=0A=
   * @param {Number} x=0A=
   * @param {String} text=0A=
   * @param {String} orientation   "top" or "bottom" (default)=0A=
   * @param {String} className=0A=
   * @return {Element} Returns the HTML element of the created label=0A=
   * @private=0A=
   */=0A=
  TimeAxis.prototype._repaintMinorText =3D function (x, text, =
orientation, className) {=0A=
    // reuse redundant label=0A=
    var label =3D this.dom.redundant.minorTexts.shift();=0A=
=0A=
    if (!label) {=0A=
      // create new label=0A=
      var content =3D document.createTextNode('');=0A=
      label =3D document.createElement('div');=0A=
      label.appendChild(content);=0A=
      this.dom.foreground.appendChild(label);=0A=
    }=0A=
    this.dom.minorTexts.push(label);=0A=
=0A=
    label.childNodes[0].nodeValue =3D text;=0A=
=0A=
    label.style.top =3D orientation =3D=3D 'top' ? =
this.props.majorLabelHeight + 'px' : '0';=0A=
    label.style.left =3D x + 'px';=0A=
    label.className =3D 'vis-text vis-minor ' + className;=0A=
    //label.title =3D title;  // TODO: this is a heavy operation=0A=
=0A=
    return label;=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a Major label for the axis at position x=0A=
   * @param {Number} x=0A=
   * @param {String} text=0A=
   * @param {String} orientation   "top" or "bottom" (default)=0A=
   * @param {String} className=0A=
   * @return {Element} Returns the HTML element of the created label=0A=
   * @private=0A=
   */=0A=
  TimeAxis.prototype._repaintMajorText =3D function (x, text, =
orientation, className) {=0A=
    // reuse redundant label=0A=
    var label =3D this.dom.redundant.majorTexts.shift();=0A=
=0A=
    if (!label) {=0A=
      // create label=0A=
      var content =3D document.createTextNode(text);=0A=
      label =3D document.createElement('div');=0A=
      label.appendChild(content);=0A=
      this.dom.foreground.appendChild(label);=0A=
    }=0A=
    this.dom.majorTexts.push(label);=0A=
=0A=
    label.childNodes[0].nodeValue =3D text;=0A=
    label.className =3D 'vis-text vis-major ' + className;=0A=
    //label.title =3D title; // TODO: this is a heavy operation=0A=
=0A=
    label.style.top =3D orientation =3D=3D 'top' ? '0' : =
this.props.minorLabelHeight + 'px';=0A=
    label.style.left =3D x + 'px';=0A=
=0A=
    return label;=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a minor line for the axis at position x=0A=
   * @param {Number} x=0A=
   * @param {Number} width=0A=
   * @param {String} orientation   "top" or "bottom" (default)=0A=
   * @param {String} className=0A=
   * @return {Element} Returns the created line=0A=
   * @private=0A=
   */=0A=
  TimeAxis.prototype._repaintMinorLine =3D function (x, width, =
orientation, className) {=0A=
    // reuse redundant line=0A=
    var line =3D this.dom.redundant.lines.shift();=0A=
    if (!line) {=0A=
      // create vertical line=0A=
      line =3D document.createElement('div');=0A=
      this.dom.background.appendChild(line);=0A=
    }=0A=
    this.dom.lines.push(line);=0A=
=0A=
    var props =3D this.props;=0A=
    if (orientation =3D=3D 'top') {=0A=
      line.style.top =3D props.majorLabelHeight + 'px';=0A=
    } else {=0A=
      line.style.top =3D this.body.domProps.top.height + 'px';=0A=
    }=0A=
    line.style.height =3D props.minorLineHeight + 'px';=0A=
    line.style.left =3D x - props.minorLineWidth / 2 + 'px';=0A=
    line.style.width =3D width + 'px';=0A=
=0A=
    line.className =3D 'vis-grid vis-vertical vis-minor ' + className;=0A=
=0A=
    return line;=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a Major line for the axis at position x=0A=
   * @param {Number} x=0A=
   * @param {Number} width=0A=
   * @param {String} orientation   "top" or "bottom" (default)=0A=
   * @param {String} className=0A=
   * @return {Element} Returns the created line=0A=
   * @private=0A=
   */=0A=
  TimeAxis.prototype._repaintMajorLine =3D function (x, width, =
orientation, className) {=0A=
    // reuse redundant line=0A=
    var line =3D this.dom.redundant.lines.shift();=0A=
    if (!line) {=0A=
      // create vertical line=0A=
      line =3D document.createElement('div');=0A=
      this.dom.background.appendChild(line);=0A=
    }=0A=
    this.dom.lines.push(line);=0A=
=0A=
    var props =3D this.props;=0A=
    if (orientation =3D=3D 'top') {=0A=
      line.style.top =3D '0';=0A=
    } else {=0A=
      line.style.top =3D this.body.domProps.top.height + 'px';=0A=
    }=0A=
    line.style.left =3D x - props.majorLineWidth / 2 + 'px';=0A=
    line.style.height =3D props.majorLineHeight + 'px';=0A=
    line.style.width =3D width + 'px';=0A=
=0A=
    line.className =3D 'vis-grid vis-vertical vis-major ' + className;=0A=
=0A=
    return line;=0A=
  };=0A=
=0A=
  /**=0A=
   * Determine the size of text on the axis (both major and minor axis).=0A=
   * The size is calculated only once and then cached in this.props.=0A=
   * @private=0A=
   */=0A=
  TimeAxis.prototype._calculateCharSize =3D function () {=0A=
    // Note: We calculate char size with every redraw. Size may change, =
for=0A=
    // example when any of the timelines parents had display:none for =
example.=0A=
=0A=
    // determine the char width and height on the minor axis=0A=
    if (!this.dom.measureCharMinor) {=0A=
      this.dom.measureCharMinor =3D document.createElement('DIV');=0A=
      this.dom.measureCharMinor.className =3D 'vis-text vis-minor =
vis-measure';=0A=
      this.dom.measureCharMinor.style.position =3D 'absolute';=0A=
=0A=
      =
this.dom.measureCharMinor.appendChild(document.createTextNode('0'));=0A=
      this.dom.foreground.appendChild(this.dom.measureCharMinor);=0A=
    }=0A=
    this.props.minorCharHeight =3D =
this.dom.measureCharMinor.clientHeight;=0A=
    this.props.minorCharWidth =3D this.dom.measureCharMinor.clientWidth;=0A=
=0A=
    // determine the char width and height on the major axis=0A=
    if (!this.dom.measureCharMajor) {=0A=
      this.dom.measureCharMajor =3D document.createElement('DIV');=0A=
      this.dom.measureCharMajor.className =3D 'vis-text vis-major =
vis-measure';=0A=
      this.dom.measureCharMajor.style.position =3D 'absolute';=0A=
=0A=
      =
this.dom.measureCharMajor.appendChild(document.createTextNode('0'));=0A=
      this.dom.foreground.appendChild(this.dom.measureCharMajor);=0A=
    }=0A=
    this.props.majorCharHeight =3D =
this.dom.measureCharMajor.clientHeight;=0A=
    this.props.majorCharWidth =3D this.dom.measureCharMajor.clientWidth;=0A=
  };=0A=
=0A=
  module.exports =3D TimeAxis;=0A=
=0A=
/***/ },=0A=
/* 40 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var keycharm =3D __webpack_require__(41);=0A=
  var Emitter =3D __webpack_require__(19);=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * Turn an element into an clickToUse element.=0A=
   * When not active, the element has a transparent overlay. When the =
overlay is=0A=
   * clicked, the mode is changed to active.=0A=
   * When active, the element is displayed with a blue border around it, =
and=0A=
   * the interactive contents of the element can be used. When clicked =
outside=0A=
   * the element, the elements mode is changed to inactive.=0A=
   * @param {Element} container=0A=
   * @constructor=0A=
   */=0A=
  function Activator(container) {=0A=
    this.active =3D false;=0A=
=0A=
    this.dom =3D {=0A=
      container: container=0A=
    };=0A=
=0A=
    this.dom.overlay =3D document.createElement('div');=0A=
    this.dom.overlay.className =3D 'vis-overlay';=0A=
=0A=
    this.dom.container.appendChild(this.dom.overlay);=0A=
=0A=
    this.hammer =3D Hammer(this.dom.overlay);=0A=
    this.hammer.on('tap', this._onTapOverlay.bind(this));=0A=
=0A=
    // block all touch events (except tap)=0A=
    var me =3D this;=0A=
    var events =3D ['tap', 'doubletap', 'press', 'pinch', 'pan', =
'panstart', 'panmove', 'panend'];=0A=
    events.forEach(function (event) {=0A=
      me.hammer.on(event, function (event) {=0A=
        event.stopPropagation();=0A=
      });=0A=
    });=0A=
=0A=
    // attach a click event to the window, in order to deactivate when =
clicking outside the timeline=0A=
    if (document && document.body) {=0A=
      this.onClick =3D function (event) {=0A=
        if (!_hasParent(event.target, container)) {=0A=
          me.deactivate();=0A=
        }=0A=
      };=0A=
      document.body.addEventListener('click', this.onClick);=0A=
    }=0A=
=0A=
    if (this.keycharm !=3D=3D undefined) {=0A=
      this.keycharm.destroy();=0A=
    }=0A=
    this.keycharm =3D keycharm();=0A=
=0A=
    // keycharm listener only bounded when active)=0A=
    this.escListener =3D this.deactivate.bind(this);=0A=
  }=0A=
=0A=
  // turn into an event emitter=0A=
  Emitter(Activator.prototype);=0A=
=0A=
  // The currently active activator=0A=
  Activator.current =3D null;=0A=
=0A=
  /**=0A=
   * Destroy the activator. Cleans up all created DOM and event listeners=0A=
   */=0A=
  Activator.prototype.destroy =3D function () {=0A=
    this.deactivate();=0A=
=0A=
    // remove dom=0A=
    this.dom.overlay.parentNode.removeChild(this.dom.overlay);=0A=
=0A=
    // remove global event listener=0A=
    if (this.onClick) {=0A=
      document.body.removeEventListener('click', this.onClick);=0A=
    }=0A=
=0A=
    // cleanup hammer instances=0A=
    this.hammer.destroy();=0A=
    this.hammer =3D null;=0A=
    // FIXME: cleaning up hammer instances doesn't work (Timeline not =
removed from memory)=0A=
  };=0A=
=0A=
  /**=0A=
   * Activate the element=0A=
   * Overlay is hidden, element is decorated with a blue shadow border=0A=
   */=0A=
  Activator.prototype.activate =3D function () {=0A=
    // we allow only one active activator at a time=0A=
    if (Activator.current) {=0A=
      Activator.current.deactivate();=0A=
    }=0A=
    Activator.current =3D this;=0A=
=0A=
    this.active =3D true;=0A=
    this.dom.overlay.style.display =3D 'none';=0A=
    util.addClassName(this.dom.container, 'vis-active');=0A=
=0A=
    this.emit('change');=0A=
    this.emit('activate');=0A=
=0A=
    // ugly hack: bind ESC after emitting the events, as the Network =
rebinds all=0A=
    // keyboard events on a 'change' event=0A=
    this.keycharm.bind('esc', this.escListener);=0A=
  };=0A=
=0A=
  /**=0A=
   * Deactivate the element=0A=
   * Overlay is displayed on top of the element=0A=
   */=0A=
  Activator.prototype.deactivate =3D function () {=0A=
    this.active =3D false;=0A=
    this.dom.overlay.style.display =3D '';=0A=
    util.removeClassName(this.dom.container, 'vis-active');=0A=
    this.keycharm.unbind('esc', this.escListener);=0A=
=0A=
    this.emit('change');=0A=
    this.emit('deactivate');=0A=
  };=0A=
=0A=
  /**=0A=
   * Handle a tap event: activate the container=0A=
   * @param event=0A=
   * @private=0A=
   */=0A=
  Activator.prototype._onTapOverlay =3D function (event) {=0A=
    // activate the container=0A=
    this.activate();=0A=
    event.stopPropagation();=0A=
  };=0A=
=0A=
  /**=0A=
   * Test whether the element has the requested parent element somewhere =
in=0A=
   * its chain of parent nodes.=0A=
   * @param {HTMLElement} element=0A=
   * @param {HTMLElement} parent=0A=
   * @returns {boolean} Returns true when the parent is found somewhere =
in the=0A=
   *                    chain of parent nodes.=0A=
   * @private=0A=
   */=0A=
  function _hasParent(element, parent) {=0A=
    while (element) {=0A=
      if (element =3D=3D=3D parent) {=0A=
        return true;=0A=
      }=0A=
      element =3D element.parentNode;=0A=
    }=0A=
    return false;=0A=
  }=0A=
=0A=
  module.exports =3D Activator;=0A=
=0A=
/***/ },=0A=
/* 41 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, =
__WEBPACK_AMD_DEFINE_RESULT__;"use strict";=0A=
  /**=0A=
   * Created by Alex on 11/6/2014.=0A=
   */=0A=
=0A=
  // https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60=0A=
  // if the module has no dependencies, the above pattern can be =
simplified to=0A=
  (function (root, factory) {=0A=
    if (true) {=0A=
      // AMD. Register as an anonymous module.=0A=
      !(__WEBPACK_AMD_DEFINE_ARRAY__ =3D [], =
__WEBPACK_AMD_DEFINE_FACTORY__ =3D (factory), =
__WEBPACK_AMD_DEFINE_RESULT__ =3D (typeof __WEBPACK_AMD_DEFINE_FACTORY__ =
=3D=3D=3D 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, =
__WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), =
__WEBPACK_AMD_DEFINE_RESULT__ !=3D=3D undefined && (module.exports =3D =
__WEBPACK_AMD_DEFINE_RESULT__));=0A=
    } else if (typeof exports =3D=3D=3D 'object') {=0A=
      // Node. Does not work with strict CommonJS, but=0A=
      // only CommonJS-like environments that support module.exports,=0A=
      // like Node.=0A=
      module.exports =3D factory();=0A=
    } else {=0A=
      // Browser globals (root is window)=0A=
      root.keycharm =3D factory();=0A=
    }=0A=
  }(this, function () {=0A=
=0A=
    function keycharm(options) {=0A=
      var preventDefault =3D options && options.preventDefault || false;=0A=
=0A=
      var container =3D options && options.container || window;=0A=
=0A=
      var _exportFunctions =3D {};=0A=
      var _bound =3D {keydown:{}, keyup:{}};=0A=
      var _keys =3D {};=0A=
      var i;=0A=
=0A=
      // a - z=0A=
      for (i =3D 97; i <=3D 122; i++) {_keys[String.fromCharCode(i)] =3D =
{code:65 + (i - 97), shift: false};}=0A=
      // A - Z=0A=
      for (i =3D 65; i <=3D 90; i++) {_keys[String.fromCharCode(i)] =3D =
{code:i, shift: true};}=0A=
      // 0 - 9=0A=
      for (i =3D 0;  i <=3D 9;   i++) {_keys['' + i] =3D {code:48 + i, =
shift: false};}=0A=
      // F1 - F12=0A=
      for (i =3D 1;  i <=3D 12;   i++) {_keys['F' + i] =3D {code:111 + =
i, shift: false};}=0A=
      // num0 - num9=0A=
      for (i =3D 0;  i <=3D 9;   i++) {_keys['num' + i] =3D {code:96 + =
i, shift: false};}=0A=
=0A=
      // numpad misc=0A=
      _keys['num*'] =3D {code:106, shift: false};=0A=
      _keys['num+'] =3D {code:107, shift: false};=0A=
      _keys['num-'] =3D {code:109, shift: false};=0A=
      _keys['num/'] =3D {code:111, shift: false};=0A=
      _keys['num.'] =3D {code:110, shift: false};=0A=
      // arrows=0A=
      _keys['left']  =3D {code:37, shift: false};=0A=
      _keys['up']    =3D {code:38, shift: false};=0A=
      _keys['right'] =3D {code:39, shift: false};=0A=
      _keys['down']  =3D {code:40, shift: false};=0A=
      // extra keys=0A=
      _keys['space'] =3D {code:32, shift: false};=0A=
      _keys['enter'] =3D {code:13, shift: false};=0A=
      _keys['shift'] =3D {code:16, shift: undefined};=0A=
      _keys['esc']   =3D {code:27, shift: false};=0A=
      _keys['backspace'] =3D {code:8, shift: false};=0A=
      _keys['tab']       =3D {code:9, shift: false};=0A=
      _keys['ctrl']      =3D {code:17, shift: false};=0A=
      _keys['alt']       =3D {code:18, shift: false};=0A=
      _keys['delete']    =3D {code:46, shift: false};=0A=
      _keys['pageup']    =3D {code:33, shift: false};=0A=
      _keys['pagedown']  =3D {code:34, shift: false};=0A=
      // symbols=0A=
      _keys['=3D']     =3D {code:187, shift: false};=0A=
      _keys['-']     =3D {code:189, shift: false};=0A=
      _keys[']']     =3D {code:221, shift: false};=0A=
      _keys['[']     =3D {code:219, shift: false};=0A=
=0A=
=0A=
=0A=
      var down =3D function(event) {handleEvent(event,'keydown');};=0A=
      var up =3D function(event) {handleEvent(event,'keyup');};=0A=
=0A=
      // handle the actualy bound key with the event=0A=
      var handleEvent =3D function(event,type) {=0A=
        if (_bound[type][event.keyCode] !=3D=3D undefined) {=0A=
          var bound =3D _bound[type][event.keyCode];=0A=
          for (var i =3D 0; i < bound.length; i++) {=0A=
            if (bound[i].shift =3D=3D=3D undefined) {=0A=
              bound[i].fn(event);=0A=
            }=0A=
            else if (bound[i].shift =3D=3D true && event.shiftKey =3D=3D =
true) {=0A=
              bound[i].fn(event);=0A=
            }=0A=
            else if (bound[i].shift =3D=3D false && event.shiftKey =
=3D=3D false) {=0A=
              bound[i].fn(event);=0A=
            }=0A=
          }=0A=
=0A=
          if (preventDefault =3D=3D true) {=0A=
            event.preventDefault();=0A=
          }=0A=
        }=0A=
      };=0A=
=0A=
      // bind a key to a callback=0A=
      _exportFunctions.bind =3D function(key, callback, type) {=0A=
        if (type =3D=3D=3D undefined) {=0A=
          type =3D 'keydown';=0A=
        }=0A=
        if (_keys[key] =3D=3D=3D undefined) {=0A=
          throw new Error("unsupported key: " + key);=0A=
        }=0A=
        if (_bound[type][_keys[key].code] =3D=3D=3D undefined) {=0A=
          _bound[type][_keys[key].code] =3D [];=0A=
        }=0A=
        _bound[type][_keys[key].code].push({fn:callback, =
shift:_keys[key].shift});=0A=
      };=0A=
=0A=
=0A=
      // bind all keys to a call back (demo purposes)=0A=
      _exportFunctions.bindAll =3D function(callback, type) {=0A=
        if (type =3D=3D=3D undefined) {=0A=
          type =3D 'keydown';=0A=
        }=0A=
        for (var key in _keys) {=0A=
          if (_keys.hasOwnProperty(key)) {=0A=
            _exportFunctions.bind(key,callback,type);=0A=
          }=0A=
        }=0A=
      };=0A=
=0A=
      // get the key label from an event=0A=
      _exportFunctions.getKey =3D function(event) {=0A=
        for (var key in _keys) {=0A=
          if (_keys.hasOwnProperty(key)) {=0A=
            if (event.shiftKey =3D=3D true && _keys[key].shift =3D=3D =
true && event.keyCode =3D=3D _keys[key].code) {=0A=
              return key;=0A=
            }=0A=
            else if (event.shiftKey =3D=3D false && _keys[key].shift =
=3D=3D false && event.keyCode =3D=3D _keys[key].code) {=0A=
              return key;=0A=
            }=0A=
            else if (event.keyCode =3D=3D _keys[key].code && key =3D=3D =
'shift') {=0A=
              return key;=0A=
            }=0A=
          }=0A=
        }=0A=
        return "unknown key, currently not supported";=0A=
      };=0A=
=0A=
      // unbind either a specific callback from a key or all of them (by =
leaving callback undefined)=0A=
      _exportFunctions.unbind =3D function(key, callback, type) {=0A=
        if (type =3D=3D=3D undefined) {=0A=
          type =3D 'keydown';=0A=
        }=0A=
        if (_keys[key] =3D=3D=3D undefined) {=0A=
          throw new Error("unsupported key: " + key);=0A=
        }=0A=
        if (callback !=3D=3D undefined) {=0A=
          var newBindings =3D [];=0A=
          var bound =3D _bound[type][_keys[key].code];=0A=
          if (bound !=3D=3D undefined) {=0A=
            for (var i =3D 0; i < bound.length; i++) {=0A=
              if (!(bound[i].fn =3D=3D callback && bound[i].shift =3D=3D =
_keys[key].shift)) {=0A=
                newBindings.push(_bound[type][_keys[key].code][i]);=0A=
              }=0A=
            }=0A=
          }=0A=
          _bound[type][_keys[key].code] =3D newBindings;=0A=
        }=0A=
        else {=0A=
          _bound[type][_keys[key].code] =3D [];=0A=
        }=0A=
      };=0A=
=0A=
      // reset all bound variables.=0A=
      _exportFunctions.reset =3D function() {=0A=
        _bound =3D {keydown:{}, keyup:{}};=0A=
      };=0A=
=0A=
      // unbind all listeners and reset all variables.=0A=
      _exportFunctions.destroy =3D function() {=0A=
        _bound =3D {keydown:{}, keyup:{}};=0A=
        container.removeEventListener('keydown', down, true);=0A=
        container.removeEventListener('keyup', up, true);=0A=
      };=0A=
=0A=
      // create listeners.=0A=
      container.addEventListener('keydown',down,true);=0A=
      container.addEventListener('keyup',up,true);=0A=
=0A=
      // return the public functions.=0A=
      return _exportFunctions;=0A=
    }=0A=
=0A=
    return keycharm;=0A=
  }));=0A=
=0A=
=0A=
=0A=
=0A=
/***/ },=0A=
/* 42 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var util =3D __webpack_require__(7);=0A=
  var Component =3D __webpack_require__(28);=0A=
  var moment =3D __webpack_require__(8);=0A=
  var locales =3D __webpack_require__(43);=0A=
=0A=
  /**=0A=
   * A custom time bar=0A=
   * @param {{range: Range, dom: Object}} body=0A=
   * @param {Object} [options]        Available parameters:=0A=
   *                                  {number | string} id=0A=
   *                                  {string} locales=0A=
   *                                  {string} locale=0A=
   * @constructor CustomTime=0A=
   * @extends Component=0A=
   */=0A=
=0A=
  function CustomTime(body, options) {=0A=
    this.body =3D body;=0A=
=0A=
    // default options=0A=
    this.defaultOptions =3D {=0A=
      moment: moment,=0A=
      locales: locales,=0A=
      locale: 'en',=0A=
      id: undefined=0A=
    };=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
=0A=
    if (options && options.time) {=0A=
      this.customTime =3D options.time;=0A=
    } else {=0A=
      this.customTime =3D new Date();=0A=
    }=0A=
=0A=
    this.eventParams =3D {}; // stores state parameters while dragging =
the bar=0A=
=0A=
    this.setOptions(options);=0A=
=0A=
    // create the DOM=0A=
    this._create();=0A=
  }=0A=
=0A=
  CustomTime.prototype =3D new Component();=0A=
=0A=
  /**=0A=
   * Set options for the component. Options will be merged in current =
options.=0A=
   * @param {Object} options  Available parameters:=0A=
   *                                  {number | string} id=0A=
   *                                  {string} locales=0A=
   *                                  {string} locale=0A=
   */=0A=
  CustomTime.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      // copy all options that we know=0A=
      util.selectiveExtend(['moment', 'locale', 'locales', 'id'], =
this.options, options);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create the DOM for the custom time=0A=
   * @private=0A=
   */=0A=
  CustomTime.prototype._create =3D function () {=0A=
    var bar =3D document.createElement('div');=0A=
    bar['custom-time'] =3D this;=0A=
    bar.className =3D 'vis-custom-time ' + (this.options.id || '');=0A=
    bar.style.position =3D 'absolute';=0A=
    bar.style.top =3D '0px';=0A=
    bar.style.height =3D '100%';=0A=
    this.bar =3D bar;=0A=
=0A=
    var drag =3D document.createElement('div');=0A=
    drag.style.position =3D 'relative';=0A=
    drag.style.top =3D '0px';=0A=
    drag.style.left =3D '-10px';=0A=
    drag.style.height =3D '100%';=0A=
    drag.style.width =3D '20px';=0A=
    bar.appendChild(drag);=0A=
=0A=
    // attach event listeners=0A=
    this.hammer =3D new Hammer(drag);=0A=
    this.hammer.on('panstart', this._onDragStart.bind(this));=0A=
    this.hammer.on('panmove', this._onDrag.bind(this));=0A=
    this.hammer.on('panend', this._onDragEnd.bind(this));=0A=
    this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 =
is ALL_DIRECTIONS in hammer.=0A=
  };=0A=
=0A=
  /**=0A=
   * Destroy the CustomTime bar=0A=
   */=0A=
  CustomTime.prototype.destroy =3D function () {=0A=
    this.hide();=0A=
=0A=
    this.hammer.destroy();=0A=
    this.hammer =3D null;=0A=
=0A=
    this.body =3D null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the component=0A=
   * @return {boolean} Returns true if the component is resized=0A=
   */=0A=
  CustomTime.prototype.redraw =3D function () {=0A=
    var parent =3D this.body.dom.backgroundVertical;=0A=
    if (this.bar.parentNode !=3D parent) {=0A=
      // attach to the dom=0A=
      if (this.bar.parentNode) {=0A=
        this.bar.parentNode.removeChild(this.bar);=0A=
      }=0A=
      parent.appendChild(this.bar);=0A=
    }=0A=
=0A=
    var x =3D this.body.util.toScreen(this.customTime);=0A=
=0A=
    var locale =3D this.options.locales[this.options.locale];=0A=
    if (!locale) {=0A=
      if (!this.warned) {=0A=
        console.log('WARNING: options.locales[\'' + this.options.locale =
+ '\'] not found. See http://visjs.org/docs/timeline.html#Localization');=0A=
        this.warned =3D true;=0A=
      }=0A=
      locale =3D this.options.locales['en']; // fall back on english =
when not available=0A=
    }=0A=
=0A=
    var title =3D locale.time + ': ' + =
this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, =
H:mm:ss');=0A=
    title =3D title.charAt(0).toUpperCase() + title.substring(1);=0A=
=0A=
    this.bar.style.left =3D x + 'px';=0A=
    this.bar.title =3D title;=0A=
=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Remove the CustomTime from the DOM=0A=
   */=0A=
  CustomTime.prototype.hide =3D function () {=0A=
    // remove the line from the DOM=0A=
    if (this.bar.parentNode) {=0A=
      this.bar.parentNode.removeChild(this.bar);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set custom time.=0A=
   * @param {Date | number | string} time=0A=
   */=0A=
  CustomTime.prototype.setCustomTime =3D function (time) {=0A=
    this.customTime =3D util.convert(time, 'Date');=0A=
    this.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Retrieve the current custom time.=0A=
   * @return {Date} customTime=0A=
   */=0A=
  CustomTime.prototype.getCustomTime =3D function () {=0A=
    return new Date(this.customTime.valueOf());=0A=
  };=0A=
=0A=
  /**=0A=
   * Start moving horizontally=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  CustomTime.prototype._onDragStart =3D function (event) {=0A=
    this.eventParams.dragging =3D true;=0A=
    this.eventParams.customTime =3D this.customTime;=0A=
=0A=
    event.stopPropagation();=0A=
  };=0A=
=0A=
  /**=0A=
   * Perform moving operating.=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  CustomTime.prototype._onDrag =3D function (event) {=0A=
    if (!this.eventParams.dragging) return;=0A=
=0A=
    var x =3D this.body.util.toScreen(this.eventParams.customTime) + =
event.deltaX;=0A=
    var time =3D this.body.util.toTime(x);=0A=
=0A=
    this.setCustomTime(time);=0A=
=0A=
    // fire a timechange event=0A=
    this.body.emitter.emit('timechange', {=0A=
      id: this.options.id,=0A=
      time: new Date(this.customTime.valueOf())=0A=
    });=0A=
=0A=
    event.stopPropagation();=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop moving operating.=0A=
   * @param {Event} event=0A=
   * @private=0A=
   */=0A=
  CustomTime.prototype._onDragEnd =3D function (event) {=0A=
    if (!this.eventParams.dragging) return;=0A=
=0A=
    // fire a timechanged event=0A=
    this.body.emitter.emit('timechanged', {=0A=
      id: this.options.id,=0A=
      time: new Date(this.customTime.valueOf())=0A=
    });=0A=
=0A=
    event.stopPropagation();=0A=
  };=0A=
=0A=
  /**=0A=
   * Find a custom time from an event target:=0A=
   * searches for the attribute 'custom-time' in the event target's =
element tree=0A=
   * @param {Event} event=0A=
   * @return {CustomTime | null} customTime=0A=
   */=0A=
  CustomTime.customTimeFromTarget =3D function (event) {=0A=
    var target =3D event.target;=0A=
    while (target) {=0A=
      if (target.hasOwnProperty('custom-time')) {=0A=
        return target['custom-time'];=0A=
      }=0A=
      target =3D target.parentNode;=0A=
    }=0A=
=0A=
    return null;=0A=
  };=0A=
=0A=
  module.exports =3D CustomTime;=0A=
=0A=
/***/ },=0A=
/* 43 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  // English=0A=
  'use strict';=0A=
=0A=
  exports['en'] =3D {=0A=
    current: 'current',=0A=
    time: 'time'=0A=
  };=0A=
  exports['en_EN'] =3D exports['en'];=0A=
  exports['en_US'] =3D exports['en'];=0A=
=0A=
  // Dutch=0A=
  exports['nl'] =3D {=0A=
    current: 'huidige',=0A=
    time: 'tijd'=0A=
  };=0A=
  exports['nl_NL'] =3D exports['nl'];=0A=
  exports['nl_BE'] =3D exports['nl'];=0A=
=0A=
/***/ },=0A=
/* 44 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var Component =3D __webpack_require__(28);=0A=
  var moment =3D __webpack_require__(8);=0A=
  var locales =3D __webpack_require__(43);=0A=
=0A=
  /**=0A=
   * A current time bar=0A=
   * @param {{range: Range, dom: Object, domProps: Object}} body=0A=
   * @param {Object} [options]        Available parameters:=0A=
   *                                  {Boolean} [showCurrentTime]=0A=
   * @constructor CurrentTime=0A=
   * @extends Component=0A=
   */=0A=
  function CurrentTime(body, options) {=0A=
    this.body =3D body;=0A=
=0A=
    // default options=0A=
    this.defaultOptions =3D {=0A=
      showCurrentTime: true,=0A=
=0A=
      moment: moment,=0A=
      locales: locales,=0A=
      locale: 'en'=0A=
    };=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
    this.offset =3D 0;=0A=
=0A=
    this._create();=0A=
=0A=
    this.setOptions(options);=0A=
  }=0A=
=0A=
  CurrentTime.prototype =3D new Component();=0A=
=0A=
  /**=0A=
   * Create the HTML DOM for the current time bar=0A=
   * @private=0A=
   */=0A=
  CurrentTime.prototype._create =3D function () {=0A=
    var bar =3D document.createElement('div');=0A=
    bar.className =3D 'vis-current-time';=0A=
    bar.style.position =3D 'absolute';=0A=
    bar.style.top =3D '0px';=0A=
    bar.style.height =3D '100%';=0A=
=0A=
    this.bar =3D bar;=0A=
  };=0A=
=0A=
  /**=0A=
   * Destroy the CurrentTime bar=0A=
   */=0A=
  CurrentTime.prototype.destroy =3D function () {=0A=
    this.options.showCurrentTime =3D false;=0A=
    this.redraw(); // will remove the bar from the DOM and stop =
refreshing=0A=
=0A=
    this.body =3D null;=0A=
  };=0A=
=0A=
  /**=0A=
   * Set options for the component. Options will be merged in current =
options.=0A=
   * @param {Object} options  Available parameters:=0A=
   *                          {boolean} [showCurrentTime]=0A=
   */=0A=
  CurrentTime.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      // copy all options that we know=0A=
      util.selectiveExtend(['showCurrentTime', 'moment', 'locale', =
'locales'], this.options, options);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the component=0A=
   * @return {boolean} Returns true if the component is resized=0A=
   */=0A=
  CurrentTime.prototype.redraw =3D function () {=0A=
    if (this.options.showCurrentTime) {=0A=
      var parent =3D this.body.dom.backgroundVertical;=0A=
      if (this.bar.parentNode !=3D parent) {=0A=
        // attach to the dom=0A=
        if (this.bar.parentNode) {=0A=
          this.bar.parentNode.removeChild(this.bar);=0A=
        }=0A=
        parent.appendChild(this.bar);=0A=
=0A=
        this.start();=0A=
      }=0A=
=0A=
      var now =3D this.options.moment(new Date().valueOf() + =
this.offset);=0A=
      var x =3D this.body.util.toScreen(now);=0A=
=0A=
      var locale =3D this.options.locales[this.options.locale];=0A=
      if (!locale) {=0A=
        if (!this.warned) {=0A=
          console.log('WARNING: options.locales[\'' + =
this.options.locale + '\'] not found. See =
http://visjs.org/docs/timeline.html#Localization');=0A=
          this.warned =3D true;=0A=
        }=0A=
        locale =3D this.options.locales['en']; // fall back on english =
when not available=0A=
      }=0A=
      var title =3D locale.current + ' ' + locale.time + ': ' + =
now.format('dddd, MMMM Do YYYY, H:mm:ss');=0A=
      title =3D title.charAt(0).toUpperCase() + title.substring(1);=0A=
=0A=
      this.bar.style.left =3D x + 'px';=0A=
      this.bar.title =3D title;=0A=
    } else {=0A=
      // remove the line from the DOM=0A=
      if (this.bar.parentNode) {=0A=
        this.bar.parentNode.removeChild(this.bar);=0A=
      }=0A=
      this.stop();=0A=
    }=0A=
=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * Start auto refreshing the current time bar=0A=
   */=0A=
  CurrentTime.prototype.start =3D function () {=0A=
    var me =3D this;=0A=
=0A=
    function update() {=0A=
      me.stop();=0A=
=0A=
      // determine interval to refresh=0A=
      var scale =3D =
me.body.range.conversion(me.body.domProps.center.width).scale;=0A=
      var interval =3D 1 / scale / 10;=0A=
      if (interval < 30) interval =3D 30;=0A=
      if (interval > 1000) interval =3D 1000;=0A=
=0A=
      me.redraw();=0A=
=0A=
      // start a renderTimer to adjust for the new time=0A=
      me.currentTimeTimer =3D setTimeout(update, interval);=0A=
    }=0A=
=0A=
    update();=0A=
  };=0A=
=0A=
  /**=0A=
   * Stop auto refreshing the current time bar=0A=
   */=0A=
  CurrentTime.prototype.stop =3D function () {=0A=
    if (this.currentTimeTimer !=3D=3D undefined) {=0A=
      clearTimeout(this.currentTimeTimer);=0A=
      delete this.currentTimeTimer;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a current time. This can be used for example to ensure that a =
client's=0A=
   * time is synchronized with a shared server time.=0A=
   * @param {Date | String | Number} time     A Date, unix timestamp, or=0A=
   *                                          ISO date string.=0A=
   */=0A=
  CurrentTime.prototype.setCurrentTime =3D function (time) {=0A=
    var t =3D util.convert(time, 'Date').valueOf();=0A=
    var now =3D new Date().valueOf();=0A=
    this.offset =3D t - now;=0A=
    this.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the current time.=0A=
   * @return {Date} Returns the current time.=0A=
   */=0A=
  CurrentTime.prototype.getCurrentTime =3D function () {=0A=
    return new Date(new Date().valueOf() + this.offset);=0A=
  };=0A=
=0A=
  module.exports =3D CurrentTime;=0A=
=0A=
/***/ },=0A=
/* 45 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _ColorPicker =3D __webpack_require__(46);=0A=
=0A=
  var _ColorPicker2 =3D _interopRequireDefault(_ColorPicker);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * The way this works is for all properties of this.possible options, =
you can supply the property name in any form to list the options.=0A=
   * Boolean options are recognised as Boolean=0A=
   * Number options should be written as array: [default value, min =
value, max value, stepsize]=0A=
   * Colors should be written as array: ['color', '#ffffff']=0A=
   * Strings with should be written as array: [option1, option2, =
option3, ..]=0A=
   *=0A=
   * The options are matched with their counterparts in each of the =
modules and the values used in the configuration are=0A=
   *=0A=
   * @param parentModule        | the location where =
parentModule.setOptions() can be called=0A=
   * @param defaultContainer    | the default container of the module=0A=
   * @param configureOptions    | the fully configured and predefined =
options set found in allOptions.js=0A=
   * @param pixelRatio          | canvas pixel ratio=0A=
   */=0A=
=0A=
  var Configurator =3D (function () {=0A=
    function Configurator(parentModule, defaultContainer, =
configureOptions) {=0A=
      var pixelRatio =3D arguments.length <=3D 3 || arguments[3] =
=3D=3D=3D undefined ? 1 : arguments[3];=0A=
=0A=
      _classCallCheck(this, Configurator);=0A=
=0A=
      this.parent =3D parentModule;=0A=
      this.changedOptions =3D [];=0A=
      this.container =3D defaultContainer;=0A=
      this.allowCreation =3D false;=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        enabled: false,=0A=
        filter: true,=0A=
        container: undefined,=0A=
        showButton: true=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.configureOptions =3D configureOptions;=0A=
      this.moduleOptions =3D {};=0A=
      this.domElements =3D [];=0A=
      this.colorPicker =3D new _ColorPicker2['default'](pixelRatio);=0A=
      this.wrapper =3D undefined;=0A=
    }=0A=
=0A=
    _createClass(Configurator, [{=0A=
      key: 'setOptions',=0A=
=0A=
      /**=0A=
       * refresh all options.=0A=
       * Because all modules parse their options by themselves, we just =
use their options. We copy them here.=0A=
       *=0A=
       * @param options=0A=
       */=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          var enabled =3D true;=0A=
          if (typeof options =3D=3D=3D 'string') {=0A=
            this.options.filter =3D options;=0A=
          } else if (options instanceof Array) {=0A=
            this.options.filter =3D options.join();=0A=
          } else if (typeof options =3D=3D=3D 'object') {=0A=
            if (options.container !=3D=3D undefined) {=0A=
              this.options.container =3D options.container;=0A=
            }=0A=
            if (options.filter !=3D=3D undefined) {=0A=
              this.options.filter =3D options.filter;=0A=
            }=0A=
            if (options.showButton !=3D=3D undefined) {=0A=
              this.options.showButton =3D options.showButton;=0A=
            }=0A=
            if (options.enabled !=3D=3D undefined) {=0A=
              enabled =3D options.enabled;=0A=
            }=0A=
          } else if (typeof options =3D=3D=3D 'boolean') {=0A=
            this.options.filter =3D true;=0A=
            enabled =3D options;=0A=
          } else if (typeof options =3D=3D=3D 'function') {=0A=
            this.options.filter =3D options;=0A=
            enabled =3D true;=0A=
          }=0A=
          if (this.options.filter =3D=3D=3D false) {=0A=
            enabled =3D false;=0A=
          }=0A=
=0A=
          this.options.enabled =3D enabled;=0A=
        }=0A=
        this._clean();=0A=
      }=0A=
    }, {=0A=
      key: 'setModuleOptions',=0A=
      value: function setModuleOptions(moduleOptions) {=0A=
        this.moduleOptions =3D moduleOptions;=0A=
        if (this.options.enabled =3D=3D=3D true) {=0A=
          this._clean();=0A=
          if (this.options.container !=3D=3D undefined) {=0A=
            this.container =3D this.options.container;=0A=
          }=0A=
          this._create();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_create',=0A=
=0A=
      /**=0A=
       * Create all DOM elements=0A=
       * @private=0A=
       */=0A=
      value: function _create() {=0A=
        var _this =3D this;=0A=
=0A=
        this._clean();=0A=
        this.changedOptions =3D [];=0A=
=0A=
        var filter =3D this.options.filter;=0A=
        var counter =3D 0;=0A=
        var show =3D false;=0A=
        for (var option in this.configureOptions) {=0A=
          if (this.configureOptions.hasOwnProperty(option)) {=0A=
            this.allowCreation =3D false;=0A=
            show =3D false;=0A=
            if (typeof filter =3D=3D=3D 'function') {=0A=
              show =3D filter(option, []);=0A=
              show =3D show || =
this._handleObject(this.configureOptions[option], [option], true);=0A=
            } else if (filter =3D=3D=3D true || filter.indexOf(option) =
!=3D=3D -1) {=0A=
              show =3D true;=0A=
            }=0A=
=0A=
            if (show !=3D=3D false) {=0A=
              this.allowCreation =3D true;=0A=
=0A=
              // linebreak between categories=0A=
              if (counter > 0) {=0A=
                this._makeItem([]);=0A=
              }=0A=
              // a header for the category=0A=
              this._makeHeader(option);=0A=
=0A=
              // get the suboptions=0A=
              this._handleObject(this.configureOptions[option], =
[option]);=0A=
            }=0A=
            counter++;=0A=
          }=0A=
        }=0A=
=0A=
        if (this.options.showButton =3D=3D=3D true) {=0A=
          (function () {=0A=
            var generateButton =3D document.createElement('div');=0A=
            generateButton.className =3D 'vis-network-configuration =
button';=0A=
            generateButton.innerHTML =3D 'generate options';=0A=
            generateButton.onclick =3D function () {=0A=
              _this._printOptions();=0A=
            };=0A=
            generateButton.onmouseover =3D function () {=0A=
              generateButton.className =3D 'vis-network-configuration =
button hover';=0A=
            };=0A=
            generateButton.onmouseout =3D function () {=0A=
              generateButton.className =3D 'vis-network-configuration =
button';=0A=
            };=0A=
=0A=
            _this.optionsContainer =3D document.createElement('div');=0A=
            _this.optionsContainer.className =3D =
'vis-network-configuration vis-option-container';=0A=
=0A=
            _this.domElements.push(_this.optionsContainer);=0A=
            _this.domElements.push(generateButton);=0A=
          })();=0A=
        }=0A=
=0A=
        this._push();=0A=
        this.colorPicker.insertTo(this.container);=0A=
      }=0A=
    }, {=0A=
      key: '_push',=0A=
=0A=
      /**=0A=
       * draw all DOM elements on the screen=0A=
       * @private=0A=
       */=0A=
      value: function _push() {=0A=
        this.wrapper =3D document.createElement('div');=0A=
        this.wrapper.className =3D 'vis-network-configuration-wrapper';=0A=
        this.container.appendChild(this.wrapper);=0A=
        for (var i =3D 0; i < this.domElements.length; i++) {=0A=
          this.wrapper.appendChild(this.domElements[i]);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_clean',=0A=
=0A=
      /**=0A=
       * delete all DOM elements=0A=
       * @private=0A=
       */=0A=
      value: function _clean() {=0A=
        for (var i =3D 0; i < this.domElements.length; i++) {=0A=
          this.wrapper.removeChild(this.domElements[i]);=0A=
        }=0A=
=0A=
        if (this.wrapper !=3D=3D undefined) {=0A=
          this.container.removeChild(this.wrapper);=0A=
          this.wrapper =3D undefined;=0A=
        }=0A=
        this.domElements =3D [];=0A=
      }=0A=
    }, {=0A=
      key: '_getValue',=0A=
=0A=
      /**=0A=
       * get the value from the actualOptions if it exists=0A=
       * @param {array} path    | where to look for the actual option=0A=
       * @returns {*}=0A=
       * @private=0A=
       */=0A=
      value: function _getValue(path) {=0A=
        var base =3D this.moduleOptions;=0A=
        for (var i =3D 0; i < path.length; i++) {=0A=
          if (base[path[i]] !=3D=3D undefined) {=0A=
            base =3D base[path[i]];=0A=
          } else {=0A=
            base =3D undefined;=0A=
            break;=0A=
          }=0A=
        }=0A=
        return base;=0A=
      }=0A=
    }, {=0A=
      key: '_makeItem',=0A=
=0A=
      /**=0A=
       * all option elements are wrapped in an item=0A=
       * @param path=0A=
       * @param domElements=0A=
       * @private=0A=
       */=0A=
      value: function _makeItem(path) {=0A=
        var _arguments =3D arguments,=0A=
            _this2 =3D this;=0A=
=0A=
        if (this.allowCreation =3D=3D=3D true) {=0A=
          var _len, domElements, _key;=0A=
=0A=
          (function () {=0A=
            var item =3D document.createElement('div');=0A=
            item.className =3D 'vis-network-configuration item s' + =
path.length;=0A=
=0A=
            for (_len =3D _arguments.length, domElements =3D Array(_len =
> 1 ? _len - 1 : 0), _key =3D 1; _key < _len; _key++) {=0A=
              domElements[_key - 1] =3D _arguments[_key];=0A=
            }=0A=
=0A=
            domElements.forEach(function (element) {=0A=
              item.appendChild(element);=0A=
            });=0A=
            _this2.domElements.push(item);=0A=
          })();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_makeHeader',=0A=
=0A=
      /**=0A=
       * header for major subjects=0A=
       * @param name=0A=
       * @private=0A=
       */=0A=
      value: function _makeHeader(name) {=0A=
        var div =3D document.createElement('div');=0A=
        div.className =3D 'vis-network-configuration header';=0A=
        div.innerHTML =3D name;=0A=
        this._makeItem([], div);=0A=
      }=0A=
    }, {=0A=
      key: '_makeLabel',=0A=
=0A=
      /**=0A=
       * make a label, if it is an object label, it gets different =
styling.=0A=
       * @param name=0A=
       * @param path=0A=
       * @param objectLabel=0A=
       * @returns {HTMLElement}=0A=
       * @private=0A=
       */=0A=
      value: function _makeLabel(name, path) {=0A=
        var objectLabel =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? false : arguments[2];=0A=
=0A=
        var div =3D document.createElement('div');=0A=
        div.className =3D 'vis-network-configuration label s' + =
path.length;=0A=
        if (objectLabel =3D=3D=3D true) {=0A=
          div.innerHTML =3D '<i><b>' + name + ':</b></i>';=0A=
        } else {=0A=
          div.innerHTML =3D name + ':';=0A=
        }=0A=
        return div;=0A=
      }=0A=
    }, {=0A=
      key: '_makeDropdown',=0A=
=0A=
      /**=0A=
       * make a dropdown list for multiple possible string optoins=0A=
       * @param arr=0A=
       * @param value=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _makeDropdown(arr, value, path) {=0A=
        var select =3D document.createElement('select');=0A=
        select.className =3D 'vis-network-configuration select';=0A=
        var selectedValue =3D 0;=0A=
        if (value !=3D=3D undefined) {=0A=
          if (arr.indexOf(value) !=3D=3D -1) {=0A=
            selectedValue =3D arr.indexOf(value);=0A=
          }=0A=
        }=0A=
=0A=
        for (var i =3D 0; i < arr.length; i++) {=0A=
          var option =3D document.createElement('option');=0A=
          option.value =3D arr[i];=0A=
          if (i =3D=3D=3D selectedValue) {=0A=
            option.selected =3D 'selected';=0A=
          }=0A=
          option.innerHTML =3D arr[i];=0A=
          select.appendChild(option);=0A=
        }=0A=
=0A=
        var me =3D this;=0A=
        select.onchange =3D function () {=0A=
          me._update(this.value, path);=0A=
        };=0A=
=0A=
        var label =3D this._makeLabel(path[path.length - 1], path);=0A=
        this._makeItem(path, label, select);=0A=
      }=0A=
    }, {=0A=
      key: '_makeRange',=0A=
=0A=
      /**=0A=
       * make a range object for numeric options=0A=
       * @param arr=0A=
       * @param value=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _makeRange(arr, value, path) {=0A=
        var defaultValue =3D arr[0];=0A=
        var min =3D arr[1];=0A=
        var max =3D arr[2];=0A=
        var step =3D arr[3];=0A=
        var range =3D document.createElement('input');=0A=
        range.className =3D 'vis-network-configuration range';=0A=
        try {=0A=
          range.type =3D 'range'; // not supported on IE9=0A=
          range.min =3D min;=0A=
          range.max =3D max;=0A=
        } catch (err) {}=0A=
        range.step =3D step;=0A=
=0A=
        if (value !=3D=3D undefined) {=0A=
          if (value < 0 && value * 2 < min) {=0A=
            range.min =3D value * 2;=0A=
          } else if (value * 0.1 < min) {=0A=
            range.min =3D value / 10;=0A=
          }=0A=
          if (value * 2 > max && max !=3D=3D 1) {=0A=
            range.max =3D value * 2;=0A=
          }=0A=
          range.value =3D value;=0A=
        } else {=0A=
          range.value =3D defaultValue;=0A=
        }=0A=
=0A=
        var input =3D document.createElement('input');=0A=
        input.className =3D 'vis-network-configuration rangeinput';=0A=
        input.value =3D range.value;=0A=
=0A=
        var me =3D this;=0A=
        range.onchange =3D function () {=0A=
          input.value =3D this.value;me._update(Number(this.value), =
path);=0A=
        };=0A=
        range.oninput =3D function () {=0A=
          input.value =3D this.value;=0A=
        };=0A=
=0A=
        var label =3D this._makeLabel(path[path.length - 1], path);=0A=
        this._makeItem(path, label, range, input);=0A=
      }=0A=
    }, {=0A=
      key: '_makeCheckbox',=0A=
=0A=
      /**=0A=
       * make a checkbox for boolean options.=0A=
       * @param defaultValue=0A=
       * @param value=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _makeCheckbox(defaultValue, value, path) {=0A=
        var checkbox =3D document.createElement('input');=0A=
        checkbox.type =3D 'checkbox';=0A=
        checkbox.className =3D 'vis-network-configuration checkbox';=0A=
        checkbox.checked =3D defaultValue;=0A=
        if (value !=3D=3D undefined) {=0A=
          checkbox.checked =3D value;=0A=
          if (value !=3D=3D defaultValue) {=0A=
            if (typeof defaultValue =3D=3D=3D 'object') {=0A=
              if (value !=3D=3D defaultValue.enabled) {=0A=
                this.changedOptions.push({ path: path, value: value });=0A=
              }=0A=
            } else {=0A=
              this.changedOptions.push({ path: path, value: value });=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        var me =3D this;=0A=
        checkbox.onchange =3D function () {=0A=
          me._update(this.checked, path);=0A=
        };=0A=
=0A=
        var label =3D this._makeLabel(path[path.length - 1], path);=0A=
        this._makeItem(path, label, checkbox);=0A=
      }=0A=
    }, {=0A=
      key: '_makeTextInput',=0A=
=0A=
      /**=0A=
       * make a text input field for string options.=0A=
       * @param defaultValue=0A=
       * @param value=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _makeTextInput(defaultValue, value, path) {=0A=
        var checkbox =3D document.createElement('input');=0A=
        checkbox.type =3D 'text';=0A=
        checkbox.className =3D 'vis-network-configuration text';=0A=
        checkbox.value =3D value;=0A=
        if (value !=3D=3D defaultValue) {=0A=
          this.changedOptions.push({ path: path, value: value });=0A=
        }=0A=
=0A=
        var me =3D this;=0A=
        checkbox.onchange =3D function () {=0A=
          me._update(this.value, path);=0A=
        };=0A=
=0A=
        var label =3D this._makeLabel(path[path.length - 1], path);=0A=
        this._makeItem(path, label, checkbox);=0A=
      }=0A=
    }, {=0A=
      key: '_makeColorField',=0A=
=0A=
      /**=0A=
       * make a color field with a color picker for color fields=0A=
       * @param arr=0A=
       * @param value=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _makeColorField(arr, value, path) {=0A=
        var _this3 =3D this;=0A=
=0A=
        var defaultColor =3D arr[1];=0A=
        var div =3D document.createElement('div');=0A=
        value =3D value =3D=3D=3D undefined ? defaultColor : value;=0A=
=0A=
        if (value !=3D=3D 'none') {=0A=
          div.className =3D 'vis-network-configuration colorBlock';=0A=
          div.style.backgroundColor =3D value;=0A=
        } else {=0A=
          div.className =3D 'vis-network-configuration colorBlock none';=0A=
        }=0A=
=0A=
        value =3D value =3D=3D=3D undefined ? defaultColor : value;=0A=
        div.onclick =3D function () {=0A=
          _this3._showColorPicker(value, div, path);=0A=
        };=0A=
=0A=
        var label =3D this._makeLabel(path[path.length - 1], path);=0A=
        this._makeItem(path, label, div);=0A=
      }=0A=
    }, {=0A=
      key: '_showColorPicker',=0A=
=0A=
      /**=0A=
       * used by the color buttons to call the color picker.=0A=
       * @param event=0A=
       * @param value=0A=
       * @param div=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _showColorPicker(value, div, path) {=0A=
        var _this4 =3D this;=0A=
=0A=
        var rect =3D div.getBoundingClientRect();=0A=
        var bodyRect =3D document.body.getBoundingClientRect();=0A=
        var pickerX =3D rect.left + rect.width + 5;=0A=
        var pickerY =3D rect.top - bodyRect.top + rect.height * 0.5;=0A=
        this.colorPicker.show(pickerX, pickerY);=0A=
        this.colorPicker.setColor(value);=0A=
        this.colorPicker.setCallback(function (color) {=0A=
          var colorString =3D 'rgba(' + color.r + ',' + color.g + ',' + =
color.b + ',' + color.a + ')';=0A=
          div.style.backgroundColor =3D colorString;=0A=
          _this4._update(colorString, path);=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: '_handleObject',=0A=
=0A=
      /**=0A=
       * parse an object and draw the correct items=0A=
       * @param obj=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _handleObject(obj) {=0A=
        var path =3D arguments.length <=3D 1 || arguments[1] =3D=3D=3D =
undefined ? [] : arguments[1];=0A=
        var checkOnly =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? false : arguments[2];=0A=
=0A=
        var show =3D false;=0A=
        var filter =3D this.options.filter;=0A=
        var visibleInSet =3D false;=0A=
        for (var subObj in obj) {=0A=
          if (obj.hasOwnProperty(subObj)) {=0A=
            show =3D true;=0A=
            var item =3D obj[subObj];=0A=
            var newPath =3D util.copyAndExtendArray(path, subObj);=0A=
            if (typeof filter =3D=3D=3D 'function') {=0A=
              show =3D filter(subObj, path);=0A=
=0A=
              // if needed we must go deeper into the object.=0A=
              if (show =3D=3D=3D false) {=0A=
                if (!(item instanceof Array) && typeof item !=3D=3D =
'string' && typeof item !=3D=3D 'boolean' && item instanceof Object) {=0A=
                  this.allowCreation =3D false;=0A=
                  show =3D this._handleObject(item, newPath, true);=0A=
                  this.allowCreation =3D checkOnly =3D=3D=3D false;=0A=
                }=0A=
              }=0A=
            }=0A=
=0A=
            if (show !=3D=3D false) {=0A=
              visibleInSet =3D true;=0A=
              var value =3D this._getValue(newPath);=0A=
=0A=
              if (item instanceof Array) {=0A=
                this._handleArray(item, value, newPath);=0A=
              } else if (typeof item =3D=3D=3D 'string') {=0A=
                this._makeTextInput(item, value, newPath);=0A=
              } else if (typeof item =3D=3D=3D 'boolean') {=0A=
                this._makeCheckbox(item, value, newPath);=0A=
              } else if (item instanceof Object) {=0A=
                // collapse the physics options that are not enabled=0A=
                var draw =3D true;=0A=
                if (path.indexOf('physics') !=3D=3D -1) {=0A=
                  if (this.moduleOptions.physics.solver !=3D=3D subObj) {=0A=
                    draw =3D false;=0A=
                  }=0A=
                }=0A=
=0A=
                if (draw =3D=3D=3D true) {=0A=
                  // initially collapse options with an disabled enabled =
option.=0A=
                  if (item.enabled !=3D=3D undefined) {=0A=
                    var enabledPath =3D util.copyAndExtendArray(newPath, =
'enabled');=0A=
                    var enabledValue =3D this._getValue(enabledPath);=0A=
                    if (enabledValue =3D=3D=3D true) {=0A=
                      var label =3D this._makeLabel(subObj, newPath, =
true);=0A=
                      this._makeItem(newPath, label);=0A=
                      visibleInSet =3D this._handleObject(item, newPath) =
|| visibleInSet;=0A=
                    } else {=0A=
                      this._makeCheckbox(item, enabledValue, newPath);=0A=
                    }=0A=
                  } else {=0A=
                    var label =3D this._makeLabel(subObj, newPath, true);=0A=
                    this._makeItem(newPath, label);=0A=
                    visibleInSet =3D this._handleObject(item, newPath) =
|| visibleInSet;=0A=
                  }=0A=
                }=0A=
              } else {=0A=
                console.error('dont know how to handle', item, subObj, =
newPath);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
        return visibleInSet;=0A=
      }=0A=
    }, {=0A=
      key: '_handleArray',=0A=
=0A=
      /**=0A=
       * handle the array type of option=0A=
       * @param optionName=0A=
       * @param arr=0A=
       * @param value=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _handleArray(arr, value, path) {=0A=
        if (typeof arr[0] =3D=3D=3D 'string' && arr[0] =3D=3D=3D =
'color') {=0A=
          this._makeColorField(arr, value, path);=0A=
          if (arr[1] !=3D=3D value) {=0A=
            this.changedOptions.push({ path: path, value: value });=0A=
          }=0A=
        } else if (typeof arr[0] =3D=3D=3D 'string') {=0A=
          this._makeDropdown(arr, value, path);=0A=
          if (arr[0] !=3D=3D value) {=0A=
            this.changedOptions.push({ path: path, value: value });=0A=
          }=0A=
        } else if (typeof arr[0] =3D=3D=3D 'number') {=0A=
          this._makeRange(arr, value, path);=0A=
          if (arr[0] !=3D=3D value) {=0A=
            this.changedOptions.push({ path: path, value: Number(value) =
});=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_update',=0A=
=0A=
      /**=0A=
       * called to update the network with the new settings.=0A=
       * @param value=0A=
       * @param path=0A=
       * @private=0A=
       */=0A=
      value: function _update(value, path) {=0A=
        var options =3D this._constructOptions(value, path);=0A=
=0A=
        if (this.parent.body && this.parent.body.emitter && =
this.parent.body.emitter.emit) {=0A=
          this.parent.body.emitter.emit('configChange', options);=0A=
        }=0A=
=0A=
        this.parent.setOptions(options);=0A=
      }=0A=
    }, {=0A=
      key: '_constructOptions',=0A=
      value: function _constructOptions(value, path) {=0A=
        var optionsObj =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? {} : arguments[2];=0A=
=0A=
        var pointer =3D optionsObj;=0A=
=0A=
        // when dropdown boxes can be string or boolean, we typecast it =
into correct types=0A=
        value =3D value =3D=3D=3D 'true' ? true : value;=0A=
        value =3D value =3D=3D=3D 'false' ? false : value;=0A=
=0A=
        for (var i =3D 0; i < path.length; i++) {=0A=
          if (path[i] !=3D=3D 'global') {=0A=
            if (pointer[path[i]] =3D=3D=3D undefined) {=0A=
              pointer[path[i]] =3D {};=0A=
            }=0A=
            if (i !=3D=3D path.length - 1) {=0A=
              pointer =3D pointer[path[i]];=0A=
            } else {=0A=
              pointer[path[i]] =3D value;=0A=
            }=0A=
          }=0A=
        }=0A=
        return optionsObj;=0A=
      }=0A=
    }, {=0A=
      key: '_printOptions',=0A=
      value: function _printOptions() {=0A=
        var options =3D this.getOptions();=0A=
        this.optionsContainer.innerHTML =3D '<pre>var options =3D ' + =
JSON.stringify(options, null, 2) + '</pre>';=0A=
      }=0A=
    }, {=0A=
      key: 'getOptions',=0A=
      value: function getOptions() {=0A=
        var options =3D {};=0A=
        for (var i =3D 0; i < this.changedOptions.length; i++) {=0A=
          this._constructOptions(this.changedOptions[i].value, =
this.changedOptions[i].path, options);=0A=
        }=0A=
        return options;=0A=
      }=0A=
    }]);=0A=
=0A=
    return Configurator;=0A=
  })();=0A=
=0A=
  exports['default'] =3D Configurator;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 46 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var hammerUtil =3D __webpack_require__(27);=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var ColorPicker =3D (function () {=0A=
    function ColorPicker() {=0A=
      var pixelRatio =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? 1 : arguments[0];=0A=
=0A=
      _classCallCheck(this, ColorPicker);=0A=
=0A=
      this.pixelRatio =3D pixelRatio;=0A=
      this.generated =3D false;=0A=
      this.centerCoordinates =3D { x: 289 / 2, y: 289 / 2 };=0A=
      this.r =3D 289 * 0.49;=0A=
      this.color =3D { r: 255, g: 255, b: 255, a: 1.0 };=0A=
      this.hueCircle =3D undefined;=0A=
      this.initialColor =3D { r: 255, g: 255, b: 255, a: 1.0 };=0A=
      this.previousColor =3D undefined;=0A=
      this.applied =3D false;=0A=
=0A=
      // bound by=0A=
      this.updateCallback =3D function () {};=0A=
=0A=
      // create all DOM elements=0A=
      this._create();=0A=
    }=0A=
=0A=
    _createClass(ColorPicker, [{=0A=
      key: 'insertTo',=0A=
=0A=
      /**=0A=
       * this inserts the colorPicker into a div from the DOM=0A=
       * @param container=0A=
       */=0A=
      value: function insertTo(container) {=0A=
        if (this.hammer !=3D=3D undefined) {=0A=
          this.hammer.destroy();=0A=
          this.hammer =3D undefined;=0A=
        }=0A=
        this.container =3D container;=0A=
        this.container.appendChild(this.frame);=0A=
        this._bindHammer();=0A=
=0A=
        this._setSize();=0A=
      }=0A=
    }, {=0A=
      key: 'setCallback',=0A=
=0A=
      /**=0A=
       * the callback is executed on apply and save. Bind it to the =
application=0A=
       * @param callback=0A=
       */=0A=
      value: function setCallback(callback) {=0A=
        if (typeof callback =3D=3D=3D 'function') {=0A=
          this.updateCallback =3D callback;=0A=
        } else {=0A=
          throw new Error('Function attempted to set as colorPicker =
callback is not a function.');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_isColorString',=0A=
      value: function _isColorString(color) {=0A=
        var htmlColors =3D { black: '#000000', navy: '#000080', =
darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: =
'#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', =
deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: =
'#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', =
cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', =
lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', =
darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: =
'#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: =
'#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: =
'#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', =
cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: =
'#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: =
'#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', =
lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', =
maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', =
skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', =
darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', =
darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', =
darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', =
yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: =
'#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: =
'#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: =
'#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: =
'#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: =
'#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', =
tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: =
'#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', =
gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: =
'#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: =
'#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: =
'#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', =
sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: =
'#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: =
'#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', =
lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', =
fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: =
'#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', =
darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', =
lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: =
'#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: =
'#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: =
'#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: =
'#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: =
'#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', =
white: '#FFFFFF' };=0A=
        if (typeof color =3D=3D=3D 'string') {=0A=
          return htmlColors[color];=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'setColor',=0A=
=0A=
      /**=0A=
       * Set the color of the colorPicker=0A=
       * Supported formats:=0A=
       * 'red'                   --> HTML color string=0A=
       * '#ffffff'               --> hex string=0A=
       * 'rbg(255,255,255)'      --> rgb string=0A=
       * 'rgba(255,255,255,1.0)' --> rgba string=0A=
       * {r:255,g:255,b:255}     --> rgb object=0A=
       * {r:255,g:255,b:255,a:1.0} --> rgba object=0A=
       * @param color=0A=
       * @param setInitial=0A=
       */=0A=
      value: function setColor(color) {=0A=
        var setInitial =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? true : arguments[1];=0A=
=0A=
        if (color =3D=3D=3D 'none') {=0A=
          return;=0A=
        }=0A=
=0A=
        var rgba =3D undefined;=0A=
=0A=
        // if a html color shorthand is used, convert to hex=0A=
        var htmlColor =3D this._isColorString(color);=0A=
        if (htmlColor !=3D=3D undefined) {=0A=
          color =3D htmlColor;=0A=
        }=0A=
=0A=
        // check format=0A=
        if (util.isString(color) =3D=3D=3D true) {=0A=
          if (util.isValidRGB(color) =3D=3D=3D true) {=0A=
            var rgbaArray =3D color.substr(4).substr(0, color.length - =
5).split(',');=0A=
            rgba =3D { r: rgbaArray[0], g: rgbaArray[1], b: =
rgbaArray[2], a: 1.0 };=0A=
          } else if (util.isValidRGBA(color) =3D=3D=3D true) {=0A=
            var rgbaArray =3D color.substr(5).substr(0, color.length - =
6).split(',');=0A=
            rgba =3D { r: rgbaArray[0], g: rgbaArray[1], b: =
rgbaArray[2], a: rgbaArray[3] };=0A=
          } else if (util.isValidHex(color) =3D=3D=3D true) {=0A=
            var rgbObj =3D util.hexToRGB(color);=0A=
            rgba =3D { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };=0A=
          }=0A=
        } else {=0A=
          if (color instanceof Object) {=0A=
            if (color.r !=3D=3D undefined && color.g !=3D=3D undefined =
&& color.b !=3D=3D undefined) {=0A=
              var alpha =3D color.a !=3D=3D undefined ? color.a : '1.0';=0A=
              rgba =3D { r: color.r, g: color.g, b: color.b, a: alpha };=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // set color=0A=
        if (rgba =3D=3D=3D undefined) {=0A=
          throw new Error('Unknown color passed to the colorPicker. =
Supported are strings: rgb, hex, rgba. Object: rgb =
({r:r,g:g,b:b,[a:a]}). Supplied: ' + JSON.stringify(color));=0A=
        } else {=0A=
          this._setColor(rgba, setInitial);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'show',=0A=
=0A=
      /**=0A=
       * this shows the color picker at a location. The hue circle is =
constructed once and stored.=0A=
       * @param x=0A=
       * @param y=0A=
       */=0A=
      value: function show(x, y) {=0A=
        this.applied =3D false;=0A=
        this.frame.style.display =3D 'block';=0A=
        this.frame.style.top =3D y + 'px';=0A=
        this.frame.style.left =3D x + 'px';=0A=
        this._generateHueCircle();=0A=
      }=0A=
    }, {=0A=
      key: '_hide',=0A=
=0A=
      // ------------------------------------------ PRIVATE =
----------------------------- //=0A=
=0A=
      /**=0A=
       * Hide the picker. Is called by the cancel button.=0A=
       * Optional boolean to store the previous color for easy access =
later on.=0A=
       * @param storePrevious=0A=
       * @private=0A=
       */=0A=
      value: function _hide() {=0A=
        var storePrevious =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? true : arguments[0];=0A=
=0A=
        // store the previous color for next time;=0A=
        if (storePrevious =3D=3D=3D true) {=0A=
          this.previousColor =3D util.extend({}, this.color);=0A=
        }=0A=
=0A=
        if (this.applied =3D=3D=3D true) {=0A=
          this.updateCallback(this.initialColor);=0A=
        }=0A=
=0A=
        this.frame.style.display =3D 'none';=0A=
      }=0A=
    }, {=0A=
      key: '_save',=0A=
=0A=
      /**=0A=
       * bound to the save button. Saves and hides.=0A=
       * @private=0A=
       */=0A=
      value: function _save() {=0A=
        this.updateCallback(this.color);=0A=
        this.applied =3D false;=0A=
        this._hide();=0A=
      }=0A=
    }, {=0A=
      key: '_apply',=0A=
=0A=
      /**=0A=
       * Bound to apply button. Saves but does not close. Is undone by =
the cancel button.=0A=
       * @private=0A=
       */=0A=
      value: function _apply() {=0A=
        this.applied =3D true;=0A=
        this.updateCallback(this.color);=0A=
        this._updatePicker(this.color);=0A=
      }=0A=
    }, {=0A=
      key: '_loadLast',=0A=
=0A=
      /**=0A=
       * load the color from the previous session.=0A=
       * @private=0A=
       */=0A=
      value: function _loadLast() {=0A=
        if (this.previousColor !=3D=3D undefined) {=0A=
          this.setColor(this.previousColor, false);=0A=
        } else {=0A=
          alert('There is no last color to load...');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_setColor',=0A=
=0A=
      /**=0A=
       * set the color, place the picker=0A=
       * @param rgba=0A=
       * @param setInitial=0A=
       * @private=0A=
       */=0A=
      value: function _setColor(rgba) {=0A=
        var setInitial =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? true : arguments[1];=0A=
=0A=
        // store the initial color=0A=
        if (setInitial =3D=3D=3D true) {=0A=
          this.initialColor =3D util.extend({}, rgba);=0A=
        }=0A=
=0A=
        this.color =3D rgba;=0A=
        var hsv =3D util.RGBToHSV(rgba.r, rgba.g, rgba.b);=0A=
=0A=
        var angleConvert =3D 2 * Math.PI;=0A=
        var radius =3D this.r * hsv.s;=0A=
        var x =3D this.centerCoordinates.x + radius * =
Math.sin(angleConvert * hsv.h);=0A=
        var y =3D this.centerCoordinates.y + radius * =
Math.cos(angleConvert * hsv.h);=0A=
=0A=
        this.colorPickerSelector.style.left =3D x - 0.5 * =
this.colorPickerSelector.clientWidth + 'px';=0A=
        this.colorPickerSelector.style.top =3D y - 0.5 * =
this.colorPickerSelector.clientHeight + 'px';=0A=
=0A=
        this._updatePicker(rgba);=0A=
      }=0A=
    }, {=0A=
      key: '_setOpacity',=0A=
=0A=
      /**=0A=
       * bound to opacity control=0A=
       * @param value=0A=
       * @private=0A=
       */=0A=
      value: function _setOpacity(value) {=0A=
        this.color.a =3D value / 100;=0A=
        this._updatePicker(this.color);=0A=
      }=0A=
    }, {=0A=
      key: '_setBrightness',=0A=
=0A=
      /**=0A=
       * bound to brightness control=0A=
       * @param value=0A=
       * @private=0A=
       */=0A=
      value: function _setBrightness(value) {=0A=
        var hsv =3D util.RGBToHSV(this.color.r, this.color.g, =
this.color.b);=0A=
        hsv.v =3D value / 100;=0A=
        var rgba =3D util.HSVToRGB(hsv.h, hsv.s, hsv.v);=0A=
        rgba['a'] =3D this.color.a;=0A=
        this.color =3D rgba;=0A=
        this._updatePicker();=0A=
      }=0A=
    }, {=0A=
      key: '_updatePicker',=0A=
=0A=
      /**=0A=
       * update the colorpicker. A black circle overlays the hue circle =
to mimic the brightness decreasing.=0A=
       * @param rgba=0A=
       * @private=0A=
       */=0A=
      value: function _updatePicker() {=0A=
        var rgba =3D arguments.length <=3D 0 || arguments[0] =3D=3D=3D =
undefined ? this.color : arguments[0];=0A=
=0A=
        var hsv =3D util.RGBToHSV(rgba.r, rgba.g, rgba.b);=0A=
        var ctx =3D this.colorPickerCanvas.getContext('2d');=0A=
        if (this.pixelRation =3D=3D=3D undefined) {=0A=
          this.pixelRatio =3D (window.devicePixelRatio || 1) / =
(ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || =
ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || =
ctx.backingStorePixelRatio || 1);=0A=
        }=0A=
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);=0A=
=0A=
        // clear the canvas=0A=
        var w =3D this.colorPickerCanvas.clientWidth;=0A=
        var h =3D this.colorPickerCanvas.clientHeight;=0A=
        ctx.clearRect(0, 0, w, h);=0A=
=0A=
        ctx.putImageData(this.hueCircle, 0, 0);=0A=
        ctx.fillStyle =3D 'rgba(0,0,0,' + (1 - hsv.v) + ')';=0A=
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, =
this.r);=0A=
        ctx.fill();=0A=
=0A=
        this.brightnessRange.value =3D 100 * hsv.v;=0A=
        this.opacityRange.value =3D 100 * rgba.a;=0A=
=0A=
        this.initialColorDiv.style.backgroundColor =3D 'rgba(' + =
this.initialColor.r + ',' + this.initialColor.g + ',' + =
this.initialColor.b + ',' + this.initialColor.a + ')';=0A=
        this.newColorDiv.style.backgroundColor =3D 'rgba(' + =
this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + =
this.color.a + ')';=0A=
      }=0A=
    }, {=0A=
      key: '_setSize',=0A=
=0A=
      /**=0A=
       * used by create to set the size of the canvas.=0A=
       * @private=0A=
       */=0A=
      value: function _setSize() {=0A=
        this.colorPickerCanvas.style.width =3D '100%';=0A=
        this.colorPickerCanvas.style.height =3D '100%';=0A=
=0A=
        this.colorPickerCanvas.width =3D 289 * this.pixelRatio;=0A=
        this.colorPickerCanvas.height =3D 289 * this.pixelRatio;=0A=
      }=0A=
    }, {=0A=
      key: '_create',=0A=
=0A=
      /**=0A=
       * create all dom elements=0A=
       * TODO: cleanup, lots of similar dom elements=0A=
       * @private=0A=
       */=0A=
      value: function _create() {=0A=
        this.frame =3D document.createElement('div');=0A=
        this.frame.className =3D 'vis-color-picker';=0A=
=0A=
        this.colorPickerDiv =3D document.createElement('div');=0A=
        this.colorPickerSelector =3D document.createElement('div');=0A=
        this.colorPickerSelector.className =3D 'vis-selector';=0A=
        this.colorPickerDiv.appendChild(this.colorPickerSelector);=0A=
=0A=
        this.colorPickerCanvas =3D document.createElement('canvas');=0A=
        this.colorPickerDiv.appendChild(this.colorPickerCanvas);=0A=
=0A=
        if (!this.colorPickerCanvas.getContext) {=0A=
          var noCanvas =3D document.createElement('DIV');=0A=
          noCanvas.style.color =3D 'red';=0A=
          noCanvas.style.fontWeight =3D 'bold';=0A=
          noCanvas.style.padding =3D '10px';=0A=
          noCanvas.innerHTML =3D 'Error: your browser does not support =
HTML canvas';=0A=
          this.colorPickerCanvas.appendChild(noCanvas);=0A=
        } else {=0A=
          var ctx =3D this.colorPickerCanvas.getContext('2d');=0A=
          this.pixelRatio =3D (window.devicePixelRatio || 1) / =
(ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || =
ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || =
ctx.backingStorePixelRatio || 1);=0A=
=0A=
          =
this.colorPickerCanvas.getContext('2d').setTransform(this.pixelRatio, 0, =
0, this.pixelRatio, 0, 0);=0A=
        }=0A=
=0A=
        this.colorPickerDiv.className =3D 'vis-color';=0A=
=0A=
        this.opacityDiv =3D document.createElement('div');=0A=
        this.opacityDiv.className =3D 'vis-opacity';=0A=
=0A=
        this.brightnessDiv =3D document.createElement('div');=0A=
        this.brightnessDiv.className =3D 'vis-brightness';=0A=
=0A=
        this.arrowDiv =3D document.createElement('div');=0A=
        this.arrowDiv.className =3D 'vis-arrow';=0A=
=0A=
        this.opacityRange =3D document.createElement('input');=0A=
        try {=0A=
          this.opacityRange.type =3D 'range'; // Not supported on IE9=0A=
          this.opacityRange.min =3D '0';=0A=
          this.opacityRange.max =3D '100';=0A=
        } catch (err) {}=0A=
        this.opacityRange.value =3D '100';=0A=
        this.opacityRange.className =3D 'vis-range';=0A=
=0A=
        this.brightnessRange =3D document.createElement('input');=0A=
        try {=0A=
          this.brightnessRange.type =3D 'range'; // Not supported on IE9=0A=
          this.brightnessRange.min =3D '0';=0A=
          this.brightnessRange.max =3D '100';=0A=
        } catch (err) {}=0A=
        this.brightnessRange.value =3D '100';=0A=
        this.brightnessRange.className =3D 'vis-range';=0A=
=0A=
        this.opacityDiv.appendChild(this.opacityRange);=0A=
        this.brightnessDiv.appendChild(this.brightnessRange);=0A=
=0A=
        var me =3D this;=0A=
        this.opacityRange.onchange =3D function () {=0A=
          me._setOpacity(this.value);=0A=
        };=0A=
        this.opacityRange.oninput =3D function () {=0A=
          me._setOpacity(this.value);=0A=
        };=0A=
        this.brightnessRange.onchange =3D function () {=0A=
          me._setBrightness(this.value);=0A=
        };=0A=
        this.brightnessRange.oninput =3D function () {=0A=
          me._setBrightness(this.value);=0A=
        };=0A=
=0A=
        this.brightnessLabel =3D document.createElement('div');=0A=
        this.brightnessLabel.className =3D 'vis-label vis-brightness';=0A=
        this.brightnessLabel.innerHTML =3D 'brightness:';=0A=
=0A=
        this.opacityLabel =3D document.createElement('div');=0A=
        this.opacityLabel.className =3D 'vis-label vis-opacity';=0A=
        this.opacityLabel.innerHTML =3D 'opacity:';=0A=
=0A=
        this.newColorDiv =3D document.createElement('div');=0A=
        this.newColorDiv.className =3D 'vis-new-color';=0A=
        this.newColorDiv.innerHTML =3D 'new';=0A=
=0A=
        this.initialColorDiv =3D document.createElement('div');=0A=
        this.initialColorDiv.className =3D 'vis-initial-color';=0A=
        this.initialColorDiv.innerHTML =3D 'initial';=0A=
=0A=
        this.cancelButton =3D document.createElement('div');=0A=
        this.cancelButton.className =3D 'vis-button vis-cancel';=0A=
        this.cancelButton.innerHTML =3D 'cancel';=0A=
        this.cancelButton.onclick =3D this._hide.bind(this, false);=0A=
=0A=
        this.applyButton =3D document.createElement('div');=0A=
        this.applyButton.className =3D 'vis-button vis-apply';=0A=
        this.applyButton.innerHTML =3D 'apply';=0A=
        this.applyButton.onclick =3D this._apply.bind(this);=0A=
=0A=
        this.saveButton =3D document.createElement('div');=0A=
        this.saveButton.className =3D 'vis-button vis-save';=0A=
        this.saveButton.innerHTML =3D 'save';=0A=
        this.saveButton.onclick =3D this._save.bind(this);=0A=
=0A=
        this.loadButton =3D document.createElement('div');=0A=
        this.loadButton.className =3D 'vis-button vis-load';=0A=
        this.loadButton.innerHTML =3D 'load last';=0A=
        this.loadButton.onclick =3D this._loadLast.bind(this);=0A=
=0A=
        this.frame.appendChild(this.colorPickerDiv);=0A=
        this.frame.appendChild(this.arrowDiv);=0A=
        this.frame.appendChild(this.brightnessLabel);=0A=
        this.frame.appendChild(this.brightnessDiv);=0A=
        this.frame.appendChild(this.opacityLabel);=0A=
        this.frame.appendChild(this.opacityDiv);=0A=
        this.frame.appendChild(this.newColorDiv);=0A=
        this.frame.appendChild(this.initialColorDiv);=0A=
=0A=
        this.frame.appendChild(this.cancelButton);=0A=
        this.frame.appendChild(this.applyButton);=0A=
        this.frame.appendChild(this.saveButton);=0A=
        this.frame.appendChild(this.loadButton);=0A=
      }=0A=
    }, {=0A=
      key: '_bindHammer',=0A=
=0A=
      /**=0A=
       * bind hammer to the color picker=0A=
       * @private=0A=
       */=0A=
      value: function _bindHammer() {=0A=
        var _this =3D this;=0A=
=0A=
        this.drag =3D {};=0A=
        this.pinch =3D {};=0A=
        this.hammer =3D new Hammer(this.colorPickerCanvas);=0A=
        this.hammer.get('pinch').set({ enable: true });=0A=
=0A=
        hammerUtil.onTouch(this.hammer, function (event) {=0A=
          _this._moveSelector(event);=0A=
        });=0A=
        this.hammer.on('tap', function (event) {=0A=
          _this._moveSelector(event);=0A=
        });=0A=
        this.hammer.on('panstart', function (event) {=0A=
          _this._moveSelector(event);=0A=
        });=0A=
        this.hammer.on('panmove', function (event) {=0A=
          _this._moveSelector(event);=0A=
        });=0A=
        this.hammer.on('panend', function (event) {=0A=
          _this._moveSelector(event);=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: '_generateHueCircle',=0A=
=0A=
      /**=0A=
       * generate the hue circle. This is relatively heavy (200ms) and =
is done only once on the first time it is shown.=0A=
       * @private=0A=
       */=0A=
      value: function _generateHueCircle() {=0A=
        if (this.generated =3D=3D=3D false) {=0A=
          var ctx =3D this.colorPickerCanvas.getContext('2d');=0A=
          if (this.pixelRation =3D=3D=3D undefined) {=0A=
            this.pixelRatio =3D (window.devicePixelRatio || 1) / =
(ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || =
ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || =
ctx.backingStorePixelRatio || 1);=0A=
          }=0A=
          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);=0A=
=0A=
          // clear the canvas=0A=
          var w =3D this.colorPickerCanvas.clientWidth;=0A=
          var h =3D this.colorPickerCanvas.clientHeight;=0A=
          ctx.clearRect(0, 0, w, h);=0A=
=0A=
          // draw hue circle=0A=
          var x =3D undefined,=0A=
              y =3D undefined,=0A=
              hue =3D undefined,=0A=
              sat =3D undefined;=0A=
          this.centerCoordinates =3D { x: w * 0.5, y: h * 0.5 };=0A=
          this.r =3D 0.49 * w;=0A=
          var angleConvert =3D 2 * Math.PI / 360;=0A=
          var hfac =3D 1 / 360;=0A=
          var sfac =3D 1 / this.r;=0A=
          var rgb =3D undefined;=0A=
          for (hue =3D 0; hue < 360; hue++) {=0A=
            for (sat =3D 0; sat < this.r; sat++) {=0A=
              x =3D this.centerCoordinates.x + sat * =
Math.sin(angleConvert * hue);=0A=
              y =3D this.centerCoordinates.y + sat * =
Math.cos(angleConvert * hue);=0A=
              rgb =3D util.HSVToRGB(hue * hfac, sat * sfac, 1);=0A=
              ctx.fillStyle =3D 'rgb(' + rgb.r + ',' + rgb.g + ',' + =
rgb.b + ')';=0A=
              ctx.fillRect(x - 0.5, y - 0.5, 2, 2);=0A=
            }=0A=
          }=0A=
          ctx.strokeStyle =3D 'rgba(0,0,0,1)';=0A=
          ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, =
this.r);=0A=
          ctx.stroke();=0A=
=0A=
          this.hueCircle =3D ctx.getImageData(0, 0, w, h);=0A=
        }=0A=
        this.generated =3D true;=0A=
      }=0A=
    }, {=0A=
      key: '_moveSelector',=0A=
=0A=
      /**=0A=
       * move the selector. This is called by hammer functions.=0A=
       *=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function _moveSelector(event) {=0A=
        var rect =3D this.colorPickerDiv.getBoundingClientRect();=0A=
        var left =3D event.center.x - rect.left;=0A=
        var top =3D event.center.y - rect.top;=0A=
=0A=
        var centerY =3D 0.5 * this.colorPickerDiv.clientHeight;=0A=
        var centerX =3D 0.5 * this.colorPickerDiv.clientWidth;=0A=
=0A=
        var x =3D left - centerX;=0A=
        var y =3D top - centerY;=0A=
=0A=
        var angle =3D Math.atan2(x, y);=0A=
        var radius =3D 0.98 * Math.min(Math.sqrt(x * x + y * y), =
centerX);=0A=
=0A=
        var newTop =3D Math.cos(angle) * radius + centerY;=0A=
        var newLeft =3D Math.sin(angle) * radius + centerX;=0A=
=0A=
        this.colorPickerSelector.style.top =3D newTop - 0.5 * =
this.colorPickerSelector.clientHeight + 'px';=0A=
        this.colorPickerSelector.style.left =3D newLeft - 0.5 * =
this.colorPickerSelector.clientWidth + 'px';=0A=
=0A=
        // set color=0A=
        var h =3D angle / (2 * Math.PI);=0A=
        h =3D h < 0 ? h + 1 : h;=0A=
        var s =3D radius / this.r;=0A=
        var hsv =3D util.RGBToHSV(this.color.r, this.color.g, =
this.color.b);=0A=
        hsv.h =3D h;=0A=
        hsv.s =3D s;=0A=
        var rgba =3D util.HSVToRGB(hsv.h, hsv.s, hsv.v);=0A=
        rgba['a'] =3D this.color.a;=0A=
        this.color =3D rgba;=0A=
=0A=
        // update previews=0A=
        this.initialColorDiv.style.backgroundColor =3D 'rgba(' + =
this.initialColor.r + ',' + this.initialColor.g + ',' + =
this.initialColor.b + ',' + this.initialColor.a + ')';=0A=
        this.newColorDiv.style.backgroundColor =3D 'rgba(' + =
this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + =
this.color.a + ')';=0A=
      }=0A=
    }]);=0A=
=0A=
    return ColorPicker;=0A=
  })();=0A=
=0A=
  exports['default'] =3D ColorPicker;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 47 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var errorFound =3D false;=0A=
  var allOptions =3D undefined;=0A=
  var printStyle =3D 'background: #FFeeee; color: #dd0000';=0A=
  /**=0A=
   *  Used to validate options.=0A=
   */=0A=
=0A=
  var Validator =3D (function () {=0A=
    function Validator() {=0A=
      _classCallCheck(this, Validator);=0A=
    }=0A=
=0A=
    _createClass(Validator, null, [{=0A=
      key: 'validate',=0A=
=0A=
      /**=0A=
       * Main function to be called=0A=
       * @param options=0A=
       * @param subObject=0A=
       * @returns {boolean}=0A=
       */=0A=
      value: function validate(options, referenceOptions, subObject) {=0A=
        errorFound =3D false;=0A=
        allOptions =3D referenceOptions;=0A=
        var usedOptions =3D referenceOptions;=0A=
        if (subObject !=3D=3D undefined) {=0A=
          usedOptions =3D referenceOptions[subObject];=0A=
        }=0A=
        Validator.parse(options, usedOptions, []);=0A=
        return errorFound;=0A=
      }=0A=
    }, {=0A=
      key: 'parse',=0A=
=0A=
      /**=0A=
       * Will traverse an object recursively and check every value=0A=
       * @param options=0A=
       * @param referenceOptions=0A=
       * @param path=0A=
       */=0A=
      value: function parse(options, referenceOptions, path) {=0A=
        for (var option in options) {=0A=
          if (options.hasOwnProperty(option)) {=0A=
            Validator.check(option, options, referenceOptions, path);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'check',=0A=
=0A=
      /**=0A=
       * Check every value. If the value is an object, call the parse =
function on that object.=0A=
       * @param option=0A=
       * @param options=0A=
       * @param referenceOptions=0A=
       * @param path=0A=
       */=0A=
      value: function check(option, options, referenceOptions, path) {=0A=
        if (referenceOptions[option] =3D=3D=3D undefined && =
referenceOptions.__any__ =3D=3D=3D undefined) {=0A=
          Validator.getSuggestion(option, referenceOptions, path);=0A=
        } else if (referenceOptions[option] =3D=3D=3D undefined && =
referenceOptions.__any__ !=3D=3D undefined) {=0A=
          // __any__ is a wildcard. Any value is accepted and will be =
further analysed by reference.=0A=
          if (Validator.getType(options[option]) =3D=3D=3D 'object' && =
referenceOptions['__any__'].__type__ !=3D=3D undefined) {=0A=
            // if the any subgroup is not a predefined object int he =
configurator we do not look deeper into the object.=0A=
            Validator.checkFields(option, options, referenceOptions, =
'__any__', referenceOptions['__any__'].__type__, path);=0A=
          } else {=0A=
            Validator.checkFields(option, options, referenceOptions, =
'__any__', referenceOptions['__any__'], path);=0A=
          }=0A=
        } else {=0A=
          // Since all options in the reference are objects, we can =
check whether they are supposed to be object to look for the __type__ =
field.=0A=
          if (referenceOptions[option].__type__ !=3D=3D undefined) {=0A=
            // if this should be an object, we check if the correct type =
has been supplied to account for shorthand options.=0A=
            Validator.checkFields(option, options, referenceOptions, =
option, referenceOptions[option].__type__, path);=0A=
          } else {=0A=
            Validator.checkFields(option, options, referenceOptions, =
option, referenceOptions[option], path);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'checkFields',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param {String}  option     | the option property=0A=
       * @param {Object}  options    | The supplied options object=0A=
       * @param {Object}  referenceOptions    | The reference options =
containing all options and their allowed formats=0A=
       * @param {String}  referenceOption     | Usually this is the same =
as option, except when handling an __any__ tag.=0A=
       * @param {String}  refOptionType       | This is the type object =
from the reference options=0A=
       * @param {Array}   path      | where in the object is the option=0A=
       */=0A=
      value: function checkFields(option, options, referenceOptions, =
referenceOption, refOptionObj, path) {=0A=
        var optionType =3D Validator.getType(options[option]);=0A=
        var refOptionType =3D refOptionObj[optionType];=0A=
        if (refOptionType !=3D=3D undefined) {=0A=
          // if the type is correct, we check if it is supposed to be =
one of a few select values=0A=
          if (Validator.getType(refOptionType) =3D=3D=3D 'array') {=0A=
            if (refOptionType.indexOf(options[option]) =3D=3D=3D -1) {=0A=
              console.log('%cInvalid option detected in "' + option + =
'".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not =
"' + options[option] + '". ' + Validator.printLocation(path, option), =
printStyle);=0A=
              errorFound =3D true;=0A=
            } else if (optionType =3D=3D=3D 'object' && referenceOption =
!=3D=3D '__any__') {=0A=
              path =3D util.copyAndExtendArray(path, option);=0A=
              Validator.parse(options[option], =
referenceOptions[referenceOption], path);=0A=
            }=0A=
          } else if (optionType =3D=3D=3D 'object' && referenceOption =
!=3D=3D '__any__') {=0A=
            path =3D util.copyAndExtendArray(path, option);=0A=
            Validator.parse(options[option], =
referenceOptions[referenceOption], path);=0A=
          }=0A=
        } else if (refOptionObj['any'] =3D=3D=3D undefined) {=0A=
          // type of the field is incorrect and the field cannot be any=0A=
          console.log('%cInvalid type received for "' + option + '". =
Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received =
[' + optionType + '] "' + options[option] + '"' + =
Validator.printLocation(path, option), printStyle);=0A=
          errorFound =3D true;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'getType',=0A=
      value: function getType(object) {=0A=
        var type =3D typeof object;=0A=
=0A=
        if (type =3D=3D=3D 'object') {=0A=
          if (object =3D=3D=3D null) {=0A=
            return 'null';=0A=
          }=0A=
          if (object instanceof Boolean) {=0A=
            return 'boolean';=0A=
          }=0A=
          if (object instanceof Number) {=0A=
            return 'number';=0A=
          }=0A=
          if (object instanceof String) {=0A=
            return 'string';=0A=
          }=0A=
          if (Array.isArray(object)) {=0A=
            return 'array';=0A=
          }=0A=
          if (object instanceof Date) {=0A=
            return 'date';=0A=
          }=0A=
          if (object.nodeType !=3D=3D undefined) {=0A=
            return 'dom';=0A=
          }=0A=
          if (object._isAMomentObject =3D=3D=3D true) {=0A=
            return 'moment';=0A=
          }=0A=
          return 'object';=0A=
        } else if (type =3D=3D=3D 'number') {=0A=
          return 'number';=0A=
        } else if (type =3D=3D=3D 'boolean') {=0A=
          return 'boolean';=0A=
        } else if (type =3D=3D=3D 'string') {=0A=
          return 'string';=0A=
        } else if (type =3D=3D=3D undefined) {=0A=
          return 'undefined';=0A=
        }=0A=
        return type;=0A=
      }=0A=
    }, {=0A=
      key: 'getSuggestion',=0A=
      value: function getSuggestion(option, options, path) {=0A=
        var localSearch =3D Validator.findInOptions(option, options, =
path, false);=0A=
        var globalSearch =3D Validator.findInOptions(option, allOptions, =
[], true);=0A=
=0A=
        var localSearchThreshold =3D 8;=0A=
        var globalSearchThreshold =3D 4;=0A=
=0A=
        if (localSearch.indexMatch !=3D=3D undefined) {=0A=
          console.log('%cUnknown option detected: "' + option + '" in ' =
+ Validator.printLocation(localSearch.path, option, '') + 'Perhaps it =
was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', =
printStyle);=0A=
        } else if (globalSearch.distance <=3D globalSearchThreshold && =
localSearch.distance > globalSearch.distance) {=0A=
          console.log('%cUnknown option detected: "' + option + '" in ' =
+ Validator.printLocation(localSearch.path, option, '') + 'Perhaps it =
was misplaced? Matching option found at: ' + =
Validator.printLocation(globalSearch.path, globalSearch.closestMatch, =
''), printStyle);=0A=
        } else if (localSearch.distance <=3D localSearchThreshold) {=0A=
          console.log('%cUnknown option detected: "' + option + '". Did =
you mean "' + localSearch.closestMatch + '"?' + =
Validator.printLocation(localSearch.path, option), printStyle);=0A=
        } else {=0A=
          console.log('%cUnknown option detected: "' + option + '". Did =
you mean one of these: ' + Validator.print(Object.keys(options)) + =
Validator.printLocation(path, option), printStyle);=0A=
        }=0A=
=0A=
        errorFound =3D true;=0A=
      }=0A=
    }, {=0A=
      key: 'findInOptions',=0A=
=0A=
      /**=0A=
       * traverse the options in search for a match.=0A=
       * @param option=0A=
       * @param options=0A=
       * @param path=0A=
       * @param recursive=0A=
       * @returns {{closestMatch: string, path: Array, distance: number}}=0A=
       */=0A=
      value: function findInOptions(option, options, path) {=0A=
        var recursive =3D arguments.length <=3D 3 || arguments[3] =
=3D=3D=3D undefined ? false : arguments[3];=0A=
=0A=
        var min =3D 1e9;=0A=
        var closestMatch =3D '';=0A=
        var closestMatchPath =3D [];=0A=
        var lowerCaseOption =3D option.toLowerCase();=0A=
        var indexMatch =3D undefined;=0A=
        for (var op in options) {=0A=
          var distance =3D undefined;=0A=
          if (options[op].__type__ !=3D=3D undefined && recursive =
=3D=3D=3D true) {=0A=
            var result =3D Validator.findInOptions(option, options[op], =
util.copyAndExtendArray(path, op));=0A=
            if (min > result.distance) {=0A=
              closestMatch =3D result.closestMatch;=0A=
              closestMatchPath =3D result.path;=0A=
              min =3D result.distance;=0A=
              indexMatch =3D result.indexMatch;=0A=
            }=0A=
          } else {=0A=
            if (op.toLowerCase().indexOf(lowerCaseOption) !=3D=3D -1) {=0A=
              indexMatch =3D op;=0A=
            }=0A=
            distance =3D Validator.levenshteinDistance(option, op);=0A=
            if (min > distance) {=0A=
              closestMatch =3D op;=0A=
              closestMatchPath =3D util.copyArray(path);=0A=
              min =3D distance;=0A=
            }=0A=
          }=0A=
        }=0A=
        return { closestMatch: closestMatch, path: closestMatchPath, =
distance: min, indexMatch: indexMatch };=0A=
      }=0A=
    }, {=0A=
      key: 'printLocation',=0A=
      value: function printLocation(path, option) {=0A=
        var prefix =3D arguments.length <=3D 2 || arguments[2] =3D=3D=3D =
undefined ? 'Problem value found at: \n' : arguments[2];=0A=
=0A=
        var str =3D '\n\n' + prefix + 'options =3D {\n';=0A=
        for (var i =3D 0; i < path.length; i++) {=0A=
          for (var j =3D 0; j < i + 1; j++) {=0A=
            str +=3D '  ';=0A=
          }=0A=
          str +=3D path[i] + ': {\n';=0A=
        }=0A=
        for (var j =3D 0; j < path.length + 1; j++) {=0A=
          str +=3D '  ';=0A=
        }=0A=
        str +=3D option + '\n';=0A=
        for (var i =3D 0; i < path.length + 1; i++) {=0A=
          for (var j =3D 0; j < path.length - i; j++) {=0A=
            str +=3D '  ';=0A=
          }=0A=
          str +=3D '}\n';=0A=
        }=0A=
        return str + '\n\n';=0A=
      }=0A=
    }, {=0A=
      key: 'print',=0A=
      value: function print(options) {=0A=
        return =
JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, =
'').replace(/(\,)/g, ', ');=0A=
      }=0A=
    }, {=0A=
      key: 'levenshteinDistance',=0A=
=0A=
      // Compute the edit distance between the two given strings=0A=
      // =
http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein=
_distance#JavaScript=0A=
      /*=0A=
       Copyright (c) 2011 Andrei Mackenzie=0A=
        Permission is hereby granted, free of charge, to any person =
obtaining a copy of this software and associated documentation files =
(the "Software"), to deal in the Software without restriction, including =
without limitation the rights to use, copy, modify, merge, publish, =
distribute, sublicense, and/or sell copies of the Software, and to =
permit persons to whom the Software is furnished to do so, subject to =
the following conditions:=0A=
        The above copyright notice and this permission notice shall be =
included in all copies or substantial portions of the Software.=0A=
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, =
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF =
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. =
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY =
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, =
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE =
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.=0A=
       */=0A=
      value: function levenshteinDistance(a, b) {=0A=
        if (a.length =3D=3D=3D 0) return b.length;=0A=
        if (b.length =3D=3D=3D 0) return a.length;=0A=
=0A=
        var matrix =3D [];=0A=
=0A=
        // increment along the first column of each row=0A=
        var i;=0A=
        for (i =3D 0; i <=3D b.length; i++) {=0A=
          matrix[i] =3D [i];=0A=
        }=0A=
=0A=
        // increment each column in the first row=0A=
        var j;=0A=
        for (j =3D 0; j <=3D a.length; j++) {=0A=
          matrix[0][j] =3D j;=0A=
        }=0A=
=0A=
        // Fill in the rest of the matrix=0A=
        for (i =3D 1; i <=3D b.length; i++) {=0A=
          for (j =3D 1; j <=3D a.length; j++) {=0A=
            if (b.charAt(i - 1) =3D=3D a.charAt(j - 1)) {=0A=
              matrix[i][j] =3D matrix[i - 1][j - 1];=0A=
            } else {=0A=
              matrix[i][j] =3D Math.min(matrix[i - 1][j - 1] + 1, // =
substitution=0A=
              Math.min(matrix[i][j - 1] + 1, // insertion=0A=
              matrix[i - 1][j] + 1)); // deletion=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        return matrix[b.length][a.length];=0A=
      }=0A=
    }]);=0A=
=0A=
    return Validator;=0A=
  })();=0A=
=0A=
  exports['default'] =3D Validator;=0A=
  exports.printStyle =3D printStyle;=0A=
=0A=
/***/ },=0A=
/* 48 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * This object contains all possible options. It will check if the =
types are correct, if required if the option is one=0A=
   * of the allowed values.=0A=
   *=0A=
   * __any__ means that the name of the property does not matter.=0A=
   * __type__ is a required field for all objects and contains the =
allowed types of all objects=0A=
   */=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
  var string =3D 'string';=0A=
  var boolean =3D 'boolean';=0A=
  var number =3D 'number';=0A=
  var array =3D 'array';=0A=
  var date =3D 'date';=0A=
  var object =3D 'object'; // should only be in a __type__ property=0A=
  var dom =3D 'dom';=0A=
  var moment =3D 'moment';=0A=
  var any =3D 'any';=0A=
=0A=
  var allOptions =3D {=0A=
    configure: {=0A=
      enabled: { boolean: boolean },=0A=
      filter: { boolean: boolean, 'function': 'function' },=0A=
      container: { dom: dom },=0A=
      __type__: { object: object, boolean: boolean, 'function': =
'function' }=0A=
    },=0A=
=0A=
    //globals :=0A=
    align: { string: string },=0A=
    autoResize: { boolean: boolean },=0A=
    clickToUse: { boolean: boolean },=0A=
    dataAttributes: { string: string, array: array },=0A=
    editable: {=0A=
      add: { boolean: boolean, 'undefined': 'undefined' },=0A=
      remove: { boolean: boolean, 'undefined': 'undefined' },=0A=
      updateGroup: { boolean: boolean, 'undefined': 'undefined' },=0A=
      updateTime: { boolean: boolean, 'undefined': 'undefined' },=0A=
      __type__: { boolean: boolean, object: object }=0A=
    },=0A=
    end: { number: number, date: date, string: string, moment: moment },=0A=
    format: {=0A=
      minorLabels: {=0A=
        millisecond: { string: string, 'undefined': 'undefined' },=0A=
        second: { string: string, 'undefined': 'undefined' },=0A=
        minute: { string: string, 'undefined': 'undefined' },=0A=
        hour: { string: string, 'undefined': 'undefined' },=0A=
        weekday: { string: string, 'undefined': 'undefined' },=0A=
        day: { string: string, 'undefined': 'undefined' },=0A=
        month: { string: string, 'undefined': 'undefined' },=0A=
        year: { string: string, 'undefined': 'undefined' },=0A=
        __type__: { object: object }=0A=
      },=0A=
      majorLabels: {=0A=
        millisecond: { string: string, 'undefined': 'undefined' },=0A=
        second: { string: string, 'undefined': 'undefined' },=0A=
        minute: { string: string, 'undefined': 'undefined' },=0A=
        hour: { string: string, 'undefined': 'undefined' },=0A=
        weekday: { string: string, 'undefined': 'undefined' },=0A=
        day: { string: string, 'undefined': 'undefined' },=0A=
        month: { string: string, 'undefined': 'undefined' },=0A=
        year: { string: string, 'undefined': 'undefined' },=0A=
        __type__: { object: object }=0A=
      },=0A=
      __type__: { object: object }=0A=
    },=0A=
    moment: { 'function': 'function' },=0A=
    groupOrder: { string: string, 'function': 'function' },=0A=
    height: { string: string, number: number },=0A=
    hiddenDates: { object: object, array: array },=0A=
    locale: { string: string },=0A=
    locales: {=0A=
      __any__: { any: any },=0A=
      __type__: { object: object }=0A=
    },=0A=
    margin: {=0A=
      axis: { number: number },=0A=
      item: {=0A=
        horizontal: { number: number, 'undefined': 'undefined' },=0A=
        vertical: { number: number, 'undefined': 'undefined' },=0A=
        __type__: { object: object, number: number }=0A=
      },=0A=
      __type__: { object: object, number: number }=0A=
    },=0A=
    max: { date: date, number: number, string: string, moment: moment },=0A=
    maxHeight: { number: number, string: string },=0A=
    min: { date: date, number: number, string: string, moment: moment },=0A=
    minHeight: { number: number, string: string },=0A=
    moveable: { boolean: boolean },=0A=
    multiselect: { boolean: boolean },=0A=
    onAdd: { 'function': 'function' },=0A=
    onUpdate: { 'function': 'function' },=0A=
    onMove: { 'function': 'function' },=0A=
    onMoving: { 'function': 'function' },=0A=
    onRemove: { 'function': 'function' },=0A=
    order: { 'function': 'function' },=0A=
    orientation: {=0A=
      axis: { string: string, 'undefined': 'undefined' },=0A=
      item: { string: string, 'undefined': 'undefined' },=0A=
      __type__: { string: string, object: object }=0A=
    },=0A=
    selectable: { boolean: boolean },=0A=
    showCurrentTime: { boolean: boolean },=0A=
    showMajorLabels: { boolean: boolean },=0A=
    showMinorLabels: { boolean: boolean },=0A=
    stack: { boolean: boolean },=0A=
    snap: { 'function': 'function', 'null': 'null' },=0A=
    start: { date: date, number: number, string: string, moment: moment =
},=0A=
    template: { 'function': 'function' },=0A=
    groupTemplate: { 'function': 'function' },=0A=
    timeAxis: {=0A=
      scale: { string: string, 'undefined': 'undefined' },=0A=
      step: { number: number, 'undefined': 'undefined' },=0A=
      __type__: { object: object }=0A=
    },=0A=
    type: { string: string },=0A=
    width: { string: string, number: number },=0A=
    zoomable: { boolean: boolean },=0A=
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },=0A=
    zoomMax: { number: number },=0A=
    zoomMin: { number: number },=0A=
=0A=
    __type__: { object: object }=0A=
  };=0A=
=0A=
  var configureOptions =3D {=0A=
    global: {=0A=
      align: ['center', 'left', 'right'],=0A=
      autoResize: true,=0A=
      clickToUse: false,=0A=
      // dataAttributes: ['all'], // FIXME: can be 'all' or string[]=0A=
      editable: {=0A=
        add: false,=0A=
        remove: false,=0A=
        updateGroup: false,=0A=
        updateTime: false=0A=
      },=0A=
      end: '',=0A=
      format: {=0A=
        minorLabels: {=0A=
          millisecond: 'SSS',=0A=
          second: 's',=0A=
          minute: 'HH:mm',=0A=
          hour: 'HH:mm',=0A=
          weekday: 'ddd D',=0A=
          day: 'D',=0A=
          month: 'MMM',=0A=
          year: 'YYYY'=0A=
        },=0A=
        majorLabels: {=0A=
          millisecond: 'HH:mm:ss',=0A=
          second: 'D MMMM HH:mm',=0A=
          minute: 'ddd D MMMM',=0A=
          hour: 'ddd D MMMM',=0A=
          weekday: 'MMMM YYYY',=0A=
          day: 'MMMM YYYY',=0A=
          month: 'YYYY',=0A=
          year: ''=0A=
        }=0A=
      },=0A=
=0A=
      //groupOrder: {string, 'function': 'function'},=0A=
      height: '',=0A=
      //hiddenDates: {object, array},=0A=
      locale: '',=0A=
      margin: {=0A=
        axis: [20, 0, 100, 1],=0A=
        item: {=0A=
          horizontal: [10, 0, 100, 1],=0A=
          vertical: [10, 0, 100, 1]=0A=
        }=0A=
      },=0A=
      max: '',=0A=
      maxHeight: '',=0A=
      min: '',=0A=
      minHeight: '',=0A=
      moveable: false,=0A=
      multiselect: false,=0A=
      //onAdd: {'function': 'function'},=0A=
      //onUpdate: {'function': 'function'},=0A=
      //onMove: {'function': 'function'},=0A=
      //onMoving: {'function': 'function'},=0A=
      //onRename: {'function': 'function'},=0A=
      //order: {'function': 'function'},=0A=
      orientation: {=0A=
        axis: ['both', 'bottom', 'top'],=0A=
        item: ['bottom', 'top']=0A=
      },=0A=
      selectable: true,=0A=
      showCurrentTime: false,=0A=
      showMajorLabels: true,=0A=
      showMinorLabels: true,=0A=
      stack: true,=0A=
      //snap: {'function': 'function', nada},=0A=
      start: '',=0A=
      //template: {'function': 'function'},=0A=
      //timeAxis: {=0A=
      //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', =
'day', 'month', 'year'],=0A=
      //  step: [1, 1, 10, 1]=0A=
      //},=0A=
      type: ['box', 'point', 'range', 'background'],=0A=
      width: '100%',=0A=
      zoomable: true,=0A=
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],=0A=
      zoomMax: [315360000000000, 10, 315360000000000, 1],=0A=
      zoomMin: [10, 10, 315360000000000, 1]=0A=
    }=0A=
  };=0A=
=0A=
  exports.allOptions =3D allOptions;=0A=
  exports.configureOptions =3D configureOptions;=0A=
=0A=
/***/ },=0A=
/* 49 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var Emitter =3D __webpack_require__(19);=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var moment =3D __webpack_require__(8);=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
  var Range =3D __webpack_require__(26);=0A=
  var Core =3D __webpack_require__(30);=0A=
  var TimeAxis =3D __webpack_require__(39);=0A=
  var CurrentTime =3D __webpack_require__(44);=0A=
  var CustomTime =3D __webpack_require__(42);=0A=
  var LineGraph =3D __webpack_require__(50);=0A=
=0A=
  var Configurator =3D __webpack_require__(45);=0A=
  var Validator =3D __webpack_require__(47)['default'];=0A=
  var printStyle =3D __webpack_require__(47).printStyle;=0A=
  var allOptions =3D __webpack_require__(58).allOptions;=0A=
  var configureOptions =3D __webpack_require__(58).configureOptions;=0A=
=0A=
  /**=0A=
   * Create a timeline visualization=0A=
   * @param {HTMLElement} container=0A=
   * @param {vis.DataSet | Array} [items]=0A=
   * @param {Object} [options]  See Graph2d.setOptions for the available =
options.=0A=
   * @constructor=0A=
   * @extends Core=0A=
   */=0A=
  function Graph2d(container, items, groups, options) {=0A=
    // if the third element is options, the forth is groups (optionally);=0A=
    if (!(Array.isArray(groups) || groups instanceof DataSet) && groups =
instanceof Object) {=0A=
      var forthArgument =3D options;=0A=
      options =3D groups;=0A=
      groups =3D forthArgument;=0A=
    }=0A=
=0A=
    var me =3D this;=0A=
    this.defaultOptions =3D {=0A=
      start: null,=0A=
      end: null,=0A=
=0A=
      autoResize: true,=0A=
=0A=
      orientation: {=0A=
        axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'=0A=
        item: 'bottom' // not relevant for Graph2d=0A=
      },=0A=
=0A=
      moment: moment,=0A=
=0A=
      width: null,=0A=
      height: null,=0A=
      maxHeight: null,=0A=
      minHeight: null=0A=
    };=0A=
    this.options =3D util.deepExtend({}, this.defaultOptions);=0A=
=0A=
    // Create the DOM, props, and emitter=0A=
    this._create(container);=0A=
=0A=
    // all components listed here will be repainted automatically=0A=
    this.components =3D [];=0A=
=0A=
    this.body =3D {=0A=
      dom: this.dom,=0A=
      domProps: this.props,=0A=
      emitter: {=0A=
        on: this.on.bind(this),=0A=
        off: this.off.bind(this),=0A=
        emit: this.emit.bind(this)=0A=
      },=0A=
      hiddenDates: [],=0A=
      util: {=0A=
        toScreen: me._toScreen.bind(me),=0A=
        toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to =
the root.width=0A=
        toTime: me._toTime.bind(me),=0A=
        toGlobalTime: me._toGlobalTime.bind(me)=0A=
      }=0A=
    };=0A=
=0A=
    // range=0A=
    this.range =3D new Range(this.body);=0A=
    this.components.push(this.range);=0A=
    this.body.range =3D this.range;=0A=
=0A=
    // time axis=0A=
    this.timeAxis =3D new TimeAxis(this.body);=0A=
    this.components.push(this.timeAxis);=0A=
    //this.body.util.snap =3D this.timeAxis.snap.bind(this.timeAxis);=0A=
=0A=
    // current time bar=0A=
    this.currentTime =3D new CurrentTime(this.body);=0A=
    this.components.push(this.currentTime);=0A=
=0A=
    // item set=0A=
    this.linegraph =3D new LineGraph(this.body);=0A=
    this.components.push(this.linegraph);=0A=
=0A=
    this.itemsData =3D null; // DataSet=0A=
    this.groupsData =3D null; // DataSet=0A=
=0A=
    this.on('tap', function (event) {=0A=
      me.emit('click', me.getEventProperties(event));=0A=
    });=0A=
    this.on('doubletap', function (event) {=0A=
      me.emit('doubleClick', me.getEventProperties(event));=0A=
    });=0A=
    this.dom.root.oncontextmenu =3D function (event) {=0A=
      me.emit('contextmenu', me.getEventProperties(event));=0A=
    };=0A=
=0A=
    // apply options=0A=
    if (options) {=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!=0A=
    if (groups) {=0A=
      this.setGroups(groups);=0A=
    }=0A=
=0A=
    // create itemset=0A=
    if (items) {=0A=
      this.setItems(items);=0A=
    } else {=0A=
      this._redraw();=0A=
    }=0A=
  }=0A=
=0A=
  // Extend the functionality from Core=0A=
  Graph2d.prototype =3D new Core();=0A=
=0A=
  Graph2d.prototype.setOptions =3D function (options) {=0A=
    // validate options=0A=
    var errorFound =3D Validator.validate(options, allOptions);=0A=
    if (errorFound =3D=3D=3D true) {=0A=
      console.log('%cErrors have been found in the supplied options =
object.', printStyle);=0A=
    }=0A=
=0A=
    Core.prototype.setOptions.call(this, options);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set items=0A=
   * @param {vis.DataSet | Array | null} items=0A=
   */=0A=
  Graph2d.prototype.setItems =3D function (items) {=0A=
    var initialLoad =3D this.itemsData =3D=3D null;=0A=
=0A=
    // convert to type DataSet when needed=0A=
    var newDataSet;=0A=
    if (!items) {=0A=
      newDataSet =3D null;=0A=
    } else if (items instanceof DataSet || items instanceof DataView) {=0A=
      newDataSet =3D items;=0A=
    } else {=0A=
      // turn an array into a dataset=0A=
      newDataSet =3D new DataSet(items, {=0A=
        type: {=0A=
          start: 'Date',=0A=
          end: 'Date'=0A=
        }=0A=
      });=0A=
    }=0A=
=0A=
    // set items=0A=
    this.itemsData =3D newDataSet;=0A=
    this.linegraph && this.linegraph.setItems(newDataSet);=0A=
=0A=
    if (initialLoad) {=0A=
      if (this.options.start !=3D undefined || this.options.end !=3D =
undefined) {=0A=
        var start =3D this.options.start !=3D undefined ? =
this.options.start : null;=0A=
        var end =3D this.options.end !=3D undefined ? this.options.end : =
null;=0A=
=0A=
        this.setWindow(start, end, { animation: false });=0A=
      } else {=0A=
        this.fit({ animation: false });=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set groups=0A=
   * @param {vis.DataSet | Array} groups=0A=
   */=0A=
  Graph2d.prototype.setGroups =3D function (groups) {=0A=
    // convert to type DataSet when needed=0A=
    var newDataSet;=0A=
    if (!groups) {=0A=
      newDataSet =3D null;=0A=
    } else if (groups instanceof DataSet || groups instanceof DataView) {=0A=
      newDataSet =3D groups;=0A=
    } else {=0A=
      // turn an array into a dataset=0A=
      newDataSet =3D new DataSet(groups);=0A=
    }=0A=
=0A=
    this.groupsData =3D newDataSet;=0A=
    this.linegraph.setGroups(newDataSet);=0A=
  };=0A=
=0A=
  /**=0A=
   * Returns an object containing an SVG element with the icon of the =
group (size determined by iconWidth and iconHeight), the label of the =
group (content) and the yAxisOrientation of the group (left or right).=0A=
   * @param groupId=0A=
   * @param width=0A=
   * @param height=0A=
   */=0A=
  Graph2d.prototype.getLegend =3D function (groupId, width, height) {=0A=
    if (width =3D=3D=3D undefined) {=0A=
      width =3D 15;=0A=
    }=0A=
    if (height =3D=3D=3D undefined) {=0A=
      height =3D 15;=0A=
    }=0A=
    if (this.linegraph.groups[groupId] !=3D=3D undefined) {=0A=
      return this.linegraph.groups[groupId].getLegend(width, height);=0A=
    } else {=0A=
      return 'cannot find group:' + groupId;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * This checks if the visible option of the supplied group (by ID) is =
true or false.=0A=
   * @param groupId=0A=
   * @returns {*}=0A=
   */=0A=
  Graph2d.prototype.isGroupVisible =3D function (groupId) {=0A=
    if (this.linegraph.groups[groupId] !=3D=3D undefined) {=0A=
      return this.linegraph.groups[groupId].visible && =
(this.linegraph.options.groups.visibility[groupId] =3D=3D=3D undefined =
|| this.linegraph.options.groups.visibility[groupId] =3D=3D true);=0A=
    } else {=0A=
      return false;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the data range of the item set.=0A=
   * @returns {{min: Date, max: Date}} range  A range with a start and =
end Date.=0A=
   *                                          When no minimum is found, =
min=3D=3Dnull=0A=
   *                                          When no maximum is found, =
max=3D=3Dnull=0A=
   */=0A=
  Graph2d.prototype.getDataRange =3D function () {=0A=
    var min =3D null;=0A=
    var max =3D null;=0A=
=0A=
    // calculate min from start filed=0A=
    for (var groupId in this.linegraph.groups) {=0A=
      if (this.linegraph.groups.hasOwnProperty(groupId)) {=0A=
        if (this.linegraph.groups[groupId].visible =3D=3D true) {=0A=
          for (var i =3D 0; i < =
this.linegraph.groups[groupId].itemsData.length; i++) {=0A=
            var item =3D this.linegraph.groups[groupId].itemsData[i];=0A=
            var value =3D util.convert(item.x, 'Date').valueOf();=0A=
            min =3D min =3D=3D null ? value : min > value ? value : min;=0A=
            max =3D max =3D=3D null ? value : max < value ? value : max;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return {=0A=
      min: min !=3D null ? new Date(min) : null,=0A=
      max: max !=3D null ? new Date(max) : null=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Generate Timeline related information from an event=0A=
   * @param {Event} event=0A=
   * @return {Object} An object with related information, like on which =
area=0A=
   *                  The event happened, whether clicked on an item, =
etc.=0A=
   */=0A=
  Graph2d.prototype.getEventProperties =3D function (event) {=0A=
    var clientX =3D event.center ? event.center.x : event.clientX;=0A=
    var clientY =3D event.center ? event.center.y : event.clientY;=0A=
    var x =3D clientX - util.getAbsoluteLeft(this.dom.centerContainer);=0A=
    var y =3D clientY - util.getAbsoluteTop(this.dom.centerContainer);=0A=
    var time =3D this._toTime(x);=0A=
=0A=
    var customTime =3D CustomTime.customTimeFromTarget(event);=0A=
=0A=
    var element =3D util.getTarget(event);=0A=
    var what =3D null;=0A=
    if (util.hasParent(element, this.timeAxis.dom.foreground)) {=0A=
      what =3D 'axis';=0A=
    } else if (this.timeAxis2 && util.hasParent(element, =
this.timeAxis2.dom.foreground)) {=0A=
      what =3D 'axis';=0A=
    } else if (util.hasParent(element, =
this.linegraph.yAxisLeft.dom.frame)) {=0A=
      what =3D 'data-axis';=0A=
    } else if (util.hasParent(element, =
this.linegraph.yAxisRight.dom.frame)) {=0A=
      what =3D 'data-axis';=0A=
    } else if (util.hasParent(element, =
this.linegraph.legendLeft.dom.frame)) {=0A=
      what =3D 'legend';=0A=
    } else if (util.hasParent(element, =
this.linegraph.legendRight.dom.frame)) {=0A=
      what =3D 'legend';=0A=
    } else if (customTime !=3D null) {=0A=
      what =3D 'custom-time';=0A=
    } else if (util.hasParent(element, this.currentTime.bar)) {=0A=
      what =3D 'current-time';=0A=
    } else if (util.hasParent(element, this.dom.center)) {=0A=
      what =3D 'background';=0A=
    }=0A=
=0A=
    var value =3D [];=0A=
    var yAxisLeft =3D this.linegraph.yAxisLeft;=0A=
    var yAxisRight =3D this.linegraph.yAxisRight;=0A=
    if (!yAxisLeft.hidden) {=0A=
      value.push(yAxisLeft.screenToValue(y));=0A=
    }=0A=
    if (!yAxisRight.hidden) {=0A=
      value.push(yAxisRight.screenToValue(y));=0A=
    }=0A=
=0A=
    return {=0A=
      event: event,=0A=
      what: what,=0A=
      pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,=0A=
      pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,=0A=
      x: x,=0A=
      y: y,=0A=
      time: time,=0A=
      value: value=0A=
    };=0A=
  };=0A=
=0A=
  /**=0A=
   * Load a configurator=0A=
   * @return {Object}=0A=
   * @private=0A=
   */=0A=
  Graph2d.prototype._createConfigurator =3D function () {=0A=
    return new Configurator(this, this.dom.container, configureOptions);=0A=
  };=0A=
=0A=
  module.exports =3D Graph2d;=0A=
=0A=
/***/ },=0A=
/* 50 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var DOMutil =3D __webpack_require__(13);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
  var Component =3D __webpack_require__(28);=0A=
  var DataAxis =3D __webpack_require__(51);=0A=
  var GraphGroup =3D __webpack_require__(53);=0A=
  var Legend =3D __webpack_require__(57);=0A=
  var BarFunctions =3D __webpack_require__(56);=0A=
  var LineFunctions =3D __webpack_require__(54);=0A=
=0A=
  var UNGROUPED =3D '__ungrouped__'; // reserved group id for ungrouped =
items=0A=
=0A=
  /**=0A=
   * This is the constructor of the LineGraph. It requires a Timeline =
body and options.=0A=
   *=0A=
   * @param body=0A=
   * @param options=0A=
   * @constructor=0A=
   */=0A=
  function LineGraph(body, options) {=0A=
    this.id =3D util.randomUUID();=0A=
    this.body =3D body;=0A=
=0A=
    this.defaultOptions =3D {=0A=
      yAxisOrientation: 'left',=0A=
      defaultGroup: 'default',=0A=
      sort: true,=0A=
      sampling: true,=0A=
      stack: false,=0A=
      graphHeight: '400px',=0A=
      shaded: {=0A=
        enabled: false,=0A=
        orientation: 'bottom' // top, bottom=0A=
      },=0A=
      style: 'line', // line, bar=0A=
      barChart: {=0A=
        width: 50,=0A=
        sideBySide: false,=0A=
        align: 'center' // left, center, right=0A=
      },=0A=
      interpolation: {=0A=
        enabled: true,=0A=
        parametrization: 'centripetal', // uniform (alpha =3D 0.0), =
chordal (alpha =3D 1.0), centripetal (alpha =3D 0.5)=0A=
        alpha: 0.5=0A=
      },=0A=
      drawPoints: {=0A=
        enabled: true,=0A=
        size: 6,=0A=
        style: 'square' // square, circle=0A=
      },=0A=
      dataAxis: {=0A=
        showMinorLabels: true,=0A=
        showMajorLabels: true,=0A=
        icons: false,=0A=
        width: '40px',=0A=
        visible: true,=0A=
        alignZeros: true,=0A=
        left: {=0A=
          range: { min: undefined, max: undefined },=0A=
          format: function format(value) {=0A=
            return value;=0A=
          },=0A=
          title: { text: undefined, style: undefined }=0A=
        },=0A=
        right: {=0A=
          range: { min: undefined, max: undefined },=0A=
          format: function format(value) {=0A=
            return value;=0A=
          },=0A=
          title: { text: undefined, style: undefined }=0A=
        }=0A=
      },=0A=
      legend: {=0A=
        enabled: false,=0A=
        icons: true,=0A=
        left: {=0A=
          visible: true,=0A=
          position: 'top-left' // top/bottom - left,right=0A=
        },=0A=
        right: {=0A=
          visible: true,=0A=
          position: 'top-right' // top/bottom - left,right=0A=
        }=0A=
      },=0A=
      groups: {=0A=
        visibility: {}=0A=
      }=0A=
    };=0A=
=0A=
    // options is shared by this ItemSet and all its items=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
    this.dom =3D {};=0A=
    this.props =3D {};=0A=
    this.hammer =3D null;=0A=
    this.groups =3D {};=0A=
    this.abortedGraphUpdate =3D false;=0A=
    this.updateSVGheight =3D false;=0A=
    this.updateSVGheightOnResize =3D false;=0A=
=0A=
    var me =3D this;=0A=
    this.itemsData =3D null; // DataSet=0A=
    this.groupsData =3D null; // DataSet=0A=
=0A=
    // listeners for the DataSet of the items=0A=
    this.itemListeners =3D {=0A=
      'add': function add(event, params, senderId) {=0A=
        me._onAdd(params.items);=0A=
      },=0A=
      'update': function update(event, params, senderId) {=0A=
        me._onUpdate(params.items);=0A=
      },=0A=
      'remove': function remove(event, params, senderId) {=0A=
        me._onRemove(params.items);=0A=
      }=0A=
    };=0A=
=0A=
    // listeners for the DataSet of the groups=0A=
    this.groupListeners =3D {=0A=
      'add': function add(event, params, senderId) {=0A=
        me._onAddGroups(params.items);=0A=
      },=0A=
      'update': function update(event, params, senderId) {=0A=
        me._onUpdateGroups(params.items);=0A=
      },=0A=
      'remove': function remove(event, params, senderId) {=0A=
        me._onRemoveGroups(params.items);=0A=
      }=0A=
    };=0A=
=0A=
    this.items =3D {}; // object with an Item for every data item=0A=
    this.selection =3D []; // list with the ids of all selected nodes=0A=
    this.lastStart =3D this.body.range.start;=0A=
    this.touchParams =3D {}; // stores properties while dragging=0A=
=0A=
    this.svgElements =3D {};=0A=
    this.setOptions(options);=0A=
    this.groupsUsingDefaultStyles =3D [0];=0A=
    this.COUNTER =3D 0;=0A=
    this.body.emitter.on('rangechanged', function () {=0A=
      me.lastStart =3D me.body.range.start;=0A=
      me.svg.style.left =3D util.option.asSize(-me.props.width);=0A=
      me.redraw.call(me, true);=0A=
    });=0A=
=0A=
    // create the HTML DOM=0A=
    this._create();=0A=
    this.framework =3D { svg: this.svg, svgElements: this.svgElements, =
options: this.options, groups: this.groups };=0A=
    this.body.emitter.emit('change');=0A=
  }=0A=
=0A=
  LineGraph.prototype =3D new Component();=0A=
=0A=
  /**=0A=
   * Create the HTML DOM for the ItemSet=0A=
   */=0A=
  LineGraph.prototype._create =3D function () {=0A=
    var frame =3D document.createElement('div');=0A=
    frame.className =3D 'vis-line-graph';=0A=
    this.dom.frame =3D frame;=0A=
=0A=
    // create svg element for graph drawing.=0A=
    this.svg =3D document.createElementNS('http://www.w3.org/2000/svg', =
'svg');=0A=
    this.svg.style.position =3D 'relative';=0A=
    this.svg.style.height =3D ('' + =
this.options.graphHeight).replace('px', '') + 'px';=0A=
    this.svg.style.display =3D 'block';=0A=
    frame.appendChild(this.svg);=0A=
=0A=
    // data axis=0A=
    this.options.dataAxis.orientation =3D 'left';=0A=
    this.yAxisLeft =3D new DataAxis(this.body, this.options.dataAxis, =
this.svg, this.options.groups);=0A=
=0A=
    this.options.dataAxis.orientation =3D 'right';=0A=
    this.yAxisRight =3D new DataAxis(this.body, this.options.dataAxis, =
this.svg, this.options.groups);=0A=
    delete this.options.dataAxis.orientation;=0A=
=0A=
    // legends=0A=
    this.legendLeft =3D new Legend(this.body, this.options.legend, =
'left', this.options.groups);=0A=
    this.legendRight =3D new Legend(this.body, this.options.legend, =
'right', this.options.groups);=0A=
=0A=
    this.show();=0A=
  };=0A=
=0A=
  /**=0A=
   * set the options of the LineGraph. the mergeOptions is used for =
subObjects that have an enabled element.=0A=
   * @param {object} options=0A=
   */=0A=
  LineGraph.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      var fields =3D ['sampling', 'defaultGroup', 'stack', 'height', =
'graphHeight', 'yAxisOrientation', 'style', 'barChart', 'dataAxis', =
'sort', 'groups'];=0A=
      if (options.graphHeight =3D=3D=3D undefined && options.height =
!=3D=3D undefined && this.body.domProps.centerContainer.height !=3D=3D =
undefined) {=0A=
        this.updateSVGheight =3D true;=0A=
        this.updateSVGheightOnResize =3D true;=0A=
      } else if (this.body.domProps.centerContainer.height !=3D=3D =
undefined && options.graphHeight !=3D=3D undefined) {=0A=
        if (parseInt((options.graphHeight + '').replace('px', '')) < =
this.body.domProps.centerContainer.height) {=0A=
          this.updateSVGheight =3D true;=0A=
        }=0A=
      }=0A=
      util.selectiveDeepExtend(fields, this.options, options);=0A=
      util.mergeOptions(this.options, options, 'interpolation');=0A=
      util.mergeOptions(this.options, options, 'drawPoints');=0A=
      util.mergeOptions(this.options, options, 'shaded');=0A=
      util.mergeOptions(this.options, options, 'legend');=0A=
=0A=
      if (options.interpolation) {=0A=
        if (typeof options.interpolation =3D=3D 'object') {=0A=
          if (options.interpolation.parametrization) {=0A=
            if (options.interpolation.parametrization =3D=3D 'uniform') {=0A=
              this.options.interpolation.alpha =3D 0;=0A=
            } else if (options.interpolation.parametrization =3D=3D =
'chordal') {=0A=
              this.options.interpolation.alpha =3D 1.0;=0A=
            } else {=0A=
              this.options.interpolation.parametrization =3D =
'centripetal';=0A=
              this.options.interpolation.alpha =3D 0.5;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if (this.yAxisLeft) {=0A=
        if (options.dataAxis !=3D=3D undefined) {=0A=
          this.yAxisLeft.setOptions(this.options.dataAxis);=0A=
          this.yAxisRight.setOptions(this.options.dataAxis);=0A=
        }=0A=
      }=0A=
=0A=
      if (this.legendLeft) {=0A=
        if (options.legend !=3D=3D undefined) {=0A=
          this.legendLeft.setOptions(this.options.legend);=0A=
          this.legendRight.setOptions(this.options.legend);=0A=
        }=0A=
      }=0A=
=0A=
      if (this.groups.hasOwnProperty(UNGROUPED)) {=0A=
        this.groups[UNGROUPED].setOptions(options);=0A=
      }=0A=
    }=0A=
=0A=
    // this is used to redraw the graph if the visibility of the groups =
is changed.=0A=
    if (this.dom.frame) {=0A=
      this.redraw(true);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the component from the DOM=0A=
   */=0A=
  LineGraph.prototype.hide =3D function () {=0A=
    // remove the frame containing the items=0A=
    if (this.dom.frame.parentNode) {=0A=
      this.dom.frame.parentNode.removeChild(this.dom.frame);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the component in the DOM (when not already visible).=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  LineGraph.prototype.show =3D function () {=0A=
    // show frame containing the items=0A=
    if (!this.dom.frame.parentNode) {=0A=
      this.body.dom.center.appendChild(this.dom.frame);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set items=0A=
   * @param {vis.DataSet | null} items=0A=
   */=0A=
  LineGraph.prototype.setItems =3D function (items) {=0A=
    var me =3D this,=0A=
        ids,=0A=
        oldItemsData =3D this.itemsData;=0A=
=0A=
    // replace the dataset=0A=
    if (!items) {=0A=
      this.itemsData =3D null;=0A=
    } else if (items instanceof DataSet || items instanceof DataView) {=0A=
      this.itemsData =3D items;=0A=
    } else {=0A=
      throw new TypeError('Data must be an instance of DataSet or =
DataView');=0A=
    }=0A=
=0A=
    if (oldItemsData) {=0A=
      // unsubscribe from old dataset=0A=
      util.forEach(this.itemListeners, function (callback, event) {=0A=
        oldItemsData.off(event, callback);=0A=
      });=0A=
=0A=
      // remove all drawn items=0A=
      ids =3D oldItemsData.getIds();=0A=
      this._onRemove(ids);=0A=
    }=0A=
=0A=
    if (this.itemsData) {=0A=
      // subscribe to new dataset=0A=
      var id =3D this.id;=0A=
      util.forEach(this.itemListeners, function (callback, event) {=0A=
        me.itemsData.on(event, callback, id);=0A=
      });=0A=
=0A=
      // add all new items=0A=
      ids =3D this.itemsData.getIds();=0A=
      this._onAdd(ids);=0A=
    }=0A=
    this._updateUngrouped();=0A=
    //this._updateGraph();=0A=
    this.redraw(true);=0A=
  };=0A=
=0A=
  /**=0A=
   * Set groups=0A=
   * @param {vis.DataSet} groups=0A=
   */=0A=
  LineGraph.prototype.setGroups =3D function (groups) {=0A=
    var me =3D this;=0A=
    var ids;=0A=
=0A=
    // unsubscribe from current dataset=0A=
    if (this.groupsData) {=0A=
      util.forEach(this.groupListeners, function (callback, event) {=0A=
        me.groupsData.off(event, callback);=0A=
      });=0A=
=0A=
      // remove all drawn groups=0A=
      ids =3D this.groupsData.getIds();=0A=
      this.groupsData =3D null;=0A=
      this._onRemoveGroups(ids); // note: this will cause a redraw=0A=
    }=0A=
=0A=
    // replace the dataset=0A=
    if (!groups) {=0A=
      this.groupsData =3D null;=0A=
    } else if (groups instanceof DataSet || groups instanceof DataView) {=0A=
      this.groupsData =3D groups;=0A=
    } else {=0A=
      throw new TypeError('Data must be an instance of DataSet or =
DataView');=0A=
    }=0A=
=0A=
    if (this.groupsData) {=0A=
      // subscribe to new dataset=0A=
      var id =3D this.id;=0A=
      util.forEach(this.groupListeners, function (callback, event) {=0A=
        me.groupsData.on(event, callback, id);=0A=
      });=0A=
=0A=
      // draw all ms=0A=
      ids =3D this.groupsData.getIds();=0A=
      this._onAddGroups(ids);=0A=
    }=0A=
    this._onUpdate();=0A=
  };=0A=
=0A=
  /**=0A=
   * Update the data=0A=
   * @param [ids]=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._onUpdate =3D function (ids) {=0A=
    this._updateUngrouped();=0A=
    this._updateAllGroupData();=0A=
    //this._updateGraph();=0A=
    this.redraw(true);=0A=
  };=0A=
  LineGraph.prototype._onAdd =3D function (ids) {=0A=
    this._onUpdate(ids);=0A=
  };=0A=
  LineGraph.prototype._onRemove =3D function (ids) {=0A=
    this._onUpdate(ids);=0A=
  };=0A=
  LineGraph.prototype._onUpdateGroups =3D function (groupIds) {=0A=
    for (var i =3D 0; i < groupIds.length; i++) {=0A=
      var group =3D this.groupsData.get(groupIds[i]);=0A=
      this._updateGroup(group, groupIds[i]);=0A=
    }=0A=
=0A=
    //this._updateGraph();=0A=
    this.redraw(true);=0A=
  };=0A=
  LineGraph.prototype._onAddGroups =3D function (groupIds) {=0A=
    this._onUpdateGroups(groupIds);=0A=
  };=0A=
=0A=
  /**=0A=
   * this cleans the group out off the legends and the dataaxis, updates =
the ungrouped and updates the graph=0A=
   * @param {Array} groupIds=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._onRemoveGroups =3D function (groupIds) {=0A=
    for (var i =3D 0; i < groupIds.length; i++) {=0A=
      if (this.groups.hasOwnProperty(groupIds[i])) {=0A=
        if (this.groups[groupIds[i]].options.yAxisOrientation =3D=3D =
'right') {=0A=
          this.yAxisRight.removeGroup(groupIds[i]);=0A=
          this.legendRight.removeGroup(groupIds[i]);=0A=
          this.legendRight.redraw();=0A=
        } else {=0A=
          this.yAxisLeft.removeGroup(groupIds[i]);=0A=
          this.legendLeft.removeGroup(groupIds[i]);=0A=
          this.legendLeft.redraw();=0A=
        }=0A=
        delete this.groups[groupIds[i]];=0A=
      }=0A=
    }=0A=
    this._updateUngrouped();=0A=
    //this._updateGraph();=0A=
    this.redraw(true);=0A=
  };=0A=
=0A=
  /**=0A=
   * update a group object with the group dataset entree=0A=
   *=0A=
   * @param group=0A=
   * @param groupId=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._updateGroup =3D function (group, groupId) {=0A=
    if (!this.groups.hasOwnProperty(groupId)) {=0A=
      this.groups[groupId] =3D new GraphGroup(group, groupId, =
this.options, this.groupsUsingDefaultStyles);=0A=
      if (this.groups[groupId].options.yAxisOrientation =3D=3D 'right') {=0A=
        this.yAxisRight.addGroup(groupId, this.groups[groupId]);=0A=
        this.legendRight.addGroup(groupId, this.groups[groupId]);=0A=
      } else {=0A=
        this.yAxisLeft.addGroup(groupId, this.groups[groupId]);=0A=
        this.legendLeft.addGroup(groupId, this.groups[groupId]);=0A=
      }=0A=
    } else {=0A=
      this.groups[groupId].update(group);=0A=
      if (this.groups[groupId].options.yAxisOrientation =3D=3D 'right') {=0A=
        this.yAxisRight.updateGroup(groupId, this.groups[groupId]);=0A=
        this.legendRight.updateGroup(groupId, this.groups[groupId]);=0A=
      } else {=0A=
        this.yAxisLeft.updateGroup(groupId, this.groups[groupId]);=0A=
        this.legendLeft.updateGroup(groupId, this.groups[groupId]);=0A=
      }=0A=
    }=0A=
    this.legendLeft.redraw();=0A=
    this.legendRight.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * this updates all groups, it is used when there is an update the the =
itemset.=0A=
   *=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._updateAllGroupData =3D function () {=0A=
    if (this.itemsData !=3D null) {=0A=
      var groupsContent =3D {};=0A=
      var groupId;=0A=
      for (groupId in this.groups) {=0A=
        if (this.groups.hasOwnProperty(groupId)) {=0A=
          groupsContent[groupId] =3D [];=0A=
        }=0A=
      }=0A=
      for (var itemId in this.itemsData._data) {=0A=
        if (this.itemsData._data.hasOwnProperty(itemId)) {=0A=
          var item =3D this.itemsData._data[itemId];=0A=
          if (groupsContent[item.group] =3D=3D=3D undefined) {=0A=
            throw new Error('Cannot find referenced group ' + item.group =
+ '. Possible reason: items added before groups? Groups need to be added =
before items, as items refer to groups.');=0A=
          }=0A=
          item.x =3D util.convert(item.x, 'Date');=0A=
          groupsContent[item.group].push(item);=0A=
        }=0A=
      }=0A=
      for (groupId in this.groups) {=0A=
        if (this.groups.hasOwnProperty(groupId)) {=0A=
          this.groups[groupId].setItems(groupsContent[groupId]);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create or delete the group holding all ungrouped items. This group =
is used when=0A=
   * there are no groups specified. This anonymous group is called =
'graph'.=0A=
   * @protected=0A=
   */=0A=
  LineGraph.prototype._updateUngrouped =3D function () {=0A=
    if (this.itemsData && this.itemsData !=3D null) {=0A=
      var ungroupedCounter =3D 0;=0A=
      for (var itemId in this.itemsData._data) {=0A=
        if (this.itemsData._data.hasOwnProperty(itemId)) {=0A=
          var item =3D this.itemsData._data[itemId];=0A=
          if (item !=3D undefined) {=0A=
            if (item.hasOwnProperty('group')) {=0A=
              if (item.group =3D=3D=3D undefined) {=0A=
                item.group =3D UNGROUPED;=0A=
              }=0A=
            } else {=0A=
              item.group =3D UNGROUPED;=0A=
            }=0A=
            ungroupedCounter =3D item.group =3D=3D UNGROUPED ? =
ungroupedCounter + 1 : ungroupedCounter;=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if (ungroupedCounter =3D=3D 0) {=0A=
        delete this.groups[UNGROUPED];=0A=
        this.legendLeft.removeGroup(UNGROUPED);=0A=
        this.legendRight.removeGroup(UNGROUPED);=0A=
        this.yAxisLeft.removeGroup(UNGROUPED);=0A=
        this.yAxisRight.removeGroup(UNGROUPED);=0A=
      } else {=0A=
        var group =3D { id: UNGROUPED, content: =
this.options.defaultGroup };=0A=
        this._updateGroup(group, UNGROUPED);=0A=
      }=0A=
    } else {=0A=
      delete this.groups[UNGROUPED];=0A=
      this.legendLeft.removeGroup(UNGROUPED);=0A=
      this.legendRight.removeGroup(UNGROUPED);=0A=
      this.yAxisLeft.removeGroup(UNGROUPED);=0A=
      this.yAxisRight.removeGroup(UNGROUPED);=0A=
    }=0A=
=0A=
    this.legendLeft.redraw();=0A=
    this.legendRight.redraw();=0A=
  };=0A=
=0A=
  /**=0A=
   * Redraw the component, mandatory function=0A=
   * @return {boolean} Returns true if the component is resized=0A=
   */=0A=
  LineGraph.prototype.redraw =3D function (forceGraphUpdate) {=0A=
    var resized =3D false;=0A=
=0A=
    // calculate actual size and position=0A=
    this.props.width =3D this.dom.frame.offsetWidth;=0A=
    this.props.height =3D this.body.domProps.centerContainer.height - =
this.body.domProps.border.top - this.body.domProps.border.bottom;=0A=
=0A=
    // update the graph if there is no lastWidth or with, used for the =
initial draw=0A=
    if (this.lastWidth =3D=3D=3D undefined && this.props.width) {=0A=
      forceGraphUpdate =3D true;=0A=
    }=0A=
=0A=
    // check if this component is resized=0A=
    resized =3D this._isResized() || resized;=0A=
=0A=
    // check whether zoomed (in that case we need to re-stack everything)=0A=
    var visibleInterval =3D this.body.range.end - this.body.range.start;=0A=
    var zoomed =3D visibleInterval !=3D this.lastVisibleInterval;=0A=
    this.lastVisibleInterval =3D visibleInterval;=0A=
=0A=
    // the svg element is three times as big as the width, this allows =
for fully dragging left and right=0A=
    // without reloading the graph. the controls for this are bound to =
events in the constructor=0A=
    if (resized =3D=3D true) {=0A=
      this.svg.style.width =3D util.option.asSize(3 * this.props.width);=0A=
      this.svg.style.left =3D util.option.asSize(-this.props.width);=0A=
=0A=
      // if the height of the graph is set as proportional, change the =
height of the svg=0A=
      if ((this.options.height + '').indexOf('%') !=3D -1 || =
this.updateSVGheightOnResize =3D=3D true) {=0A=
        this.updateSVGheight =3D true;=0A=
      }=0A=
    }=0A=
=0A=
    // update the height of the graph on each redraw of the graph.=0A=
    if (this.updateSVGheight =3D=3D true) {=0A=
      if (this.options.graphHeight !=3D this.props.height + 'px') {=0A=
        this.options.graphHeight =3D this.props.height + 'px';=0A=
        this.svg.style.height =3D this.props.height + 'px';=0A=
      }=0A=
      this.updateSVGheight =3D false;=0A=
    } else {=0A=
      this.svg.style.height =3D ('' + =
this.options.graphHeight).replace('px', '') + 'px';=0A=
    }=0A=
=0A=
    // zoomed is here to ensure that animations are shown correctly.=0A=
    if (resized =3D=3D true || zoomed =3D=3D true || =
this.abortedGraphUpdate =3D=3D true || forceGraphUpdate =3D=3D true) {=0A=
      resized =3D this._updateGraph() || resized;=0A=
    } else {=0A=
      // move the whole svg while dragging=0A=
      if (this.lastStart !=3D 0) {=0A=
        var offset =3D this.body.range.start - this.lastStart;=0A=
        var range =3D this.body.range.end - this.body.range.start;=0A=
        if (this.props.width !=3D 0) {=0A=
          var rangePerPixelInv =3D this.props.width / range;=0A=
          var xOffset =3D offset * rangePerPixelInv;=0A=
          this.svg.style.left =3D -this.props.width - xOffset + 'px';=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    this.legendLeft.redraw();=0A=
    this.legendRight.redraw();=0A=
    return resized;=0A=
  };=0A=
=0A=
  /**=0A=
   * Update and redraw the graph.=0A=
   *=0A=
   */=0A=
  LineGraph.prototype._updateGraph =3D function () {=0A=
    // reset the svg elements=0A=
    DOMutil.prepareElements(this.svgElements);=0A=
    if (this.props.width !=3D 0 && this.itemsData !=3D null) {=0A=
      var group, i;=0A=
      var preprocessedGroupData =3D {};=0A=
      var processedGroupData =3D {};=0A=
      var groupRanges =3D {};=0A=
      var changeCalled =3D false;=0A=
=0A=
      // getting group Ids=0A=
      var groupIds =3D [];=0A=
      for (var groupId in this.groups) {=0A=
        if (this.groups.hasOwnProperty(groupId)) {=0A=
          group =3D this.groups[groupId];=0A=
          if (group.visible =3D=3D true && =
(this.options.groups.visibility[groupId] =3D=3D=3D undefined || =
this.options.groups.visibility[groupId] =3D=3D true)) {=0A=
            groupIds.push(groupId);=0A=
          }=0A=
        }=0A=
      }=0A=
      if (groupIds.length > 0) {=0A=
        // this is the range of the SVG canvas=0A=
        var minDate =3D =
this.body.util.toGlobalTime(-this.body.domProps.root.width);=0A=
        var maxDate =3D this.body.util.toGlobalTime(2 * =
this.body.domProps.root.width);=0A=
        var groupsData =3D {};=0A=
        // fill groups data, this only loads the data we require based =
on the timewindow=0A=
        this._getRelevantData(groupIds, groupsData, minDate, maxDate);=0A=
=0A=
        // apply sampling, if disabled, it will pass through this =
function.=0A=
        this._applySampling(groupIds, groupsData);=0A=
=0A=
        // we transform the X coordinates to detect collisions=0A=
        for (i =3D 0; i < groupIds.length; i++) {=0A=
          preprocessedGroupData[groupIds[i]] =3D =
this._convertXcoordinates(groupsData[groupIds[i]]);=0A=
        }=0A=
=0A=
        // now all needed data has been collected we start the =
processing.=0A=
        this._getYRanges(groupIds, preprocessedGroupData, groupRanges);=0A=
=0A=
        // update the Y axis first, we use this data to draw at the =
correct Y points=0A=
        // changeCalled is required to clean the SVG on a change emit.=0A=
        changeCalled =3D this._updateYAxis(groupIds, groupRanges);=0A=
        var MAX_CYCLES =3D 5;=0A=
        if (changeCalled =3D=3D true && this.COUNTER < MAX_CYCLES) {=0A=
          DOMutil.cleanupElements(this.svgElements);=0A=
          this.abortedGraphUpdate =3D true;=0A=
          this.COUNTER++;=0A=
          this.body.emitter.emit('change');=0A=
          return true;=0A=
        } else {=0A=
          if (this.COUNTER > MAX_CYCLES) {=0A=
            console.log('WARNING: there may be an infinite loop in the =
_updateGraph emitter cycle.');=0A=
          }=0A=
          this.COUNTER =3D 0;=0A=
          this.abortedGraphUpdate =3D false;=0A=
=0A=
          // With the yAxis scaled correctly, use this to get the Y =
values of the points.=0A=
          for (i =3D 0; i < groupIds.length; i++) {=0A=
            group =3D this.groups[groupIds[i]];=0A=
            processedGroupData[groupIds[i]] =3D =
this._convertYcoordinates(groupsData[groupIds[i]], group);=0A=
          }=0A=
=0A=
          // draw the groups=0A=
          for (i =3D 0; i < groupIds.length; i++) {=0A=
            group =3D this.groups[groupIds[i]];=0A=
            if (group.options.style !=3D 'bar') {=0A=
              // bar needs to be drawn enmasse=0A=
              group.draw(processedGroupData[groupIds[i]], group, =
this.framework);=0A=
            }=0A=
          }=0A=
          BarFunctions.draw(groupIds, processedGroupData, =
this.framework);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // cleanup unused svg elements=0A=
    DOMutil.cleanupElements(this.svgElements);=0A=
    return false;=0A=
  };=0A=
=0A=
  /**=0A=
   * first select and preprocess the data from the datasets.=0A=
   * the groups have their preselection of data, we now loop over this =
data to see=0A=
   * what data we need to draw. Sorted data is much faster.=0A=
   * more optimization is possible by doing the sampling before and =
using the binary search=0A=
   * to find the end date to determine the increment.=0A=
   *=0A=
   * @param {array}  groupIds=0A=
   * @param {object} groupsData=0A=
   * @param {date}   minDate=0A=
   * @param {date}   maxDate=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._getRelevantData =3D function (groupIds, =
groupsData, minDate, maxDate) {=0A=
    var group, i, j, item;=0A=
    if (groupIds.length > 0) {=0A=
      for (i =3D 0; i < groupIds.length; i++) {=0A=
        group =3D this.groups[groupIds[i]];=0A=
        groupsData[groupIds[i]] =3D [];=0A=
        var dataContainer =3D groupsData[groupIds[i]];=0A=
        // optimization for sorted data=0A=
        if (group.options.sort =3D=3D true) {=0A=
          var guess =3D Math.max(0, =
util.binarySearchValue(group.itemsData, minDate, 'x', 'before'));=0A=
          for (j =3D guess; j < group.itemsData.length; j++) {=0A=
            item =3D group.itemsData[j];=0A=
            if (item !=3D=3D undefined) {=0A=
              if (item.x > maxDate) {=0A=
                dataContainer.push(item);=0A=
                break;=0A=
              } else {=0A=
                dataContainer.push(item);=0A=
              }=0A=
            }=0A=
          }=0A=
        } else {=0A=
          for (j =3D 0; j < group.itemsData.length; j++) {=0A=
            item =3D group.itemsData[j];=0A=
            if (item !=3D=3D undefined) {=0A=
              if (item.x > minDate && item.x < maxDate) {=0A=
                dataContainer.push(item);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   *=0A=
   * @param groupIds=0A=
   * @param groupsData=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._applySampling =3D function (groupIds, groupsData) =
{=0A=
    var group;=0A=
    if (groupIds.length > 0) {=0A=
      for (var i =3D 0; i < groupIds.length; i++) {=0A=
        group =3D this.groups[groupIds[i]];=0A=
        if (group.options.sampling =3D=3D true) {=0A=
          var dataContainer =3D groupsData[groupIds[i]];=0A=
          if (dataContainer.length > 0) {=0A=
            var increment =3D 1;=0A=
            var amountOfPoints =3D dataContainer.length;=0A=
=0A=
            // the global screen is used because changing the width of =
the yAxis may affect the increment, resulting in an endless loop=0A=
            // of width changing of the yAxis.=0A=
            var xDistance =3D =
this.body.util.toGlobalScreen(dataContainer[dataContainer.length - 1].x) =
- this.body.util.toGlobalScreen(dataContainer[0].x);=0A=
            var pointsPerPixel =3D amountOfPoints / xDistance;=0A=
            increment =3D Math.min(Math.ceil(0.2 * amountOfPoints), =
Math.max(1, Math.round(pointsPerPixel)));=0A=
=0A=
            var sampledData =3D [];=0A=
            for (var j =3D 0; j < amountOfPoints; j +=3D increment) {=0A=
              sampledData.push(dataContainer[j]);=0A=
            }=0A=
            groupsData[groupIds[i]] =3D sampledData;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   *=0A=
   *=0A=
   * @param {array}  groupIds=0A=
   * @param {object} groupsData=0A=
   * @param {object} groupRanges  | this is being filled here=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._getYRanges =3D function (groupIds, groupsData, =
groupRanges) {=0A=
    var groupData, group, i;=0A=
    var combinedDataLeft =3D [];=0A=
    var combinedDataRight =3D [];=0A=
    var options;=0A=
    if (groupIds.length > 0) {=0A=
      for (i =3D 0; i < groupIds.length; i++) {=0A=
        groupData =3D groupsData[groupIds[i]];=0A=
        options =3D this.groups[groupIds[i]].options;=0A=
        if (groupData.length > 0) {=0A=
          group =3D this.groups[groupIds[i]];=0A=
          // if bar graphs are stacked, their range need to be handled =
differently and accumulated over all groups.=0A=
          if (options.stack =3D=3D=3D true && options.style =3D=3D=3D =
'bar') {=0A=
            if (options.yAxisOrientation =3D=3D=3D 'left') {=0A=
              combinedDataLeft =3D =
combinedDataLeft.concat(group.getData(groupData));=0A=
            } else {=0A=
              combinedDataRight =3D =
combinedDataRight.concat(group.getData(groupData));=0A=
            }=0A=
          } else {=0A=
            groupRanges[groupIds[i]] =3D group.getYRange(groupData, =
groupIds[i]);=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      // if bar graphs are stacked, their range need to be handled =
differently and accumulated over all groups.=0A=
      BarFunctions.getStackedYRange(combinedDataLeft, groupRanges, =
groupIds, '__barStackLeft', 'left');=0A=
      BarFunctions.getStackedYRange(combinedDataRight, groupRanges, =
groupIds, '__barStackRight', 'right');=0A=
      // if line graphs are stacked, their range need to be handled =
differently and accumulated over all groups.=0A=
      //LineFunctions.getStackedYRange(combinedDataLeft , groupRanges, =
groupIds, '__lineStackLeft' , 'left' );=0A=
      //LineFunctions.getStackedYRange(combinedDataRight, groupRanges, =
groupIds, '__lineStackRight', 'right');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this sets the Y ranges for the Y axis. It also determines which of =
the axis should be shown or hidden.=0A=
   * @param {Array} groupIds=0A=
   * @param {Object} groupRanges=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._updateYAxis =3D function (groupIds, groupRanges) {=0A=
    var resized =3D false;=0A=
    var yAxisLeftUsed =3D false;=0A=
    var yAxisRightUsed =3D false;=0A=
    var minLeft =3D 1e9,=0A=
        minRight =3D 1e9,=0A=
        maxLeft =3D -1e9,=0A=
        maxRight =3D -1e9,=0A=
        minVal,=0A=
        maxVal;=0A=
    // if groups are present=0A=
    if (groupIds.length > 0) {=0A=
      // this is here to make sure that if there are no items in the =
axis but there are groups, that there is no infinite draw/redraw loop.=0A=
      for (var i =3D 0; i < groupIds.length; i++) {=0A=
        var group =3D this.groups[groupIds[i]];=0A=
        if (group && group.options.yAxisOrientation !=3D 'right') {=0A=
          yAxisLeftUsed =3D true;=0A=
          minLeft =3D 1e9;=0A=
          maxLeft =3D -1e9;=0A=
        } else if (group && group.options.yAxisOrientation) {=0A=
          yAxisRightUsed =3D true;=0A=
          minRight =3D 1e9;=0A=
          maxRight =3D -1e9;=0A=
        }=0A=
      }=0A=
=0A=
      // if there are items:=0A=
      for (var i =3D 0; i < groupIds.length; i++) {=0A=
        if (groupRanges.hasOwnProperty(groupIds[i])) {=0A=
          if (groupRanges[groupIds[i]].ignore !=3D=3D true) {=0A=
            minVal =3D groupRanges[groupIds[i]].min;=0A=
            maxVal =3D groupRanges[groupIds[i]].max;=0A=
=0A=
            if (groupRanges[groupIds[i]].yAxisOrientation !=3D 'right') {=0A=
              yAxisLeftUsed =3D true;=0A=
              minLeft =3D minLeft > minVal ? minVal : minLeft;=0A=
              maxLeft =3D maxLeft < maxVal ? maxVal : maxLeft;=0A=
            } else {=0A=
              yAxisRightUsed =3D true;=0A=
              minRight =3D minRight > minVal ? minVal : minRight;=0A=
              maxRight =3D maxRight < maxVal ? maxVal : maxRight;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if (yAxisLeftUsed =3D=3D true) {=0A=
        this.yAxisLeft.setRange(minLeft, maxLeft);=0A=
      }=0A=
      if (yAxisRightUsed =3D=3D true) {=0A=
        this.yAxisRight.setRange(minRight, maxRight);=0A=
      }=0A=
    }=0A=
    resized =3D this._toggleAxisVisiblity(yAxisLeftUsed, this.yAxisLeft) =
|| resized;=0A=
    resized =3D this._toggleAxisVisiblity(yAxisRightUsed, =
this.yAxisRight) || resized;=0A=
=0A=
    if (yAxisRightUsed =3D=3D true && yAxisLeftUsed =3D=3D true) {=0A=
      this.yAxisLeft.drawIcons =3D true;=0A=
      this.yAxisRight.drawIcons =3D true;=0A=
    } else {=0A=
      this.yAxisLeft.drawIcons =3D false;=0A=
      this.yAxisRight.drawIcons =3D false;=0A=
    }=0A=
    this.yAxisRight.master =3D !yAxisLeftUsed;=0A=
    if (this.yAxisRight.master =3D=3D false) {=0A=
      if (yAxisRightUsed =3D=3D true) {=0A=
        this.yAxisLeft.lineOffset =3D this.yAxisRight.width;=0A=
      } else {=0A=
        this.yAxisLeft.lineOffset =3D 0;=0A=
      }=0A=
=0A=
      resized =3D this.yAxisLeft.redraw() || resized;=0A=
      this.yAxisRight.stepPixels =3D this.yAxisLeft.stepPixels;=0A=
      this.yAxisRight.zeroCrossing =3D this.yAxisLeft.zeroCrossing;=0A=
      this.yAxisRight.amountOfSteps =3D this.yAxisLeft.amountOfSteps;=0A=
      resized =3D this.yAxisRight.redraw() || resized;=0A=
    } else {=0A=
      resized =3D this.yAxisRight.redraw() || resized;=0A=
    }=0A=
=0A=
    // clean the accumulated lists=0A=
    var tempGroups =3D ['__barStackLeft', '__barStackRight', =
'__lineStackLeft', '__lineStackRight'];=0A=
    for (var i =3D 0; i < tempGroups.length; i++) {=0A=
      if (groupIds.indexOf(tempGroups[i]) !=3D -1) {=0A=
        groupIds.splice(groupIds.indexOf(tempGroups[i]), 1);=0A=
      }=0A=
    }=0A=
=0A=
    return resized;=0A=
  };=0A=
=0A=
  /**=0A=
   * This shows or hides the Y axis if needed. If there is a change, the =
changed event is emitted by the updateYAxis function=0A=
   *=0A=
   * @param {boolean} axisUsed=0A=
   * @returns {boolean}=0A=
   * @private=0A=
   * @param axis=0A=
   */=0A=
  LineGraph.prototype._toggleAxisVisiblity =3D function (axisUsed, axis) =
{=0A=
    var changed =3D false;=0A=
    if (axisUsed =3D=3D false) {=0A=
      if (axis.dom.frame.parentNode && axis.hidden =3D=3D false) {=0A=
        axis.hide();=0A=
        changed =3D true;=0A=
      }=0A=
    } else {=0A=
      if (!axis.dom.frame.parentNode && axis.hidden =3D=3D true) {=0A=
        axis.show();=0A=
        changed =3D true;=0A=
      }=0A=
    }=0A=
    return changed;=0A=
  };=0A=
=0A=
  /**=0A=
   * This uses the DataAxis object to generate the correct X coordinate =
on the SVG window. It uses the=0A=
   * util function toScreen to get the x coordinate from the timestamp. =
It also pre-filters the data and get the minMax ranges for=0A=
   * the yAxis.=0A=
   *=0A=
   * @param datapoints=0A=
   * @returns {Array}=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._convertXcoordinates =3D function (datapoints) {=0A=
    var extractedData =3D [];=0A=
    var xValue, yValue;=0A=
    var toScreen =3D this.body.util.toScreen;=0A=
=0A=
    for (var i =3D 0; i < datapoints.length; i++) {=0A=
      xValue =3D toScreen(datapoints[i].x) + this.props.width;=0A=
      yValue =3D datapoints[i].y;=0A=
      extractedData.push({ x: xValue, y: yValue });=0A=
    }=0A=
=0A=
    return extractedData;=0A=
  };=0A=
=0A=
  /**=0A=
   * This uses the DataAxis object to generate the correct X coordinate =
on the SVG window. It uses the=0A=
   * util function toScreen to get the x coordinate from the timestamp. =
It also pre-filters the data and get the minMax ranges for=0A=
   * the yAxis.=0A=
   *=0A=
   * @param datapoints=0A=
   * @param group=0A=
   * @returns {Array}=0A=
   * @private=0A=
   */=0A=
  LineGraph.prototype._convertYcoordinates =3D function (datapoints, =
group) {=0A=
    var extractedData =3D [];=0A=
    var xValue, yValue;=0A=
    var toScreen =3D this.body.util.toScreen;=0A=
    var axis =3D this.yAxisLeft;=0A=
    var svgHeight =3D Number(this.svg.style.height.replace('px', ''));=0A=
    if (group.options.yAxisOrientation =3D=3D 'right') {=0A=
      axis =3D this.yAxisRight;=0A=
    }=0A=
=0A=
    for (var i =3D 0; i < datapoints.length; i++) {=0A=
      var labelValue =3D datapoints[i].label ? datapoints[i].label : =
null;=0A=
      xValue =3D toScreen(datapoints[i].x) + this.props.width;=0A=
      yValue =3D Math.round(axis.convertValue(datapoints[i].y));=0A=
      extractedData.push({ x: xValue, y: yValue, label: labelValue });=0A=
    }=0A=
=0A=
    group.setZeroPosition(Math.min(svgHeight, axis.convertValue(0)));=0A=
=0A=
    return extractedData;=0A=
  };=0A=
=0A=
  module.exports =3D LineGraph;=0A=
=0A=
/***/ },=0A=
/* 51 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var DOMutil =3D __webpack_require__(13);=0A=
  var Component =3D __webpack_require__(28);=0A=
  var DataStep =3D __webpack_require__(52);=0A=
=0A=
  /**=0A=
   * A horizontal time axis=0A=
   * @param {Object} [options]        See DataAxis.setOptions for the =
available=0A=
   *                                  options.=0A=
   * @constructor DataAxis=0A=
   * @extends Component=0A=
   * @param body=0A=
   */=0A=
  function DataAxis(body, options, svg, linegraphOptions) {=0A=
    this.id =3D util.randomUUID();=0A=
    this.body =3D body;=0A=
=0A=
    this.defaultOptions =3D {=0A=
      orientation: 'left', // supported: 'left', 'right'=0A=
      showMinorLabels: true,=0A=
      showMajorLabels: true,=0A=
      icons: true,=0A=
      majorLinesOffset: 7,=0A=
      minorLinesOffset: 4,=0A=
      labelOffsetX: 10,=0A=
      labelOffsetY: 2,=0A=
      iconWidth: 20,=0A=
      width: '40px',=0A=
      visible: true,=0A=
      alignZeros: true,=0A=
      left: {=0A=
        range: { min: undefined, max: undefined },=0A=
        format: function format(value) {=0A=
          return value;=0A=
        },=0A=
        title: { text: undefined, style: undefined }=0A=
      },=0A=
      right: {=0A=
        range: { min: undefined, max: undefined },=0A=
        format: function format(value) {=0A=
          return value;=0A=
        },=0A=
        title: { text: undefined, style: undefined }=0A=
      }=0A=
    };=0A=
=0A=
    this.linegraphOptions =3D linegraphOptions;=0A=
    this.linegraphSVG =3D svg;=0A=
    this.props =3D {};=0A=
    this.DOMelements =3D { // dynamic elements=0A=
      lines: {},=0A=
      labels: {},=0A=
      title: {}=0A=
    };=0A=
=0A=
    this.dom =3D {};=0A=
=0A=
    this.range =3D { start: 0, end: 0 };=0A=
=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
    this.conversionFactor =3D 1;=0A=
=0A=
    this.setOptions(options);=0A=
    this.width =3D Number(('' + this.options.width).replace('px', ''));=0A=
    this.minWidth =3D this.width;=0A=
    this.height =3D this.linegraphSVG.offsetHeight;=0A=
    this.hidden =3D false;=0A=
=0A=
    this.stepPixels =3D 25;=0A=
    this.zeroCrossing =3D -1;=0A=
    this.amountOfSteps =3D -1;=0A=
=0A=
    this.lineOffset =3D 0;=0A=
    this.master =3D true;=0A=
    this.svgElements =3D {};=0A=
    this.iconsRemoved =3D false;=0A=
=0A=
    this.groups =3D {};=0A=
    this.amountOfGroups =3D 0;=0A=
=0A=
    // create the HTML DOM=0A=
    this._create();=0A=
=0A=
    var me =3D this;=0A=
    this.body.emitter.on('verticalDrag', function () {=0A=
      me.dom.lineContainer.style.top =3D me.body.domProps.scrollTop + =
'px';=0A=
    });=0A=
  }=0A=
=0A=
  DataAxis.prototype =3D new Component();=0A=
=0A=
  DataAxis.prototype.addGroup =3D function (label, graphOptions) {=0A=
    if (!this.groups.hasOwnProperty(label)) {=0A=
      this.groups[label] =3D graphOptions;=0A=
    }=0A=
    this.amountOfGroups +=3D 1;=0A=
  };=0A=
=0A=
  DataAxis.prototype.updateGroup =3D function (label, graphOptions) {=0A=
    this.groups[label] =3D graphOptions;=0A=
  };=0A=
=0A=
  DataAxis.prototype.removeGroup =3D function (label) {=0A=
    if (this.groups.hasOwnProperty(label)) {=0A=
      delete this.groups[label];=0A=
      this.amountOfGroups -=3D 1;=0A=
    }=0A=
  };=0A=
=0A=
  DataAxis.prototype.setOptions =3D function (options) {=0A=
    if (options) {=0A=
      var redraw =3D false;=0A=
      if (this.options.orientation !=3D options.orientation && =
options.orientation !=3D=3D undefined) {=0A=
        redraw =3D true;=0A=
      }=0A=
      var fields =3D ['orientation', 'showMinorLabels', =
'showMajorLabels', 'icons', 'majorLinesOffset', 'minorLinesOffset', =
'labelOffsetX', 'labelOffsetY', 'iconWidth', 'width', 'visible', 'left', =
'right', 'alignZeros'];=0A=
      util.selectiveExtend(fields, this.options, options);=0A=
=0A=
      this.minWidth =3D Number(('' + this.options.width).replace('px', =
''));=0A=
=0A=
      if (redraw =3D=3D=3D true && this.dom.frame) {=0A=
        this.hide();=0A=
        this.show();=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create the HTML DOM for the DataAxis=0A=
   */=0A=
  DataAxis.prototype._create =3D function () {=0A=
    this.dom.frame =3D document.createElement('div');=0A=
    this.dom.frame.style.width =3D this.options.width;=0A=
    this.dom.frame.style.height =3D this.height;=0A=
=0A=
    this.dom.lineContainer =3D document.createElement('div');=0A=
    this.dom.lineContainer.style.width =3D '100%';=0A=
    this.dom.lineContainer.style.height =3D this.height;=0A=
    this.dom.lineContainer.style.position =3D 'relative';=0A=
=0A=
    // create svg element for graph drawing.=0A=
    this.svg =3D document.createElementNS('http://www.w3.org/2000/svg', =
'svg');=0A=
    this.svg.style.position =3D 'absolute';=0A=
    this.svg.style.top =3D '0px';=0A=
    this.svg.style.height =3D '100%';=0A=
    this.svg.style.width =3D '100%';=0A=
    this.svg.style.display =3D 'block';=0A=
    this.dom.frame.appendChild(this.svg);=0A=
  };=0A=
=0A=
  DataAxis.prototype._redrawGroupIcons =3D function () {=0A=
    DOMutil.prepareElements(this.svgElements);=0A=
=0A=
    var x;=0A=
    var iconWidth =3D this.options.iconWidth;=0A=
    var iconHeight =3D 15;=0A=
    var iconOffset =3D 4;=0A=
    var y =3D iconOffset + 0.5 * iconHeight;=0A=
=0A=
    if (this.options.orientation =3D=3D=3D 'left') {=0A=
      x =3D iconOffset;=0A=
    } else {=0A=
      x =3D this.width - iconWidth - iconOffset;=0A=
    }=0A=
=0A=
    var groupArray =3D Object.keys(this.groups);=0A=
    groupArray.sort(function (a, b) {=0A=
      return a < b ? -1 : 1;=0A=
    });=0A=
=0A=
    for (var i =3D 0; i < groupArray.length; i++) {=0A=
      var groupId =3D groupArray[i];=0A=
      if (this.groups[groupId].visible =3D=3D=3D true && =
(this.linegraphOptions.visibility[groupId] =3D=3D=3D undefined || =
this.linegraphOptions.visibility[groupId] =3D=3D=3D true)) {=0A=
        this.groups[groupId].drawIcon(x, y, this.svgElements, this.svg, =
iconWidth, iconHeight);=0A=
        y +=3D iconHeight + iconOffset;=0A=
      }=0A=
    }=0A=
=0A=
    DOMutil.cleanupElements(this.svgElements);=0A=
    this.iconsRemoved =3D false;=0A=
  };=0A=
=0A=
  DataAxis.prototype._cleanupIcons =3D function () {=0A=
    if (this.iconsRemoved =3D=3D=3D false) {=0A=
      DOMutil.prepareElements(this.svgElements);=0A=
      DOMutil.cleanupElements(this.svgElements);=0A=
      this.iconsRemoved =3D true;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create the HTML DOM for the DataAxis=0A=
   */=0A=
  DataAxis.prototype.show =3D function () {=0A=
    this.hidden =3D false;=0A=
    if (!this.dom.frame.parentNode) {=0A=
      if (this.options.orientation =3D=3D=3D 'left') {=0A=
        this.body.dom.left.appendChild(this.dom.frame);=0A=
      } else {=0A=
        this.body.dom.right.appendChild(this.dom.frame);=0A=
      }=0A=
    }=0A=
=0A=
    if (!this.dom.lineContainer.parentNode) {=0A=
      =
this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create the HTML DOM for the DataAxis=0A=
   */=0A=
  DataAxis.prototype.hide =3D function () {=0A=
    this.hidden =3D true;=0A=
    if (this.dom.frame.parentNode) {=0A=
      this.dom.frame.parentNode.removeChild(this.dom.frame);=0A=
    }=0A=
=0A=
    if (this.dom.lineContainer.parentNode) {=0A=
      =
this.dom.lineContainer.parentNode.removeChild(this.dom.lineContainer);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Set a range (start and end)=0A=
   * @param end=0A=
   * @param start=0A=
   * @param end=0A=
   */=0A=
  DataAxis.prototype.setRange =3D function (start, end) {=0A=
    if (this.master =3D=3D=3D false && this.options.alignZeros =3D=3D=3D =
true && this.zeroCrossing !=3D -1) {=0A=
      if (start > 0) {=0A=
        start =3D 0;=0A=
      }=0A=
    }=0A=
    this.range.start =3D start;=0A=
    this.range.end =3D end;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint the component=0A=
   * @return {boolean} Returns true if the component is resized=0A=
   */=0A=
  DataAxis.prototype.redraw =3D function () {=0A=
    var resized =3D false;=0A=
    var activeGroups =3D 0;=0A=
=0A=
    // Make sure the line container adheres to the vertical scrolling.=0A=
    this.dom.lineContainer.style.top =3D this.body.domProps.scrollTop + =
'px';=0A=
=0A=
    for (var groupId in this.groups) {=0A=
      if (this.groups.hasOwnProperty(groupId)) {=0A=
        if (this.groups[groupId].visible =3D=3D=3D true && =
(this.linegraphOptions.visibility[groupId] =3D=3D=3D undefined || =
this.linegraphOptions.visibility[groupId] =3D=3D=3D true)) {=0A=
          activeGroups++;=0A=
        }=0A=
      }=0A=
    }=0A=
    if (this.amountOfGroups =3D=3D=3D 0 || activeGroups =3D=3D=3D 0) {=0A=
      this.hide();=0A=
    } else {=0A=
      this.show();=0A=
      this.height =3D =
Number(this.linegraphSVG.style.height.replace('px', ''));=0A=
=0A=
      // svg offsetheight did not work in firefox and explorer...=0A=
      this.dom.lineContainer.style.height =3D this.height + 'px';=0A=
      this.width =3D this.options.visible =3D=3D=3D true ? Number(('' + =
this.options.width).replace('px', '')) : 0;=0A=
=0A=
      var props =3D this.props;=0A=
      var frame =3D this.dom.frame;=0A=
=0A=
      // update classname=0A=
      frame.className =3D 'vis-data-axis';=0A=
=0A=
      // calculate character width and height=0A=
      this._calculateCharSize();=0A=
=0A=
      var orientation =3D this.options.orientation;=0A=
      var showMinorLabels =3D this.options.showMinorLabels;=0A=
      var showMajorLabels =3D this.options.showMajorLabels;=0A=
=0A=
      // determine the width and height of the elements for the axis=0A=
      props.minorLabelHeight =3D showMinorLabels ? props.minorCharHeight =
: 0;=0A=
      props.majorLabelHeight =3D showMajorLabels ? props.majorCharHeight =
: 0;=0A=
=0A=
      props.minorLineWidth =3D =
this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - =
this.width + 2 * this.options.minorLinesOffset;=0A=
      props.minorLineHeight =3D 1;=0A=
      props.majorLineWidth =3D =
this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - =
this.width + 2 * this.options.majorLinesOffset;=0A=
      props.majorLineHeight =3D 1;=0A=
=0A=
      //  take frame offline while updating (is almost twice as fast)=0A=
      if (orientation =3D=3D=3D 'left') {=0A=
        frame.style.top =3D '0';=0A=
        frame.style.left =3D '0';=0A=
        frame.style.bottom =3D '';=0A=
        frame.style.width =3D this.width + 'px';=0A=
        frame.style.height =3D this.height + 'px';=0A=
        this.props.width =3D this.body.domProps.left.width;=0A=
        this.props.height =3D this.body.domProps.left.height;=0A=
      } else {=0A=
        // right=0A=
        frame.style.top =3D '';=0A=
        frame.style.bottom =3D '0';=0A=
        frame.style.left =3D '0';=0A=
        frame.style.width =3D this.width + 'px';=0A=
        frame.style.height =3D this.height + 'px';=0A=
        this.props.width =3D this.body.domProps.right.width;=0A=
        this.props.height =3D this.body.domProps.right.height;=0A=
      }=0A=
=0A=
      resized =3D this._redrawLabels();=0A=
      resized =3D this._isResized() || resized;=0A=
=0A=
      if (this.options.icons =3D=3D=3D true) {=0A=
        this._redrawGroupIcons();=0A=
      } else {=0A=
        this._cleanupIcons();=0A=
      }=0A=
=0A=
      this._redrawTitle(orientation);=0A=
    }=0A=
    return resized;=0A=
  };=0A=
=0A=
  /**=0A=
   * Repaint major and minor text labels and vertical grid lines=0A=
   * @private=0A=
   */=0A=
  DataAxis.prototype._redrawLabels =3D function () {=0A=
    var resized =3D false;=0A=
    DOMutil.prepareElements(this.DOMelements.lines);=0A=
    DOMutil.prepareElements(this.DOMelements.labels);=0A=
    var orientation =3D this.options['orientation'];=0A=
=0A=
    // get the range for the slaved axis=0A=
    var step;=0A=
    if (this.master =3D=3D=3D false) {=0A=
      var stepSize, rangeStart, rangeEnd, minimumStep;=0A=
      if (this.zeroCrossing !=3D=3D -1 && this.options.alignZeros =
=3D=3D=3D true) {=0A=
        if (this.range.end > 0) {=0A=
          stepSize =3D this.range.end / this.zeroCrossing; // size of =
one step=0A=
          rangeStart =3D this.range.end - this.amountOfSteps * stepSize;=0A=
          rangeEnd =3D this.range.end;=0A=
        } else {=0A=
          // all of the range (including start) has to be done before =
the zero crossing.=0A=
          stepSize =3D -1 * this.range.start / (this.amountOfSteps - =
this.zeroCrossing); // absolute size of a step=0A=
          rangeStart =3D this.range.start;=0A=
          rangeEnd =3D this.range.start + stepSize * this.amountOfSteps;=0A=
        }=0A=
      } else {=0A=
        rangeStart =3D this.range.start;=0A=
        rangeEnd =3D this.range.end;=0A=
      }=0A=
      minimumStep =3D this.stepPixels;=0A=
    } else {=0A=
      // calculate range and step (step such that we have space for 7 =
characters per label)=0A=
      minimumStep =3D this.props.majorCharHeight;=0A=
      rangeStart =3D this.range.start;=0A=
      rangeEnd =3D this.range.end;=0A=
    }=0A=
=0A=
    this.step =3D step =3D new DataStep(rangeStart, rangeEnd, =
minimumStep, this.dom.frame.offsetHeight, =
this.options[this.options.orientation].range, =
this.options[this.options.orientation].format, this.master =3D=3D=3D =
false && this.options.alignZeros // does the step have to align zeros? =
only if not master and the options is on=0A=
    );=0A=
=0A=
    // the slave axis needs to use the same horizontal lines as the =
master axis.=0A=
    if (this.master =3D=3D=3D true) {=0A=
      this.stepPixels =3D this.dom.frame.offsetHeight / step.marginRange =
* step.step;=0A=
      this.amountOfSteps =3D Math.ceil(this.dom.frame.offsetHeight / =
this.stepPixels);=0A=
    } else {=0A=
      // align with zero=0A=
      if (this.options.alignZeros =3D=3D=3D true && this.zeroCrossing =
!=3D=3D -1) {=0A=
        // distance is the amount of steps away from the zero crossing =
we are.=0A=
        var distance =3D (step.current - this.zeroCrossing * step.step) =
/ step.step;=0A=
        this.step.shift(distance);=0A=
      }=0A=
    }=0A=
=0A=
    // value at the bottom of the SVG=0A=
    this.valueAtBottom =3D step.marginEnd;=0A=
=0A=
    this.maxLabelSize =3D 0;=0A=
    var y =3D 0; // init value=0A=
    var stepIndex =3D 0; // init value=0A=
    var isMajor =3D false; // init value=0A=
    while (stepIndex < this.amountOfSteps) {=0A=
      y =3D Math.round(stepIndex * this.stepPixels);=0A=
      isMajor =3D step.isMajor();=0A=
=0A=
      if (stepIndex > 0 && stepIndex !=3D=3D this.amountOfSteps) {=0A=
        if (this.options['showMinorLabels'] && isMajor =3D=3D=3D false =
|| this.master =3D=3D=3D false && this.options['showMinorLabels'] =
=3D=3D=3D true) {=0A=
          this._redrawLabel(y - 2, step.getCurrent(), orientation, =
'vis-y-axis vis-minor', this.props.minorCharHeight);=0A=
        }=0A=
=0A=
        if (isMajor && this.options['showMajorLabels'] && this.master =
=3D=3D=3D true || this.options['showMinorLabels'] =3D=3D=3D false && =
this.master =3D=3D=3D false && isMajor =3D=3D=3D true) {=0A=
          if (y >=3D 0) {=0A=
            this._redrawLabel(y - 2, step.getCurrent(), orientation, =
'vis-y-axis vis-major', this.props.majorCharHeight);=0A=
          }=0A=
          this._redrawLine(y, orientation, 'vis-grid vis-horizontal =
vis-major', this.options.majorLinesOffset, this.props.majorLineWidth);=0A=
        } else {=0A=
          this._redrawLine(y, orientation, 'vis-grid vis-horizontal =
vis-minor', this.options.minorLinesOffset, this.props.minorLineWidth);=0A=
        }=0A=
      }=0A=
=0A=
      // get zero crossing=0A=
      if (this.master =3D=3D=3D true && step.current =3D=3D=3D 0) {=0A=
        this.zeroCrossing =3D stepIndex;=0A=
      }=0A=
=0A=
      step.next();=0A=
      stepIndex +=3D 1;=0A=
    }=0A=
=0A=
    // get zero crossing if it's the last step=0A=
    if (this.master =3D=3D=3D true && step.current =3D=3D=3D 0) {=0A=
      this.zeroCrossing =3D stepIndex;=0A=
    }=0A=
=0A=
    this.conversionFactor =3D this.stepPixels / step.step;=0A=
=0A=
    // Note that title is rotated, so we're using the height, not width!=0A=
    var titleWidth =3D 0;=0A=
    if (this.options[orientation].title !=3D=3D undefined && =
this.options[orientation].title.text !=3D=3D undefined) {=0A=
      titleWidth =3D this.props.titleCharHeight;=0A=
    }=0A=
    var offset =3D this.options.icons =3D=3D=3D true ? =
Math.max(this.options.iconWidth, titleWidth) + this.options.labelOffsetX =
+ 15 : titleWidth + this.options.labelOffsetX + 15;=0A=
=0A=
    // this will resize the yAxis to accommodate the labels.=0A=
    if (this.maxLabelSize > this.width - offset && this.options.visible =
=3D=3D=3D true) {=0A=
      this.width =3D this.maxLabelSize + offset;=0A=
      this.options.width =3D this.width + 'px';=0A=
      DOMutil.cleanupElements(this.DOMelements.lines);=0A=
      DOMutil.cleanupElements(this.DOMelements.labels);=0A=
      this.redraw();=0A=
      resized =3D true;=0A=
    }=0A=
    // this will resize the yAxis if it is too big for the labels.=0A=
    else if (this.maxLabelSize < this.width - offset && =
this.options.visible =3D=3D=3D true && this.width > this.minWidth) {=0A=
      this.width =3D Math.max(this.minWidth, this.maxLabelSize + offset);=0A=
      this.options.width =3D this.width + 'px';=0A=
      DOMutil.cleanupElements(this.DOMelements.lines);=0A=
      DOMutil.cleanupElements(this.DOMelements.labels);=0A=
      this.redraw();=0A=
      resized =3D true;=0A=
    } else {=0A=
      DOMutil.cleanupElements(this.DOMelements.lines);=0A=
      DOMutil.cleanupElements(this.DOMelements.labels);=0A=
      resized =3D false;=0A=
    }=0A=
=0A=
    return resized;=0A=
  };=0A=
=0A=
  DataAxis.prototype.convertValue =3D function (value) {=0A=
    var invertedValue =3D this.valueAtBottom - value;=0A=
    var convertedValue =3D invertedValue * this.conversionFactor;=0A=
    return convertedValue;=0A=
  };=0A=
=0A=
  DataAxis.prototype.screenToValue =3D function (x) {=0A=
    return this.valueAtBottom - x / this.conversionFactor;=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a label for the axis at position x=0A=
   * @private=0A=
   * @param y=0A=
   * @param text=0A=
   * @param orientation=0A=
   * @param className=0A=
   * @param characterHeight=0A=
   */=0A=
  DataAxis.prototype._redrawLabel =3D function (y, text, orientation, =
className, characterHeight) {=0A=
    // reuse redundant label=0A=
    var label =3D DOMutil.getDOMElement('div', this.DOMelements.labels, =
this.dom.frame); //this.dom.redundant.labels.shift();=0A=
    label.className =3D className;=0A=
    label.innerHTML =3D text;=0A=
    if (orientation =3D=3D=3D 'left') {=0A=
      label.style.left =3D '-' + this.options.labelOffsetX + 'px';=0A=
      label.style.textAlign =3D 'right';=0A=
    } else {=0A=
      label.style.right =3D '-' + this.options.labelOffsetX + 'px';=0A=
      label.style.textAlign =3D 'left';=0A=
    }=0A=
=0A=
    label.style.top =3D y - 0.5 * characterHeight + =
this.options.labelOffsetY + 'px';=0A=
=0A=
    text +=3D '';=0A=
=0A=
    var largestWidth =3D Math.max(this.props.majorCharWidth, =
this.props.minorCharWidth);=0A=
    if (this.maxLabelSize < text.length * largestWidth) {=0A=
      this.maxLabelSize =3D text.length * largestWidth;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a minor line for the axis at position y=0A=
   * @param y=0A=
   * @param orientation=0A=
   * @param className=0A=
   * @param offset=0A=
   * @param width=0A=
   */=0A=
  DataAxis.prototype._redrawLine =3D function (y, orientation, =
className, offset, width) {=0A=
    if (this.master =3D=3D=3D true) {=0A=
      var line =3D DOMutil.getDOMElement('div', this.DOMelements.lines, =
this.dom.lineContainer); //this.dom.redundant.lines.shift();=0A=
      line.className =3D className;=0A=
      line.innerHTML =3D '';=0A=
=0A=
      if (orientation =3D=3D=3D 'left') {=0A=
        line.style.left =3D this.width - offset + 'px';=0A=
      } else {=0A=
        line.style.right =3D this.width - offset + 'px';=0A=
      }=0A=
=0A=
      line.style.width =3D width + 'px';=0A=
      line.style.top =3D y + 'px';=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Create a title for the axis=0A=
   * @private=0A=
   * @param orientation=0A=
   */=0A=
  DataAxis.prototype._redrawTitle =3D function (orientation) {=0A=
    DOMutil.prepareElements(this.DOMelements.title);=0A=
=0A=
    // Check if the title is defined for this axes=0A=
    if (this.options[orientation].title !=3D=3D undefined && =
this.options[orientation].title.text !=3D=3D undefined) {=0A=
      var title =3D DOMutil.getDOMElement('div', this.DOMelements.title, =
this.dom.frame);=0A=
      title.className =3D 'vis-y-axis vis-title vis-' + orientation;=0A=
      title.innerHTML =3D this.options[orientation].title.text;=0A=
=0A=
      // Add style - if provided=0A=
      if (this.options[orientation].title.style !=3D=3D undefined) {=0A=
        util.addCssText(title, this.options[orientation].title.style);=0A=
      }=0A=
=0A=
      if (orientation =3D=3D=3D 'left') {=0A=
        title.style.left =3D this.props.titleCharHeight + 'px';=0A=
      } else {=0A=
        title.style.right =3D this.props.titleCharHeight + 'px';=0A=
      }=0A=
=0A=
      title.style.width =3D this.height + 'px';=0A=
    }=0A=
=0A=
    // we need to clean up in case we did not use all elements.=0A=
    DOMutil.cleanupElements(this.DOMelements.title);=0A=
  };=0A=
=0A=
  /**=0A=
   * Determine the size of text on the axis (both major and minor axis).=0A=
   * The size is calculated only once and then cached in this.props.=0A=
   * @private=0A=
   */=0A=
  DataAxis.prototype._calculateCharSize =3D function () {=0A=
    // determine the char width and height on the minor axis=0A=
    if (!('minorCharHeight' in this.props)) {=0A=
      var textMinor =3D document.createTextNode('0');=0A=
      var measureCharMinor =3D document.createElement('div');=0A=
      measureCharMinor.className =3D 'vis-y-axis vis-minor vis-measure';=0A=
      measureCharMinor.appendChild(textMinor);=0A=
      this.dom.frame.appendChild(measureCharMinor);=0A=
=0A=
      this.props.minorCharHeight =3D measureCharMinor.clientHeight;=0A=
      this.props.minorCharWidth =3D measureCharMinor.clientWidth;=0A=
=0A=
      this.dom.frame.removeChild(measureCharMinor);=0A=
    }=0A=
=0A=
    if (!('majorCharHeight' in this.props)) {=0A=
      var textMajor =3D document.createTextNode('0');=0A=
      var measureCharMajor =3D document.createElement('div');=0A=
      measureCharMajor.className =3D 'vis-y-axis vis-major vis-measure';=0A=
      measureCharMajor.appendChild(textMajor);=0A=
      this.dom.frame.appendChild(measureCharMajor);=0A=
=0A=
      this.props.majorCharHeight =3D measureCharMajor.clientHeight;=0A=
      this.props.majorCharWidth =3D measureCharMajor.clientWidth;=0A=
=0A=
      this.dom.frame.removeChild(measureCharMajor);=0A=
    }=0A=
=0A=
    if (!('titleCharHeight' in this.props)) {=0A=
      var textTitle =3D document.createTextNode('0');=0A=
      var measureCharTitle =3D document.createElement('div');=0A=
      measureCharTitle.className =3D 'vis-y-axis vis-title vis-measure';=0A=
      measureCharTitle.appendChild(textTitle);=0A=
      this.dom.frame.appendChild(measureCharTitle);=0A=
=0A=
      this.props.titleCharHeight =3D measureCharTitle.clientHeight;=0A=
      this.props.titleCharWidth =3D measureCharTitle.clientWidth;=0A=
=0A=
      this.dom.frame.removeChild(measureCharTitle);=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D DataAxis;=0A=
=0A=
/***/ },=0A=
/* 52 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * @constructor  DataStep=0A=
   * The class DataStep is an iterator for data for the lineGraph. You =
provide a start data point and an=0A=
   * end data point. The class itself determines the best scale (step =
size) based on the=0A=
   * provided start Date, end Date, and minimumStep.=0A=
   *=0A=
   * If minimumStep is provided, the step size is chosen as close as =
possible=0A=
   * to the minimumStep but larger than minimumStep. If minimumStep is =
not=0A=
   * provided, the scale is set to 1 DAY.=0A=
   * The minimumStep should correspond with the onscreen size of about 6 =
characters=0A=
   *=0A=
   * Alternatively, you can set a scale by hand.=0A=
   * After creation, you can initialize the class by executing first(). =
Then you=0A=
   * can iterate from the start date to the end date via next(). You can =
check if=0A=
   * the end date is reached with the function hasNext(). After each =
step, you can=0A=
   * retrieve the current date via getCurrent().=0A=
   * The DataStep has scales ranging from milliseconds, seconds, =
minutes, hours,=0A=
   * days, to years.=0A=
   *=0A=
   * Version: 1.2=0A=
   *=0A=
   * @param {Date} [start]         The start date, for example new =
Date(2010, 9, 21)=0A=
   *                               or new Date(2010, 9, 21, 23, 45, 00)=0A=
   * @param {Date} [end]           The end date=0A=
   * @param {Number} [minimumStep] Optional. Minimum step size in =
milliseconds=0A=
   */=0A=
  'use strict';=0A=
=0A=
  function DataStep(start, end, minimumStep, containerHeight, =
customRange, formattingFunction, alignZeros) {=0A=
    // variables=0A=
    this.current =3D 0;=0A=
=0A=
    this.autoScale =3D true;=0A=
    this.stepIndex =3D 0;=0A=
    this.step =3D 1;=0A=
    this.scale =3D 1;=0A=
    this.formattingFunction =3D formattingFunction;=0A=
=0A=
    this.marginStart;=0A=
    this.marginEnd;=0A=
    this.deadSpace =3D 0;=0A=
=0A=
    this.majorSteps =3D [1, 2, 5, 10];=0A=
    this.minorSteps =3D [0.25, 0.5, 1, 2];=0A=
=0A=
    this.alignZeros =3D alignZeros;=0A=
=0A=
    this.setRange(start, end, minimumStep, containerHeight, customRange);=0A=
  }=0A=
=0A=
  /**=0A=
   * Set a new range=0A=
   * If minimumStep is provided, the step size is chosen as close as =
possible=0A=
   * to the minimumStep but larger than minimumStep. If minimumStep is =
not=0A=
   * provided, the scale is set to 1 DAY.=0A=
   * The minimumStep should correspond with the onscreen size of about 6 =
characters=0A=
   * @param {Number} [start]      The start date and time.=0A=
   * @param {Number} [end]        The end date and time.=0A=
   * @param {Number} [minimumStep] Optional. Minimum step size in =
milliseconds=0A=
   */=0A=
  DataStep.prototype.setRange =3D function (start, end, minimumStep, =
containerHeight, customRange) {=0A=
    this._start =3D customRange.min =3D=3D=3D undefined ? start : =
customRange.min;=0A=
    this._end =3D customRange.max =3D=3D=3D undefined ? end : =
customRange.max;=0A=
    if (this._start =3D=3D=3D this._end) {=0A=
      this._start =3D customRange.min =3D=3D=3D undefined ? this._start =
- 0.75 : this._start;=0A=
      this._end =3D customRange.max =3D=3D=3D undefined ? this._end + 1 =
: this._end;;=0A=
    }=0A=
=0A=
    if (this.autoScale =3D=3D=3D true) {=0A=
      this.setMinimumStep(minimumStep, containerHeight);=0A=
    }=0A=
=0A=
    this.setFirst(customRange);=0A=
  };=0A=
=0A=
  /**=0A=
   * Automatically determine the scale that bests fits the provided =
minimum step=0A=
   * @param {Number} [minimumStep]  The minimum step size in pixels=0A=
   */=0A=
  DataStep.prototype.setMinimumStep =3D function (minimumStep, =
containerHeight) {=0A=
    // round to floor=0A=
    var range =3D this._end - this._start;=0A=
    var safeRange =3D range * 1.2;=0A=
    var minimumStepValue =3D minimumStep * (safeRange / containerHeight);=0A=
    var orderOfMagnitude =3D Math.round(Math.log(safeRange) / Math.LN10);=0A=
=0A=
    var minorStepIdx =3D -1;=0A=
    var magnitudefactor =3D Math.pow(10, orderOfMagnitude);=0A=
=0A=
    var start =3D 0;=0A=
    if (orderOfMagnitude < 0) {=0A=
      start =3D orderOfMagnitude;=0A=
    }=0A=
=0A=
    var solutionFound =3D false;=0A=
    for (var i =3D start; Math.abs(i) <=3D Math.abs(orderOfMagnitude); =
i++) {=0A=
      magnitudefactor =3D Math.pow(10, i);=0A=
      for (var j =3D 0; j < this.minorSteps.length; j++) {=0A=
        var stepSize =3D magnitudefactor * this.minorSteps[j];=0A=
        if (stepSize >=3D minimumStepValue) {=0A=
          solutionFound =3D true;=0A=
          minorStepIdx =3D j;=0A=
          break;=0A=
        }=0A=
      }=0A=
      if (solutionFound =3D=3D=3D true) {=0A=
        break;=0A=
      }=0A=
    }=0A=
    this.stepIndex =3D minorStepIdx;=0A=
    this.scale =3D magnitudefactor;=0A=
    this.step =3D magnitudefactor * this.minorSteps[minorStepIdx];=0A=
  };=0A=
=0A=
  /**=0A=
   * Round the current date to the first minor date value=0A=
   * This must be executed once when the current date is set to start =
Date=0A=
   */=0A=
  DataStep.prototype.setFirst =3D function (customRange) {=0A=
    if (customRange =3D=3D=3D undefined) {=0A=
      customRange =3D {};=0A=
    }=0A=
=0A=
    var niceStart =3D customRange.min =3D=3D=3D undefined ? this._start =
- this.scale * 2 * this.minorSteps[this.stepIndex] : customRange.min;=0A=
    var niceEnd =3D customRange.max =3D=3D=3D undefined ? this._end + =
this.scale * this.minorSteps[this.stepIndex] : customRange.max;=0A=
=0A=
    this.marginEnd =3D customRange.max =3D=3D=3D undefined ? =
this.roundToMinor(niceEnd) : customRange.max;=0A=
    this.marginStart =3D customRange.min =3D=3D=3D undefined ? =
this.roundToMinor(niceStart) : customRange.min;=0A=
=0A=
    // if we need to align the zero's we need to make sure that there is =
a zero to use.=0A=
    if (this.alignZeros =3D=3D=3D true && (this.marginEnd - =
this.marginStart) % this.step !=3D 0) {=0A=
      this.marginEnd +=3D this.marginEnd % this.step;=0A=
    }=0A=
=0A=
    this.deadSpace =3D this.roundToMinor(niceEnd) - niceEnd + =
this.roundToMinor(niceStart) - niceStart;=0A=
    this.marginRange =3D this.marginEnd - this.marginStart;=0A=
=0A=
    this.current =3D this.marginEnd;=0A=
  };=0A=
=0A=
  DataStep.prototype.roundToMinor =3D function (value) {=0A=
    var rounded =3D value - value % (this.scale * =
this.minorSteps[this.stepIndex]);=0A=
    if (value % (this.scale * this.minorSteps[this.stepIndex]) > 0.5 * =
(this.scale * this.minorSteps[this.stepIndex])) {=0A=
      return rounded + this.scale * this.minorSteps[this.stepIndex];=0A=
    } else {=0A=
      return rounded;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Check if the there is a next step=0A=
   * @return {boolean}  true if the current date has not passed the end =
date=0A=
   */=0A=
  DataStep.prototype.hasNext =3D function () {=0A=
    return this.current >=3D this.marginStart;=0A=
  };=0A=
=0A=
  /**=0A=
   * Do the next step=0A=
   */=0A=
  DataStep.prototype.next =3D function () {=0A=
    var prev =3D this.current;=0A=
    this.current -=3D this.step;=0A=
=0A=
    // safety mechanism: if current time is still unchanged, move to the =
end=0A=
    if (this.current =3D=3D=3D prev) {=0A=
      this.current =3D this._end;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Do the next step=0A=
   */=0A=
  DataStep.prototype.previous =3D function () {=0A=
    this.current +=3D this.step;=0A=
    this.marginEnd +=3D this.step;=0A=
    this.marginRange =3D this.marginEnd - this.marginStart;=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the current datetime=0A=
   * @return {String}  current The current date=0A=
   */=0A=
  DataStep.prototype.getCurrent =3D function () {=0A=
    // prevent round-off errors when close to zero=0A=
    var current =3D Math.abs(this.current) < this.step / 2 ? 0 : =
this.current;=0A=
    var returnValue =3D current.toPrecision(5);=0A=
    if (typeof this.formattingFunction =3D=3D=3D 'function') {=0A=
      returnValue =3D this.formattingFunction(current);=0A=
    }=0A=
=0A=
    if (typeof returnValue =3D=3D=3D 'number') {=0A=
      return '' + returnValue;=0A=
    } else if (typeof returnValue =3D=3D=3D 'string') {=0A=
      return returnValue;=0A=
    } else {=0A=
      return current.toPrecision(5);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Check if the current value is a major value (for example when the =
step=0A=
   * is DAY, a major value is each first day of the MONTH)=0A=
   * @return {boolean} true if current date is major, else false.=0A=
   */=0A=
  DataStep.prototype.isMajor =3D function () {=0A=
    return this.current % (this.scale * this.majorSteps[this.stepIndex]) =
=3D=3D=3D 0;=0A=
  };=0A=
=0A=
  DataStep.prototype.shift =3D function (steps) {=0A=
    if (steps < 0) {=0A=
      for (var i =3D 0; i < -steps; i++) {=0A=
        this.previous();=0A=
      }=0A=
    } else if (steps > 0) {=0A=
      for (var i =3D 0; i < steps; i++) {=0A=
        this.next();=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D DataStep;=0A=
=0A=
/***/ },=0A=
/* 53 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var DOMutil =3D __webpack_require__(13);=0A=
  var Line =3D __webpack_require__(54);=0A=
  var Bar =3D __webpack_require__(56);=0A=
  var Points =3D __webpack_require__(55);=0A=
=0A=
  /**=0A=
   * /**=0A=
   * @param {object} group            | the object of the group from the =
dataset=0A=
   * @param {string} groupId          | ID of the group=0A=
   * @param {object} options          | the default options=0A=
   * @param {array} groupsUsingDefaultStyles  | this array has one =
entree.=0A=
   *                                            It is passed as an array =
so it is passed by reference.=0A=
   *                                            It enumerates through =
the default styles=0A=
   * @constructor=0A=
   */=0A=
  function GraphGroup(group, groupId, options, groupsUsingDefaultStyles) =
{=0A=
    this.id =3D groupId;=0A=
    var fields =3D ['sampling', 'style', 'sort', 'yAxisOrientation', =
'barChart', 'drawPoints', 'shaded', 'interpolation'];=0A=
    this.options =3D util.selectiveBridgeObject(fields, options);=0A=
    this.usingDefaultStyle =3D group.className =3D=3D=3D undefined;=0A=
    this.groupsUsingDefaultStyles =3D groupsUsingDefaultStyles;=0A=
    this.zeroPosition =3D 0;=0A=
    this.update(group);=0A=
    if (this.usingDefaultStyle =3D=3D true) {=0A=
      this.groupsUsingDefaultStyles[0] +=3D 1;=0A=
    }=0A=
    this.itemsData =3D [];=0A=
    this.visible =3D group.visible =3D=3D=3D undefined ? true : =
group.visible;=0A=
  }=0A=
=0A=
  /**=0A=
   * this loads a reference to all items in this group into this group.=0A=
   * @param {array} items=0A=
   */=0A=
  GraphGroup.prototype.setItems =3D function (items) {=0A=
    if (items !=3D null) {=0A=
      this.itemsData =3D items;=0A=
      if (this.options.sort =3D=3D true) {=0A=
        this.itemsData.sort(function (a, b) {=0A=
          return a.x - b.x;=0A=
        });=0A=
      }=0A=
      // typecast all items to numbers. Takes around 10ms for 500.000 =
items=0A=
      for (var i =3D 0; i < this.itemsData.length; i++) {=0A=
        this.itemsData[i].y =3D Number(this.itemsData[i].y);=0A=
      }=0A=
    } else {=0A=
      this.itemsData =3D [];=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this is used for plotting barcharts, this way, we only have to =
calculate it once.=0A=
   * @param pos=0A=
   */=0A=
  GraphGroup.prototype.setZeroPosition =3D function (pos) {=0A=
    this.zeroPosition =3D pos;=0A=
  };=0A=
=0A=
  /**=0A=
   * set the options of the graph group over the default options.=0A=
   * @param options=0A=
   */=0A=
  GraphGroup.prototype.setOptions =3D function (options) {=0A=
    if (options !=3D=3D undefined) {=0A=
      var fields =3D ['sampling', 'style', 'sort', 'yAxisOrientation', =
'barChart'];=0A=
      util.selectiveDeepExtend(fields, this.options, options);=0A=
=0A=
      // if the group's drawPoints is a function delegate the callback =
to the onRender property=0A=
      if (typeof options.drawPoints =3D=3D 'function') {=0A=
        options.drawPoints =3D {=0A=
          onRender: options.drawPoints=0A=
        };=0A=
      }=0A=
=0A=
      util.mergeOptions(this.options, options, 'interpolation');=0A=
      util.mergeOptions(this.options, options, 'drawPoints');=0A=
      util.mergeOptions(this.options, options, 'shaded');=0A=
=0A=
      if (options.interpolation) {=0A=
        if (typeof options.interpolation =3D=3D 'object') {=0A=
          if (options.interpolation.parametrization) {=0A=
            if (options.interpolation.parametrization =3D=3D 'uniform') {=0A=
              this.options.interpolation.alpha =3D 0;=0A=
            } else if (options.interpolation.parametrization =3D=3D =
'chordal') {=0A=
              this.options.interpolation.alpha =3D 1.0;=0A=
            } else {=0A=
              this.options.interpolation.parametrization =3D =
'centripetal';=0A=
              this.options.interpolation.alpha =3D 0.5;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    if (this.options.style =3D=3D 'line') {=0A=
      this.type =3D new Line(this.id, this.options);=0A=
    } else if (this.options.style =3D=3D 'bar') {=0A=
      this.type =3D new Bar(this.id, this.options);=0A=
    } else if (this.options.style =3D=3D 'points') {=0A=
      this.type =3D new Points(this.id, this.options);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this updates the current group class with the latest group dataset =
entree, used in _updateGroup in linegraph=0A=
   * @param group=0A=
   */=0A=
  GraphGroup.prototype.update =3D function (group) {=0A=
    this.group =3D group;=0A=
    this.content =3D group.content || 'graph';=0A=
    this.className =3D group.className || this.className || =
'vis-graph-group' + this.groupsUsingDefaultStyles[0] % 10;=0A=
    this.visible =3D group.visible =3D=3D=3D undefined ? true : =
group.visible;=0A=
    this.style =3D group.style;=0A=
    this.setOptions(group.options);=0A=
  };=0A=
=0A=
  /**=0A=
   * draw the icon for the legend.=0A=
   *=0A=
   * @param x=0A=
   * @param y=0A=
   * @param JSONcontainer=0A=
   * @param SVGcontainer=0A=
   * @param iconWidth=0A=
   * @param iconHeight=0A=
   */=0A=
  GraphGroup.prototype.drawIcon =3D function (x, y, JSONcontainer, =
SVGcontainer, iconWidth, iconHeight) {=0A=
    var fillHeight =3D iconHeight * 0.5;=0A=
    var path, fillPath;=0A=
=0A=
    var outline =3D DOMutil.getSVGElement('rect', JSONcontainer, =
SVGcontainer);=0A=
    outline.setAttributeNS(null, 'x', x);=0A=
    outline.setAttributeNS(null, 'y', y - fillHeight);=0A=
    outline.setAttributeNS(null, 'width', iconWidth);=0A=
    outline.setAttributeNS(null, 'height', 2 * fillHeight);=0A=
    outline.setAttributeNS(null, 'class', 'vis-outline');=0A=
=0A=
    if (this.options.style =3D=3D 'line') {=0A=
      path =3D DOMutil.getSVGElement('path', JSONcontainer, =
SVGcontainer);=0A=
      path.setAttributeNS(null, 'class', this.className);=0A=
      if (this.style !=3D=3D undefined) {=0A=
        path.setAttributeNS(null, 'style', this.style);=0A=
      }=0A=
=0A=
      path.setAttributeNS(null, 'd', 'M' + x + ',' + y + ' L' + (x + =
iconWidth) + ',' + y + '');=0A=
      if (this.options.shaded.enabled =3D=3D true) {=0A=
        fillPath =3D DOMutil.getSVGElement('path', JSONcontainer, =
SVGcontainer);=0A=
        if (this.options.shaded.orientation =3D=3D 'top') {=0A=
          fillPath.setAttributeNS(null, 'd', 'M' + x + ', ' + (y - =
fillHeight) + 'L' + x + ',' + y + ' L' + (x + iconWidth) + ',' + y + ' =
L' + (x + iconWidth) + ',' + (y - fillHeight));=0A=
        } else {=0A=
          fillPath.setAttributeNS(null, 'd', 'M' + x + ',' + y + ' ' + =
'L' + x + ',' + (y + fillHeight) + ' ' + 'L' + (x + iconWidth) + ',' + =
(y + fillHeight) + 'L' + (x + iconWidth) + ',' + y);=0A=
        }=0A=
        fillPath.setAttributeNS(null, 'class', this.className + ' =
vis-icon-fill');=0A=
      }=0A=
=0A=
      if (this.options.drawPoints.enabled =3D=3D true) {=0A=
        var groupTemplate =3D {=0A=
          style: this.options.drawPoints.style,=0A=
          size: this.options.drawPoints.size,=0A=
          className: this.className=0A=
        };=0A=
        DOMutil.drawPoint(x + 0.5 * iconWidth, y, groupTemplate, =
JSONcontainer, SVGcontainer);=0A=
      }=0A=
    } else {=0A=
      var barWidth =3D Math.round(0.3 * iconWidth);=0A=
      var bar1Height =3D Math.round(0.4 * iconHeight);=0A=
      var bar2Height =3D Math.round(0.75 * iconHeight);=0A=
=0A=
      var offset =3D Math.round((iconWidth - 2 * barWidth) / 3);=0A=
=0A=
      DOMutil.drawBar(x + 0.5 * barWidth + offset, y + fillHeight - =
bar1Height - 1, barWidth, bar1Height, this.className + ' vis-bar', =
JSONcontainer, SVGcontainer, this.style);=0A=
      DOMutil.drawBar(x + 1.5 * barWidth + offset + 2, y + fillHeight - =
bar2Height - 1, barWidth, bar2Height, this.className + ' vis-bar', =
JSONcontainer, SVGcontainer, this.style);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * return the legend entree for this group.=0A=
   *=0A=
   * @param iconWidth=0A=
   * @param iconHeight=0A=
   * @returns {{icon: HTMLElement, label: (group.content|*|string), =
orientation: (.options.yAxisOrientation|*)}}=0A=
   */=0A=
  GraphGroup.prototype.getLegend =3D function (iconWidth, iconHeight) {=0A=
    var svg =3D document.createElementNS('http://www.w3.org/2000/svg', =
'svg');=0A=
    this.drawIcon(0, 0.5 * iconHeight, [], svg, iconWidth, iconHeight);=0A=
    return { icon: svg, label: this.content, orientation: =
this.options.yAxisOrientation };=0A=
  };=0A=
=0A=
  GraphGroup.prototype.getYRange =3D function (groupData) {=0A=
    return this.type.getYRange(groupData);=0A=
  };=0A=
=0A=
  GraphGroup.prototype.getData =3D function (groupData) {=0A=
    return this.type.getData(groupData);=0A=
  };=0A=
=0A=
  GraphGroup.prototype.draw =3D function (dataset, group, framework) {=0A=
    this.type.draw(dataset, group, framework);=0A=
  };=0A=
=0A=
  module.exports =3D GraphGroup;=0A=
=0A=
/***/ },=0A=
/* 54 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var DOMutil =3D __webpack_require__(13);=0A=
  var Points =3D __webpack_require__(55);=0A=
=0A=
  function Line(groupId, options) {=0A=
    this.groupId =3D groupId;=0A=
    this.options =3D options;=0A=
  }=0A=
=0A=
  Line.prototype.getData =3D function (groupData) {=0A=
    var combinedData =3D [];=0A=
    for (var j =3D 0; j < groupData.length; j++) {=0A=
      combinedData.push({=0A=
        x: groupData[j].x,=0A=
        y: groupData[j].y,=0A=
        groupId: this.groupId=0A=
      });=0A=
    }=0A=
    return combinedData;=0A=
  };=0A=
=0A=
  Line.prototype.getYRange =3D function (groupData) {=0A=
    var yMin =3D groupData[0].y;=0A=
    var yMax =3D groupData[0].y;=0A=
    for (var j =3D 0; j < groupData.length; j++) {=0A=
      yMin =3D yMin > groupData[j].y ? groupData[j].y : yMin;=0A=
      yMax =3D yMax < groupData[j].y ? groupData[j].y : yMax;=0A=
    }=0A=
    return { min: yMin, max: yMax, yAxisOrientation: =
this.options.yAxisOrientation };=0A=
  };=0A=
=0A=
  Line.getStackedYRange =3D function (combinedData, groupRanges, =
groupIds, groupLabel, orientation) {=0A=
    if (combinedData.length > 0) {=0A=
      // sort by time and by group=0A=
      combinedData.sort(function (a, b) {=0A=
        if (a.x =3D=3D=3D b.x) {=0A=
          return a.groupId < b.groupId ? -1 : 1;=0A=
        } else {=0A=
          return a.x - b.x;=0A=
        }=0A=
      });=0A=
      var intersections =3D {};=0A=
=0A=
      Line._getDataIntersections(intersections, combinedData);=0A=
      groupRanges[groupLabel] =3D Line._getStackedYRange(intersections, =
combinedData);=0A=
      groupRanges[groupLabel].yAxisOrientation =3D orientation;=0A=
      groupIds.push(groupLabel);=0A=
    }=0A=
  };=0A=
=0A=
  Line._getStackedYRange =3D function (intersections, combinedData) {=0A=
    var key;=0A=
    var yMin =3D combinedData[0].y;=0A=
    var yMax =3D combinedData[0].y;=0A=
    for (var i =3D 0; i < combinedData.length; i++) {=0A=
      key =3D combinedData[i].x;=0A=
      if (intersections[key] =3D=3D=3D undefined) {=0A=
        yMin =3D yMin > combinedData[i].y ? combinedData[i].y : yMin;=0A=
        yMax =3D yMax < combinedData[i].y ? combinedData[i].y : yMax;=0A=
      } else {=0A=
        if (combinedData[i].y < 0) {=0A=
          intersections[key].accumulatedNegative +=3D combinedData[i].y;=0A=
        } else {=0A=
          intersections[key].accumulatedPositive +=3D combinedData[i].y;=0A=
        }=0A=
      }=0A=
    }=0A=
    for (var xpos in intersections) {=0A=
      if (intersections.hasOwnProperty(xpos)) {=0A=
        yMin =3D yMin > intersections[xpos].accumulatedNegative ? =
intersections[xpos].accumulatedNegative : yMin;=0A=
        yMin =3D yMin > intersections[xpos].accumulatedPositive ? =
intersections[xpos].accumulatedPositive : yMin;=0A=
        yMax =3D yMax < intersections[xpos].accumulatedNegative ? =
intersections[xpos].accumulatedNegative : yMax;=0A=
        yMax =3D yMax < intersections[xpos].accumulatedPositive ? =
intersections[xpos].accumulatedPositive : yMax;=0A=
      }=0A=
    }=0A=
=0A=
    return { min: yMin, max: yMax };=0A=
  };=0A=
=0A=
  /**=0A=
   * Fill the intersections object with counters of how many datapoints =
share the same x coordinates=0A=
   * @param intersections=0A=
   * @param combinedData=0A=
   * @private=0A=
   */=0A=
  Line._getDataIntersections =3D function (intersections, combinedData) {=0A=
    // get intersections=0A=
    var coreDistance;=0A=
    for (var i =3D 0; i < combinedData.length; i++) {=0A=
      if (i + 1 < combinedData.length) {=0A=
        coreDistance =3D Math.abs(combinedData[i + 1].x - =
combinedData[i].x);=0A=
      }=0A=
      if (i > 0) {=0A=
        coreDistance =3D Math.min(coreDistance, Math.abs(combinedData[i =
- 1].x - combinedData[i].x));=0A=
      }=0A=
      if (coreDistance =3D=3D=3D 0) {=0A=
        if (intersections[combinedData[i].x] =3D=3D=3D undefined) {=0A=
          intersections[combinedData[i].x] =3D { amount: 0, resolved: 0, =
accumulatedPositive: 0, accumulatedNegative: 0 };=0A=
        }=0A=
        intersections[combinedData[i].x].amount +=3D 1;=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * draw a line graph=0A=
   *=0A=
   * @param dataset=0A=
   * @param group=0A=
   */=0A=
  Line.prototype.draw =3D function (dataset, group, framework) {=0A=
    if (dataset !=3D null) {=0A=
      if (dataset.length > 0) {=0A=
        var path, d;=0A=
        var svgHeight =3D =
Number(framework.svg.style.height.replace('px', ''));=0A=
        path =3D DOMutil.getSVGElement('path', framework.svgElements, =
framework.svg);=0A=
        path.setAttributeNS(null, 'class', group.className);=0A=
        if (group.style !=3D=3D undefined) {=0A=
          path.setAttributeNS(null, 'style', group.style);=0A=
        }=0A=
=0A=
        // construct path from dataset=0A=
        if (group.options.interpolation.enabled =3D=3D true) {=0A=
          d =3D Line._catmullRom(dataset, group);=0A=
        } else {=0A=
          d =3D Line._linear(dataset);=0A=
        }=0A=
=0A=
        // append with points for fill and finalize the path=0A=
        if (group.options.shaded.enabled =3D=3D true) {=0A=
          var fillPath =3D DOMutil.getSVGElement('path', =
framework.svgElements, framework.svg);=0A=
          var dFill;=0A=
          if (group.options.shaded.orientation =3D=3D 'top') {=0A=
            dFill =3D 'M' + dataset[0].x + ',' + 0 + ' ' + d + 'L' + =
dataset[dataset.length - 1].x + ',' + 0;=0A=
          } else {=0A=
            dFill =3D 'M' + dataset[0].x + ',' + svgHeight + ' ' + d + =
'L' + dataset[dataset.length - 1].x + ',' + svgHeight;=0A=
          }=0A=
          fillPath.setAttributeNS(null, 'class', group.className + ' =
vis-fill');=0A=
          if (group.options.shaded.style !=3D=3D undefined) {=0A=
            fillPath.setAttributeNS(null, 'style', =
group.options.shaded.style);=0A=
          }=0A=
          fillPath.setAttributeNS(null, 'd', dFill);=0A=
        }=0A=
        // copy properties to path for drawing.=0A=
        path.setAttributeNS(null, 'd', 'M' + d);=0A=
=0A=
        // draw points=0A=
        if (group.options.drawPoints.enabled =3D=3D true) {=0A=
          Points.draw(dataset, group, framework);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * This uses an uniform parametrization of the interpolation algorithm:=0A=
   * 'On the Parameterization of Catmull-Rom Curves' by Cem Yuksel et al.=0A=
   * @param data=0A=
   * @returns {string}=0A=
   * @private=0A=
   */=0A=
  Line._catmullRomUniform =3D function (data) {=0A=
    // catmull rom=0A=
    var p0, p1, p2, p3, bp1, bp2;=0A=
    var d =3D Math.round(data[0].x) + ',' + Math.round(data[0].y) + ' ';=0A=
    var normalization =3D 1 / 6;=0A=
    var length =3D data.length;=0A=
    for (var i =3D 0; i < length - 1; i++) {=0A=
=0A=
      p0 =3D i =3D=3D 0 ? data[0] : data[i - 1];=0A=
      p1 =3D data[i];=0A=
      p2 =3D data[i + 1];=0A=
      p3 =3D i + 2 < length ? data[i + 2] : p2;=0A=
=0A=
      // Catmull-Rom to Cubic Bezier conversion matrix=0A=
      //    0       1       0       0=0A=
      //  -1/6      1      1/6      0=0A=
      //    0      1/6      1     -1/6=0A=
      //    0       0       1       0=0A=
=0A=
      //    bp0 =3D { x: p1.x,                               y: p1.y };=0A=
      bp1 =3D { x: (-p0.x + 6 * p1.x + p2.x) * normalization, y: (-p0.y =
+ 6 * p1.y + p2.y) * normalization };=0A=
      bp2 =3D { x: (p1.x + 6 * p2.x - p3.x) * normalization, y: (p1.y + =
6 * p2.y - p3.y) * normalization };=0A=
      //    bp0 =3D { x: p2.x,                               y: p2.y };=0A=
=0A=
      d +=3D 'C' + bp1.x + ',' + bp1.y + ' ' + bp2.x + ',' + bp2.y + ' ' =
+ p2.x + ',' + p2.y + ' ';=0A=
    }=0A=
=0A=
    return d;=0A=
  };=0A=
=0A=
  /**=0A=
   * This uses either the chordal or centripetal parameterization of the =
catmull-rom algorithm.=0A=
   * By default, the centripetal parameterization is used because this =
gives the nicest results.=0A=
   * These parameterizations are relatively heavy because the distance =
between 4 points have to be calculated.=0A=
   *=0A=
   * One optimization can be used to reuse distances since this is a =
sliding window approach.=0A=
   * @param data=0A=
   * @param group=0A=
   * @returns {string}=0A=
   * @private=0A=
   */=0A=
  Line._catmullRom =3D function (data, group) {=0A=
    var alpha =3D group.options.interpolation.alpha;=0A=
    if (alpha =3D=3D 0 || alpha =3D=3D=3D undefined) {=0A=
      return this._catmullRomUniform(data);=0A=
    } else {=0A=
      var p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;=0A=
      var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;=0A=
      var d =3D Math.round(data[0].x) + ',' + Math.round(data[0].y) + ' =
';=0A=
      var length =3D data.length;=0A=
      for (var i =3D 0; i < length - 1; i++) {=0A=
=0A=
        p0 =3D i =3D=3D 0 ? data[0] : data[i - 1];=0A=
        p1 =3D data[i];=0A=
        p2 =3D data[i + 1];=0A=
        p3 =3D i + 2 < length ? data[i + 2] : p2;=0A=
=0A=
        d1 =3D Math.sqrt(Math.pow(p0.x - p1.x, 2) + Math.pow(p0.y - =
p1.y, 2));=0A=
        d2 =3D Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - =
p2.y, 2));=0A=
        d3 =3D Math.sqrt(Math.pow(p2.x - p3.x, 2) + Math.pow(p2.y - =
p3.y, 2));=0A=
=0A=
        // Catmull-Rom to Cubic Bezier conversion matrix=0A=
=0A=
        // A =3D 2d1^2a + 3d1^a * d2^a + d3^2a=0A=
        // B =3D 2d3^2a + 3d3^a * d2^a + d2^2a=0A=
=0A=
        // [   0             1            0          0          ]=0A=
        // [   -d2^2a /N     A/N          d1^2a /N   0          ]=0A=
        // [   0             d3^2a /M     B/M        -d2^2a /M  ]=0A=
        // [   0             0            1          0          ]=0A=
=0A=
        d3powA =3D Math.pow(d3, alpha);=0A=
        d3pow2A =3D Math.pow(d3, 2 * alpha);=0A=
        d2powA =3D Math.pow(d2, alpha);=0A=
        d2pow2A =3D Math.pow(d2, 2 * alpha);=0A=
        d1powA =3D Math.pow(d1, alpha);=0A=
        d1pow2A =3D Math.pow(d1, 2 * alpha);=0A=
=0A=
        A =3D 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;=0A=
        B =3D 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;=0A=
        N =3D 3 * d1powA * (d1powA + d2powA);=0A=
        if (N > 0) {=0A=
          N =3D 1 / N;=0A=
        }=0A=
        M =3D 3 * d3powA * (d3powA + d2powA);=0A=
        if (M > 0) {=0A=
          M =3D 1 / M;=0A=
        }=0A=
=0A=
        bp1 =3D { x: (-d2pow2A * p0.x + A * p1.x + d1pow2A * p2.x) * N,=0A=
          y: (-d2pow2A * p0.y + A * p1.y + d1pow2A * p2.y) * N };=0A=
=0A=
        bp2 =3D { x: (d3pow2A * p1.x + B * p2.x - d2pow2A * p3.x) * M,=0A=
          y: (d3pow2A * p1.y + B * p2.y - d2pow2A * p3.y) * M };=0A=
=0A=
        if (bp1.x =3D=3D 0 && bp1.y =3D=3D 0) {=0A=
          bp1 =3D p1;=0A=
        }=0A=
        if (bp2.x =3D=3D 0 && bp2.y =3D=3D 0) {=0A=
          bp2 =3D p2;=0A=
        }=0A=
        d +=3D 'C' + bp1.x + ',' + bp1.y + ' ' + bp2.x + ',' + bp2.y + ' =
' + p2.x + ',' + p2.y + ' ';=0A=
      }=0A=
=0A=
      return d;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * this generates the SVG path for a linear drawing between datapoints.=0A=
   * @param data=0A=
   * @returns {string}=0A=
   * @private=0A=
   */=0A=
  Line._linear =3D function (data) {=0A=
    // linear=0A=
    var d =3D '';=0A=
    for (var i =3D 0; i < data.length; i++) {=0A=
      if (i =3D=3D 0) {=0A=
        d +=3D data[i].x + ',' + data[i].y;=0A=
      } else {=0A=
        d +=3D ' ' + data[i].x + ',' + data[i].y;=0A=
      }=0A=
    }=0A=
    return d;=0A=
  };=0A=
=0A=
  module.exports =3D Line;=0A=
=0A=
/***/ },=0A=
/* 55 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var DOMutil =3D __webpack_require__(13);=0A=
=0A=
  function Points(groupId, options) {=0A=
    this.groupId =3D groupId;=0A=
    this.options =3D options;=0A=
  }=0A=
=0A=
  Points.prototype.getYRange =3D function (groupData) {=0A=
    var yMin =3D groupData[0].y;=0A=
    var yMax =3D groupData[0].y;=0A=
    for (var j =3D 0; j < groupData.length; j++) {=0A=
      yMin =3D yMin > groupData[j].y ? groupData[j].y : yMin;=0A=
      yMax =3D yMax < groupData[j].y ? groupData[j].y : yMax;=0A=
    }=0A=
    return { min: yMin, max: yMax, yAxisOrientation: =
this.options.yAxisOrientation };=0A=
  };=0A=
=0A=
  Points.prototype.draw =3D function (dataset, group, framework, offset) =
{=0A=
    Points.draw(dataset, group, framework, offset);=0A=
  };=0A=
=0A=
  /**=0A=
   * draw the data points=0A=
   *=0A=
   * @param {Array} dataset=0A=
   * @param {Object} JSONcontainer=0A=
   * @param {Object} svg            | SVG DOM element=0A=
   * @param {GraphGroup} group=0A=
   * @param {Number} [offset]=0A=
   */=0A=
  Points.draw =3D function (dataset, group, framework, offset) {=0A=
    offset =3D offset || 0;=0A=
    var callback =3D getCallback();=0A=
=0A=
    for (var i =3D 0; i < dataset.length; i++) {=0A=
      if (!callback) {=0A=
        // draw the point the simple way.=0A=
        DOMutil.drawPoint(dataset[i].x + offset, dataset[i].y, =
getGroupTemplate(), framework.svgElements, framework.svg, =
dataset[i].label);=0A=
      } else {=0A=
        var callbackResult =3D callback(dataset[i], group, framework); =
// result might be true, false or an object=0A=
        if (callbackResult =3D=3D=3D true || typeof callbackResult =
=3D=3D=3D 'object') {=0A=
          DOMutil.drawPoint(dataset[i].x + offset, dataset[i].y, =
getGroupTemplate(callbackResult), framework.svgElements, framework.svg, =
dataset[i].label);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function getGroupTemplate(callbackResult) {=0A=
      callbackResult =3D typeof callbackResult =3D=3D=3D 'undefined' ? =
{} : callbackResult;=0A=
      return {=0A=
        style: callbackResult.style || group.options.drawPoints.style,=0A=
        size: callbackResult.size || group.options.drawPoints.size,=0A=
        className: callbackResult.className || group.className=0A=
      };=0A=
    }=0A=
=0A=
    function getCallback() {=0A=
      var callback =3D undefined;=0A=
      // check for the graph2d onRender=0A=
      if (framework.options.drawPoints.onRender && typeof =
framework.options.drawPoints.onRender =3D=3D 'function') {=0A=
        callback =3D framework.options.drawPoints.onRender;=0A=
      }=0A=
=0A=
      // override it with the group onRender if defined=0A=
      if (group.group.options && group.group.options.drawPoints && =
group.group.options.drawPoints.onRender && typeof =
group.group.options.drawPoints.onRender =3D=3D 'function') {=0A=
        callback =3D group.group.options.drawPoints.onRender;=0A=
      }=0A=
=0A=
      return callback;=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D Points;=0A=
=0A=
/***/ },=0A=
/* 56 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var DOMutil =3D __webpack_require__(13);=0A=
  var Points =3D __webpack_require__(55);=0A=
=0A=
  function Bargraph(groupId, options) {=0A=
    this.groupId =3D groupId;=0A=
    this.options =3D options;=0A=
  }=0A=
=0A=
  Bargraph.prototype.getYRange =3D function (groupData) {=0A=
    var yMin =3D groupData[0].y;=0A=
    var yMax =3D groupData[0].y;=0A=
    for (var j =3D 0; j < groupData.length; j++) {=0A=
      yMin =3D yMin > groupData[j].y ? groupData[j].y : yMin;=0A=
      yMax =3D yMax < groupData[j].y ? groupData[j].y : yMax;=0A=
    }=0A=
    return { min: yMin, max: yMax, yAxisOrientation: =
this.options.yAxisOrientation };=0A=
  };=0A=
=0A=
  Bargraph.prototype.getData =3D function (groupData) {=0A=
    var combinedData =3D [];=0A=
    for (var j =3D 0; j < groupData.length; j++) {=0A=
      combinedData.push({=0A=
        x: groupData[j].x,=0A=
        y: groupData[j].y,=0A=
        groupId: this.groupId=0A=
      });=0A=
    }=0A=
    return combinedData;=0A=
  };=0A=
=0A=
  /**=0A=
   * draw a bar graph=0A=
   *=0A=
   * @param groupIds=0A=
   * @param processedGroupData=0A=
   */=0A=
  Bargraph.draw =3D function (groupIds, processedGroupData, framework) {=0A=
    var combinedData =3D [];=0A=
    var intersections =3D {};=0A=
    var coreDistance;=0A=
    var key, drawData;=0A=
    var group;=0A=
    var i, j;=0A=
    var barPoints =3D 0;=0A=
=0A=
    // combine all barchart data=0A=
    for (i =3D 0; i < groupIds.length; i++) {=0A=
      group =3D framework.groups[groupIds[i]];=0A=
      if (group.options.style =3D=3D=3D 'bar') {=0A=
        if (group.visible =3D=3D=3D true && =
(framework.options.groups.visibility[groupIds[i]] =3D=3D=3D undefined || =
framework.options.groups.visibility[groupIds[i]] =3D=3D=3D true)) {=0A=
          for (j =3D 0; j < processedGroupData[groupIds[i]].length; j++) =
{=0A=
            combinedData.push({=0A=
              x: processedGroupData[groupIds[i]][j].x,=0A=
              y: processedGroupData[groupIds[i]][j].y,=0A=
              groupId: groupIds[i],=0A=
              label: processedGroupData[groupIds[i]][j].label=0A=
            });=0A=
            barPoints +=3D 1;=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    if (barPoints =3D=3D=3D 0) {=0A=
      return;=0A=
    }=0A=
=0A=
    // sort by time and by group=0A=
    combinedData.sort(function (a, b) {=0A=
      if (a.x =3D=3D=3D b.x) {=0A=
        return a.groupId < b.groupId ? -1 : 1;=0A=
      } else {=0A=
        return a.x - b.x;=0A=
      }=0A=
    });=0A=
=0A=
    // get intersections=0A=
    Bargraph._getDataIntersections(intersections, combinedData);=0A=
=0A=
    // plot barchart=0A=
    for (i =3D 0; i < combinedData.length; i++) {=0A=
      group =3D framework.groups[combinedData[i].groupId];=0A=
      var minWidth =3D 0.1 * group.options.barChart.width;=0A=
=0A=
      key =3D combinedData[i].x;=0A=
      var heightOffset =3D 0;=0A=
      if (intersections[key] =3D=3D=3D undefined) {=0A=
        if (i + 1 < combinedData.length) {=0A=
          coreDistance =3D Math.abs(combinedData[i + 1].x - key);=0A=
        }=0A=
        if (i > 0) {=0A=
          coreDistance =3D Math.min(coreDistance, =
Math.abs(combinedData[i - 1].x - key));=0A=
        }=0A=
        drawData =3D Bargraph._getSafeDrawData(coreDistance, group, =
minWidth);=0A=
      } else {=0A=
        var nextKey =3D i + (intersections[key].amount - =
intersections[key].resolved);=0A=
        var prevKey =3D i - (intersections[key].resolved + 1);=0A=
        if (nextKey < combinedData.length) {=0A=
          coreDistance =3D Math.abs(combinedData[nextKey].x - key);=0A=
        }=0A=
        if (prevKey > 0) {=0A=
          coreDistance =3D Math.min(coreDistance, =
Math.abs(combinedData[prevKey].x - key));=0A=
        }=0A=
        drawData =3D Bargraph._getSafeDrawData(coreDistance, group, =
minWidth);=0A=
        intersections[key].resolved +=3D 1;=0A=
=0A=
        if (group.options.stack =3D=3D=3D true) {=0A=
          if (combinedData[i].y < group.zeroPosition) {=0A=
            heightOffset =3D intersections[key].accumulatedNegative;=0A=
            intersections[key].accumulatedNegative +=3D =
group.zeroPosition - combinedData[i].y;=0A=
          } else {=0A=
            heightOffset =3D intersections[key].accumulatedPositive;=0A=
            intersections[key].accumulatedPositive +=3D =
group.zeroPosition - combinedData[i].y;=0A=
          }=0A=
        } else if (group.options.barChart.sideBySide =3D=3D=3D true) {=0A=
          drawData.width =3D drawData.width / intersections[key].amount;=0A=
          drawData.offset +=3D intersections[key].resolved * =
drawData.width - 0.5 * drawData.width * (intersections[key].amount + 1);=0A=
          if (group.options.barChart.align =3D=3D=3D 'left') {=0A=
            drawData.offset -=3D 0.5 * drawData.width;=0A=
          } else if (group.options.barChart.align =3D=3D=3D 'right') {=0A=
            drawData.offset +=3D 0.5 * drawData.width;=0A=
          }=0A=
        }=0A=
      }=0A=
      DOMutil.drawBar(combinedData[i].x + drawData.offset, =
combinedData[i].y - heightOffset, drawData.width, group.zeroPosition - =
combinedData[i].y, group.className + ' vis-bar', framework.svgElements, =
framework.svg, group.style);=0A=
      // draw points=0A=
      if (group.options.drawPoints.enabled =3D=3D=3D true) {=0A=
        Points.draw([combinedData[i]], group, framework, =
drawData.offset);=0A=
        //DOMutil.drawPoint(combinedData[i].x + drawData.offset, =
combinedData[i].y, group, framework.svgElements, framework.svg);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Fill the intersections object with counters of how many datapoints =
share the same x coordinates=0A=
   * @param intersections=0A=
   * @param combinedData=0A=
   * @private=0A=
   */=0A=
  Bargraph._getDataIntersections =3D function (intersections, =
combinedData) {=0A=
    // get intersections=0A=
    var coreDistance;=0A=
    for (var i =3D 0; i < combinedData.length; i++) {=0A=
      if (i + 1 < combinedData.length) {=0A=
        coreDistance =3D Math.abs(combinedData[i + 1].x - =
combinedData[i].x);=0A=
      }=0A=
      if (i > 0) {=0A=
        coreDistance =3D Math.min(coreDistance, Math.abs(combinedData[i =
- 1].x - combinedData[i].x));=0A=
      }=0A=
      if (coreDistance =3D=3D=3D 0) {=0A=
        if (intersections[combinedData[i].x] =3D=3D=3D undefined) {=0A=
          intersections[combinedData[i].x] =3D { amount: 0, resolved: 0, =
accumulatedPositive: 0, accumulatedNegative: 0 };=0A=
        }=0A=
        intersections[combinedData[i].x].amount +=3D 1;=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Get the width and offset for bargraphs based on the coredistance =
between datapoints=0A=
   *=0A=
   * @param coreDistance=0A=
   * @param group=0A=
   * @param minWidth=0A=
   * @returns {{width: Number, offset: Number}}=0A=
   * @private=0A=
   */=0A=
  Bargraph._getSafeDrawData =3D function (coreDistance, group, minWidth) =
{=0A=
    var width, offset;=0A=
    if (coreDistance < group.options.barChart.width && coreDistance > 0) =
{=0A=
      width =3D coreDistance < minWidth ? minWidth : coreDistance;=0A=
=0A=
      offset =3D 0; // recalculate offset with the new width;=0A=
      if (group.options.barChart.align =3D=3D=3D 'left') {=0A=
        offset -=3D 0.5 * coreDistance;=0A=
      } else if (group.options.barChart.align =3D=3D=3D 'right') {=0A=
        offset +=3D 0.5 * coreDistance;=0A=
      }=0A=
    } else {=0A=
      // default settings=0A=
      width =3D group.options.barChart.width;=0A=
      offset =3D 0;=0A=
      if (group.options.barChart.align =3D=3D=3D 'left') {=0A=
        offset -=3D 0.5 * group.options.barChart.width;=0A=
      } else if (group.options.barChart.align =3D=3D=3D 'right') {=0A=
        offset +=3D 0.5 * group.options.barChart.width;=0A=
      }=0A=
    }=0A=
=0A=
    return { width: width, offset: offset };=0A=
  };=0A=
=0A=
  Bargraph.getStackedYRange =3D function (combinedData, groupRanges, =
groupIds, groupLabel, orientation) {=0A=
    if (combinedData.length > 0) {=0A=
      // sort by time and by group=0A=
      combinedData.sort(function (a, b) {=0A=
        if (a.x =3D=3D=3D b.x) {=0A=
          return a.groupId < b.groupId ? -1 : 1;=0A=
        } else {=0A=
          return a.x - b.x;=0A=
        }=0A=
      });=0A=
      var intersections =3D {};=0A=
=0A=
      Bargraph._getDataIntersections(intersections, combinedData);=0A=
      groupRanges[groupLabel] =3D =
Bargraph._getStackedYRange(intersections, combinedData);=0A=
      groupRanges[groupLabel].yAxisOrientation =3D orientation;=0A=
      groupIds.push(groupLabel);=0A=
    }=0A=
  };=0A=
=0A=
  Bargraph._getStackedYRange =3D function (intersections, combinedData) {=0A=
    var key;=0A=
    var yMin =3D combinedData[0].y;=0A=
    var yMax =3D combinedData[0].y;=0A=
    for (var i =3D 0; i < combinedData.length; i++) {=0A=
      key =3D combinedData[i].x;=0A=
      if (intersections[key] =3D=3D=3D undefined) {=0A=
        yMin =3D yMin > combinedData[i].y ? combinedData[i].y : yMin;=0A=
        yMax =3D yMax < combinedData[i].y ? combinedData[i].y : yMax;=0A=
      } else {=0A=
        if (combinedData[i].y < 0) {=0A=
          intersections[key].accumulatedNegative +=3D combinedData[i].y;=0A=
        } else {=0A=
          intersections[key].accumulatedPositive +=3D combinedData[i].y;=0A=
        }=0A=
      }=0A=
    }=0A=
    for (var xpos in intersections) {=0A=
      if (intersections.hasOwnProperty(xpos)) {=0A=
        yMin =3D yMin > intersections[xpos].accumulatedNegative ? =
intersections[xpos].accumulatedNegative : yMin;=0A=
        yMin =3D yMin > intersections[xpos].accumulatedPositive ? =
intersections[xpos].accumulatedPositive : yMin;=0A=
        yMax =3D yMax < intersections[xpos].accumulatedNegative ? =
intersections[xpos].accumulatedNegative : yMax;=0A=
        yMax =3D yMax < intersections[xpos].accumulatedPositive ? =
intersections[xpos].accumulatedPositive : yMax;=0A=
      }=0A=
    }=0A=
=0A=
    return { min: yMin, max: yMax };=0A=
  };=0A=
=0A=
  module.exports =3D Bargraph;=0A=
=0A=
/***/ },=0A=
/* 57 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var DOMutil =3D __webpack_require__(13);=0A=
  var Component =3D __webpack_require__(28);=0A=
=0A=
  /**=0A=
   * Legend for Graph2d=0A=
   */=0A=
  function Legend(body, options, side, linegraphOptions) {=0A=
    this.body =3D body;=0A=
    this.defaultOptions =3D {=0A=
      enabled: true,=0A=
      icons: true,=0A=
      iconSize: 20,=0A=
      iconSpacing: 6,=0A=
      left: {=0A=
        visible: true,=0A=
        position: 'top-left' // top/bottom - left,center,right=0A=
      },=0A=
      right: {=0A=
        visible: true,=0A=
        position: 'top-left' // top/bottom - left,center,right=0A=
      }=0A=
    };=0A=
    this.side =3D side;=0A=
    this.options =3D util.extend({}, this.defaultOptions);=0A=
    this.linegraphOptions =3D linegraphOptions;=0A=
=0A=
    this.svgElements =3D {};=0A=
    this.dom =3D {};=0A=
    this.groups =3D {};=0A=
    this.amountOfGroups =3D 0;=0A=
    this._create();=0A=
=0A=
    this.setOptions(options);=0A=
  }=0A=
=0A=
  Legend.prototype =3D new Component();=0A=
=0A=
  Legend.prototype.clear =3D function () {=0A=
    this.groups =3D {};=0A=
    this.amountOfGroups =3D 0;=0A=
  };=0A=
=0A=
  Legend.prototype.addGroup =3D function (label, graphOptions) {=0A=
=0A=
    if (!this.groups.hasOwnProperty(label)) {=0A=
      this.groups[label] =3D graphOptions;=0A=
    }=0A=
    this.amountOfGroups +=3D 1;=0A=
  };=0A=
=0A=
  Legend.prototype.updateGroup =3D function (label, graphOptions) {=0A=
    this.groups[label] =3D graphOptions;=0A=
  };=0A=
=0A=
  Legend.prototype.removeGroup =3D function (label) {=0A=
    if (this.groups.hasOwnProperty(label)) {=0A=
      delete this.groups[label];=0A=
      this.amountOfGroups -=3D 1;=0A=
    }=0A=
  };=0A=
=0A=
  Legend.prototype._create =3D function () {=0A=
    this.dom.frame =3D document.createElement('div');=0A=
    this.dom.frame.className =3D 'vis-legend';=0A=
    this.dom.frame.style.position =3D 'absolute';=0A=
    this.dom.frame.style.top =3D '10px';=0A=
    this.dom.frame.style.display =3D 'block';=0A=
=0A=
    this.dom.textArea =3D document.createElement('div');=0A=
    this.dom.textArea.className =3D 'vis-legend-text';=0A=
    this.dom.textArea.style.position =3D 'relative';=0A=
    this.dom.textArea.style.top =3D '0px';=0A=
=0A=
    this.svg =3D document.createElementNS('http://www.w3.org/2000/svg', =
'svg');=0A=
    this.svg.style.position =3D 'absolute';=0A=
    this.svg.style.top =3D 0 + 'px';=0A=
    this.svg.style.width =3D this.options.iconSize + 5 + 'px';=0A=
    this.svg.style.height =3D '100%';=0A=
=0A=
    this.dom.frame.appendChild(this.svg);=0A=
    this.dom.frame.appendChild(this.dom.textArea);=0A=
  };=0A=
=0A=
  /**=0A=
   * Hide the component from the DOM=0A=
   */=0A=
  Legend.prototype.hide =3D function () {=0A=
    // remove the frame containing the items=0A=
    if (this.dom.frame.parentNode) {=0A=
      this.dom.frame.parentNode.removeChild(this.dom.frame);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Show the component in the DOM (when not already visible).=0A=
   * @return {Boolean} changed=0A=
   */=0A=
  Legend.prototype.show =3D function () {=0A=
    // show frame containing the items=0A=
    if (!this.dom.frame.parentNode) {=0A=
      this.body.dom.center.appendChild(this.dom.frame);=0A=
    }=0A=
  };=0A=
=0A=
  Legend.prototype.setOptions =3D function (options) {=0A=
    var fields =3D ['enabled', 'orientation', 'icons', 'left', 'right'];=0A=
    util.selectiveDeepExtend(fields, this.options, options);=0A=
  };=0A=
=0A=
  Legend.prototype.redraw =3D function () {=0A=
    var activeGroups =3D 0;=0A=
    var groupArray =3D Object.keys(this.groups);=0A=
    groupArray.sort(function (a, b) {=0A=
      return a < b ? -1 : 1;=0A=
    });=0A=
=0A=
    for (var i =3D 0; i < groupArray.length; i++) {=0A=
      var groupId =3D groupArray[i];=0A=
      if (this.groups[groupId].visible =3D=3D true && =
(this.linegraphOptions.visibility[groupId] =3D=3D=3D undefined || =
this.linegraphOptions.visibility[groupId] =3D=3D true)) {=0A=
        activeGroups++;=0A=
      }=0A=
    }=0A=
=0A=
    if (this.options[this.side].visible =3D=3D false || =
this.amountOfGroups =3D=3D 0 || this.options.enabled =3D=3D false || =
activeGroups =3D=3D 0) {=0A=
      this.hide();=0A=
    } else {=0A=
      this.show();=0A=
      if (this.options[this.side].position =3D=3D 'top-left' || =
this.options[this.side].position =3D=3D 'bottom-left') {=0A=
        this.dom.frame.style.left =3D '4px';=0A=
        this.dom.frame.style.textAlign =3D 'left';=0A=
        this.dom.textArea.style.textAlign =3D 'left';=0A=
        this.dom.textArea.style.left =3D this.options.iconSize + 15 + =
'px';=0A=
        this.dom.textArea.style.right =3D '';=0A=
        this.svg.style.left =3D 0 + 'px';=0A=
        this.svg.style.right =3D '';=0A=
      } else {=0A=
        this.dom.frame.style.right =3D '4px';=0A=
        this.dom.frame.style.textAlign =3D 'right';=0A=
        this.dom.textArea.style.textAlign =3D 'right';=0A=
        this.dom.textArea.style.right =3D this.options.iconSize + 15 + =
'px';=0A=
        this.dom.textArea.style.left =3D '';=0A=
        this.svg.style.right =3D 0 + 'px';=0A=
        this.svg.style.left =3D '';=0A=
      }=0A=
=0A=
      if (this.options[this.side].position =3D=3D 'top-left' || =
this.options[this.side].position =3D=3D 'top-right') {=0A=
        this.dom.frame.style.top =3D 4 - =
Number(this.body.dom.center.style.top.replace('px', '')) + 'px';=0A=
        this.dom.frame.style.bottom =3D '';=0A=
      } else {=0A=
        var scrollableHeight =3D this.body.domProps.center.height - =
this.body.domProps.centerContainer.height;=0A=
        this.dom.frame.style.bottom =3D 4 + scrollableHeight + =
Number(this.body.dom.center.style.top.replace('px', '')) + 'px';=0A=
        this.dom.frame.style.top =3D '';=0A=
      }=0A=
=0A=
      if (this.options.icons =3D=3D false) {=0A=
        this.dom.frame.style.width =3D this.dom.textArea.offsetWidth + =
10 + 'px';=0A=
        this.dom.textArea.style.right =3D '';=0A=
        this.dom.textArea.style.left =3D '';=0A=
        this.svg.style.width =3D '0px';=0A=
      } else {=0A=
        this.dom.frame.style.width =3D this.options.iconSize + 15 + =
this.dom.textArea.offsetWidth + 10 + 'px';=0A=
        this.drawLegendIcons();=0A=
      }=0A=
=0A=
      var content =3D '';=0A=
      for (var i =3D 0; i < groupArray.length; i++) {=0A=
        var groupId =3D groupArray[i];=0A=
        if (this.groups[groupId].visible =3D=3D true && =
(this.linegraphOptions.visibility[groupId] =3D=3D=3D undefined || =
this.linegraphOptions.visibility[groupId] =3D=3D true)) {=0A=
          content +=3D this.groups[groupId].content + '<br />';=0A=
        }=0A=
      }=0A=
      this.dom.textArea.innerHTML =3D content;=0A=
      this.dom.textArea.style.lineHeight =3D 0.75 * =
this.options.iconSize + this.options.iconSpacing + 'px';=0A=
    }=0A=
  };=0A=
=0A=
  Legend.prototype.drawLegendIcons =3D function () {=0A=
    if (this.dom.frame.parentNode) {=0A=
      var groupArray =3D Object.keys(this.groups);=0A=
      groupArray.sort(function (a, b) {=0A=
        return a < b ? -1 : 1;=0A=
      });=0A=
=0A=
      DOMutil.prepareElements(this.svgElements);=0A=
      var padding =3D window.getComputedStyle(this.dom.frame).paddingTop;=0A=
      var iconOffset =3D Number(padding.replace('px', ''));=0A=
      var x =3D iconOffset;=0A=
      var iconWidth =3D this.options.iconSize;=0A=
      var iconHeight =3D 0.75 * this.options.iconSize;=0A=
      var y =3D iconOffset + 0.5 * iconHeight + 3;=0A=
=0A=
      this.svg.style.width =3D iconWidth + 5 + iconOffset + 'px';=0A=
=0A=
      for (var i =3D 0; i < groupArray.length; i++) {=0A=
        var groupId =3D groupArray[i];=0A=
        if (this.groups[groupId].visible =3D=3D true && =
(this.linegraphOptions.visibility[groupId] =3D=3D=3D undefined || =
this.linegraphOptions.visibility[groupId] =3D=3D true)) {=0A=
          this.groups[groupId].drawIcon(x, y, this.svgElements, =
this.svg, iconWidth, iconHeight);=0A=
          y +=3D iconHeight + this.options.iconSpacing;=0A=
        }=0A=
      }=0A=
=0A=
      DOMutil.cleanupElements(this.svgElements);=0A=
    }=0A=
  };=0A=
=0A=
  module.exports =3D Legend;=0A=
=0A=
/***/ },=0A=
/* 58 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * This object contains all possible options. It will check if the =
types are correct, if required if the option is one=0A=
   * of the allowed values.=0A=
   *=0A=
   * __any__ means that the name of the property does not matter.=0A=
   * __type__ is a required field for all objects and contains the =
allowed types of all objects=0A=
   */=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
  var string =3D 'string';=0A=
  var boolean =3D 'boolean';=0A=
  var number =3D 'number';=0A=
  var array =3D 'array';=0A=
  var date =3D 'date';=0A=
  var object =3D 'object'; // should only be in a __type__ property=0A=
  var dom =3D 'dom';=0A=
  var moment =3D 'moment';=0A=
  var any =3D 'any';=0A=
=0A=
  var allOptions =3D {=0A=
    configure: {=0A=
      enabled: { boolean: boolean },=0A=
      filter: { boolean: boolean, 'function': 'function' },=0A=
      container: { dom: dom },=0A=
      __type__: { object: object, boolean: boolean, 'function': =
'function' }=0A=
    },=0A=
=0A=
    //globals :=0A=
    yAxisOrientation: { string: ['left', 'right'] },=0A=
    defaultGroup: { string: string },=0A=
    sort: { boolean: boolean },=0A=
    sampling: { boolean: boolean },=0A=
    stack: { boolean: boolean },=0A=
    graphHeight: { string: string, number: number },=0A=
    shaded: {=0A=
      enabled: { boolean: boolean },=0A=
      orientation: { string: ['bottom', 'top'] }, // top, bottom=0A=
      __type__: { boolean: boolean, object: object }=0A=
    },=0A=
    style: { string: ['line', 'bar', 'points'] }, // line, bar=0A=
    barChart: {=0A=
      width: { number: number },=0A=
      sideBySide: { boolean: boolean },=0A=
      align: { string: ['left', 'center', 'right'] },=0A=
      __type__: { object: object }=0A=
    },=0A=
    interpolation: {=0A=
      enabled: { boolean: boolean },=0A=
      parametrization: { string: ['centripetal', 'chordal', 'uniform'] =
}, // uniform (alpha =3D 0.0), chordal (alpha =3D 1.0), centripetal =
(alpha =3D 0.5)=0A=
      alpha: { number: number },=0A=
      __type__: { object: object, boolean: boolean }=0A=
    },=0A=
    drawPoints: {=0A=
      enabled: { boolean: boolean },=0A=
      onRender: { 'function': 'function' },=0A=
      size: { number: number },=0A=
      style: { string: ['square', 'circle'] }, // square, circle=0A=
      __type__: { object: object, boolean: boolean, 'function': =
'function' }=0A=
    },=0A=
    dataAxis: {=0A=
      showMinorLabels: { boolean: boolean },=0A=
      showMajorLabels: { boolean: boolean },=0A=
      icons: { boolean: boolean },=0A=
      width: { string: string, number: number },=0A=
      visible: { boolean: boolean },=0A=
      alignZeros: { boolean: boolean },=0A=
      left: {=0A=
        range: { min: { number: number }, max: { number: number }, =
__type__: { object: object } },=0A=
        format: { 'function': 'function' },=0A=
        title: { text: { string: string, number: number }, style: { =
string: string }, __type__: { object: object } },=0A=
        __type__: { object: object }=0A=
      },=0A=
      right: {=0A=
        range: { min: { number: number }, max: { number: number }, =
__type__: { object: object } },=0A=
        format: { 'function': 'function' },=0A=
        title: { text: { string: string, number: number }, style: { =
string: string }, __type__: { object: object } },=0A=
        __type__: { object: object }=0A=
      },=0A=
      __type__: { object: object }=0A=
    },=0A=
    legend: {=0A=
      enabled: { boolean: boolean },=0A=
      icons: { boolean: boolean },=0A=
      left: {=0A=
        visible: { boolean: boolean },=0A=
        position: { string: ['top-right', 'bottom-right', 'top-left', =
'bottom-left'] },=0A=
        __type__: { object: object }=0A=
      },=0A=
      right: {=0A=
        visible: { boolean: boolean },=0A=
        position: { string: ['top-right', 'bottom-right', 'top-left', =
'bottom-left'] },=0A=
        __type__: { object: object }=0A=
      },=0A=
      __type__: { object: object, boolean: boolean }=0A=
    },=0A=
    groups: {=0A=
      visibility: { any: any },=0A=
      __type__: { object: object }=0A=
    },=0A=
=0A=
    autoResize: { boolean: boolean },=0A=
    clickToUse: { boolean: boolean },=0A=
    end: { number: number, date: date, string: string, moment: moment },=0A=
    format: {=0A=
      minorLabels: {=0A=
        millisecond: { string: string, 'undefined': 'undefined' },=0A=
        second: { string: string, 'undefined': 'undefined' },=0A=
        minute: { string: string, 'undefined': 'undefined' },=0A=
        hour: { string: string, 'undefined': 'undefined' },=0A=
        weekday: { string: string, 'undefined': 'undefined' },=0A=
        day: { string: string, 'undefined': 'undefined' },=0A=
        month: { string: string, 'undefined': 'undefined' },=0A=
        year: { string: string, 'undefined': 'undefined' },=0A=
        __type__: { object: object }=0A=
      },=0A=
      majorLabels: {=0A=
        millisecond: { string: string, 'undefined': 'undefined' },=0A=
        second: { string: string, 'undefined': 'undefined' },=0A=
        minute: { string: string, 'undefined': 'undefined' },=0A=
        hour: { string: string, 'undefined': 'undefined' },=0A=
        weekday: { string: string, 'undefined': 'undefined' },=0A=
        day: { string: string, 'undefined': 'undefined' },=0A=
        month: { string: string, 'undefined': 'undefined' },=0A=
        year: { string: string, 'undefined': 'undefined' },=0A=
        __type__: { object: object }=0A=
      },=0A=
      __type__: { object: object }=0A=
    },=0A=
    moment: { 'function': 'function' },=0A=
    height: { string: string, number: number },=0A=
    hiddenDates: { object: object, array: array },=0A=
    locale: { string: string },=0A=
    locales: {=0A=
      __any__: { any: any },=0A=
      __type__: { object: object }=0A=
    },=0A=
    max: { date: date, number: number, string: string, moment: moment },=0A=
    maxHeight: { number: number, string: string },=0A=
    min: { date: date, number: number, string: string, moment: moment },=0A=
    minHeight: { number: number, string: string },=0A=
    moveable: { boolean: boolean },=0A=
    multiselect: { boolean: boolean },=0A=
    orientation: { string: string },=0A=
    showCurrentTime: { boolean: boolean },=0A=
    showMajorLabels: { boolean: boolean },=0A=
    showMinorLabels: { boolean: boolean },=0A=
    start: { date: date, number: number, string: string, moment: moment =
},=0A=
    timeAxis: {=0A=
      scale: { string: string, 'undefined': 'undefined' },=0A=
      step: { number: number, 'undefined': 'undefined' },=0A=
      __type__: { object: object }=0A=
    },=0A=
    width: { string: string, number: number },=0A=
    zoomable: { boolean: boolean },=0A=
    zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },=0A=
    zoomMax: { number: number },=0A=
    zoomMin: { number: number },=0A=
    __type__: { object: object }=0A=
  };=0A=
=0A=
  var configureOptions =3D {=0A=
    global: {=0A=
      //yAxisOrientation: ['left','right'], // TDOO: enable as soon as =
Grahp2d doesn't crash when changing this on the fly=0A=
      sort: true,=0A=
      sampling: true,=0A=
      stack: false,=0A=
      shaded: {=0A=
        enabled: false,=0A=
        orientation: ['top', 'bottom'] // top, bottom=0A=
      },=0A=
      style: ['line', 'bar', 'points'], // line, bar=0A=
      barChart: {=0A=
        width: [50, 5, 100, 5],=0A=
        sideBySide: false,=0A=
        align: ['left', 'center', 'right'] // left, center, right=0A=
      },=0A=
      interpolation: {=0A=
        enabled: true,=0A=
        parametrization: ['centripetal', 'chordal', 'uniform'] // =
uniform (alpha =3D 0.0), chordal (alpha =3D 1.0), centripetal (alpha =3D =
0.5)=0A=
      },=0A=
      drawPoints: {=0A=
        enabled: true,=0A=
        size: [6, 2, 30, 1],=0A=
        style: ['square', 'circle'] // square, circle=0A=
      },=0A=
      dataAxis: {=0A=
        showMinorLabels: true,=0A=
        showMajorLabels: true,=0A=
        icons: false,=0A=
        width: [40, 0, 200, 1],=0A=
        visible: true,=0A=
        alignZeros: true,=0A=
        left: {=0A=
          //range: {min:'undefined': 'undefined'ined,max:'undefined': =
'undefined'ined},=0A=
          //format: function (value) {return value;},=0A=
          title: { text: '', style: '' }=0A=
        },=0A=
        right: {=0A=
          //range: {min:'undefined': 'undefined'ined,max:'undefined': =
'undefined'ined},=0A=
          //format: function (value) {return value;},=0A=
          title: { text: '', style: '' }=0A=
        }=0A=
      },=0A=
      legend: {=0A=
        enabled: false,=0A=
        icons: true,=0A=
        left: {=0A=
          visible: true,=0A=
          position: ['top-right', 'bottom-right', 'top-left', =
'bottom-left'] // top/bottom - left,right=0A=
        },=0A=
        right: {=0A=
          visible: true,=0A=
          position: ['top-right', 'bottom-right', 'top-left', =
'bottom-left'] // top/bottom - left,right=0A=
        }=0A=
      },=0A=
=0A=
      autoResize: true,=0A=
      clickToUse: false,=0A=
      end: '',=0A=
      format: {=0A=
        minorLabels: {=0A=
          millisecond: 'SSS',=0A=
          second: 's',=0A=
          minute: 'HH:mm',=0A=
          hour: 'HH:mm',=0A=
          weekday: 'ddd D',=0A=
          day: 'D',=0A=
          month: 'MMM',=0A=
          year: 'YYYY'=0A=
        },=0A=
        majorLabels: {=0A=
          millisecond: 'HH:mm:ss',=0A=
          second: 'D MMMM HH:mm',=0A=
          minute: 'ddd D MMMM',=0A=
          hour: 'ddd D MMMM',=0A=
          weekday: 'MMMM YYYY',=0A=
          day: 'MMMM YYYY',=0A=
          month: 'YYYY',=0A=
          year: ''=0A=
        }=0A=
      },=0A=
=0A=
      height: '',=0A=
      locale: '',=0A=
      max: '',=0A=
      maxHeight: '',=0A=
      min: '',=0A=
      minHeight: '',=0A=
      moveable: true,=0A=
      orientation: ['both', 'bottom', 'top'],=0A=
      showCurrentTime: false,=0A=
      showMajorLabels: true,=0A=
      showMinorLabels: true,=0A=
      start: '',=0A=
      width: '100%',=0A=
      zoomable: true,=0A=
      zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],=0A=
      zoomMax: [315360000000000, 10, 315360000000000, 1],=0A=
      zoomMin: [10, 10, 315360000000000, 1]=0A=
    }=0A=
  };=0A=
=0A=
  exports.allOptions =3D allOptions;=0A=
  exports.configureOptions =3D configureOptions;=0A=
=0A=
/***/ },=0A=
/* 59 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  // Load custom shapes into CanvasRenderingContext2D=0A=
  'use strict';=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  var _modulesGroups =3D __webpack_require__(60);=0A=
=0A=
  var _modulesGroups2 =3D _interopRequireDefault(_modulesGroups);=0A=
=0A=
  var _modulesNodesHandler =3D __webpack_require__(61);=0A=
=0A=
  var _modulesNodesHandler2 =3D =
_interopRequireDefault(_modulesNodesHandler);=0A=
=0A=
  var _modulesEdgesHandler =3D __webpack_require__(81);=0A=
=0A=
  var _modulesEdgesHandler2 =3D =
_interopRequireDefault(_modulesEdgesHandler);=0A=
=0A=
  var _modulesPhysicsEngine =3D __webpack_require__(90);=0A=
=0A=
  var _modulesPhysicsEngine2 =3D =
_interopRequireDefault(_modulesPhysicsEngine);=0A=
=0A=
  var _modulesClustering =3D __webpack_require__(99);=0A=
=0A=
  var _modulesClustering2 =3D _interopRequireDefault(_modulesClustering);=0A=
=0A=
  var _modulesCanvasRenderer =3D __webpack_require__(101);=0A=
=0A=
  var _modulesCanvasRenderer2 =3D =
_interopRequireDefault(_modulesCanvasRenderer);=0A=
=0A=
  var _modulesCanvas =3D __webpack_require__(102);=0A=
=0A=
  var _modulesCanvas2 =3D _interopRequireDefault(_modulesCanvas);=0A=
=0A=
  var _modulesView =3D __webpack_require__(103);=0A=
=0A=
  var _modulesView2 =3D _interopRequireDefault(_modulesView);=0A=
=0A=
  var _modulesInteractionHandler =3D __webpack_require__(104);=0A=
=0A=
  var _modulesInteractionHandler2 =3D =
_interopRequireDefault(_modulesInteractionHandler);=0A=
=0A=
  var _modulesSelectionHandler =3D __webpack_require__(107);=0A=
=0A=
  var _modulesSelectionHandler2 =3D =
_interopRequireDefault(_modulesSelectionHandler);=0A=
=0A=
  var _modulesLayoutEngine =3D __webpack_require__(108);=0A=
=0A=
  var _modulesLayoutEngine2 =3D =
_interopRequireDefault(_modulesLayoutEngine);=0A=
=0A=
  var _modulesManipulationSystem =3D __webpack_require__(109);=0A=
=0A=
  var _modulesManipulationSystem2 =3D =
_interopRequireDefault(_modulesManipulationSystem);=0A=
=0A=
  var _sharedConfigurator =3D __webpack_require__(45);=0A=
=0A=
  var _sharedConfigurator2 =3D =
_interopRequireDefault(_sharedConfigurator);=0A=
=0A=
  var _sharedValidator =3D __webpack_require__(47);=0A=
=0A=
  var _sharedValidator2 =3D _interopRequireDefault(_sharedValidator);=0A=
=0A=
  var _optionsJs =3D __webpack_require__(110);=0A=
=0A=
  __webpack_require__(111);=0A=
=0A=
  var Emitter =3D __webpack_require__(19);=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
  var dotparser =3D __webpack_require__(112);=0A=
  var gephiParser =3D __webpack_require__(113);=0A=
  var Images =3D __webpack_require__(114);=0A=
  var Activator =3D __webpack_require__(40);=0A=
  var locales =3D __webpack_require__(115);=0A=
=0A=
  /**=0A=
   * @constructor Network=0A=
   * Create a network visualization, displaying nodes and edges.=0A=
   *=0A=
   * @param {Element} container   The DOM element in which the Network =
will=0A=
   *                                  be created. Normally a div element.=0A=
   * @param {Object} data         An object containing parameters=0A=
   *                              {Array} nodes=0A=
   *                              {Array} edges=0A=
   * @param {Object} options      Options=0A=
   */=0A=
  function Network(container, data, options) {=0A=
    var _this =3D this;=0A=
=0A=
    if (!(this instanceof Network)) {=0A=
      throw new SyntaxError('Constructor must be called with the new =
operator');=0A=
    }=0A=
=0A=
    // set constant values=0A=
    this.options =3D {};=0A=
    this.defaultOptions =3D {=0A=
      locale: 'en',=0A=
      locales: locales,=0A=
      clickToUse: false=0A=
    };=0A=
    util.extend(this.options, this.defaultOptions);=0A=
=0A=
    // containers for nodes and edges=0A=
    this.body =3D {=0A=
      container: container,=0A=
      nodes: {},=0A=
      nodeIndices: [],=0A=
      edges: {},=0A=
      edgeIndices: [],=0A=
      emitter: {=0A=
        on: this.on.bind(this),=0A=
        off: this.off.bind(this),=0A=
        emit: this.emit.bind(this),=0A=
        once: this.once.bind(this)=0A=
      },=0A=
      eventListeners: {=0A=
        onTap: function onTap() {},=0A=
        onTouch: function onTouch() {},=0A=
        onDoubleTap: function onDoubleTap() {},=0A=
        onHold: function onHold() {},=0A=
        onDragStart: function onDragStart() {},=0A=
        onDrag: function onDrag() {},=0A=
        onDragEnd: function onDragEnd() {},=0A=
        onMouseWheel: function onMouseWheel() {},=0A=
        onPinch: function onPinch() {},=0A=
        onMouseMove: function onMouseMove() {},=0A=
        onRelease: function onRelease() {},=0A=
        onContext: function onContext() {}=0A=
      },=0A=
      data: {=0A=
        nodes: null, // A DataSet or DataView=0A=
        edges: null // A DataSet or DataView=0A=
      },=0A=
      functions: {=0A=
        createNode: function createNode() {},=0A=
        createEdge: function createEdge() {},=0A=
        getPointer: function getPointer() {}=0A=
      },=0A=
      view: {=0A=
        scale: 1,=0A=
        translation: { x: 0, y: 0 }=0A=
      }=0A=
    };=0A=
=0A=
    // bind the event listeners=0A=
    this.bindEventListeners();=0A=
=0A=
    // setting up all modules=0A=
    this.images =3D new Images(function () {=0A=
      return _this.body.emitter.emit('_requestRedraw');=0A=
    }); // object with images=0A=
    this.groups =3D new _modulesGroups2['default'](); // object with =
groups=0A=
    this.canvas =3D new _modulesCanvas2['default'](this.body); // DOM =
handler=0A=
    this.selectionHandler =3D new =
_modulesSelectionHandler2['default'](this.body, this.canvas); // =
Selection handler=0A=
    this.interactionHandler =3D new =
_modulesInteractionHandler2['default'](this.body, this.canvas, =
this.selectionHandler); // Interaction handler handles all the hammer =
bindings (that are bound by canvas), key=0A=
    this.view =3D new _modulesView2['default'](this.body, this.canvas); =
// camera handler, does animations and zooms=0A=
    this.renderer =3D new _modulesCanvasRenderer2['default'](this.body, =
this.canvas); // renderer, starts renderloop, has events that modules =
can hook into=0A=
    this.physics =3D new _modulesPhysicsEngine2['default'](this.body); =
// physics engine, does all the simulations=0A=
    this.layoutEngine =3D new =
_modulesLayoutEngine2['default'](this.body); // layout engine for inital =
layout and hierarchical layout=0A=
    this.clustering =3D new _modulesClustering2['default'](this.body); =
// clustering api=0A=
    this.manipulation =3D new =
_modulesManipulationSystem2['default'](this.body, this.canvas, =
this.selectionHandler); // data manipulation system=0A=
=0A=
    this.nodesHandler =3D new =
_modulesNodesHandler2['default'](this.body, this.images, this.groups, =
this.layoutEngine); // Handle adding, deleting and updating of nodes as =
well as global options=0A=
    this.edgesHandler =3D new =
_modulesEdgesHandler2['default'](this.body, this.images, this.groups); =
// Handle adding, deleting and updating of edges as well as global =
options=0A=
=0A=
    // create the DOM elements=0A=
    this.canvas._create();=0A=
=0A=
    // apply options=0A=
    this.setOptions(options);=0A=
=0A=
    // load data (the disable start variable will be the same as the =
enabled clustering)=0A=
    this.setData(data);=0A=
  }=0A=
=0A=
  // Extend Network with an Emitter mixin=0A=
  Emitter(Network.prototype);=0A=
=0A=
  /**=0A=
   * Set options=0A=
   * @param {Object} options=0A=
   */=0A=
  Network.prototype.setOptions =3D function (options) {=0A=
    var _this2 =3D this;=0A=
=0A=
    if (options !=3D=3D undefined) {=0A=
=0A=
      var errorFound =3D _sharedValidator2['default'].validate(options, =
_optionsJs.allOptions);=0A=
      if (errorFound =3D=3D=3D true) {=0A=
        console.log('%cErrors have been found in the supplied options =
object.', _sharedValidator.printStyle);=0A=
      }=0A=
=0A=
      // copy the global fields over=0A=
      var fields =3D ['locale', 'locales', 'clickToUse'];=0A=
      util.selectiveDeepExtend(fields, this.options, options);=0A=
=0A=
      // the hierarchical system can adapt the edges and the physics to =
it's own options because not all combinations work with the =
hierarichical system.=0A=
      options =3D this.layoutEngine.setOptions(options.layout, options);=0A=
=0A=
      this.canvas.setOptions(options); // options for canvas are in =
globals=0A=
=0A=
      // pass the options to the modules=0A=
      this.groups.setOptions(options.groups);=0A=
      this.nodesHandler.setOptions(options.nodes);=0A=
      this.edgesHandler.setOptions(options.edges);=0A=
      this.physics.setOptions(options.physics);=0A=
      this.manipulation.setOptions(options.manipulation, options, =
this.options); // manipulation uses the locales in the globals=0A=
=0A=
      this.interactionHandler.setOptions(options.interaction);=0A=
      this.renderer.setOptions(options.interaction); // options for =
rendering are in interaction=0A=
      this.selectionHandler.setOptions(options.interaction); // options =
for selection are in interaction=0A=
=0A=
      // reload the settings of the nodes to apply changes in groups =
that are not referenced by pointer.=0A=
      if (options.groups !=3D=3D undefined) {=0A=
        this.body.emitter.emit('refreshNodes');=0A=
      }=0A=
      // these two do not have options at the moment, here for =
completeness=0A=
      //this.view.setOptions(options.view);=0A=
      //this.clustering.setOptions(options.clustering);=0A=
=0A=
      if ('configure' in options) {=0A=
        if (!this.configurator) {=0A=
          this.configurator =3D new =
_sharedConfigurator2['default'](this, this.body.container, =
_optionsJs.configureOptions, this.canvas.pixelRatio);=0A=
        }=0A=
=0A=
        this.configurator.setOptions(options.configure);=0A=
      }=0A=
=0A=
      // if the configuration system is enabled, copy all options and =
put them into the config system=0A=
      if (this.configurator && this.configurator.options.enabled =
=3D=3D=3D true) {=0A=
        var networkOptions =3D { nodes: {}, edges: {}, layout: {}, =
interaction: {}, manipulation: {}, physics: {}, global: {} };=0A=
        util.deepExtend(networkOptions.nodes, this.nodesHandler.options);=0A=
        util.deepExtend(networkOptions.edges, this.edgesHandler.options);=0A=
        util.deepExtend(networkOptions.layout, =
this.layoutEngine.options);=0A=
        // load the selectionHandler and render default options in to =
the interaction group=0A=
        util.deepExtend(networkOptions.interaction, =
this.selectionHandler.options);=0A=
        util.deepExtend(networkOptions.interaction, =
this.renderer.options);=0A=
=0A=
        util.deepExtend(networkOptions.interaction, =
this.interactionHandler.options);=0A=
        util.deepExtend(networkOptions.manipulation, =
this.manipulation.options);=0A=
        util.deepExtend(networkOptions.physics, this.physics.options);=0A=
=0A=
        // load globals into the global object=0A=
        util.deepExtend(networkOptions.global, this.canvas.options);=0A=
        util.deepExtend(networkOptions.global, this.options);=0A=
=0A=
        this.configurator.setModuleOptions(networkOptions);=0A=
      }=0A=
=0A=
      // handle network global options=0A=
      if (options.clickToUse !=3D=3D undefined) {=0A=
        if (options.clickToUse =3D=3D=3D true) {=0A=
          if (this.activator =3D=3D=3D undefined) {=0A=
            this.activator =3D new Activator(this.canvas.frame);=0A=
            this.activator.on('change', function () {=0A=
              _this2.body.emitter.emit('activate');=0A=
            });=0A=
          }=0A=
        } else {=0A=
          if (this.activator !=3D=3D undefined) {=0A=
            this.activator.destroy();=0A=
            delete this.activator;=0A=
          }=0A=
          this.body.emitter.emit('activate');=0A=
        }=0A=
      } else {=0A=
        this.body.emitter.emit('activate');=0A=
      }=0A=
=0A=
      this.canvas.setSize();=0A=
      // start the physics simulation. Can be safely called multiple =
times.=0A=
      this.body.emitter.emit('startSimulation');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Update the this.body.nodeIndices with the most recent node index =
list=0A=
   * @private=0A=
   */=0A=
  Network.prototype._updateVisibleIndices =3D function () {=0A=
    var nodes =3D this.body.nodes;=0A=
    var edges =3D this.body.edges;=0A=
    this.body.nodeIndices =3D [];=0A=
    this.body.edgeIndices =3D [];=0A=
=0A=
    for (var nodeId in nodes) {=0A=
      if (nodes.hasOwnProperty(nodeId)) {=0A=
        if (nodes[nodeId].options.hidden =3D=3D=3D false) {=0A=
          this.body.nodeIndices.push(nodeId);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    for (var edgeId in edges) {=0A=
      if (edges.hasOwnProperty(edgeId)) {=0A=
        if (edges[edgeId].options.hidden =3D=3D=3D false) {=0A=
          this.body.edgeIndices.push(edgeId);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Bind all events=0A=
   */=0A=
  Network.prototype.bindEventListeners =3D function () {=0A=
    var _this3 =3D this;=0A=
=0A=
    // this event will trigger a rebuilding of the cache everything. =
Used when nodes or edges have been added or removed.=0A=
    this.body.emitter.on('_dataChanged', function () {=0A=
      // update shortcut lists=0A=
      _this3._updateVisibleIndices();=0A=
      _this3.physics.updatePhysicsData();=0A=
      _this3.body.emitter.emit('_requestRedraw');=0A=
      // call the dataUpdated event because the only difference between =
the two is the updating of the indices=0A=
      _this3.body.emitter.emit('_dataUpdated');=0A=
    });=0A=
=0A=
    // this is called when options of EXISTING nodes or edges have =
changed.=0A=
    this.body.emitter.on('_dataUpdated', function () {=0A=
      // update values=0A=
      _this3._updateValueRange(_this3.body.nodes);=0A=
      _this3._updateValueRange(_this3.body.edges);=0A=
      // start simulation (can be called safely, even if already running)=0A=
      _this3.body.emitter.emit('startSimulation');=0A=
      _this3.body.emitter.emit('_requestRedraw');=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * Set nodes and edges, and optionally options as well.=0A=
   *=0A=
   * @param {Object} data              Object containing parameters:=0A=
   *                                   {Array | DataSet | DataView} =
[nodes] Array with nodes=0A=
   *                                   {Array | DataSet | DataView} =
[edges] Array with edges=0A=
   *                                   {String} [dot] String containing =
data in DOT format=0A=
   *                                   {String} [gephi] String =
containing data in gephi JSON format=0A=
   *                                   {Options} [options] Object with =
options=0A=
   */=0A=
  Network.prototype.setData =3D function (data) {=0A=
    // reset the physics engine.=0A=
    this.body.emitter.emit('resetPhysics');=0A=
    this.body.emitter.emit('_resetData');=0A=
=0A=
    // unselect all to ensure no selections from old data are carried =
over.=0A=
    this.selectionHandler.unselectAll();=0A=
=0A=
    if (data && data.dot && (data.nodes || data.edges)) {=0A=
      throw new SyntaxError('Data must contain either parameter "dot" or =
' + ' parameter pair "nodes" and "edges", but not both.');=0A=
    }=0A=
=0A=
    // set options=0A=
    this.setOptions(data && data.options);=0A=
    // set all data=0A=
    if (data && data.dot) {=0A=
      console.log('The dot property has been depricated. Please use the =
static convertDot method to convert DOT into vis.network format and use =
the normal data format with nodes and edges. This converter is used like =
this: var data =3D vis.network.convertDot(dotString);');=0A=
      // parse DOT file=0A=
      var dotData =3D dotparser.DOTToGraph(data.dot);=0A=
      this.setData(dotData);=0A=
      return;=0A=
    } else if (data && data.gephi) {=0A=
      // parse DOT file=0A=
      console.log('The gephi property has been depricated. Please use =
the static convertGephi method to convert gephi into vis.network format =
and use the normal data format with nodes and edges. This converter is =
used like this: var data =3D vis.network.convertGephi(gephiJson);');=0A=
      var gephiData =3D gephiParser.parseGephi(data.gephi);=0A=
      this.setData(gephiData);=0A=
      return;=0A=
    } else {=0A=
      this.nodesHandler.setData(data && data.nodes, true);=0A=
      this.edgesHandler.setData(data && data.edges, true);=0A=
    }=0A=
=0A=
    // emit change in data=0A=
    this.body.emitter.emit('_dataChanged');=0A=
=0A=
    // find a stable position or start animating to a stable position=0A=
    this.body.emitter.emit('initPhysics');=0A=
  };=0A=
=0A=
  /**=0A=
   * Cleans up all bindings of the network, removing it fully from the =
memory IF the variable is set to null after calling this function.=0A=
   * var network =3D new vis.Network(..);=0A=
   * network.destroy();=0A=
   * network =3D null;=0A=
   */=0A=
  Network.prototype.destroy =3D function () {=0A=
    this.body.emitter.emit('destroy');=0A=
    // clear events=0A=
    this.body.emitter.off();=0A=
    this.off();=0A=
=0A=
    // delete modules=0A=
    delete this.groups;=0A=
    delete this.canvas;=0A=
    delete this.selectionHandler;=0A=
    delete this.interactionHandler;=0A=
    delete this.view;=0A=
    delete this.renderer;=0A=
    delete this.physics;=0A=
    delete this.layoutEngine;=0A=
    delete this.clustering;=0A=
    delete this.manipulation;=0A=
    delete this.nodesHandler;=0A=
    delete this.edgesHandler;=0A=
    delete this.configurator;=0A=
    delete this.images;=0A=
=0A=
    for (var nodeId in this.body.nodes) {=0A=
      delete this.body.nodes[nodeId];=0A=
    }=0A=
    for (var edgeId in this.body.edges) {=0A=
      delete this.body.edges[edgeId];=0A=
    }=0A=
=0A=
    // remove the container and everything inside it recursively=0A=
    util.recursiveDOMDelete(this.body.container);=0A=
  };=0A=
=0A=
  /**=0A=
   * Update the values of all object in the given array according to the =
current=0A=
   * value range of the objects in the array.=0A=
   * @param {Object} obj    An object containing a set of Edges or Nodes=0A=
   *                        The objects must have a method getValue() and=0A=
   *                        setValueRange(min, max).=0A=
   * @private=0A=
   */=0A=
  Network.prototype._updateValueRange =3D function (obj) {=0A=
    var id;=0A=
=0A=
    // determine the range of the objects=0A=
    var valueMin =3D undefined;=0A=
    var valueMax =3D undefined;=0A=
    var valueTotal =3D 0;=0A=
    for (id in obj) {=0A=
      if (obj.hasOwnProperty(id)) {=0A=
        var value =3D obj[id].getValue();=0A=
        if (value !=3D=3D undefined) {=0A=
          valueMin =3D valueMin =3D=3D=3D undefined ? value : =
Math.min(value, valueMin);=0A=
          valueMax =3D valueMax =3D=3D=3D undefined ? value : =
Math.max(value, valueMax);=0A=
          valueTotal +=3D value;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    // adjust the range of all objects=0A=
    if (valueMin !=3D=3D undefined && valueMax !=3D=3D undefined) {=0A=
      for (id in obj) {=0A=
        if (obj.hasOwnProperty(id)) {=0A=
          obj[id].setValueRange(valueMin, valueMax, valueTotal);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Returns true when the Network is active.=0A=
   * @returns {boolean}=0A=
   */=0A=
  Network.prototype.isActive =3D function () {=0A=
    return !this.activator || this.activator.active;=0A=
  };=0A=
=0A=
  Network.prototype.setSize =3D function () {=0A=
    return this.canvas.setSize.apply(this.canvas, arguments);=0A=
  };=0A=
  Network.prototype.canvasToDOM =3D function () {=0A=
    return this.canvas.canvasToDOM.apply(this.canvas, arguments);=0A=
  };=0A=
  Network.prototype.DOMtoCanvas =3D function () {=0A=
    return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);=0A=
  };=0A=
  Network.prototype.findNode =3D function () {=0A=
    return this.clustering.findNode.apply(this.clustering, arguments);=0A=
  };=0A=
  Network.prototype.isCluster =3D function () {=0A=
    return this.clustering.isCluster.apply(this.clustering, arguments);=0A=
  };=0A=
  Network.prototype.openCluster =3D function () {=0A=
    return this.clustering.openCluster.apply(this.clustering, arguments);=0A=
  };=0A=
  Network.prototype.cluster =3D function () {=0A=
    return this.clustering.cluster.apply(this.clustering, arguments);=0A=
  };=0A=
  Network.prototype.getNodesInCluster =3D function () {=0A=
    return this.clustering.getNodesInCluster.apply(this.clustering, =
arguments);=0A=
  };=0A=
  Network.prototype.clusterByConnection =3D function () {=0A=
    return this.clustering.clusterByConnection.apply(this.clustering, =
arguments);=0A=
  };=0A=
  Network.prototype.clusterByHubsize =3D function () {=0A=
    return this.clustering.clusterByHubsize.apply(this.clustering, =
arguments);=0A=
  };=0A=
  Network.prototype.clusterOutliers =3D function () {=0A=
    return this.clustering.clusterOutliers.apply(this.clustering, =
arguments);=0A=
  };=0A=
  Network.prototype.getSeed =3D function () {=0A=
    return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);=0A=
  };=0A=
  Network.prototype.enableEditMode =3D function () {=0A=
    return this.manipulation.enableEditMode.apply(this.manipulation, =
arguments);=0A=
  };=0A=
  Network.prototype.disableEditMode =3D function () {=0A=
    return this.manipulation.disableEditMode.apply(this.manipulation, =
arguments);=0A=
  };=0A=
  Network.prototype.addNodeMode =3D function () {=0A=
    return this.manipulation.addNodeMode.apply(this.manipulation, =
arguments);=0A=
  };=0A=
  Network.prototype.editNode =3D function () {=0A=
    return this.manipulation.editNode.apply(this.manipulation, =
arguments);=0A=
  };=0A=
  Network.prototype.editNodeMode =3D function () {=0A=
    console.log('Depricated: Please use editNode instead of =
editNodeMode.');return =
this.manipulation.editNode.apply(this.manipulation, arguments);=0A=
  };=0A=
  Network.prototype.addEdgeMode =3D function () {=0A=
    return this.manipulation.addEdgeMode.apply(this.manipulation, =
arguments);=0A=
  };=0A=
  Network.prototype.editEdgeMode =3D function () {=0A=
    return this.manipulation.editEdgeMode.apply(this.manipulation, =
arguments);=0A=
  };=0A=
  Network.prototype.deleteSelected =3D function () {=0A=
    return this.manipulation.deleteSelected.apply(this.manipulation, =
arguments);=0A=
  };=0A=
  Network.prototype.getPositions =3D function () {=0A=
    return this.nodesHandler.getPositions.apply(this.nodesHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.storePositions =3D function () {=0A=
    return this.nodesHandler.storePositions.apply(this.nodesHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.moveNode =3D function () {=0A=
    return this.nodesHandler.moveNode.apply(this.nodesHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.getBoundingBox =3D function () {=0A=
    return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.getConnectedNodes =3D function (objectId) {=0A=
    if (this.body.nodes[objectId] !=3D=3D undefined) {=0A=
      return =
this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);=0A=
    } else {=0A=
      return =
this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);=0A=
    }=0A=
  };=0A=
  Network.prototype.getConnectedEdges =3D function () {=0A=
    return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.startSimulation =3D function () {=0A=
    return this.physics.startSimulation.apply(this.physics, arguments);=0A=
  };=0A=
  Network.prototype.stopSimulation =3D function () {=0A=
    return this.physics.stopSimulation.apply(this.physics, arguments);=0A=
  };=0A=
  Network.prototype.stabilize =3D function () {=0A=
    return this.physics.stabilize.apply(this.physics, arguments);=0A=
  };=0A=
  Network.prototype.getSelection =3D function () {=0A=
    return =
this.selectionHandler.getSelection.apply(this.selectionHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.getSelectedNodes =3D function () {=0A=
    return =
this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.getSelectedEdges =3D function () {=0A=
    return =
this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.getNodeAt =3D function () {=0A=
    var node =3D =
this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);=0A=
    if (node !=3D=3D undefined && node.id !=3D=3D undefined) {=0A=
      return node.id;=0A=
    }=0A=
    return node;=0A=
  };=0A=
  Network.prototype.getEdgeAt =3D function () {=0A=
    var edge =3D =
this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);=0A=
    if (edge !=3D=3D undefined && edge.id !=3D=3D undefined) {=0A=
      return edge.id;=0A=
    }=0A=
    return edge;=0A=
  };=0A=
  Network.prototype.selectNodes =3D function () {=0A=
    return =
this.selectionHandler.selectNodes.apply(this.selectionHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.selectEdges =3D function () {=0A=
    return =
this.selectionHandler.selectEdges.apply(this.selectionHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.unselectAll =3D function () {=0A=
    return =
this.selectionHandler.unselectAll.apply(this.selectionHandler, =
arguments);=0A=
  };=0A=
  Network.prototype.redraw =3D function () {=0A=
    return this.renderer.redraw.apply(this.renderer, arguments);=0A=
  };=0A=
  Network.prototype.getScale =3D function () {=0A=
    return this.view.getScale.apply(this.view, arguments);=0A=
  };=0A=
  Network.prototype.getViewPosition =3D function () {=0A=
    return this.view.getViewPosition.apply(this.view, arguments);=0A=
  };=0A=
  Network.prototype.fit =3D function () {=0A=
    return this.view.fit.apply(this.view, arguments);=0A=
  };=0A=
  Network.prototype.moveTo =3D function () {=0A=
    return this.view.moveTo.apply(this.view, arguments);=0A=
  };=0A=
  Network.prototype.focus =3D function () {=0A=
    return this.view.focus.apply(this.view, arguments);=0A=
  };=0A=
  Network.prototype.releaseNode =3D function () {=0A=
    return this.view.releaseNode.apply(this.view, arguments);=0A=
  };=0A=
  Network.prototype.getOptionsFromConfigurator =3D function () {=0A=
    var options =3D {};=0A=
    if (this.configurator) {=0A=
      options =3D this.configurator.getOptions.apply(this.configurator);=0A=
    }=0A=
    return options;=0A=
  };=0A=
=0A=
  module.exports =3D Network;=0A=
=0A=
/***/ },=0A=
/* 60 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * @class Groups=0A=
   * This class can store groups and options specific for groups.=0A=
   */=0A=
=0A=
  var Groups =3D (function () {=0A=
    function Groups() {=0A=
      _classCallCheck(this, Groups);=0A=
=0A=
      this.clear();=0A=
      this.defaultIndex =3D 0;=0A=
      this.groupsArray =3D [];=0A=
      this.groupIndex =3D 0;=0A=
=0A=
      this.defaultGroups =3D [{ border: "#2B7CE9", background: =
"#97C2FC", highlight: { border: "#2B7CE9", background: "#D2E5FF" }, =
hover: { border: "#2B7CE9", background: "#D2E5FF" } }, // 0: blue=0A=
      { border: "#FFA500", background: "#FFFF00", highlight: { border: =
"#FFA500", background: "#FFFFA3" }, hover: { border: "#FFA500", =
background: "#FFFFA3" } }, // 1: yellow=0A=
      { border: "#FA0A10", background: "#FB7E81", highlight: { border: =
"#FA0A10", background: "#FFAFB1" }, hover: { border: "#FA0A10", =
background: "#FFAFB1" } }, // 2: red=0A=
      { border: "#41A906", background: "#7BE141", highlight: { border: =
"#41A906", background: "#A1EC76" }, hover: { border: "#41A906", =
background: "#A1EC76" } }, // 3: green=0A=
      { border: "#E129F0", background: "#EB7DF4", highlight: { border: =
"#E129F0", background: "#F0B3F5" }, hover: { border: "#E129F0", =
background: "#F0B3F5" } }, // 4: magenta=0A=
      { border: "#7C29F0", background: "#AD85E4", highlight: { border: =
"#7C29F0", background: "#D3BDF0" }, hover: { border: "#7C29F0", =
background: "#D3BDF0" } }, // 5: purple=0A=
      { border: "#C37F00", background: "#FFA807", highlight: { border: =
"#C37F00", background: "#FFCA66" }, hover: { border: "#C37F00", =
background: "#FFCA66" } }, // 6: orange=0A=
      { border: "#4220FB", background: "#6E6EFD", highlight: { border: =
"#4220FB", background: "#9B9BFD" }, hover: { border: "#4220FB", =
background: "#9B9BFD" } }, // 7: darkblue=0A=
      { border: "#FD5A77", background: "#FFC0CB", highlight: { border: =
"#FD5A77", background: "#FFD1D9" }, hover: { border: "#FD5A77", =
background: "#FFD1D9" } }, // 8: pink=0A=
      { border: "#4AD63A", background: "#C2FABC", highlight: { border: =
"#4AD63A", background: "#E6FFE3" }, hover: { border: "#4AD63A", =
background: "#E6FFE3" } }, // 9: mint=0A=
=0A=
      { border: "#990000", background: "#EE0000", highlight: { border: =
"#BB0000", background: "#FF3333" }, hover: { border: "#BB0000", =
background: "#FF3333" } }, // 10:bright red=0A=
=0A=
      { border: "#FF6000", background: "#FF6000", highlight: { border: =
"#FF6000", background: "#FF6000" }, hover: { border: "#FF6000", =
background: "#FF6000" } }, // 12: real orange=0A=
      { border: "#97C2FC", background: "#2B7CE9", highlight: { border: =
"#D2E5FF", background: "#2B7CE9" }, hover: { border: "#D2E5FF", =
background: "#2B7CE9" } }, // 13: blue=0A=
      { border: "#399605", background: "#255C03", highlight: { border: =
"#399605", background: "#255C03" }, hover: { border: "#399605", =
background: "#255C03" } }, // 14: green=0A=
      { border: "#B70054", background: "#FF007E", highlight: { border: =
"#B70054", background: "#FF007E" }, hover: { border: "#B70054", =
background: "#FF007E" } }, // 15: magenta=0A=
      { border: "#AD85E4", background: "#7C29F0", highlight: { border: =
"#D3BDF0", background: "#7C29F0" }, hover: { border: "#D3BDF0", =
background: "#7C29F0" } }, // 16: purple=0A=
      { border: "#4557FA", background: "#000EA1", highlight: { border: =
"#6E6EFD", background: "#000EA1" }, hover: { border: "#6E6EFD", =
background: "#000EA1" } }, // 17: darkblue=0A=
      { border: "#FFC0CB", background: "#FD5A77", highlight: { border: =
"#FFD1D9", background: "#FD5A77" }, hover: { border: "#FFD1D9", =
background: "#FD5A77" } }, // 18: pink=0A=
      { border: "#C2FABC", background: "#74D66A", highlight: { border: =
"#E6FFE3", background: "#74D66A" }, hover: { border: "#E6FFE3", =
background: "#74D66A" } }, // 19: mint=0A=
=0A=
      { border: "#EE0000", background: "#990000", highlight: { border: =
"#FF3333", background: "#BB0000" }, hover: { border: "#FF3333", =
background: "#BB0000" } } // 20:bright red=0A=
      ];=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        useDefaultGroups: true=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
    }=0A=
=0A=
    _createClass(Groups, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        var optionFields =3D ["useDefaultGroups"];=0A=
=0A=
        if (options !=3D=3D undefined) {=0A=
          for (var groupName in options) {=0A=
            if (options.hasOwnProperty(groupName)) {=0A=
              if (optionFields.indexOf(groupName) =3D=3D=3D -1) {=0A=
                var group =3D options[groupName];=0A=
                this.add(groupName, group);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "clear",=0A=
=0A=
      /**=0A=
       * Clear all groups=0A=
       */=0A=
      value: function clear() {=0A=
        this.groups =3D {};=0A=
        this.groupsArray =3D [];=0A=
      }=0A=
    }, {=0A=
      key: "get",=0A=
=0A=
      /**=0A=
       * get group options of a groupname. If groupname is not found, a =
new group=0A=
       * is added.=0A=
       * @param {*} groupname        Can be a number, string, Date, etc.=0A=
       * @return {Object} group      The created group, containing all =
group options=0A=
       */=0A=
      value: function get(groupname) {=0A=
        var group =3D this.groups[groupname];=0A=
        if (group =3D=3D=3D undefined) {=0A=
          if (this.options.useDefaultGroups =3D=3D=3D false && =
this.groupsArray.length > 0) {=0A=
            // create new group=0A=
            var index =3D this.groupIndex % this.groupsArray.length;=0A=
            this.groupIndex++;=0A=
            group =3D {};=0A=
            group.color =3D this.groups[this.groupsArray[index]];=0A=
            this.groups[groupname] =3D group;=0A=
          } else {=0A=
            // create new group=0A=
            var index =3D this.defaultIndex % this.defaultGroups.length;=0A=
            this.defaultIndex++;=0A=
            group =3D {};=0A=
            group.color =3D this.defaultGroups[index];=0A=
            this.groups[groupname] =3D group;=0A=
          }=0A=
        }=0A=
=0A=
        return group;=0A=
      }=0A=
    }, {=0A=
      key: "add",=0A=
=0A=
      /**=0A=
       * Add a custom group style=0A=
       * @param {String} groupName=0A=
       * @param {Object} style       An object containing borderColor,=0A=
       *                             backgroundColor, etc.=0A=
       * @return {Object} group      The created group object=0A=
       */=0A=
      value: function add(groupName, style) {=0A=
        this.groups[groupName] =3D style;=0A=
        this.groupsArray.push(groupName);=0A=
        return style;=0A=
      }=0A=
    }]);=0A=
=0A=
    return Groups;=0A=
  })();=0A=
=0A=
  exports["default"] =3D Groups;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 61 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _componentsNode =3D __webpack_require__(62);=0A=
=0A=
  var _componentsNode2 =3D _interopRequireDefault(_componentsNode);=0A=
=0A=
  var _componentsSharedLabel =3D __webpack_require__(63);=0A=
=0A=
  var _componentsSharedLabel2 =3D =
_interopRequireDefault(_componentsSharedLabel);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
=0A=
  var NodesHandler =3D (function () {=0A=
    function NodesHandler(body, images, groups, layoutEngine) {=0A=
      var _this =3D this;=0A=
=0A=
      _classCallCheck(this, NodesHandler);=0A=
=0A=
      this.body =3D body;=0A=
      this.images =3D images;=0A=
      this.groups =3D groups;=0A=
      this.layoutEngine =3D layoutEngine;=0A=
=0A=
      // create the node API in the body container=0A=
      this.body.functions.createNode =3D this.create.bind(this);=0A=
=0A=
      this.nodesListeners =3D {=0A=
        add: function add(event, params) {=0A=
          _this.add(params.items);=0A=
        },=0A=
        update: function update(event, params) {=0A=
          _this.update(params.items, params.data);=0A=
        },=0A=
        remove: function remove(event, params) {=0A=
          _this.remove(params.items);=0A=
        }=0A=
      };=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        borderWidth: 1,=0A=
        borderWidthSelected: 2,=0A=
        brokenImage: undefined,=0A=
        color: {=0A=
          border: '#2B7CE9',=0A=
          background: '#97C2FC',=0A=
          highlight: {=0A=
            border: '#2B7CE9',=0A=
            background: '#D2E5FF'=0A=
          },=0A=
          hover: {=0A=
            border: '#2B7CE9',=0A=
            background: '#D2E5FF'=0A=
          }=0A=
        },=0A=
        fixed: {=0A=
          x: false,=0A=
          y: false=0A=
        },=0A=
        font: {=0A=
          color: '#343434',=0A=
          size: 14, // px=0A=
          face: 'arial',=0A=
          background: 'none',=0A=
          strokeWidth: 0, // px=0A=
          strokeColor: '#ffffff',=0A=
          align: 'horizontal'=0A=
        },=0A=
        group: undefined,=0A=
        hidden: false,=0A=
        icon: {=0A=
          face: 'FontAwesome', //'FontAwesome',=0A=
          code: undefined, //'\uf007',=0A=
          size: 50, //50,=0A=
          color: '#2B7CE9' //'#aa00ff'=0A=
        },=0A=
        image: undefined, // --> URL=0A=
        label: undefined,=0A=
        labelHighlightBold: true,=0A=
        level: undefined,=0A=
        mass: 1,=0A=
        physics: true,=0A=
        scaling: {=0A=
          min: 10,=0A=
          max: 30,=0A=
          label: {=0A=
            enabled: false,=0A=
            min: 14,=0A=
            max: 30,=0A=
            maxVisible: 30,=0A=
            drawThreshold: 5=0A=
          },=0A=
          customScalingFunction: function customScalingFunction(min, =
max, total, value) {=0A=
            if (max =3D=3D=3D min) {=0A=
              return 0.5;=0A=
            } else {=0A=
              var scale =3D 1 / (max - min);=0A=
              return Math.max(0, (value - min) * scale);=0A=
            }=0A=
          }=0A=
        },=0A=
        shadow: {=0A=
          enabled: false,=0A=
          size: 10,=0A=
          x: 5,=0A=
          y: 5=0A=
        },=0A=
        shape: 'ellipse',=0A=
        shapeProperties: {=0A=
          borderDashes: false, // only for borders=0A=
          borderRadius: 6, // only for box shape=0A=
          useImageSize: false // only for image and circularImage shapes=0A=
        },=0A=
        size: 25,=0A=
        title: undefined,=0A=
        value: undefined,=0A=
        x: undefined,=0A=
        y: undefined=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.bindEventListeners();=0A=
    }=0A=
=0A=
    _createClass(NodesHandler, [{=0A=
      key: 'bindEventListeners',=0A=
      value: function bindEventListeners() {=0A=
        var _this2 =3D this;=0A=
=0A=
        // refresh the nodes. Used when reverting from hierarchical =
layout=0A=
        this.body.emitter.on('refreshNodes', this.refresh.bind(this));=0A=
        this.body.emitter.on('refresh', this.refresh.bind(this));=0A=
        this.body.emitter.on('destroy', function () {=0A=
          delete _this2.body.functions.createNode;=0A=
          delete _this2.nodesListeners.add;=0A=
          delete _this2.nodesListeners.update;=0A=
          delete _this2.nodesListeners.remove;=0A=
          delete _this2.nodesListeners;=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          _componentsNode2['default'].parseOptions(this.options, =
options);=0A=
=0A=
          // update the shape in all nodes=0A=
          if (options.shape !=3D=3D undefined) {=0A=
            for (var nodeId in this.body.nodes) {=0A=
              if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
                this.body.nodes[nodeId].updateShape();=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          // update the shape size in all nodes=0A=
          if (options.font !=3D=3D undefined) {=0A=
            =
_componentsSharedLabel2['default'].parseOptions(this.options.font, =
options);=0A=
            for (var nodeId in this.body.nodes) {=0A=
              if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
                this.body.nodes[nodeId].updateLabelModule();=0A=
                this.body.nodes[nodeId]._reset();=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          // update the shape size in all nodes=0A=
          if (options.size !=3D=3D undefined) {=0A=
            for (var nodeId in this.body.nodes) {=0A=
              if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
                this.body.nodes[nodeId]._reset();=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          // update the state of the letiables if needed=0A=
          if (options.hidden !=3D=3D undefined || options.physics =
!=3D=3D undefined) {=0A=
            this.body.emitter.emit('_dataChanged');=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'setData',=0A=
=0A=
      /**=0A=
       * Set a data set with nodes for the network=0A=
       * @param {Array | DataSet | DataView} nodes         The data =
containing the nodes.=0A=
       * @private=0A=
       */=0A=
      value: function setData(nodes) {=0A=
        var _this3 =3D this;=0A=
=0A=
        var doNotEmit =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        var oldNodesData =3D this.body.data.nodes;=0A=
=0A=
        if (nodes instanceof DataSet || nodes instanceof DataView) {=0A=
          this.body.data.nodes =3D nodes;=0A=
        } else if (Array.isArray(nodes)) {=0A=
          this.body.data.nodes =3D new DataSet();=0A=
          this.body.data.nodes.add(nodes);=0A=
        } else if (!nodes) {=0A=
          this.body.data.nodes =3D new DataSet();=0A=
        } else {=0A=
          throw new TypeError('Array or DataSet expected');=0A=
        }=0A=
=0A=
        if (oldNodesData) {=0A=
          // unsubscribe from old dataset=0A=
          util.forEach(this.nodesListeners, function (callback, event) {=0A=
            oldNodesData.off(event, callback);=0A=
          });=0A=
        }=0A=
=0A=
        // remove drawn nodes=0A=
        this.body.nodes =3D {};=0A=
=0A=
        if (this.body.data.nodes) {=0A=
          (function () {=0A=
            // subscribe to new dataset=0A=
            var me =3D _this3;=0A=
            util.forEach(_this3.nodesListeners, function (callback, =
event) {=0A=
              me.body.data.nodes.on(event, callback);=0A=
            });=0A=
=0A=
            // draw all new nodes=0A=
            var ids =3D _this3.body.data.nodes.getIds();=0A=
            _this3.add(ids, true);=0A=
          })();=0A=
        }=0A=
=0A=
        if (doNotEmit =3D=3D=3D false) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'add',=0A=
=0A=
      /**=0A=
       * Add nodes=0A=
       * @param {Number[] | String[]} ids=0A=
       * @private=0A=
       */=0A=
      value: function add(ids) {=0A=
        var doNotEmit =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        var id =3D undefined;=0A=
        var newNodes =3D [];=0A=
        for (var i =3D 0; i < ids.length; i++) {=0A=
          id =3D ids[i];=0A=
          var properties =3D this.body.data.nodes.get(id);=0A=
          var node =3D this.create(properties);=0A=
          newNodes.push(node);=0A=
          this.body.nodes[id] =3D node; // note: this may replace an =
existing node=0A=
        }=0A=
=0A=
        this.layoutEngine.positionInitially(newNodes);=0A=
=0A=
        if (doNotEmit =3D=3D=3D false) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'update',=0A=
=0A=
      /**=0A=
       * Update existing nodes, or create them when not yet existing=0A=
       * @param {Number[] | String[]} ids=0A=
       * @private=0A=
       */=0A=
      value: function update(ids, changedData) {=0A=
        var nodes =3D this.body.nodes;=0A=
        var dataChanged =3D false;=0A=
        for (var i =3D 0; i < ids.length; i++) {=0A=
          var id =3D ids[i];=0A=
          var node =3D nodes[id];=0A=
          var data =3D changedData[i];=0A=
          if (node !=3D=3D undefined) {=0A=
            // update node=0A=
            dataChanged =3D node.setOptions(data);=0A=
          } else {=0A=
            dataChanged =3D true;=0A=
            // create node=0A=
            node =3D this.create(data);=0A=
            nodes[id] =3D node;=0A=
          }=0A=
        }=0A=
        if (dataChanged =3D=3D=3D true) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        } else {=0A=
          this.body.emitter.emit('_dataUpdated');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'remove',=0A=
=0A=
      /**=0A=
       * Remove existing nodes. If nodes do not exist, the method will =
just ignore it.=0A=
       * @param {Number[] | String[]} ids=0A=
       * @private=0A=
       */=0A=
      value: function remove(ids) {=0A=
        var nodes =3D this.body.nodes;=0A=
=0A=
        for (var i =3D 0; i < ids.length; i++) {=0A=
          var id =3D ids[i];=0A=
          nodes[id].cleanup();=0A=
          delete nodes[id];=0A=
        }=0A=
=0A=
        this.body.emitter.emit('_dataChanged');=0A=
      }=0A=
    }, {=0A=
      key: 'create',=0A=
=0A=
      /**=0A=
       * create a node=0A=
       * @param properties=0A=
       * @param constructorClass=0A=
       */=0A=
      value: function create(properties) {=0A=
        var constructorClass =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? _componentsNode2['default'] : arguments[1];=0A=
=0A=
        return new constructorClass(properties, this.body, this.images, =
this.groups, this.options);=0A=
      }=0A=
    }, {=0A=
      key: 'refresh',=0A=
      value: function refresh() {=0A=
        var clearPositions =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? false : arguments[0];=0A=
=0A=
        var nodes =3D this.body.nodes;=0A=
        for (var nodeId in nodes) {=0A=
          var node =3D undefined;=0A=
          if (nodes.hasOwnProperty(nodeId)) {=0A=
            node =3D nodes[nodeId];=0A=
          }=0A=
          var data =3D this.body.data.nodes._data[nodeId];=0A=
          if (node !=3D=3D undefined && data !=3D=3D undefined) {=0A=
            if (clearPositions =3D=3D=3D true) {=0A=
              node.setOptions({ x: null, y: null });=0A=
            }=0A=
            node.setOptions({ fixed: false });=0A=
            node.setOptions(data);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'getPositions',=0A=
=0A=
      /**=0A=
       * Returns the positions of the nodes.=0A=
       * @param ids  --> optional, can be array of nodeIds, can be string=0A=
       * @returns {{}}=0A=
       */=0A=
      value: function getPositions(ids) {=0A=
        var dataArray =3D {};=0A=
        if (ids !=3D=3D undefined) {=0A=
          if (Array.isArray(ids) =3D=3D=3D true) {=0A=
            for (var i =3D 0; i < ids.length; i++) {=0A=
              if (this.body.nodes[ids[i]] !=3D=3D undefined) {=0A=
                var node =3D this.body.nodes[ids[i]];=0A=
                dataArray[ids[i]] =3D { x: Math.round(node.x), y: =
Math.round(node.y) };=0A=
              }=0A=
            }=0A=
          } else {=0A=
            if (this.body.nodes[ids] !=3D=3D undefined) {=0A=
              var node =3D this.body.nodes[ids];=0A=
              dataArray[ids] =3D { x: Math.round(node.x), y: =
Math.round(node.y) };=0A=
            }=0A=
          }=0A=
        } else {=0A=
          for (var nodeId in this.body.nodes) {=0A=
            if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
              var node =3D this.body.nodes[nodeId];=0A=
              dataArray[nodeId] =3D { x: Math.round(node.x), y: =
Math.round(node.y) };=0A=
            }=0A=
          }=0A=
        }=0A=
        return dataArray;=0A=
      }=0A=
    }, {=0A=
      key: 'storePositions',=0A=
=0A=
      /**=0A=
       * Load the XY positions of the nodes into the dataset.=0A=
       */=0A=
      value: function storePositions() {=0A=
        // todo: add support for clusters and hierarchical.=0A=
        var dataArray =3D [];=0A=
        var dataset =3D this.body.data.nodes.getDataSet();=0A=
=0A=
        for (var nodeId in dataset._data) {=0A=
          if (dataset._data.hasOwnProperty(nodeId)) {=0A=
            var node =3D this.body.nodes[nodeId];=0A=
            if (dataset._data[nodeId].x !=3D Math.round(node.x) || =
dataset._data[nodeId].y !=3D Math.round(node.y)) {=0A=
              dataArray.push({ id: nodeId, x: Math.round(node.x), y: =
Math.round(node.y) });=0A=
            }=0A=
          }=0A=
        }=0A=
        dataset.update(dataArray);=0A=
      }=0A=
    }, {=0A=
      key: 'getBoundingBox',=0A=
=0A=
      /**=0A=
       * get the bounding box of a node.=0A=
       * @param nodeId=0A=
       * @returns {j|*}=0A=
       */=0A=
      value: function getBoundingBox(nodeId) {=0A=
        if (this.body.nodes[nodeId] !=3D=3D undefined) {=0A=
          return this.body.nodes[nodeId].shape.boundingBox;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'getConnectedNodes',=0A=
=0A=
      /**=0A=
       * Get the Ids of nodes connected to this node.=0A=
       * @param nodeId=0A=
       * @returns {Array}=0A=
       */=0A=
      value: function getConnectedNodes(nodeId) {=0A=
        var nodeList =3D [];=0A=
        if (this.body.nodes[nodeId] !=3D=3D undefined) {=0A=
          var node =3D this.body.nodes[nodeId];=0A=
          var nodeObj =3D {}; // used to quickly check if node already =
exists=0A=
          for (var i =3D 0; i < node.edges.length; i++) {=0A=
            var edge =3D node.edges[i];=0A=
            if (edge.toId =3D=3D nodeId) {=0A=
              // these are double equals since ids can be numeric or =
string=0A=
              if (nodeObj[edge.fromId] =3D=3D=3D undefined) {=0A=
                nodeList.push(edge.fromId);=0A=
                nodeObj[edge.fromId] =3D true;=0A=
              }=0A=
            } else if (edge.fromId =3D=3D nodeId) {=0A=
              // these are double equals since ids can be numeric or =
string=0A=
              if (nodeObj[edge.toId] =3D=3D=3D undefined) {=0A=
                nodeList.push(edge.toId);=0A=
                nodeObj[edge.toId] =3D true;=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
        return nodeList;=0A=
      }=0A=
    }, {=0A=
      key: 'getConnectedEdges',=0A=
=0A=
      /**=0A=
       * Get the ids of the edges connected to this node.=0A=
       * @param nodeId=0A=
       * @returns {*}=0A=
       */=0A=
      value: function getConnectedEdges(nodeId) {=0A=
        var edgeList =3D [];=0A=
        if (this.body.nodes[nodeId] !=3D=3D undefined) {=0A=
          var node =3D this.body.nodes[nodeId];=0A=
          for (var i =3D 0; i < node.edges.length; i++) {=0A=
            edgeList.push(node.edges[i].id);=0A=
          }=0A=
        } else {=0A=
          console.log('NodeId provided for getConnectedEdges does not =
exist. Provided: ', nodeId);=0A=
        }=0A=
        return edgeList;=0A=
      }=0A=
    }, {=0A=
      key: 'moveNode',=0A=
=0A=
      /**=0A=
       * Move a node.=0A=
       * @param String nodeId=0A=
       * @param Number x=0A=
       * @param Number y=0A=
       */=0A=
      value: function moveNode(nodeId, x, y) {=0A=
        var _this4 =3D this;=0A=
=0A=
        if (this.body.nodes[nodeId] !=3D=3D undefined) {=0A=
          this.body.nodes[nodeId].x =3D Number(x);=0A=
          this.body.nodes[nodeId].y =3D Number(y);=0A=
          setTimeout(function () {=0A=
            _this4.body.emitter.emit('startSimulation');=0A=
          }, 0);=0A=
        } else {=0A=
          console.log('Node id supplied to moveNode does not exist. =
Provided: ', nodeId);=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return NodesHandler;=0A=
  })();=0A=
=0A=
  exports['default'] =3D NodesHandler;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 62 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _sharedLabel =3D __webpack_require__(63);=0A=
=0A=
  var _sharedLabel2 =3D _interopRequireDefault(_sharedLabel);=0A=
=0A=
  var _nodesShapesBox =3D __webpack_require__(64);=0A=
=0A=
  var _nodesShapesBox2 =3D _interopRequireDefault(_nodesShapesBox);=0A=
=0A=
  var _nodesShapesCircle =3D __webpack_require__(66);=0A=
=0A=
  var _nodesShapesCircle2 =3D _interopRequireDefault(_nodesShapesCircle);=0A=
=0A=
  var _nodesShapesCircularImage =3D __webpack_require__(68);=0A=
=0A=
  var _nodesShapesCircularImage2 =3D =
_interopRequireDefault(_nodesShapesCircularImage);=0A=
=0A=
  var _nodesShapesDatabase =3D __webpack_require__(69);=0A=
=0A=
  var _nodesShapesDatabase2 =3D =
_interopRequireDefault(_nodesShapesDatabase);=0A=
=0A=
  var _nodesShapesDiamond =3D __webpack_require__(70);=0A=
=0A=
  var _nodesShapesDiamond2 =3D =
_interopRequireDefault(_nodesShapesDiamond);=0A=
=0A=
  var _nodesShapesDot =3D __webpack_require__(72);=0A=
=0A=
  var _nodesShapesDot2 =3D _interopRequireDefault(_nodesShapesDot);=0A=
=0A=
  var _nodesShapesEllipse =3D __webpack_require__(73);=0A=
=0A=
  var _nodesShapesEllipse2 =3D =
_interopRequireDefault(_nodesShapesEllipse);=0A=
=0A=
  var _nodesShapesIcon =3D __webpack_require__(74);=0A=
=0A=
  var _nodesShapesIcon2 =3D _interopRequireDefault(_nodesShapesIcon);=0A=
=0A=
  var _nodesShapesImage =3D __webpack_require__(75);=0A=
=0A=
  var _nodesShapesImage2 =3D _interopRequireDefault(_nodesShapesImage);=0A=
=0A=
  var _nodesShapesSquare =3D __webpack_require__(76);=0A=
=0A=
  var _nodesShapesSquare2 =3D _interopRequireDefault(_nodesShapesSquare);=0A=
=0A=
  var _nodesShapesStar =3D __webpack_require__(77);=0A=
=0A=
  var _nodesShapesStar2 =3D _interopRequireDefault(_nodesShapesStar);=0A=
=0A=
  var _nodesShapesText =3D __webpack_require__(78);=0A=
=0A=
  var _nodesShapesText2 =3D _interopRequireDefault(_nodesShapesText);=0A=
=0A=
  var _nodesShapesTriangle =3D __webpack_require__(79);=0A=
=0A=
  var _nodesShapesTriangle2 =3D =
_interopRequireDefault(_nodesShapesTriangle);=0A=
=0A=
  var _nodesShapesTriangleDown =3D __webpack_require__(80);=0A=
=0A=
  var _nodesShapesTriangleDown2 =3D =
_interopRequireDefault(_nodesShapesTriangleDown);=0A=
=0A=
  var _sharedValidator =3D __webpack_require__(47);=0A=
=0A=
  var _sharedValidator2 =3D _interopRequireDefault(_sharedValidator);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * @class Node=0A=
   * A node. A node can be connected to other nodes via one or multiple =
edges.=0A=
   * @param {object} options An object containing options for the node. =
All=0A=
   *                            options are optional, except for the id.=0A=
   *                              {number} id     Id of the node. =
Required=0A=
   *                              {string} label  Text label for the node=0A=
   *                              {number} x      Horizontal position of =
the node=0A=
   *                              {number} y      Vertical position of =
the node=0A=
   *                              {string} shape  Node shape, available:=0A=
   *                                              "database", "circle", =
"ellipse",=0A=
   *                                              "box", "image", =
"text", "dot",=0A=
   *                                              "star", "triangle", =
"triangleDown",=0A=
   *                                              "square", "icon"=0A=
   *                              {string} image  An image url=0A=
   *                              {string} title  An title text, can be =
HTML=0A=
   *                              {anytype} group A group name or number=0A=
   * @param {Network.Images} imagelist    A list with images. Only needed=0A=
   *                                            when the node has an =
image=0A=
   * @param {Network.Groups} grouplist    A list with groups. Needed for=0A=
   *                                            retrieving group options=0A=
   * @param {Object}               constants    An object with default =
values for=0A=
   *                                            example for the color=0A=
   *=0A=
   */=0A=
=0A=
  var Node =3D (function () {=0A=
    function Node(options, body, imagelist, grouplist, globalOptions) {=0A=
      _classCallCheck(this, Node);=0A=
=0A=
      this.options =3D util.bridgeObject(globalOptions);=0A=
      this.body =3D body;=0A=
=0A=
      this.edges =3D []; // all edges connected to this node=0A=
=0A=
      // set defaults for the options=0A=
      this.id =3D undefined;=0A=
      this.imagelist =3D imagelist;=0A=
      this.grouplist =3D grouplist;=0A=
=0A=
      // state options=0A=
      this.x =3D undefined;=0A=
      this.y =3D undefined;=0A=
      this.baseSize =3D this.options.size;=0A=
      this.baseFontSize =3D this.options.font.size;=0A=
      this.predefinedPosition =3D false; // used to check if initial fit =
should just take the range or approximate=0A=
      this.selected =3D false;=0A=
      this.hover =3D false;=0A=
=0A=
      this.labelModule =3D new _sharedLabel2['default'](this.body, =
this.options);=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    _createClass(Node, [{=0A=
      key: 'attachEdge',=0A=
=0A=
      /**=0A=
       * Attach a edge to the node=0A=
       * @param {Edge} edge=0A=
       */=0A=
      value: function attachEdge(edge) {=0A=
        if (this.edges.indexOf(edge) =3D=3D=3D -1) {=0A=
          this.edges.push(edge);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'detachEdge',=0A=
=0A=
      /**=0A=
       * Detach a edge from the node=0A=
       * @param {Edge} edge=0A=
       */=0A=
      value: function detachEdge(edge) {=0A=
        var index =3D this.edges.indexOf(edge);=0A=
        if (index !=3D -1) {=0A=
          this.edges.splice(index, 1);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
=0A=
      /**=0A=
       * Set or overwrite options for the node=0A=
       * @param {Object} options an object with options=0A=
       * @param {Object} constants  and object with default, global =
options=0A=
       */=0A=
      value: function setOptions(options) {=0A=
        var currentShape =3D this.options.shape;=0A=
        if (!options) {=0A=
          return;=0A=
        }=0A=
        // basic options=0A=
        if (options.id !=3D=3D undefined) {=0A=
          this.id =3D options.id;=0A=
        }=0A=
=0A=
        if (this.id =3D=3D=3D undefined) {=0A=
          throw 'Node must have an id';=0A=
        }=0A=
=0A=
        // set these options locally=0A=
        // clear x and y positions=0A=
        if (options.x !=3D=3D undefined) {=0A=
          if (options.x =3D=3D=3D null) {=0A=
            this.x =3D undefined;this.predefinedPosition =3D false;=0A=
          } else {=0A=
            this.x =3D parseInt(options.x);this.predefinedPosition =3D =
true;=0A=
          }=0A=
        }=0A=
        if (options.y !=3D=3D undefined) {=0A=
          if (options.y =3D=3D=3D null) {=0A=
            this.y =3D undefined;this.predefinedPosition =3D false;=0A=
          } else {=0A=
            this.y =3D parseInt(options.y);this.predefinedPosition =3D =
true;=0A=
          }=0A=
        }=0A=
        if (options.size !=3D=3D undefined) {=0A=
          this.baseSize =3D options.size;=0A=
        }=0A=
        if (options.value !=3D=3D undefined) {=0A=
          options.value =3D parseFloat(options.value);=0A=
        }=0A=
=0A=
        // copy group options=0A=
        if (typeof options.group =3D=3D=3D 'number' || typeof =
options.group =3D=3D=3D 'string' && options.group !=3D '') {=0A=
          var groupObj =3D this.grouplist.get(options.group);=0A=
          util.deepExtend(this.options, groupObj);=0A=
          // the color object needs to be completely defined. Since =
groups can partially overwrite the colors, we parse it again, just in =
case.=0A=
          this.options.color =3D util.parseColor(this.options.color);=0A=
        }=0A=
=0A=
        // this transforms all shorthands into fully defined options=0A=
        Node.parseOptions(this.options, options, true);=0A=
=0A=
        // load the images=0A=
        if (this.options.image !=3D=3D undefined) {=0A=
          if (this.imagelist) {=0A=
            this.imageObj =3D this.imagelist.load(this.options.image, =
this.options.brokenImage, this.id);=0A=
          } else {=0A=
            throw 'No imagelist provided';=0A=
          }=0A=
        }=0A=
=0A=
        this.updateShape(currentShape);=0A=
        this.updateLabelModule();=0A=
=0A=
        if (options.hidden !=3D=3D undefined || options.physics !=3D=3D =
undefined) {=0A=
          return true;=0A=
        }=0A=
        return false;=0A=
      }=0A=
    }, {=0A=
      key: 'updateLabelModule',=0A=
      value: function updateLabelModule() {=0A=
        if (this.options.label =3D=3D=3D undefined || this.options.label =
=3D=3D=3D null) {=0A=
          this.options.label =3D '';=0A=
        }=0A=
        this.labelModule.setOptions(this.options, true);=0A=
        if (this.labelModule.baseSize !=3D=3D undefined) {=0A=
          this.baseFontSize =3D this.labelModule.baseSize;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'updateShape',=0A=
      value: function updateShape(currentShape) {=0A=
        if (currentShape =3D=3D=3D this.options.shape && this.shape) {=0A=
          this.shape.setOptions(this.options);=0A=
        } else {=0A=
          // clean up the shape if it is already made so the new shape =
can start clean.=0A=
          if (this.shape) {=0A=
            this.shape.cleanup();=0A=
          }=0A=
          // choose draw method depending on the shape=0A=
          switch (this.options.shape) {=0A=
            case 'box':=0A=
              this.shape =3D new =
_nodesShapesBox2['default'](this.options, this.body, this.labelModule);=0A=
              break;=0A=
            case 'circle':=0A=
              this.shape =3D new =
_nodesShapesCircle2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
            case 'circularImage':=0A=
              this.shape =3D new =
_nodesShapesCircularImage2['default'](this.options, this.body, =
this.labelModule, this.imageObj);=0A=
              break;=0A=
            case 'database':=0A=
              this.shape =3D new =
_nodesShapesDatabase2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
            case 'diamond':=0A=
              this.shape =3D new =
_nodesShapesDiamond2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
            case 'dot':=0A=
              this.shape =3D new =
_nodesShapesDot2['default'](this.options, this.body, this.labelModule);=0A=
              break;=0A=
            case 'ellipse':=0A=
              this.shape =3D new =
_nodesShapesEllipse2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
            case 'icon':=0A=
              this.shape =3D new =
_nodesShapesIcon2['default'](this.options, this.body, this.labelModule);=0A=
              break;=0A=
            case 'image':=0A=
              this.shape =3D new =
_nodesShapesImage2['default'](this.options, this.body, this.labelModule, =
this.imageObj);=0A=
              break;=0A=
            case 'square':=0A=
              this.shape =3D new =
_nodesShapesSquare2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
            case 'star':=0A=
              this.shape =3D new =
_nodesShapesStar2['default'](this.options, this.body, this.labelModule);=0A=
              break;=0A=
            case 'text':=0A=
              this.shape =3D new =
_nodesShapesText2['default'](this.options, this.body, this.labelModule);=0A=
              break;=0A=
            case 'triangle':=0A=
              this.shape =3D new =
_nodesShapesTriangle2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
            case 'triangleDown':=0A=
              this.shape =3D new =
_nodesShapesTriangleDown2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
            default:=0A=
              this.shape =3D new =
_nodesShapesEllipse2['default'](this.options, this.body, =
this.labelModule);=0A=
              break;=0A=
          }=0A=
        }=0A=
        this._reset();=0A=
      }=0A=
    }, {=0A=
      key: 'select',=0A=
=0A=
      /**=0A=
       * select this node=0A=
       */=0A=
      value: function select() {=0A=
        this.selected =3D true;=0A=
        this._reset();=0A=
      }=0A=
    }, {=0A=
      key: 'unselect',=0A=
=0A=
      /**=0A=
       * unselect this node=0A=
       */=0A=
      value: function unselect() {=0A=
        this.selected =3D false;=0A=
        this._reset();=0A=
      }=0A=
    }, {=0A=
      key: '_reset',=0A=
=0A=
      /**=0A=
       * Reset the calculated size of the node, forces it to recalculate =
its size=0A=
       * @private=0A=
       */=0A=
      value: function _reset() {=0A=
        this.shape.width =3D undefined;=0A=
        this.shape.height =3D undefined;=0A=
      }=0A=
    }, {=0A=
      key: 'getTitle',=0A=
=0A=
      /**=0A=
       * get the title of this node.=0A=
       * @return {string} title    The title of the node, or undefined =
when no title=0A=
       *                           has been set.=0A=
       */=0A=
      value: function getTitle() {=0A=
        return this.options.title;=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
=0A=
      /**=0A=
       * Calculate the distance to the border of the Node=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       * @param {Number} angle        Angle in radians=0A=
       * @returns {number} distance   Distance to the border in pixels=0A=
       */=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        return this.shape.distanceToBorder(ctx, angle);=0A=
      }=0A=
    }, {=0A=
      key: 'isFixed',=0A=
=0A=
      /**=0A=
       * Check if this node has a fixed x and y position=0A=
       * @return {boolean}      true if fixed, false if not=0A=
       */=0A=
      value: function isFixed() {=0A=
        return this.options.fixed.x && this.options.fixed.y;=0A=
      }=0A=
    }, {=0A=
      key: 'isSelected',=0A=
=0A=
      /**=0A=
       * check if this node is selecte=0A=
       * @return {boolean} selected   True if node is selected, else =
false=0A=
       */=0A=
      value: function isSelected() {=0A=
        return this.selected;=0A=
      }=0A=
    }, {=0A=
      key: 'getValue',=0A=
=0A=
      /**=0A=
       * Retrieve the value of the node. Can be undefined=0A=
       * @return {Number} value=0A=
       */=0A=
      value: function getValue() {=0A=
        return this.options.value;=0A=
      }=0A=
    }, {=0A=
      key: 'setValueRange',=0A=
=0A=
      /**=0A=
       * Adjust the value range of the node. The node will adjust it's =
size=0A=
       * based on its value.=0A=
       * @param {Number} min=0A=
       * @param {Number} max=0A=
       */=0A=
      value: function setValueRange(min, max, total) {=0A=
        if (this.options.value !=3D=3D undefined) {=0A=
          var scale =3D this.options.scaling.customScalingFunction(min, =
max, total, this.options.value);=0A=
          var sizeDiff =3D this.options.scaling.max - =
this.options.scaling.min;=0A=
          if (this.options.scaling.label.enabled =3D=3D=3D true) {=0A=
            var fontDiff =3D this.options.scaling.label.max - =
this.options.scaling.label.min;=0A=
            this.options.font.size =3D this.options.scaling.label.min + =
scale * fontDiff;=0A=
          }=0A=
          this.options.size =3D this.options.scaling.min + scale * =
sizeDiff;=0A=
        } else {=0A=
          this.options.size =3D this.baseSize;=0A=
          this.options.font.size =3D this.baseFontSize;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
=0A=
      /**=0A=
       * Draw this node in the given canvas=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext("2d");=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       */=0A=
      value: function draw(ctx) {=0A=
        this.shape.draw(ctx, this.x, this.y, this.selected, this.hover);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
=0A=
      /**=0A=
       * Update the bounding box of the shape=0A=
       */=0A=
      value: function updateBoundingBox(ctx) {=0A=
        this.shape.updateBoundingBox(this.x, this.y, ctx);=0A=
      }=0A=
    }, {=0A=
      key: 'resize',=0A=
=0A=
      /**=0A=
       * Recalculate the size of this node in the given canvas=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext("2d");=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       */=0A=
      value: function resize(ctx) {=0A=
        this.shape.resize(ctx, this.selected);=0A=
      }=0A=
    }, {=0A=
      key: 'isOverlappingWith',=0A=
=0A=
      /**=0A=
       * Check if this object is overlapping with the provided object=0A=
       * @param {Object} obj   an object with parameters left, top, =
right, bottom=0A=
       * @return {boolean}     True if location is located on node=0A=
       */=0A=
      value: function isOverlappingWith(obj) {=0A=
        return this.shape.left < obj.right && this.shape.left + =
this.shape.width > obj.left && this.shape.top < obj.bottom && =
this.shape.top + this.shape.height > obj.top;=0A=
      }=0A=
    }, {=0A=
      key: 'isBoundingBoxOverlappingWith',=0A=
=0A=
      /**=0A=
       * Check if this object is overlapping with the provided object=0A=
       * @param {Object} obj   an object with parameters left, top, =
right, bottom=0A=
       * @return {boolean}     True if location is located on node=0A=
       */=0A=
      value: function isBoundingBoxOverlappingWith(obj) {=0A=
        return this.shape.boundingBox.left < obj.right && =
this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < =
obj.bottom && this.shape.boundingBox.bottom > obj.top;=0A=
      }=0A=
    }, {=0A=
      key: 'cleanup',=0A=
=0A=
      /**=0A=
       * clean all required things on delete.=0A=
       * @returns {*}=0A=
       */=0A=
      value: function cleanup() {=0A=
        return this.shape.cleanup();=0A=
      }=0A=
    }], [{=0A=
      key: 'parseOptions',=0A=
=0A=
      /**=0A=
       * This process all possible shorthands in the new options and =
makes sure that the parentOptions are fully defined.=0A=
       * Static so it can also be used by the handler.=0A=
       * @param parentOptions=0A=
       * @param newOptions=0A=
       */=0A=
      value: function parseOptions(parentOptions, newOptions) {=0A=
        var allowDeletion =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? false : arguments[2];=0A=
=0A=
        var fields =3D ['color', 'font', 'fixed', 'shadow'];=0A=
        util.selectiveNotDeepExtend(fields, parentOptions, newOptions, =
allowDeletion);=0A=
=0A=
        // merge the shadow options into the parent.=0A=
        util.mergeOptions(parentOptions, newOptions, 'shadow');=0A=
=0A=
        // individual shape newOptions=0A=
        if (newOptions.color !=3D=3D undefined && newOptions.color =
!=3D=3D null) {=0A=
          var parsedColor =3D util.parseColor(newOptions.color);=0A=
          util.fillIfDefined(parentOptions.color, parsedColor);=0A=
        } else if (allowDeletion =3D=3D=3D true && newOptions.color =
=3D=3D=3D null) {=0A=
          parentOptions.color =3D undefined;=0A=
          delete parentOptions.color;=0A=
        }=0A=
=0A=
        // handle the fixed options=0A=
        if (newOptions.fixed !=3D=3D undefined && newOptions.fixed =
!=3D=3D null) {=0A=
          if (typeof newOptions.fixed =3D=3D=3D 'boolean') {=0A=
            parentOptions.fixed.x =3D newOptions.fixed;=0A=
            parentOptions.fixed.y =3D newOptions.fixed;=0A=
          } else {=0A=
            if (newOptions.fixed.x !=3D=3D undefined && typeof =
newOptions.fixed.x =3D=3D=3D 'boolean') {=0A=
              parentOptions.fixed.x =3D newOptions.fixed.x;=0A=
            }=0A=
            if (newOptions.fixed.y !=3D=3D undefined && typeof =
newOptions.fixed.y =3D=3D=3D 'boolean') {=0A=
              parentOptions.fixed.y =3D newOptions.fixed.y;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // handle the font options=0A=
        if (newOptions.font !=3D=3D undefined) {=0A=
          _sharedLabel2['default'].parseOptions(parentOptions.font, =
newOptions);=0A=
        }=0A=
=0A=
        // handle the scaling options, specifically the label part=0A=
        if (newOptions.scaling !=3D=3D undefined) {=0A=
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, =
'label');=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return Node;=0A=
  })();=0A=
=0A=
  exports['default'] =3D Node;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 63 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _slicedToArray =3D (function () { function sliceIterator(arr, i) { =
var _arr =3D []; var _n =3D true; var _d =3D false; var _e =3D =
undefined; try { for (var _i =3D arr[Symbol.iterator](), _s; !(_n =3D =
(_s =3D _i.next()).done); _n =3D true) { _arr.push(_s.value); if (i && =
_arr.length =3D=3D=3D i) break; } } catch (err) { _d =3D true; _e =3D =
err; } finally { try { if (!_n && _i['return']) _i['return'](); } =
finally { if (_d) throw _e; } } return _arr; } return function (arr, i) =
{ if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in =
Object(arr)) { return sliceIterator(arr, i); } else { throw new =
TypeError('Invalid attempt to destructure non-iterable instance'); } }; =
})();=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var Label =3D (function () {=0A=
    function Label(body, options) {=0A=
      _classCallCheck(this, Label);=0A=
=0A=
      this.body =3D body;=0A=
=0A=
      this.pointToSelf =3D false;=0A=
      this.baseSize =3D undefined;=0A=
      this.setOptions(options);=0A=
      this.size =3D { top: 0, left: 0, width: 0, height: 0, yLine: 0 }; =
// could be cached=0A=
    }=0A=
=0A=
    _createClass(Label, [{=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        var allowDeletion =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        this.options =3D options;=0A=
=0A=
        if (options.label !=3D=3D undefined) {=0A=
          this.labelDirty =3D true;=0A=
        }=0A=
=0A=
        if (options.font !=3D=3D undefined) {=0A=
          Label.parseOptions(this.options.font, options, allowDeletion);=0A=
          if (typeof options.font =3D=3D=3D 'string') {=0A=
            this.baseSize =3D this.options.font.size;=0A=
          } else if (typeof options.font =3D=3D=3D 'object') {=0A=
            if (options.font.size !=3D=3D undefined) {=0A=
              this.baseSize =3D options.font.size;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
=0A=
      /**=0A=
       * Main function. This is called from anything that wants to draw =
a label.=0A=
       * @param ctx=0A=
       * @param x=0A=
       * @param y=0A=
       * @param selected=0A=
       * @param baseline=0A=
       */=0A=
      value: function draw(ctx, x, y, selected) {=0A=
        var baseline =3D arguments.length <=3D 4 || arguments[4] =
=3D=3D=3D undefined ? 'middle' : arguments[4];=0A=
=0A=
        // if no label, return=0A=
        if (this.options.label =3D=3D=3D undefined) return;=0A=
=0A=
        // check if we have to render the label=0A=
        var viewFontSize =3D this.options.font.size * =
this.body.view.scale;=0A=
        if (this.options.label && viewFontSize < =
this.options.scaling.label.drawThreshold - 1) return;=0A=
=0A=
        // update the size cache if required=0A=
        this.calculateLabelSize(ctx, selected, x, y, baseline);=0A=
=0A=
        // create the fontfill background=0A=
        this._drawBackground(ctx);=0A=
        // draw text=0A=
        this._drawText(ctx, selected, x, y, baseline);=0A=
      }=0A=
    }, {=0A=
      key: '_drawBackground',=0A=
=0A=
      /**=0A=
       * Draws the label background=0A=
       * @param {CanvasRenderingContext2D} ctx=0A=
       * @private=0A=
       */=0A=
      value: function _drawBackground(ctx) {=0A=
        if (this.options.font.background !=3D=3D undefined && =
this.options.font.background !=3D=3D 'none') {=0A=
          ctx.fillStyle =3D this.options.font.background;=0A=
=0A=
          var lineMargin =3D 2;=0A=
=0A=
          switch (this.options.font.align) {=0A=
            case 'middle':=0A=
              ctx.fillRect(-this.size.width * 0.5, -this.size.height * =
0.5, this.size.width, this.size.height);=0A=
              break;=0A=
            case 'top':=0A=
              ctx.fillRect(-this.size.width * 0.5, -(this.size.height + =
lineMargin), this.size.width, this.size.height);=0A=
              break;=0A=
            case 'bottom':=0A=
              ctx.fillRect(-this.size.width * 0.5, lineMargin, =
this.size.width, this.size.height);=0A=
              break;=0A=
            default:=0A=
              ctx.fillRect(this.size.left, this.size.top - 0.5 * =
lineMargin, this.size.width, this.size.height);=0A=
              break;=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_drawText',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param ctx=0A=
       * @param x=0A=
       * @param baseline=0A=
       * @private=0A=
       */=0A=
      value: function _drawText(ctx, selected, x, y) {=0A=
        var baseline =3D arguments.length <=3D 4 || arguments[4] =
=3D=3D=3D undefined ? 'middle' : arguments[4];=0A=
=0A=
        var fontSize =3D this.options.font.size;=0A=
        var viewFontSize =3D fontSize * this.body.view.scale;=0A=
        // this ensures that there will not be HUGE letters on screen by =
setting an upper limit on the visible text size (regardless of zoomLevel)=0A=
        if (viewFontSize >=3D this.options.scaling.label.maxVisible) {=0A=
          fontSize =3D Number(this.options.scaling.label.maxVisible) / =
this.body.view.scale;=0A=
        }=0A=
=0A=
        var yLine =3D this.size.yLine;=0A=
=0A=
        var _getColor2 =3D this._getColor(viewFontSize);=0A=
=0A=
        var _getColor22 =3D _slicedToArray(_getColor2, 2);=0A=
=0A=
        var fontColor =3D _getColor22[0];=0A=
        var strokeColor =3D _getColor22[1];=0A=
=0A=
        var _setAlignment2 =3D this._setAlignment(ctx, x, yLine, =
baseline);=0A=
=0A=
        var _setAlignment22 =3D _slicedToArray(_setAlignment2, 2);=0A=
=0A=
        x =3D _setAlignment22[0];=0A=
        yLine =3D _setAlignment22[1];=0A=
=0A=
        // configure context for drawing the text=0A=
        ctx.font =3D (selected && this.options.labelHighlightBold ? =
'bold ' : '') + fontSize + 'px ' + this.options.font.face;=0A=
        ctx.fillStyle =3D fontColor;=0A=
        ctx.textAlign =3D 'center';=0A=
=0A=
        // set the strokeWidth=0A=
        if (this.options.font.strokeWidth > 0) {=0A=
          ctx.lineWidth =3D this.options.font.strokeWidth;=0A=
          ctx.strokeStyle =3D strokeColor;=0A=
          ctx.lineJoin =3D 'round';=0A=
        }=0A=
=0A=
        // draw the text=0A=
        for (var i =3D 0; i < this.lineCount; i++) {=0A=
          if (this.options.font.strokeWidth > 0) {=0A=
            ctx.strokeText(this.lines[i], x, yLine);=0A=
          }=0A=
          ctx.fillText(this.lines[i], x, yLine);=0A=
          yLine +=3D fontSize;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_setAlignment',=0A=
      value: function _setAlignment(ctx, x, yLine, baseline) {=0A=
        // check for label alignment (for edges)=0A=
        // TODO: make alignment for nodes=0A=
        if (this.options.font.align !=3D=3D 'horizontal' && =
this.pointToSelf =3D=3D=3D false) {=0A=
          x =3D 0;=0A=
          yLine =3D 0;=0A=
=0A=
          var lineMargin =3D 2;=0A=
          if (this.options.font.align =3D=3D=3D 'top') {=0A=
            ctx.textBaseline =3D 'alphabetic';=0A=
            yLine -=3D 2 * lineMargin; // distance from edge, required =
because we use alphabetic. Alphabetic has less difference between =
browsers=0A=
          } else if (this.options.font.align =3D=3D=3D 'bottom') {=0A=
            ctx.textBaseline =3D 'hanging';=0A=
            yLine +=3D 2 * lineMargin; // distance from edge, required =
because we use hanging. Hanging has less difference between browsers=0A=
          } else {=0A=
            ctx.textBaseline =3D 'middle';=0A=
          }=0A=
        } else {=0A=
          ctx.textBaseline =3D baseline;=0A=
        }=0A=
=0A=
        return [x, yLine];=0A=
      }=0A=
    }, {=0A=
      key: '_getColor',=0A=
=0A=
      /**=0A=
       * fade in when relative scale is between threshold and threshold =
- 1.=0A=
       * If the relative scale would be smaller than threshold -1 the =
draw function would have returned before coming here.=0A=
       *=0A=
       * @param viewFontSize=0A=
       * @returns {*[]}=0A=
       * @private=0A=
       */=0A=
      value: function _getColor(viewFontSize) {=0A=
        var fontColor =3D this.options.font.color || '#000000';=0A=
        var strokeColor =3D this.options.font.strokeColor || '#ffffff';=0A=
        if (viewFontSize <=3D this.options.scaling.label.drawThreshold) {=0A=
          var opacity =3D Math.max(0, Math.min(1, 1 - =
(this.options.scaling.label.drawThreshold - viewFontSize)));=0A=
          fontColor =3D util.overrideOpacity(fontColor, opacity);=0A=
          strokeColor =3D util.overrideOpacity(strokeColor, opacity);=0A=
        }=0A=
        return [fontColor, strokeColor];=0A=
      }=0A=
    }, {=0A=
      key: 'getTextSize',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param ctx=0A=
       * @param selected=0A=
       * @returns {{width: number, height: number}}=0A=
       */=0A=
      value: function getTextSize(ctx) {=0A=
        var selected =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        var size =3D {=0A=
          width: this._processLabel(ctx, selected),=0A=
          height: this.options.font.size * this.lineCount,=0A=
          lineCount: this.lineCount=0A=
        };=0A=
        return size;=0A=
      }=0A=
    }, {=0A=
      key: 'calculateLabelSize',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param ctx=0A=
       * @param selected=0A=
       * @param x=0A=
       * @param y=0A=
       * @param baseline=0A=
       */=0A=
      value: function calculateLabelSize(ctx, selected) {=0A=
        var x =3D arguments.length <=3D 2 || arguments[2] =3D=3D=3D =
undefined ? 0 : arguments[2];=0A=
        var y =3D arguments.length <=3D 3 || arguments[3] =3D=3D=3D =
undefined ? 0 : arguments[3];=0A=
        var baseline =3D arguments.length <=3D 4 || arguments[4] =
=3D=3D=3D undefined ? 'middle' : arguments[4];=0A=
=0A=
        if (this.labelDirty =3D=3D=3D true) {=0A=
          this.size.width =3D this._processLabel(ctx, selected);=0A=
        }=0A=
        this.size.height =3D this.options.font.size * this.lineCount;=0A=
        this.size.left =3D x - this.size.width * 0.5;=0A=
        this.size.top =3D y - this.size.height * 0.5;=0A=
        this.size.yLine =3D y + (1 - this.lineCount) * 0.5 * =
this.options.font.size;=0A=
        if (baseline =3D=3D=3D 'hanging') {=0A=
          this.size.top +=3D 0.5 * this.options.font.size;=0A=
          this.size.top +=3D 4; // distance from node, required because =
we use hanging. Hanging has less difference between browsers=0A=
          this.size.yLine +=3D 4; // distance from node=0A=
        }=0A=
=0A=
        this.labelDirty =3D false;=0A=
      }=0A=
    }, {=0A=
      key: '_processLabel',=0A=
=0A=
      /**=0A=
       * This calculates the width as well as explodes the label string =
and calculates the amount of lines.=0A=
       * @param ctx=0A=
       * @param selected=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _processLabel(ctx, selected) {=0A=
        var width =3D 0;=0A=
        var lines =3D [''];=0A=
        var lineCount =3D 0;=0A=
        if (this.options.label !=3D=3D undefined) {=0A=
          lines =3D String(this.options.label).split('\n');=0A=
          lineCount =3D lines.length;=0A=
          ctx.font =3D (selected && this.options.labelHighlightBold ? =
'bold ' : '') + this.options.font.size + 'px ' + this.options.font.face;=0A=
          width =3D ctx.measureText(lines[0]).width;=0A=
          for (var i =3D 1; i < lineCount; i++) {=0A=
            var lineWidth =3D ctx.measureText(lines[i]).width;=0A=
            width =3D lineWidth > width ? lineWidth : width;=0A=
          }=0A=
        }=0A=
        this.lines =3D lines;=0A=
        this.lineCount =3D lineCount;=0A=
=0A=
        return width;=0A=
      }=0A=
    }], [{=0A=
      key: 'parseOptions',=0A=
      value: function parseOptions(parentOptions, newOptions) {=0A=
        var allowDeletion =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? false : arguments[2];=0A=
=0A=
        if (typeof newOptions.font =3D=3D=3D 'string') {=0A=
          var newOptionsArray =3D newOptions.font.split(' ');=0A=
          parentOptions.size =3D newOptionsArray[0].replace('px', '');=0A=
          parentOptions.face =3D newOptionsArray[1];=0A=
          parentOptions.color =3D newOptionsArray[2];=0A=
        } else if (typeof newOptions.font =3D=3D=3D 'object') {=0A=
          util.fillIfDefined(parentOptions, newOptions.font, =
allowDeletion);=0A=
        }=0A=
        parentOptions.size =3D Number(parentOptions.size);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Label;=0A=
  })();=0A=
=0A=
  exports['default'] =3D Label;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 64 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilNodeBase =3D __webpack_require__(65);=0A=
=0A=
  var _utilNodeBase2 =3D _interopRequireDefault(_utilNodeBase);=0A=
=0A=
  var Box =3D (function (_NodeBase) {=0A=
    _inherits(Box, _NodeBase);=0A=
=0A=
    function Box(options, body, labelModule) {=0A=
      _classCallCheck(this, Box);=0A=
=0A=
      _get(Object.getPrototypeOf(Box.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Box, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx, selected) {=0A=
        if (this.width =3D=3D=3D undefined) {=0A=
          var margin =3D 5;=0A=
          var textSize =3D this.labelModule.getTextSize(ctx, selected);=0A=
          this.width =3D textSize.width + 2 * margin;=0A=
          this.height =3D textSize.height + 2 * margin;=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize(ctx, selected);=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        var borderWidth =3D this.options.borderWidth;=0A=
        var selectionLineWidth =3D this.options.borderWidthSelected || 2 =
* this.options.borderWidth;=0A=
=0A=
        ctx.strokeStyle =3D selected ? =
this.options.color.highlight.border : hover ? =
this.options.color.hover.border : this.options.color.border;=0A=
        ctx.lineWidth =3D selected ? selectionLineWidth : borderWidth;=0A=
        ctx.lineWidth /=3D this.body.view.scale;=0A=
        ctx.lineWidth =3D Math.min(this.width, ctx.lineWidth);=0A=
=0A=
        ctx.fillStyle =3D selected ? =
this.options.color.highlight.background : hover ? =
this.options.color.hover.background : this.options.color.background;=0A=
=0A=
        var borderRadius =3D this.options.shapeProperties.borderRadius; =
// only effective for box=0A=
        ctx.roundRect(this.left, this.top, this.width, this.height, =
borderRadius);=0A=
=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        // draw the background=0A=
        ctx.fill();=0A=
        // disable shadows for other elements.=0A=
        this.disableShadow(ctx);=0A=
=0A=
        //draw dashed border if enabled, save and restore is required =
for firefox not to crash on unix.=0A=
        ctx.save();=0A=
        this.enableBorderDashes(ctx);=0A=
        //draw the border=0A=
        ctx.stroke();=0A=
        //disable dashed border for other elements=0A=
        this.disableBorderDashes(ctx);=0A=
        ctx.restore();=0A=
=0A=
        this.updateBoundingBox(x, y);=0A=
        this.labelModule.draw(ctx, x, y, selected);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y) {=0A=
        this.left =3D x - this.width * 0.5;=0A=
        this.top =3D y - this.height * 0.5;=0A=
=0A=
        this.boundingBox.left =3D this.left;=0A=
        this.boundingBox.top =3D this.top;=0A=
        this.boundingBox.bottom =3D this.top + this.height;=0A=
        this.boundingBox.right =3D this.left + this.width;=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        var a =3D this.width / 2;=0A=
        var b =3D this.height / 2;=0A=
        var w =3D Math.sin(angle) * a;=0A=
        var h =3D Math.cos(angle) * b;=0A=
        return a * b / Math.sqrt(w * w + h * h);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Box;=0A=
  })(_utilNodeBase2['default']);=0A=
=0A=
  exports['default'] =3D Box;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 65 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var NodeBase =3D (function () {=0A=
    function NodeBase(options, body, labelModule) {=0A=
      _classCallCheck(this, NodeBase);=0A=
=0A=
      this.body =3D body;=0A=
      this.labelModule =3D labelModule;=0A=
      this.setOptions(options);=0A=
      this.top =3D undefined;=0A=
      this.left =3D undefined;=0A=
      this.height =3D undefined;=0A=
      this.width =3D undefined;=0A=
      this.radius =3D undefined;=0A=
      this.boundingBox =3D { top: 0, left: 0, right: 0, bottom: 0 };=0A=
    }=0A=
=0A=
    _createClass(NodeBase, [{=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
      }=0A=
    }, {=0A=
      key: '_distanceToBorder',=0A=
      value: function _distanceToBorder(angle) {=0A=
        var borderWidth =3D 1;=0A=
        return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), =
Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;=0A=
      }=0A=
    }, {=0A=
      key: 'enableShadow',=0A=
      value: function enableShadow(ctx) {=0A=
        if (this.options.shadow.enabled =3D=3D=3D true) {=0A=
          ctx.shadowColor =3D 'rgba(0,0,0,0.5)';=0A=
          ctx.shadowBlur =3D this.options.shadow.size;=0A=
          ctx.shadowOffsetX =3D this.options.shadow.x;=0A=
          ctx.shadowOffsetY =3D this.options.shadow.y;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'disableShadow',=0A=
      value: function disableShadow(ctx) {=0A=
        if (this.options.shadow.enabled =3D=3D=3D true) {=0A=
          ctx.shadowColor =3D 'rgba(0,0,0,0)';=0A=
          ctx.shadowBlur =3D 0;=0A=
          ctx.shadowOffsetX =3D 0;=0A=
          ctx.shadowOffsetY =3D 0;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'enableBorderDashes',=0A=
      value: function enableBorderDashes(ctx) {=0A=
        if (this.options.shapeProperties.borderDashes !=3D=3D false) {=0A=
          if (ctx.setLineDash !=3D=3D undefined) {=0A=
            var dashes =3D this.options.shapeProperties.borderDashes;=0A=
            if (dashes =3D=3D=3D true) {=0A=
              dashes =3D [5, 15];=0A=
            }=0A=
            ctx.setLineDash(dashes);=0A=
          } else {=0A=
            console.warn('setLineDash is not supported in this browser. =
The dashed borders cannot be used.');=0A=
            this.options.shapeProperties.borderDashes =3D false;=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'disableBorderDashes',=0A=
      value: function disableBorderDashes(ctx) {=0A=
        if (this.options.shapeProperties.borderDashes !=3D=3D false) {=0A=
          if (ctx.setLineDash !=3D=3D undefined) {=0A=
            ctx.setLineDash([0]);=0A=
          } else {=0A=
            console.warn('setLineDash is not supported in this browser. =
The dashed borders cannot be used.');=0A=
            this.options.shapeProperties.borderDashes =3D false;=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'cleanup',=0A=
=0A=
      // possible cleanup for use in shapes=0A=
      value: function cleanup() {}=0A=
    }]);=0A=
=0A=
    return NodeBase;=0A=
  })();=0A=
=0A=
  exports['default'] =3D NodeBase;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 66 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilCircleImageBase =3D __webpack_require__(67);=0A=
=0A=
  var _utilCircleImageBase2 =3D =
_interopRequireDefault(_utilCircleImageBase);=0A=
=0A=
  var Circle =3D (function (_CircleImageBase) {=0A=
    _inherits(Circle, _CircleImageBase);=0A=
=0A=
    function Circle(options, body, labelModule) {=0A=
      _classCallCheck(this, Circle);=0A=
=0A=
      _get(Object.getPrototypeOf(Circle.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Circle, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx, selected) {=0A=
        if (this.width =3D=3D=3D undefined) {=0A=
          var margin =3D 5;=0A=
          var textSize =3D this.labelModule.getTextSize(ctx, selected);=0A=
          var diameter =3D Math.max(textSize.width, textSize.height) + 2 =
* margin;=0A=
          this.options.size =3D diameter / 2;=0A=
=0A=
          this.width =3D diameter;=0A=
          this.height =3D diameter;=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize(ctx, selected);=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        this._drawRawCircle(ctx, x, y, selected, hover, =
this.options.size);=0A=
=0A=
        this.boundingBox.top =3D y - this.options.size;=0A=
        this.boundingBox.left =3D x - this.options.size;=0A=
        this.boundingBox.right =3D x + this.options.size;=0A=
        this.boundingBox.bottom =3D y + this.options.size;=0A=
=0A=
        this.updateBoundingBox(x, y);=0A=
        this.labelModule.draw(ctx, x, y, selected);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y) {=0A=
        this.boundingBox.top =3D y - this.options.size;=0A=
        this.boundingBox.left =3D x - this.options.size;=0A=
        this.boundingBox.right =3D x + this.options.size;=0A=
        this.boundingBox.bottom =3D y + this.options.size;=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        var a =3D this.width / 2;=0A=
        var b =3D this.height / 2;=0A=
        var w =3D Math.sin(angle) * a;=0A=
        var h =3D Math.cos(angle) * b;=0A=
        return a * b / Math.sqrt(w * w + h * h);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Circle;=0A=
  })(_utilCircleImageBase2['default']);=0A=
=0A=
  exports['default'] =3D Circle;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 67 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilNodeBase =3D __webpack_require__(65);=0A=
=0A=
  var _utilNodeBase2 =3D _interopRequireDefault(_utilNodeBase);=0A=
=0A=
  var CircleImageBase =3D (function (_NodeBase) {=0A=
    _inherits(CircleImageBase, _NodeBase);=0A=
=0A=
    function CircleImageBase(options, body, labelModule) {=0A=
      _classCallCheck(this, CircleImageBase);=0A=
=0A=
      _get(Object.getPrototypeOf(CircleImageBase.prototype), =
'constructor', this).call(this, options, body, labelModule);=0A=
      this.labelOffset =3D 0;=0A=
      this.imageLoaded =3D false;=0A=
    }=0A=
=0A=
    _createClass(CircleImageBase, [{=0A=
      key: '_resizeImage',=0A=
=0A=
      /**=0A=
       * This function resizes the image by the options size when the =
image has not yet loaded. If the image has loaded, we=0A=
       * force the update of the size again.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _resizeImage() {=0A=
        var force =3D false;=0A=
        if (!this.imageObj.width || !this.imageObj.height) {=0A=
          // undefined or 0=0A=
          this.imageLoaded =3D false;=0A=
        } else if (this.imageLoaded =3D=3D=3D false) {=0A=
          this.imageLoaded =3D true;=0A=
          force =3D true;=0A=
        }=0A=
=0A=
        if (!this.width || !this.height || force =3D=3D=3D true) {=0A=
          // undefined or 0=0A=
          var width, height, ratio;=0A=
          if (this.imageObj.width && this.imageObj.height) {=0A=
            // not undefined or 0=0A=
            width =3D 0;=0A=
            height =3D 0;=0A=
          }=0A=
          if (this.options.shapeProperties.useImageSize =3D=3D=3D false) =
{=0A=
            if (this.imageObj.width > this.imageObj.height) {=0A=
              ratio =3D this.imageObj.width / this.imageObj.height;=0A=
              width =3D this.options.size * 2 * ratio || =
this.imageObj.width;=0A=
              height =3D this.options.size * 2 || this.imageObj.height;=0A=
            } else {=0A=
              if (this.imageObj.width && this.imageObj.height) {=0A=
                // not undefined or 0=0A=
                ratio =3D this.imageObj.height / this.imageObj.width;=0A=
              } else {=0A=
                ratio =3D 1;=0A=
              }=0A=
              width =3D this.options.size * 2;=0A=
              height =3D this.options.size * 2 * ratio;=0A=
            }=0A=
          } else {=0A=
            // when not using the size property, we use the image size=0A=
            width =3D this.imageObj.width;=0A=
            height =3D this.imageObj.height;=0A=
          }=0A=
          this.width =3D width;=0A=
          this.height =3D height;=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_drawRawCircle',=0A=
      value: function _drawRawCircle(ctx, x, y, selected, hover, size) {=0A=
        var borderWidth =3D this.options.borderWidth;=0A=
        var selectionLineWidth =3D this.options.borderWidthSelected || 2 =
* this.options.borderWidth;=0A=
=0A=
        ctx.strokeStyle =3D selected ? =
this.options.color.highlight.border : hover ? =
this.options.color.hover.border : this.options.color.border;=0A=
=0A=
        ctx.lineWidth =3D selected ? selectionLineWidth : borderWidth;=0A=
        ctx.lineWidth *=3D this.networkScaleInv;=0A=
        ctx.lineWidth =3D Math.min(this.width, ctx.lineWidth);=0A=
        ctx.fillStyle =3D selected ? =
this.options.color.highlight.background : hover ? =
this.options.color.hover.background : this.options.color.background;=0A=
        ctx.circle(x, y, size);=0A=
=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        // draw the background=0A=
        ctx.fill();=0A=
        // disable shadows for other elements.=0A=
        this.disableShadow(ctx);=0A=
=0A=
        //draw dashed border if enabled, save and restore is required =
for firefox not to crash on unix.=0A=
        ctx.save();=0A=
        this.enableBorderDashes(ctx);=0A=
        //draw the border=0A=
        ctx.stroke();=0A=
        //disable dashed border for other elements=0A=
        this.disableBorderDashes(ctx);=0A=
        ctx.restore();=0A=
      }=0A=
    }, {=0A=
      key: '_drawImageAtPosition',=0A=
      value: function _drawImageAtPosition(ctx) {=0A=
        if (this.imageObj.width !=3D 0) {=0A=
          // draw the image=0A=
          ctx.globalAlpha =3D 1.0;=0A=
=0A=
          // draw shadow if enabled=0A=
          this.enableShadow(ctx);=0A=
=0A=
          // draw image=0A=
          ctx.drawImage(this.imageObj, this.left, this.top, this.width, =
this.height);=0A=
=0A=
          // disable shadows for other elements.=0A=
          this.disableShadow(ctx);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_drawImageLabel',=0A=
      value: function _drawImageLabel(ctx, x, y, selected) {=0A=
        var yLabel;=0A=
        var offset =3D 0;=0A=
=0A=
        if (this.height !=3D=3D undefined) {=0A=
          offset =3D this.height * 0.5;=0A=
          var labelDimensions =3D this.labelModule.getTextSize(ctx);=0A=
          if (labelDimensions.lineCount >=3D 1) {=0A=
            offset +=3D labelDimensions.height / 2;=0A=
          }=0A=
        }=0A=
=0A=
        yLabel =3D y + offset;=0A=
=0A=
        if (this.options.label) {=0A=
          this.labelOffset =3D offset;=0A=
        }=0A=
        this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');=0A=
      }=0A=
    }]);=0A=
=0A=
    return CircleImageBase;=0A=
  })(_utilNodeBase2['default']);=0A=
=0A=
  exports['default'] =3D CircleImageBase;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 68 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilCircleImageBase =3D __webpack_require__(67);=0A=
=0A=
  var _utilCircleImageBase2 =3D =
_interopRequireDefault(_utilCircleImageBase);=0A=
=0A=
  var CircularImage =3D (function (_CircleImageBase) {=0A=
    _inherits(CircularImage, _CircleImageBase);=0A=
=0A=
    function CircularImage(options, body, labelModule, imageObj) {=0A=
      _classCallCheck(this, CircularImage);=0A=
=0A=
      _get(Object.getPrototypeOf(CircularImage.prototype), =
'constructor', this).call(this, options, body, labelModule);=0A=
      this.imageObj =3D imageObj;=0A=
      this._swapToImageResizeWhenImageLoaded =3D true;=0A=
    }=0A=
=0A=
    _createClass(CircularImage, [{=0A=
      key: 'resize',=0A=
      value: function resize() {=0A=
        if (this.imageObj.src =3D=3D=3D undefined || this.imageObj.width =
=3D=3D=3D undefined || this.imageObj.height =3D=3D=3D undefined) {=0A=
          if (!this.width) {=0A=
            var diameter =3D this.options.size * 2;=0A=
            this.width =3D diameter;=0A=
            this.height =3D diameter;=0A=
            this._swapToImageResizeWhenImageLoaded =3D true;=0A=
            this.radius =3D 0.5 * this.width;=0A=
          }=0A=
        } else {=0A=
          if (this._swapToImageResizeWhenImageLoaded) {=0A=
            this.width =3D undefined;=0A=
            this.height =3D undefined;=0A=
            this._swapToImageResizeWhenImageLoaded =3D false;=0A=
          }=0A=
          this._resizeImage();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize();=0A=
=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        var size =3D Math.min(0.5 * this.height, 0.5 * this.width);=0A=
=0A=
        // draw the backgroun circle. IMPORTANT: the stroke in this =
method is used by the clip method below.=0A=
        this._drawRawCircle(ctx, x, y, selected, hover, size);=0A=
=0A=
        // now we draw in the cicle, we save so we can revert the clip =
operation after drawing.=0A=
        ctx.save();=0A=
        // clip is used to use the stroke in drawRawCircle as an area =
that we can draw in.=0A=
        ctx.clip();=0A=
        // draw the image=0A=
        this._drawImageAtPosition(ctx);=0A=
        // restore so we can again draw on the full canvas=0A=
        ctx.restore();=0A=
=0A=
        this._drawImageLabel(ctx, x, y, selected);=0A=
=0A=
        this.updateBoundingBox(x, y);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y) {=0A=
        this.boundingBox.top =3D y - this.options.size;=0A=
        this.boundingBox.left =3D x - this.options.size;=0A=
        this.boundingBox.right =3D x + this.options.size;=0A=
        this.boundingBox.bottom =3D y + this.options.size;=0A=
        this.boundingBox.left =3D Math.min(this.boundingBox.left, =
this.labelModule.size.left);=0A=
        this.boundingBox.right =3D Math.max(this.boundingBox.right, =
this.labelModule.size.left + this.labelModule.size.width);=0A=
        this.boundingBox.bottom =3D Math.max(this.boundingBox.bottom, =
this.boundingBox.bottom + this.labelOffset);=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return CircularImage;=0A=
  })(_utilCircleImageBase2['default']);=0A=
=0A=
  exports['default'] =3D CircularImage;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 69 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilNodeBase =3D __webpack_require__(65);=0A=
=0A=
  var _utilNodeBase2 =3D _interopRequireDefault(_utilNodeBase);=0A=
=0A=
  var Database =3D (function (_NodeBase) {=0A=
    _inherits(Database, _NodeBase);=0A=
=0A=
    function Database(options, body, labelModule) {=0A=
      _classCallCheck(this, Database);=0A=
=0A=
      _get(Object.getPrototypeOf(Database.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Database, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx, selected) {=0A=
        if (this.width =3D=3D=3D undefined) {=0A=
          var margin =3D 5;=0A=
          var textSize =3D this.labelModule.getTextSize(ctx, selected);=0A=
          var size =3D textSize.width + 2 * margin;=0A=
          this.width =3D size;=0A=
          this.height =3D size;=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize(ctx, selected);=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        var borderWidth =3D this.options.borderWidth;=0A=
        var selectionLineWidth =3D this.options.borderWidthSelected || 2 =
* this.options.borderWidth;=0A=
=0A=
        ctx.strokeStyle =3D selected ? =
this.options.color.highlight.border : hover ? =
this.options.color.hover.border : this.options.color.border;=0A=
        ctx.lineWidth =3D this.selected ? selectionLineWidth : =
borderWidth;=0A=
        ctx.lineWidth *=3D this.networkScaleInv;=0A=
        ctx.lineWidth =3D Math.min(this.width, ctx.lineWidth);=0A=
=0A=
        ctx.fillStyle =3D selected ? =
this.options.color.highlight.background : hover ? =
this.options.color.hover.background : this.options.color.background;=0A=
        ctx.database(x - this.width / 2, y - this.height * 0.5, =
this.width, this.height);=0A=
=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        // draw the background=0A=
        ctx.fill();=0A=
        // disable shadows for other elements.=0A=
        this.disableShadow(ctx);=0A=
=0A=
        //draw dashed border if enabled, save and restore is required =
for firefox not to crash on unix.=0A=
        ctx.save();=0A=
        this.enableBorderDashes(ctx);=0A=
        //draw the border=0A=
        ctx.stroke();=0A=
        //disable dashed border for other elements=0A=
        this.disableBorderDashes(ctx);=0A=
        ctx.restore();=0A=
=0A=
        this.updateBoundingBox(x, y, ctx, selected);=0A=
        this.labelModule.draw(ctx, x, y, selected);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y, ctx, selected) {=0A=
        this.resize(ctx, selected);=0A=
=0A=
        this.left =3D x - this.width * 0.5;=0A=
        this.top =3D y - this.height * 0.5;=0A=
=0A=
        this.boundingBox.left =3D this.left;=0A=
        this.boundingBox.top =3D this.top;=0A=
        this.boundingBox.bottom =3D this.top + this.height;=0A=
        this.boundingBox.right =3D this.left + this.width;=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        var a =3D this.width / 2;=0A=
        var b =3D this.height / 2;=0A=
        var w =3D Math.sin(angle) * a;=0A=
        var h =3D Math.cos(angle) * b;=0A=
        return a * b / Math.sqrt(w * w + h * h);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Database;=0A=
  })(_utilNodeBase2['default']);=0A=
=0A=
  exports['default'] =3D Database;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 70 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilShapeBase =3D __webpack_require__(71);=0A=
=0A=
  var _utilShapeBase2 =3D _interopRequireDefault(_utilShapeBase);=0A=
=0A=
  var Diamond =3D (function (_ShapeBase) {=0A=
    _inherits(Diamond, _ShapeBase);=0A=
=0A=
    function Diamond(options, body, labelModule) {=0A=
      _classCallCheck(this, Diamond);=0A=
=0A=
      _get(Object.getPrototypeOf(Diamond.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Diamond, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx) {=0A=
        this._resizeShape();=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this._drawShape(ctx, 'diamond', 4, x, y, selected, hover);=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Diamond;=0A=
  })(_utilShapeBase2['default']);=0A=
=0A=
  exports['default'] =3D Diamond;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 71 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilNodeBase =3D __webpack_require__(65);=0A=
=0A=
  var _utilNodeBase2 =3D _interopRequireDefault(_utilNodeBase);=0A=
=0A=
  var ShapeBase =3D (function (_NodeBase) {=0A=
    _inherits(ShapeBase, _NodeBase);=0A=
=0A=
    function ShapeBase(options, body, labelModule) {=0A=
      _classCallCheck(this, ShapeBase);=0A=
=0A=
      _get(Object.getPrototypeOf(ShapeBase.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(ShapeBase, [{=0A=
      key: '_resizeShape',=0A=
      value: function _resizeShape() {=0A=
        if (this.width =3D=3D=3D undefined) {=0A=
          var size =3D 2 * this.options.size;=0A=
          this.width =3D size;=0A=
          this.height =3D size;=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_drawShape',=0A=
      value: function _drawShape(ctx, shape, sizeMultiplier, x, y, =
selected, hover) {=0A=
        this._resizeShape();=0A=
=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        var borderWidth =3D this.options.borderWidth;=0A=
        var selectionLineWidth =3D this.options.borderWidthSelected || 2 =
* this.options.borderWidth;=0A=
=0A=
        ctx.strokeStyle =3D selected ? =
this.options.color.highlight.border : hover ? =
this.options.color.hover.border : this.options.color.border;=0A=
        ctx.lineWidth =3D selected ? selectionLineWidth : borderWidth;=0A=
        ctx.lineWidth /=3D this.body.view.scale;=0A=
        ctx.lineWidth =3D Math.min(this.width, ctx.lineWidth);=0A=
        ctx.fillStyle =3D selected ? =
this.options.color.highlight.background : hover ? =
this.options.color.hover.background : this.options.color.background;=0A=
        ctx[shape](x, y, this.options.size);=0A=
=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        // draw the background=0A=
        ctx.fill();=0A=
        // disable shadows for other elements.=0A=
        this.disableShadow(ctx);=0A=
=0A=
        //draw dashed border if enabled, save and restore is required =
for firefox not to crash on unix.=0A=
        ctx.save();=0A=
        this.enableBorderDashes(ctx);=0A=
        //draw the border=0A=
        ctx.stroke();=0A=
        //disable dashed border for other elements=0A=
        this.disableBorderDashes(ctx);=0A=
        ctx.restore();=0A=
=0A=
        if (this.options.label !=3D=3D undefined) {=0A=
          var yLabel =3D y + 0.5 * this.height + 3; // the + 3 is to =
offset it a bit below the node.=0A=
          this.labelModule.draw(ctx, x, yLabel, selected, 'hanging');=0A=
        }=0A=
=0A=
        this.updateBoundingBox(x, y);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y) {=0A=
        this.boundingBox.top =3D y - this.options.size;=0A=
        this.boundingBox.left =3D x - this.options.size;=0A=
        this.boundingBox.right =3D x + this.options.size;=0A=
        this.boundingBox.bottom =3D y + this.options.size;=0A=
=0A=
        if (this.options.label !=3D=3D undefined && =
this.labelModule.size.width > 0) {=0A=
          this.boundingBox.left =3D Math.min(this.boundingBox.left, =
this.labelModule.size.left);=0A=
          this.boundingBox.right =3D Math.max(this.boundingBox.right, =
this.labelModule.size.left + this.labelModule.size.width);=0A=
          this.boundingBox.bottom =3D Math.max(this.boundingBox.bottom, =
this.boundingBox.bottom + this.labelModule.size.height + 3);=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return ShapeBase;=0A=
  })(_utilNodeBase2['default']);=0A=
=0A=
  exports['default'] =3D ShapeBase;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 72 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilShapeBase =3D __webpack_require__(71);=0A=
=0A=
  var _utilShapeBase2 =3D _interopRequireDefault(_utilShapeBase);=0A=
=0A=
  var Dot =3D (function (_ShapeBase) {=0A=
    _inherits(Dot, _ShapeBase);=0A=
=0A=
    function Dot(options, body, labelModule) {=0A=
      _classCallCheck(this, Dot);=0A=
=0A=
      _get(Object.getPrototypeOf(Dot.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Dot, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx) {=0A=
        this._resizeShape();=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this._drawShape(ctx, 'circle', 2, x, y, selected, hover);=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        return this.options.size + this.options.borderWidth;=0A=
      }=0A=
    }]);=0A=
=0A=
    return Dot;=0A=
  })(_utilShapeBase2['default']);=0A=
=0A=
  exports['default'] =3D Dot;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 73 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilNodeBase =3D __webpack_require__(65);=0A=
=0A=
  var _utilNodeBase2 =3D _interopRequireDefault(_utilNodeBase);=0A=
=0A=
  var Ellipse =3D (function (_NodeBase) {=0A=
    _inherits(Ellipse, _NodeBase);=0A=
=0A=
    function Ellipse(options, body, labelModule) {=0A=
      _classCallCheck(this, Ellipse);=0A=
=0A=
      _get(Object.getPrototypeOf(Ellipse.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Ellipse, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx, selected) {=0A=
        if (this.width =3D=3D=3D undefined) {=0A=
          var textSize =3D this.labelModule.getTextSize(ctx, selected);=0A=
=0A=
          this.width =3D textSize.width * 1.5;=0A=
          this.height =3D textSize.height * 2;=0A=
          if (this.width < this.height) {=0A=
            this.width =3D this.height;=0A=
          }=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize(ctx, selected);=0A=
        this.left =3D x - this.width * 0.5;=0A=
        this.top =3D y - this.height * 0.5;=0A=
=0A=
        var borderWidth =3D this.options.borderWidth;=0A=
        var selectionLineWidth =3D this.options.borderWidthSelected || 2 =
* this.options.borderWidth;=0A=
=0A=
        ctx.strokeStyle =3D selected ? =
this.options.color.highlight.border : hover ? =
this.options.color.hover.border : this.options.color.border;=0A=
=0A=
        ctx.lineWidth =3D selected ? selectionLineWidth : borderWidth;=0A=
        ctx.lineWidth /=3D this.body.view.scale;=0A=
        ctx.lineWidth =3D Math.min(this.width, ctx.lineWidth);=0A=
=0A=
        ctx.fillStyle =3D selected ? =
this.options.color.highlight.background : hover ? =
this.options.color.hover.background : this.options.color.background;=0A=
        ctx.ellipse(this.left, this.top, this.width, this.height);=0A=
=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        // draw the background=0A=
        ctx.fill();=0A=
        // disable shadows for other elements.=0A=
        this.disableShadow(ctx);=0A=
=0A=
        //draw dashed border if enabled, save and restore is required =
for firefox not to crash on unix.=0A=
        ctx.save();=0A=
        this.enableBorderDashes(ctx);=0A=
        //draw the border=0A=
        ctx.stroke();=0A=
        //disable dashed border for other elements=0A=
        this.disableBorderDashes(ctx);=0A=
        ctx.restore();=0A=
=0A=
        this.updateBoundingBox(x, y, ctx, selected);=0A=
        this.labelModule.draw(ctx, x, y, selected);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y, ctx, selected) {=0A=
        this.resize(ctx, selected); // just in case=0A=
=0A=
        this.left =3D x - this.width * 0.5;=0A=
        this.top =3D y - this.height * 0.5;=0A=
=0A=
        this.boundingBox.left =3D this.left;=0A=
        this.boundingBox.top =3D this.top;=0A=
        this.boundingBox.bottom =3D this.top + this.height;=0A=
        this.boundingBox.right =3D this.left + this.width;=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        var a =3D this.width * 0.5;=0A=
        var b =3D this.height * 0.5;=0A=
        var w =3D Math.sin(angle) * a;=0A=
        var h =3D Math.cos(angle) * b;=0A=
        return a * b / Math.sqrt(w * w + h * h);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Ellipse;=0A=
  })(_utilNodeBase2['default']);=0A=
=0A=
  exports['default'] =3D Ellipse;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 74 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilNodeBase =3D __webpack_require__(65);=0A=
=0A=
  var _utilNodeBase2 =3D _interopRequireDefault(_utilNodeBase);=0A=
=0A=
  var Icon =3D (function (_NodeBase) {=0A=
    _inherits(Icon, _NodeBase);=0A=
=0A=
    function Icon(options, body, labelModule) {=0A=
      _classCallCheck(this, Icon);=0A=
=0A=
      _get(Object.getPrototypeOf(Icon.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Icon, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx) {=0A=
        if (this.width =3D=3D=3D undefined) {=0A=
          var margin =3D 5;=0A=
          var iconSize =3D {=0A=
            width: Number(this.options.icon.size),=0A=
            height: Number(this.options.icon.size)=0A=
          };=0A=
          this.width =3D iconSize.width + 2 * margin;=0A=
          this.height =3D iconSize.height + 2 * margin;=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize(ctx);=0A=
        this.options.icon.size =3D this.options.icon.size || 50;=0A=
=0A=
        this.left =3D x - this.width * 0.5;=0A=
        this.top =3D y - this.height * 0.5;=0A=
        this._icon(ctx, x, y, selected);=0A=
=0A=
        if (this.options.label !=3D=3D undefined) {=0A=
          var iconTextSpacing =3D 5;=0A=
          this.labelModule.draw(ctx, x, y + this.height * 0.5 + =
iconTextSpacing, selected);=0A=
        }=0A=
=0A=
        this.updateBoundingBox(x, y);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y) {=0A=
        this.boundingBox.top =3D y - this.options.icon.size * 0.5;=0A=
        this.boundingBox.left =3D x - this.options.icon.size * 0.5;=0A=
        this.boundingBox.right =3D x + this.options.icon.size * 0.5;=0A=
        this.boundingBox.bottom =3D y + this.options.icon.size * 0.5;=0A=
=0A=
        if (this.options.label !=3D=3D undefined && =
this.labelModule.size.width > 0) {=0A=
          var iconTextSpacing =3D 5;=0A=
          this.boundingBox.left =3D Math.min(this.boundingBox.left, =
this.labelModule.size.left);=0A=
          this.boundingBox.right =3D Math.max(this.boundingBox.right, =
this.labelModule.size.left + this.labelModule.size.width);=0A=
          this.boundingBox.bottom =3D Math.max(this.boundingBox.bottom, =
this.boundingBox.bottom + this.labelModule.size.height + =
iconTextSpacing);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_icon',=0A=
      value: function _icon(ctx, x, y, selected) {=0A=
        var iconSize =3D Number(this.options.icon.size);=0A=
=0A=
        if (this.options.icon.code !=3D=3D undefined) {=0A=
          ctx.font =3D (selected ? 'bold ' : '') + iconSize + 'px ' + =
this.options.icon.face;=0A=
=0A=
          // draw icon=0A=
          ctx.fillStyle =3D this.options.icon.color || 'black';=0A=
          ctx.textAlign =3D 'center';=0A=
          ctx.textBaseline =3D 'middle';=0A=
=0A=
          // draw shadow if enabled=0A=
          this.enableShadow(ctx);=0A=
          ctx.fillText(this.options.icon.code, x, y);=0A=
=0A=
          // disable shadows for other elements.=0A=
          this.disableShadow(ctx);=0A=
        } else {=0A=
          console.error('When using the icon shape, you need to define =
the code in the icon options object. This can be done per node or =
globally.');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Icon;=0A=
  })(_utilNodeBase2['default']);=0A=
=0A=
  exports['default'] =3D Icon;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 75 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilCircleImageBase =3D __webpack_require__(67);=0A=
=0A=
  var _utilCircleImageBase2 =3D =
_interopRequireDefault(_utilCircleImageBase);=0A=
=0A=
  var Image =3D (function (_CircleImageBase) {=0A=
    _inherits(Image, _CircleImageBase);=0A=
=0A=
    function Image(options, body, labelModule, imageObj) {=0A=
      _classCallCheck(this, Image);=0A=
=0A=
      _get(Object.getPrototypeOf(Image.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
      this.imageObj =3D imageObj;=0A=
    }=0A=
=0A=
    _createClass(Image, [{=0A=
      key: 'resize',=0A=
      value: function resize() {=0A=
        this._resizeImage();=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize();=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        this._drawImageAtPosition(ctx);=0A=
=0A=
        this._drawImageLabel(ctx, x, y, selected || hover);=0A=
=0A=
        this.updateBoundingBox(x, y);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y) {=0A=
        this.resize();=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        this.boundingBox.top =3D this.top;=0A=
        this.boundingBox.left =3D this.left;=0A=
        this.boundingBox.right =3D this.left + this.width;=0A=
        this.boundingBox.bottom =3D this.top + this.height;=0A=
=0A=
        if (this.options.label !=3D=3D undefined && =
this.labelModule.size.width > 0) {=0A=
          this.boundingBox.left =3D Math.min(this.boundingBox.left, =
this.labelModule.size.left);=0A=
          this.boundingBox.right =3D Math.max(this.boundingBox.right, =
this.labelModule.size.left + this.labelModule.size.width);=0A=
          this.boundingBox.bottom =3D Math.max(this.boundingBox.bottom, =
this.boundingBox.bottom + this.labelOffset);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        var a =3D this.width / 2;=0A=
        var b =3D this.height / 2;=0A=
        var w =3D Math.sin(angle) * a;=0A=
        var h =3D Math.cos(angle) * b;=0A=
        return a * b / Math.sqrt(w * w + h * h);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Image;=0A=
  })(_utilCircleImageBase2['default']);=0A=
=0A=
  exports['default'] =3D Image;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 76 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilShapeBase =3D __webpack_require__(71);=0A=
=0A=
  var _utilShapeBase2 =3D _interopRequireDefault(_utilShapeBase);=0A=
=0A=
  var Square =3D (function (_ShapeBase) {=0A=
    _inherits(Square, _ShapeBase);=0A=
=0A=
    function Square(options, body, labelModule) {=0A=
      _classCallCheck(this, Square);=0A=
=0A=
      _get(Object.getPrototypeOf(Square.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Square, [{=0A=
      key: 'resize',=0A=
      value: function resize() {=0A=
        this._resizeShape();=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this._drawShape(ctx, 'square', 2, x, y, selected, hover);=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize();=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Square;=0A=
  })(_utilShapeBase2['default']);=0A=
=0A=
  exports['default'] =3D Square;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 77 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilShapeBase =3D __webpack_require__(71);=0A=
=0A=
  var _utilShapeBase2 =3D _interopRequireDefault(_utilShapeBase);=0A=
=0A=
  var Star =3D (function (_ShapeBase) {=0A=
    _inherits(Star, _ShapeBase);=0A=
=0A=
    function Star(options, body, labelModule) {=0A=
      _classCallCheck(this, Star);=0A=
=0A=
      _get(Object.getPrototypeOf(Star.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Star, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx) {=0A=
        this._resizeShape();=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this._drawShape(ctx, 'star', 4, x, y, selected, hover);=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Star;=0A=
  })(_utilShapeBase2['default']);=0A=
=0A=
  exports['default'] =3D Star;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 78 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilNodeBase =3D __webpack_require__(65);=0A=
=0A=
  var _utilNodeBase2 =3D _interopRequireDefault(_utilNodeBase);=0A=
=0A=
  var Text =3D (function (_NodeBase) {=0A=
    _inherits(Text, _NodeBase);=0A=
=0A=
    function Text(options, body, labelModule) {=0A=
      _classCallCheck(this, Text);=0A=
=0A=
      _get(Object.getPrototypeOf(Text.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Text, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx, selected) {=0A=
        if (this.width =3D=3D=3D undefined) {=0A=
          var margin =3D 5;=0A=
          var textSize =3D this.labelModule.getTextSize(ctx, selected);=0A=
          this.width =3D textSize.width + 2 * margin;=0A=
          this.height =3D textSize.height + 2 * margin;=0A=
          this.radius =3D 0.5 * this.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this.resize(ctx, selected || hover);=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        this.labelModule.draw(ctx, x, y, selected || hover);=0A=
=0A=
        // disable shadows for other elements.=0A=
        this.disableShadow(ctx);=0A=
=0A=
        this.updateBoundingBox(x, y, ctx, selected);=0A=
      }=0A=
    }, {=0A=
      key: 'updateBoundingBox',=0A=
      value: function updateBoundingBox(x, y, ctx, selected) {=0A=
        this.resize(ctx, selected);=0A=
=0A=
        this.left =3D x - this.width / 2;=0A=
        this.top =3D y - this.height / 2;=0A=
=0A=
        this.boundingBox.top =3D this.top;=0A=
        this.boundingBox.left =3D this.left;=0A=
        this.boundingBox.right =3D this.left + this.width;=0A=
        this.boundingBox.bottom =3D this.top + this.height;=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        this.resize(ctx);=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Text;=0A=
  })(_utilNodeBase2['default']);=0A=
=0A=
  exports['default'] =3D Text;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 79 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilShapeBase =3D __webpack_require__(71);=0A=
=0A=
  var _utilShapeBase2 =3D _interopRequireDefault(_utilShapeBase);=0A=
=0A=
  var Triangle =3D (function (_ShapeBase) {=0A=
    _inherits(Triangle, _ShapeBase);=0A=
=0A=
    function Triangle(options, body, labelModule) {=0A=
      _classCallCheck(this, Triangle);=0A=
=0A=
      _get(Object.getPrototypeOf(Triangle.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(Triangle, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx) {=0A=
        this._resizeShape();=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this._drawShape(ctx, 'triangle', 3, x, y, selected, hover);=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return Triangle;=0A=
  })(_utilShapeBase2['default']);=0A=
=0A=
  exports['default'] =3D Triangle;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 80 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilShapeBase =3D __webpack_require__(71);=0A=
=0A=
  var _utilShapeBase2 =3D _interopRequireDefault(_utilShapeBase);=0A=
=0A=
  var TriangleDown =3D (function (_ShapeBase) {=0A=
    _inherits(TriangleDown, _ShapeBase);=0A=
=0A=
    function TriangleDown(options, body, labelModule) {=0A=
      _classCallCheck(this, TriangleDown);=0A=
=0A=
      _get(Object.getPrototypeOf(TriangleDown.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(TriangleDown, [{=0A=
      key: 'resize',=0A=
      value: function resize(ctx) {=0A=
        this._resizeShape();=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
      value: function draw(ctx, x, y, selected, hover) {=0A=
        this._drawShape(ctx, 'triangleDown', 3, x, y, selected, hover);=0A=
      }=0A=
    }, {=0A=
      key: 'distanceToBorder',=0A=
      value: function distanceToBorder(ctx, angle) {=0A=
        return this._distanceToBorder(angle);=0A=
      }=0A=
    }]);=0A=
=0A=
    return TriangleDown;=0A=
  })(_utilShapeBase2['default']);=0A=
=0A=
  exports['default'] =3D TriangleDown;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 81 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _componentsEdge =3D __webpack_require__(82);=0A=
=0A=
  var _componentsEdge2 =3D _interopRequireDefault(_componentsEdge);=0A=
=0A=
  var _componentsSharedLabel =3D __webpack_require__(63);=0A=
=0A=
  var _componentsSharedLabel2 =3D =
_interopRequireDefault(_componentsSharedLabel);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var DataSet =3D __webpack_require__(14);=0A=
  var DataView =3D __webpack_require__(16);=0A=
=0A=
  var EdgesHandler =3D (function () {=0A=
    function EdgesHandler(body, images, groups) {=0A=
      var _this =3D this;=0A=
=0A=
      _classCallCheck(this, EdgesHandler);=0A=
=0A=
      this.body =3D body;=0A=
      this.images =3D images;=0A=
      this.groups =3D groups;=0A=
=0A=
      // create the edge API in the body container=0A=
      this.body.functions.createEdge =3D this.create.bind(this);=0A=
=0A=
      this.edgesListeners =3D {=0A=
        add: function add(event, params) {=0A=
          _this.add(params.items);=0A=
        },=0A=
        update: function update(event, params) {=0A=
          _this.update(params.items);=0A=
        },=0A=
        remove: function remove(event, params) {=0A=
          _this.remove(params.items);=0A=
        }=0A=
      };=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        arrows: {=0A=
          to: { enabled: false, scaleFactor: 1 }, // boolean / =
{arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}=0A=
          middle: { enabled: false, scaleFactor: 1 },=0A=
          from: { enabled: false, scaleFactor: 1 }=0A=
        },=0A=
        color: {=0A=
          color: '#848484',=0A=
          highlight: '#848484',=0A=
          hover: '#848484',=0A=
          inherit: 'from',=0A=
          opacity: 1.0=0A=
        },=0A=
        dashes: false,=0A=
        font: {=0A=
          color: '#343434',=0A=
          size: 14, // px=0A=
          face: 'arial',=0A=
          background: 'none',=0A=
          strokeWidth: 2, // px=0A=
          strokeColor: '#ffffff',=0A=
          align: 'horizontal'=0A=
        },=0A=
        hidden: false,=0A=
        hoverWidth: 1.5,=0A=
        label: undefined,=0A=
        labelHighlightBold: true,=0A=
        length: undefined,=0A=
        physics: true,=0A=
        scaling: {=0A=
          min: 1,=0A=
          max: 15,=0A=
          label: {=0A=
            enabled: true,=0A=
            min: 14,=0A=
            max: 30,=0A=
            maxVisible: 30,=0A=
            drawThreshold: 5=0A=
          },=0A=
          customScalingFunction: function customScalingFunction(min, =
max, total, value) {=0A=
            if (max =3D=3D=3D min) {=0A=
              return 0.5;=0A=
            } else {=0A=
              var scale =3D 1 / (max - min);=0A=
              return Math.max(0, (value - min) * scale);=0A=
            }=0A=
          }=0A=
        },=0A=
        selectionWidth: 1.5,=0A=
        selfReferenceSize: 20,=0A=
        shadow: {=0A=
          enabled: false,=0A=
          size: 10,=0A=
          x: 5,=0A=
          y: 5=0A=
        },=0A=
        smooth: {=0A=
          enabled: true,=0A=
          type: 'dynamic',=0A=
          forceDirection: 'none',=0A=
          roundness: 0.5=0A=
        },=0A=
        title: undefined,=0A=
        width: 1,=0A=
        value: undefined=0A=
      };=0A=
=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.bindEventListeners();=0A=
    }=0A=
=0A=
    _createClass(EdgesHandler, [{=0A=
      key: 'bindEventListeners',=0A=
      value: function bindEventListeners() {=0A=
        var _this2 =3D this;=0A=
=0A=
        // this allows external modules to force all dynamic curves to =
turn static.=0A=
        this.body.emitter.on('_forceDisableDynamicCurves', function =
(type) {=0A=
          if (type =3D=3D=3D 'dynamic') {=0A=
            type =3D 'continuous';=0A=
          }=0A=
          var emitChange =3D false;=0A=
          for (var edgeId in _this2.body.edges) {=0A=
            if (_this2.body.edges.hasOwnProperty(edgeId)) {=0A=
              var edge =3D _this2.body.edges[edgeId];=0A=
              var edgeData =3D _this2.body.data.edges._data[edgeId];=0A=
=0A=
              // only forcilby remove the smooth curve if the data has =
been set of the edge has the smooth curves defined.=0A=
              // this is because a change in the global would not affect =
these curves.=0A=
              if (edgeData !=3D=3D undefined) {=0A=
                var edgeOptions =3D edgeData.smooth;=0A=
                if (edgeOptions !=3D=3D undefined) {=0A=
                  if (edgeOptions.enabled =3D=3D=3D true && =
edgeOptions.type =3D=3D=3D 'dynamic') {=0A=
                    if (type =3D=3D=3D undefined) {=0A=
                      edge.setOptions({ smooth: false });=0A=
                    } else {=0A=
                      edge.setOptions({ smooth: { type: type } });=0A=
                    }=0A=
                    emitChange =3D true;=0A=
                  }=0A=
                }=0A=
              }=0A=
            }=0A=
          }=0A=
          if (emitChange =3D=3D=3D true) {=0A=
            _this2.body.emitter.emit('_dataChanged');=0A=
          }=0A=
        });=0A=
=0A=
        // this is called when options of EXISTING nodes or edges have =
changed.=0A=
        this.body.emitter.on('_dataUpdated', function () {=0A=
          _this2.reconnectEdges();=0A=
          _this2.markAllEdgesAsDirty();=0A=
        });=0A=
=0A=
        // refresh the edges. Used when reverting from hierarchical =
layout=0A=
        this.body.emitter.on('refreshEdges', this.refresh.bind(this));=0A=
        this.body.emitter.on('refresh', this.refresh.bind(this));=0A=
        this.body.emitter.on('destroy', function () {=0A=
          delete _this2.body.functions.createEdge;=0A=
          delete _this2.edgesListeners.add;=0A=
          delete _this2.edgesListeners.update;=0A=
          delete _this2.edgesListeners.remove;=0A=
          delete _this2.edgesListeners;=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          // use the parser from the Edge class to fill in all shorthand =
notations=0A=
          _componentsEdge2['default'].parseOptions(this.options, =
options);=0A=
=0A=
          // hanlde multiple input cases for color=0A=
          if (options.color !=3D=3D undefined) {=0A=
            this.markAllEdgesAsDirty();=0A=
          }=0A=
=0A=
          // update smooth settings in all edges=0A=
          var dataChanged =3D false;=0A=
          if (options.smooth !=3D=3D undefined) {=0A=
            for (var edgeId in this.body.edges) {=0A=
              if (this.body.edges.hasOwnProperty(edgeId)) {=0A=
                dataChanged =3D this.body.edges[edgeId].updateEdgeType() =
|| dataChanged;=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          // update fonts in all edges=0A=
          if (options.font !=3D=3D undefined) {=0A=
            // use the parser from the Label class to fill in all =
shorthand notations=0A=
            =
_componentsSharedLabel2['default'].parseOptions(this.options.font, =
options);=0A=
            for (var edgeId in this.body.edges) {=0A=
              if (this.body.edges.hasOwnProperty(edgeId)) {=0A=
                this.body.edges[edgeId].updateLabelModule();=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          // update the state of the variables if needed=0A=
          if (options.hidden !=3D=3D undefined || options.physics =
!=3D=3D undefined || dataChanged =3D=3D=3D true) {=0A=
            this.body.emitter.emit('_dataChanged');=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'setData',=0A=
=0A=
      /**=0A=
       * Load edges by reading the data table=0A=
       * @param {Array | DataSet | DataView} edges    The data =
containing the edges.=0A=
       * @private=0A=
       * @private=0A=
       */=0A=
      value: function setData(edges) {=0A=
        var _this3 =3D this;=0A=
=0A=
        var doNotEmit =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        var oldEdgesData =3D this.body.data.edges;=0A=
=0A=
        if (edges instanceof DataSet || edges instanceof DataView) {=0A=
          this.body.data.edges =3D edges;=0A=
        } else if (Array.isArray(edges)) {=0A=
          this.body.data.edges =3D new DataSet();=0A=
          this.body.data.edges.add(edges);=0A=
        } else if (!edges) {=0A=
          this.body.data.edges =3D new DataSet();=0A=
        } else {=0A=
          throw new TypeError('Array or DataSet expected');=0A=
        }=0A=
=0A=
        // TODO: is this null or undefined or false?=0A=
        if (oldEdgesData) {=0A=
          // unsubscribe from old dataset=0A=
          util.forEach(this.edgesListeners, function (callback, event) {=0A=
            oldEdgesData.off(event, callback);=0A=
          });=0A=
        }=0A=
=0A=
        // remove drawn edges=0A=
        this.body.edges =3D {};=0A=
=0A=
        // TODO: is this null or undefined or false?=0A=
        if (this.body.data.edges) {=0A=
          // subscribe to new dataset=0A=
          util.forEach(this.edgesListeners, function (callback, event) {=0A=
            _this3.body.data.edges.on(event, callback);=0A=
          });=0A=
=0A=
          // draw all new nodes=0A=
          var ids =3D this.body.data.edges.getIds();=0A=
          this.add(ids, true);=0A=
        }=0A=
=0A=
        if (doNotEmit =3D=3D=3D false) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'add',=0A=
=0A=
      /**=0A=
       * Add edges=0A=
       * @param {Number[] | String[]} ids=0A=
       * @private=0A=
       */=0A=
      value: function add(ids) {=0A=
        var doNotEmit =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        var edges =3D this.body.edges;=0A=
        var edgesData =3D this.body.data.edges;=0A=
=0A=
        for (var i =3D 0; i < ids.length; i++) {=0A=
          var id =3D ids[i];=0A=
=0A=
          var oldEdge =3D edges[id];=0A=
          if (oldEdge) {=0A=
            oldEdge.disconnect();=0A=
          }=0A=
=0A=
          var data =3D edgesData.get(id, { 'showInternalIds': true });=0A=
          edges[id] =3D this.create(data);=0A=
        }=0A=
=0A=
        if (doNotEmit =3D=3D=3D false) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'update',=0A=
=0A=
      /**=0A=
       * Update existing edges, or create them when not yet existing=0A=
       * @param {Number[] | String[]} ids=0A=
       * @private=0A=
       */=0A=
      value: function update(ids) {=0A=
        var edges =3D this.body.edges;=0A=
        var edgesData =3D this.body.data.edges;=0A=
        var dataChanged =3D false;=0A=
        for (var i =3D 0; i < ids.length; i++) {=0A=
          var id =3D ids[i];=0A=
          var data =3D edgesData.get(id);=0A=
          var edge =3D edges[id];=0A=
          if (edge !=3D=3D undefined) {=0A=
            // update edge=0A=
            edge.disconnect();=0A=
            dataChanged =3D edge.setOptions(data) || dataChanged; // if =
a support node is added, data can be changed.=0A=
            edge.connect();=0A=
          } else {=0A=
            // create edge=0A=
            this.body.edges[id] =3D this.create(data);=0A=
            dataChanged =3D true;=0A=
          }=0A=
        }=0A=
=0A=
        if (dataChanged =3D=3D=3D true) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        } else {=0A=
          this.body.emitter.emit('_dataUpdated');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'remove',=0A=
=0A=
      /**=0A=
       * Remove existing edges. Non existing ids will be ignored=0A=
       * @param {Number[] | String[]} ids=0A=
       * @private=0A=
       */=0A=
      value: function remove(ids) {=0A=
        var edges =3D this.body.edges;=0A=
        for (var i =3D 0; i < ids.length; i++) {=0A=
          var id =3D ids[i];=0A=
          var edge =3D edges[id];=0A=
          if (edge !=3D=3D undefined) {=0A=
            edge.cleanup();=0A=
            edge.disconnect();=0A=
            delete edges[id];=0A=
          }=0A=
        }=0A=
=0A=
        this.body.emitter.emit('_dataChanged');=0A=
      }=0A=
    }, {=0A=
      key: 'refresh',=0A=
      value: function refresh() {=0A=
        var edges =3D this.body.edges;=0A=
        for (var edgeId in edges) {=0A=
          var edge =3D undefined;=0A=
          if (edges.hasOwnProperty(edgeId)) {=0A=
            edge =3D edges[edgeId];=0A=
          }=0A=
          var data =3D this.body.data.edges._data[edgeId];=0A=
          if (edge !=3D=3D undefined && data !=3D=3D undefined) {=0A=
            edge.setOptions(data);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'create',=0A=
      value: function create(properties) {=0A=
        return new _componentsEdge2['default'](properties, this.body, =
this.options);=0A=
      }=0A=
    }, {=0A=
      key: 'markAllEdgesAsDirty',=0A=
      value: function markAllEdgesAsDirty() {=0A=
        for (var edgeId in this.body.edges) {=0A=
          this.body.edges[edgeId].edgeType.colorDirty =3D true;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'reconnectEdges',=0A=
=0A=
      /**=0A=
       * Reconnect all edges=0A=
       * @private=0A=
       */=0A=
      value: function reconnectEdges() {=0A=
        var id;=0A=
        var nodes =3D this.body.nodes;=0A=
        var edges =3D this.body.edges;=0A=
=0A=
        for (id in nodes) {=0A=
          if (nodes.hasOwnProperty(id)) {=0A=
            nodes[id].edges =3D [];=0A=
          }=0A=
        }=0A=
=0A=
        for (id in edges) {=0A=
          if (edges.hasOwnProperty(id)) {=0A=
            var edge =3D edges[id];=0A=
            edge.from =3D null;=0A=
            edge.to =3D null;=0A=
            edge.connect();=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'getConnectedNodes',=0A=
      value: function getConnectedNodes(edgeId) {=0A=
        var nodeList =3D [];=0A=
        if (this.body.edges[edgeId] !=3D=3D undefined) {=0A=
          var edge =3D this.body.edges[edgeId];=0A=
          if (edge.fromId) {=0A=
            nodeList.push(edge.fromId);=0A=
          }=0A=
          if (edge.toId) {=0A=
            nodeList.push(edge.toId);=0A=
          }=0A=
        }=0A=
        return nodeList;=0A=
      }=0A=
    }]);=0A=
=0A=
    return EdgesHandler;=0A=
  })();=0A=
=0A=
  exports['default'] =3D EdgesHandler;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 82 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _sharedLabel =3D __webpack_require__(63);=0A=
=0A=
  var _sharedLabel2 =3D _interopRequireDefault(_sharedLabel);=0A=
=0A=
  var _edgesCubicBezierEdge =3D __webpack_require__(86);=0A=
=0A=
  var _edgesCubicBezierEdge2 =3D =
_interopRequireDefault(_edgesCubicBezierEdge);=0A=
=0A=
  var _edgesBezierEdgeDynamic =3D __webpack_require__(88);=0A=
=0A=
  var _edgesBezierEdgeDynamic2 =3D =
_interopRequireDefault(_edgesBezierEdgeDynamic);=0A=
=0A=
  var _edgesBezierEdgeStatic =3D __webpack_require__(83);=0A=
=0A=
  var _edgesBezierEdgeStatic2 =3D =
_interopRequireDefault(_edgesBezierEdgeStatic);=0A=
=0A=
  var _edgesStraightEdge =3D __webpack_require__(89);=0A=
=0A=
  var _edgesStraightEdge2 =3D _interopRequireDefault(_edgesStraightEdge);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * @class Edge=0A=
   *=0A=
   * A edge connects two nodes=0A=
   * @param {Object} properties     Object with options. Must contain=0A=
   *                                At least options from and to.=0A=
   *                                Available options: from (number),=0A=
   *                                to (number), label (string, color =
(string),=0A=
   *                                width (number), style (string),=0A=
   *                                length (number), title (string)=0A=
   * @param {Network} network       A Network object, used to find and =
edge to=0A=
   *                                nodes.=0A=
   * @param {Object} constants      An object with default values for=0A=
   *                                example for the color=0A=
   */=0A=
=0A=
  var Edge =3D (function () {=0A=
    function Edge(options, body, globalOptions) {=0A=
      _classCallCheck(this, Edge);=0A=
=0A=
      if (body =3D=3D=3D undefined) {=0A=
        throw 'No body provided';=0A=
      }=0A=
      this.options =3D util.bridgeObject(globalOptions);=0A=
      this.body =3D body;=0A=
=0A=
      // initialize variables=0A=
      this.id =3D undefined;=0A=
      this.fromId =3D undefined;=0A=
      this.toId =3D undefined;=0A=
      this.selected =3D false;=0A=
      this.hover =3D false;=0A=
      this.labelDirty =3D true;=0A=
      this.colorDirty =3D true;=0A=
=0A=
      this.baseWidth =3D this.options.width;=0A=
      this.baseFontSize =3D this.options.font.size;=0A=
=0A=
      this.from =3D undefined; // a node=0A=
      this.to =3D undefined; // a node=0A=
=0A=
      this.edgeType =3D undefined;=0A=
=0A=
      this.connected =3D false;=0A=
=0A=
      this.labelModule =3D new _sharedLabel2['default'](this.body, =
this.options);=0A=
=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    _createClass(Edge, [{=0A=
      key: 'setOptions',=0A=
=0A=
      /**=0A=
       * Set or overwrite options for the edge=0A=
       * @param {Object} options  an object with options=0A=
       * @param doNotEmit=0A=
       */=0A=
      value: function setOptions(options) {=0A=
        if (!options) {=0A=
          return;=0A=
        }=0A=
        this.colorDirty =3D true;=0A=
=0A=
        Edge.parseOptions(this.options, options, true);=0A=
=0A=
        if (options.id !=3D=3D undefined) {=0A=
          this.id =3D options.id;=0A=
        }=0A=
        if (options.from !=3D=3D undefined) {=0A=
          this.fromId =3D options.from;=0A=
        }=0A=
        if (options.to !=3D=3D undefined) {=0A=
          this.toId =3D options.to;=0A=
        }=0A=
        if (options.title !=3D=3D undefined) {=0A=
          this.title =3D options.title;=0A=
        }=0A=
        if (options.value !=3D=3D undefined) {=0A=
          options.value =3D parseFloat(options.value);=0A=
        }=0A=
=0A=
        // update label Module=0A=
        this.updateLabelModule();=0A=
=0A=
        var dataChanged =3D this.updateEdgeType();=0A=
=0A=
        // if anything has been updates, reset the selection width and =
the hover width=0A=
        this._setInteractionWidths();=0A=
=0A=
        // A node is connected when it has a from and to node that both =
exist in the network.body.nodes.=0A=
        this.connect();=0A=
=0A=
        if (options.hidden !=3D=3D undefined || options.physics !=3D=3D =
undefined) {=0A=
          dataChanged =3D true;=0A=
        }=0A=
=0A=
        return dataChanged;=0A=
      }=0A=
    }, {=0A=
      key: 'updateLabelModule',=0A=
=0A=
      /**=0A=
       * update the options in the label module=0A=
       */=0A=
      value: function updateLabelModule() {=0A=
        this.labelModule.setOptions(this.options, true);=0A=
        if (this.labelModule.baseSize !=3D=3D undefined) {=0A=
          this.baseFontSize =3D this.labelModule.baseSize;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'updateEdgeType',=0A=
=0A=
      /**=0A=
       * update the edge type, set the options=0A=
       * @returns {boolean}=0A=
       */=0A=
      value: function updateEdgeType() {=0A=
        var dataChanged =3D false;=0A=
        var changeInType =3D true;=0A=
        var smooth =3D this.options.smooth;=0A=
        if (this.edgeType !=3D=3D undefined) {=0A=
          if (this.edgeType instanceof =
_edgesBezierEdgeDynamic2['default'] && smooth.enabled =3D=3D=3D true && =
smooth.type =3D=3D=3D 'dynamic') {=0A=
            changeInType =3D false;=0A=
          }=0A=
          if (this.edgeType instanceof _edgesCubicBezierEdge2['default'] =
&& smooth.enabled =3D=3D=3D true && smooth.type =3D=3D=3D 'cubicBezier') =
{=0A=
            changeInType =3D false;=0A=
          }=0A=
          if (this.edgeType instanceof =
_edgesBezierEdgeStatic2['default'] && smooth.enabled =3D=3D=3D true && =
smooth.type !=3D=3D 'dynamic' && smooth.type !=3D=3D 'cubicBezier') {=0A=
            changeInType =3D false;=0A=
          }=0A=
          if (this.edgeType instanceof _edgesStraightEdge2['default'] && =
smooth.enabled =3D=3D=3D false) {=0A=
            changeInType =3D false;=0A=
          }=0A=
=0A=
          if (changeInType =3D=3D=3D true) {=0A=
            dataChanged =3D this.cleanup();=0A=
          }=0A=
        }=0A=
=0A=
        if (changeInType =3D=3D=3D true) {=0A=
          if (this.options.smooth.enabled =3D=3D=3D true) {=0A=
            if (this.options.smooth.type =3D=3D=3D 'dynamic') {=0A=
              dataChanged =3D true;=0A=
              this.edgeType =3D new =
_edgesBezierEdgeDynamic2['default'](this.options, this.body, =
this.labelModule);=0A=
            } else if (this.options.smooth.type =3D=3D=3D 'cubicBezier') =
{=0A=
              this.edgeType =3D new =
_edgesCubicBezierEdge2['default'](this.options, this.body, =
this.labelModule);=0A=
            } else {=0A=
              this.edgeType =3D new =
_edgesBezierEdgeStatic2['default'](this.options, this.body, =
this.labelModule);=0A=
            }=0A=
          } else {=0A=
            this.edgeType =3D new =
_edgesStraightEdge2['default'](this.options, this.body, =
this.labelModule);=0A=
          }=0A=
        } else {=0A=
          // if nothing changes, we just set the options.=0A=
          this.edgeType.setOptions(this.options);=0A=
        }=0A=
=0A=
        return dataChanged;=0A=
      }=0A=
    }, {=0A=
      key: 'connect',=0A=
=0A=
      /**=0A=
       * Connect an edge to its nodes=0A=
       */=0A=
      value: function connect() {=0A=
        this.disconnect();=0A=
=0A=
        this.from =3D this.body.nodes[this.fromId] || undefined;=0A=
        this.to =3D this.body.nodes[this.toId] || undefined;=0A=
        this.connected =3D this.from !=3D=3D undefined && this.to =
!=3D=3D undefined;=0A=
=0A=
        if (this.connected =3D=3D=3D true) {=0A=
          this.from.attachEdge(this);=0A=
          this.to.attachEdge(this);=0A=
        } else {=0A=
          if (this.from) {=0A=
            this.from.detachEdge(this);=0A=
          }=0A=
          if (this.to) {=0A=
            this.to.detachEdge(this);=0A=
          }=0A=
        }=0A=
=0A=
        this.edgeType.connect();=0A=
      }=0A=
    }, {=0A=
      key: 'disconnect',=0A=
=0A=
      /**=0A=
       * Disconnect an edge from its nodes=0A=
       */=0A=
      value: function disconnect() {=0A=
        if (this.from) {=0A=
          this.from.detachEdge(this);=0A=
          this.from =3D undefined;=0A=
        }=0A=
        if (this.to) {=0A=
          this.to.detachEdge(this);=0A=
          this.to =3D undefined;=0A=
        }=0A=
=0A=
        this.connected =3D false;=0A=
      }=0A=
    }, {=0A=
      key: 'getTitle',=0A=
=0A=
      /**=0A=
       * get the title of this edge.=0A=
       * @return {string} title    The title of the edge, or undefined =
when no title=0A=
       *                           has been set.=0A=
       */=0A=
      value: function getTitle() {=0A=
        return this.title;=0A=
      }=0A=
    }, {=0A=
      key: 'isSelected',=0A=
=0A=
      /**=0A=
       * check if this node is selecte=0A=
       * @return {boolean} selected   True if node is selected, else =
false=0A=
       */=0A=
      value: function isSelected() {=0A=
        return this.selected;=0A=
      }=0A=
    }, {=0A=
      key: 'getValue',=0A=
=0A=
      /**=0A=
       * Retrieve the value of the edge. Can be undefined=0A=
       * @return {Number} value=0A=
       */=0A=
      value: function getValue() {=0A=
        return this.options.value;=0A=
      }=0A=
    }, {=0A=
      key: 'setValueRange',=0A=
=0A=
      /**=0A=
       * Adjust the value range of the edge. The edge will adjust it's =
width=0A=
       * based on its value.=0A=
       * @param {Number} min=0A=
       * @param {Number} max=0A=
       * @param total=0A=
       */=0A=
      value: function setValueRange(min, max, total) {=0A=
        if (this.options.value !=3D=3D undefined) {=0A=
          var scale =3D this.options.scaling.customScalingFunction(min, =
max, total, this.options.value);=0A=
          var widthDiff =3D this.options.scaling.max - =
this.options.scaling.min;=0A=
          if (this.options.scaling.label.enabled =3D=3D=3D true) {=0A=
            var fontDiff =3D this.options.scaling.label.max - =
this.options.scaling.label.min;=0A=
            this.options.font.size =3D this.options.scaling.label.min + =
scale * fontDiff;=0A=
          }=0A=
          this.options.width =3D this.options.scaling.min + scale * =
widthDiff;=0A=
        } else {=0A=
          this.options.width =3D this.baseWidth;=0A=
          this.options.font.size =3D this.baseFontSize;=0A=
        }=0A=
=0A=
        this._setInteractionWidths();=0A=
      }=0A=
    }, {=0A=
      key: '_setInteractionWidths',=0A=
      value: function _setInteractionWidths() {=0A=
        if (typeof this.options.hoverWidth =3D=3D=3D 'function') {=0A=
          this.edgeType.hoverWidth =3D =
this.options.hoverWidth(this.options.width);=0A=
        } else {=0A=
          this.edgeType.hoverWidth =3D this.options.hoverWidth + =
this.options.width;=0A=
        }=0A=
=0A=
        if (typeof this.options.selectionWidth =3D=3D=3D 'function') {=0A=
          this.edgeType.selectionWidth =3D =
this.options.selectionWidth(this.options.width);=0A=
        } else {=0A=
          this.edgeType.selectionWidth =3D this.options.selectionWidth + =
this.options.width;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'draw',=0A=
=0A=
      /**=0A=
       * Redraw a edge=0A=
       * Draw this edge in the given canvas=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext("2d");=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       */=0A=
      value: function draw(ctx) {=0A=
        var via =3D this.edgeType.drawLine(ctx, this.selected, =
this.hover);=0A=
        this.drawArrows(ctx, via);=0A=
        this.drawLabel(ctx, via);=0A=
      }=0A=
    }, {=0A=
      key: 'drawArrows',=0A=
      value: function drawArrows(ctx, viaNode) {=0A=
        if (this.options.arrows.from.enabled =3D=3D=3D true) {=0A=
          this.edgeType.drawArrowHead(ctx, 'from', viaNode, =
this.selected, this.hover);=0A=
        }=0A=
        if (this.options.arrows.middle.enabled =3D=3D=3D true) {=0A=
          this.edgeType.drawArrowHead(ctx, 'middle', viaNode, =
this.selected, this.hover);=0A=
        }=0A=
        if (this.options.arrows.to.enabled =3D=3D=3D true) {=0A=
          this.edgeType.drawArrowHead(ctx, 'to', viaNode, this.selected, =
this.hover);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'drawLabel',=0A=
      value: function drawLabel(ctx, viaNode) {=0A=
        if (this.options.label !=3D=3D undefined) {=0A=
          // set style=0A=
          var node1 =3D this.from;=0A=
          var node2 =3D this.to;=0A=
          var selected =3D this.from.selected || this.to.selected || =
this.selected;=0A=
          if (node1.id !=3D node2.id) {=0A=
            this.labelModule.pointToSelf =3D false;=0A=
            var point =3D this.edgeType.getPoint(0.5, viaNode);=0A=
            ctx.save();=0A=
=0A=
            // if the label has to be rotated:=0A=
            if (this.options.font.align !=3D=3D 'horizontal') {=0A=
              this.labelModule.calculateLabelSize(ctx, selected, =
point.x, point.y);=0A=
              ctx.translate(point.x, this.labelModule.size.yLine);=0A=
              this._rotateForLabelAlignment(ctx);=0A=
            }=0A=
=0A=
            // draw the label=0A=
            this.labelModule.draw(ctx, point.x, point.y, selected);=0A=
            ctx.restore();=0A=
          } else {=0A=
            // Ignore the orientations.=0A=
            this.labelModule.pointToSelf =3D true;=0A=
            var x, y;=0A=
            var radius =3D this.options.selfReferenceSize;=0A=
            if (node1.shape.width > node1.shape.height) {=0A=
              x =3D node1.x + node1.shape.width * 0.5;=0A=
              y =3D node1.y - radius;=0A=
            } else {=0A=
              x =3D node1.x + radius;=0A=
              y =3D node1.y - node1.shape.height * 0.5;=0A=
            }=0A=
            point =3D this._pointOnCircle(x, y, radius, 0.125);=0A=
            this.labelModule.draw(ctx, point.x, point.y, selected);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'isOverlappingWith',=0A=
=0A=
      /**=0A=
       * Check if this object is overlapping with the provided object=0A=
       * @param {Object} obj   an object with parameters left, top=0A=
       * @return {boolean}     True if location is located on the edge=0A=
       */=0A=
      value: function isOverlappingWith(obj) {=0A=
        if (this.connected) {=0A=
          var distMax =3D 10;=0A=
          var xFrom =3D this.from.x;=0A=
          var yFrom =3D this.from.y;=0A=
          var xTo =3D this.to.x;=0A=
          var yTo =3D this.to.y;=0A=
          var xObj =3D obj.left;=0A=
          var yObj =3D obj.top;=0A=
=0A=
          var dist =3D this.edgeType.getDistanceToEdge(xFrom, yFrom, =
xTo, yTo, xObj, yObj);=0A=
=0A=
          return dist < distMax;=0A=
        } else {=0A=
          return false;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_rotateForLabelAlignment',=0A=
=0A=
      /**=0A=
       * Rotates the canvas so the text is most readable=0A=
       * @param {CanvasRenderingContext2D} ctx=0A=
       * @private=0A=
       */=0A=
      value: function _rotateForLabelAlignment(ctx) {=0A=
        var dy =3D this.from.y - this.to.y;=0A=
        var dx =3D this.from.x - this.to.x;=0A=
        var angleInDegrees =3D Math.atan2(dy, dx);=0A=
=0A=
        // rotate so label it is readable=0A=
        if (angleInDegrees < -1 && dx < 0 || angleInDegrees > 0 && dx < =
0) {=0A=
          angleInDegrees =3D angleInDegrees + Math.PI;=0A=
        }=0A=
=0A=
        ctx.rotate(angleInDegrees);=0A=
      }=0A=
    }, {=0A=
      key: '_pointOnCircle',=0A=
=0A=
      /**=0A=
       * Get a point on a circle=0A=
       * @param {Number} x=0A=
       * @param {Number} y=0A=
       * @param {Number} radius=0A=
       * @param {Number} percentage. Value between 0 (line start) and 1 =
(line end)=0A=
       * @return {Object} point=0A=
       * @private=0A=
       */=0A=
      value: function _pointOnCircle(x, y, radius, percentage) {=0A=
        var angle =3D percentage * 2 * Math.PI;=0A=
        return {=0A=
          x: x + radius * Math.cos(angle),=0A=
          y: y - radius * Math.sin(angle)=0A=
        };=0A=
      }=0A=
    }, {=0A=
      key: 'select',=0A=
      value: function select() {=0A=
        this.selected =3D true;=0A=
      }=0A=
    }, {=0A=
      key: 'unselect',=0A=
      value: function unselect() {=0A=
        this.selected =3D false;=0A=
      }=0A=
    }, {=0A=
      key: 'cleanup',=0A=
=0A=
      /**=0A=
       * cleans all required things on delete=0A=
       * @returns {*}=0A=
       */=0A=
      value: function cleanup() {=0A=
        return this.edgeType.cleanup();=0A=
      }=0A=
    }], [{=0A=
      key: 'parseOptions',=0A=
      value: function parseOptions(parentOptions, newOptions) {=0A=
        var allowDeletion =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? false : arguments[2];=0A=
=0A=
        var fields =3D ['id', 'from', 'hidden', 'hoverWidth', 'label', =
'labelHighlightBold', 'length', 'line', 'opacity', 'physics', =
'selectionWidth', 'selfReferenceSize', 'to', 'title', 'value', 'width'];=0A=
=0A=
        // only deep extend the items in the field array. These do not =
have shorthand.=0A=
        util.selectiveDeepExtend(fields, parentOptions, newOptions, =
allowDeletion);=0A=
=0A=
        util.mergeOptions(parentOptions, newOptions, 'smooth');=0A=
        util.mergeOptions(parentOptions, newOptions, 'shadow');=0A=
=0A=
        if (newOptions.dashes !=3D=3D undefined && newOptions.dashes =
!=3D=3D null) {=0A=
          parentOptions.dashes =3D newOptions.dashes;=0A=
        } else if (allowDeletion =3D=3D=3D true && newOptions.dashes =
=3D=3D=3D null) {=0A=
          parentOptions.dashes =3D undefined;=0A=
          delete parentOptions.dashes;=0A=
        }=0A=
=0A=
        // set the scaling newOptions=0A=
        if (newOptions.scaling !=3D=3D undefined && newOptions.scaling =
!=3D=3D null) {=0A=
          if (newOptions.scaling.min !=3D=3D undefined) {=0A=
            parentOptions.scaling.min =3D newOptions.scaling.min;=0A=
          }=0A=
          if (newOptions.scaling.max !=3D=3D undefined) {=0A=
            parentOptions.scaling.max =3D newOptions.scaling.max;=0A=
          }=0A=
          util.mergeOptions(parentOptions.scaling, newOptions.scaling, =
'label');=0A=
        } else if (allowDeletion =3D=3D=3D true && newOptions.scaling =
=3D=3D=3D null) {=0A=
          parentOptions.scaling =3D undefined;=0A=
          delete parentOptions.scaling;=0A=
        }=0A=
=0A=
        // hanlde multiple input cases for arrows=0A=
        if (newOptions.arrows !=3D=3D undefined && newOptions.arrows =
!=3D=3D null) {=0A=
          if (typeof newOptions.arrows =3D=3D=3D 'string') {=0A=
            var arrows =3D newOptions.arrows.toLowerCase();=0A=
            if (arrows.indexOf('to') !=3D -1) {=0A=
              parentOptions.arrows.to.enabled =3D true;=0A=
            }=0A=
            if (arrows.indexOf('middle') !=3D -1) {=0A=
              parentOptions.arrows.middle.enabled =3D true;=0A=
            }=0A=
            if (arrows.indexOf('from') !=3D -1) {=0A=
              parentOptions.arrows.from.enabled =3D true;=0A=
            }=0A=
          } else if (typeof newOptions.arrows =3D=3D=3D 'object') {=0A=
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, =
'to');=0A=
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, =
'middle');=0A=
            util.mergeOptions(parentOptions.arrows, newOptions.arrows, =
'from');=0A=
          } else {=0A=
            throw new Error('The arrow newOptions can only be an object =
or a string. Refer to the documentation. You used:' + =
JSON.stringify(newOptions.arrows));=0A=
          }=0A=
        } else if (allowDeletion =3D=3D=3D true && newOptions.arrows =
=3D=3D=3D null) {=0A=
          parentOptions.arrows =3D undefined;=0A=
          delete parentOptions.arrows;=0A=
        }=0A=
=0A=
        // hanlde multiple input cases for color=0A=
        if (newOptions.color !=3D=3D undefined && newOptions.color =
!=3D=3D null) {=0A=
          if (util.isString(newOptions.color)) {=0A=
            parentOptions.color.color =3D newOptions.color;=0A=
            parentOptions.color.highlight =3D newOptions.color;=0A=
            parentOptions.color.hover =3D newOptions.color;=0A=
            parentOptions.color.inherit =3D false;=0A=
          } else {=0A=
            var colorsDefined =3D false;=0A=
            if (newOptions.color.color !=3D=3D undefined) {=0A=
              parentOptions.color.color =3D =
newOptions.color.color;colorsDefined =3D true;=0A=
            }=0A=
            if (newOptions.color.highlight !=3D=3D undefined) {=0A=
              parentOptions.color.highlight =3D =
newOptions.color.highlight;colorsDefined =3D true;=0A=
            }=0A=
            if (newOptions.color.hover !=3D=3D undefined) {=0A=
              parentOptions.color.hover =3D =
newOptions.color.hover;colorsDefined =3D true;=0A=
            }=0A=
            if (newOptions.color.inherit !=3D=3D undefined) {=0A=
              parentOptions.color.inherit =3D newOptions.color.inherit;=0A=
            }=0A=
            if (newOptions.color.opacity !=3D=3D undefined) {=0A=
              parentOptions.color.opacity =3D Math.min(1, Math.max(0, =
newOptions.color.opacity));=0A=
            }=0A=
=0A=
            if (newOptions.color.inherit =3D=3D=3D undefined && =
colorsDefined =3D=3D=3D true) {=0A=
              parentOptions.color.inherit =3D false;=0A=
            }=0A=
          }=0A=
        } else if (allowDeletion =3D=3D=3D true && newOptions.color =
=3D=3D=3D null) {=0A=
          parentOptions.color =3D undefined;=0A=
          delete parentOptions.color;=0A=
        }=0A=
=0A=
        // handle the font settings=0A=
        if (newOptions.font !=3D=3D undefined) {=0A=
          _sharedLabel2['default'].parseOptions(parentOptions.font, =
newOptions);=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return Edge;=0A=
  })();=0A=
=0A=
  exports['default'] =3D Edge;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 83 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x4, _x5, _x6) { var _again =3D true; =
_function: while (_again) { var object =3D _x4, property =3D _x5, =
receiver =3D _x6; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x4 =3D parent; _x5 =
=3D property; _x6 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilBezierEdgeBase =3D __webpack_require__(84);=0A=
=0A=
  var _utilBezierEdgeBase2 =3D =
_interopRequireDefault(_utilBezierEdgeBase);=0A=
=0A=
  var BezierEdgeStatic =3D (function (_BezierEdgeBase) {=0A=
    _inherits(BezierEdgeStatic, _BezierEdgeBase);=0A=
=0A=
    function BezierEdgeStatic(options, body, labelModule) {=0A=
      _classCallCheck(this, BezierEdgeStatic);=0A=
=0A=
      _get(Object.getPrototypeOf(BezierEdgeStatic.prototype), =
'constructor', this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(BezierEdgeStatic, [{=0A=
      key: '_line',=0A=
=0A=
      /**=0A=
       * Draw a line between two nodes=0A=
       * @param {CanvasRenderingContext2D} ctx=0A=
       * @private=0A=
       */=0A=
      value: function _line(ctx) {=0A=
        // draw a straight line=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(this.from.x, this.from.y);=0A=
        var via =3D this._getViaCoordinates();=0A=
        var returnValue =3D via;=0A=
=0A=
        // fallback to normal straight edges=0A=
        if (via.x =3D=3D=3D undefined) {=0A=
          ctx.lineTo(this.to.x, this.to.y);=0A=
          returnValue =3D undefined;=0A=
        } else {=0A=
          ctx.quadraticCurveTo(via.x, via.y, this.to.x, this.to.y);=0A=
        }=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        ctx.stroke();=0A=
        this.disableShadow(ctx);=0A=
        return returnValue;=0A=
      }=0A=
    }, {=0A=
      key: '_getViaCoordinates',=0A=
      value: function _getViaCoordinates() {=0A=
        var xVia =3D undefined;=0A=
        var yVia =3D undefined;=0A=
        var factor =3D this.options.smooth.roundness;=0A=
        var type =3D this.options.smooth.type;=0A=
        var dx =3D Math.abs(this.from.x - this.to.x);=0A=
        var dy =3D Math.abs(this.from.y - this.to.y);=0A=
        if (type =3D=3D=3D 'discrete' || type =3D=3D=3D 'diagonalCross') =
{=0A=
          if (Math.abs(this.from.x - this.to.x) <=3D =
Math.abs(this.from.y - this.to.y)) {=0A=
            if (this.from.y >=3D this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dy;=0A=
                yVia =3D this.from.y - factor * dy;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dy;=0A=
                yVia =3D this.from.y - factor * dy;=0A=
              }=0A=
            } else if (this.from.y < this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dy;=0A=
                yVia =3D this.from.y + factor * dy;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dy;=0A=
                yVia =3D this.from.y + factor * dy;=0A=
              }=0A=
            }=0A=
            if (type =3D=3D=3D 'discrete') {=0A=
              xVia =3D dx < factor * dy ? this.from.x : xVia;=0A=
            }=0A=
          } else if (Math.abs(this.from.x - this.to.x) > =
Math.abs(this.from.y - this.to.y)) {=0A=
            if (this.from.y >=3D this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dx;=0A=
                yVia =3D this.from.y - factor * dx;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dx;=0A=
                yVia =3D this.from.y - factor * dx;=0A=
              }=0A=
            } else if (this.from.y < this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dx;=0A=
                yVia =3D this.from.y + factor * dx;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dx;=0A=
                yVia =3D this.from.y + factor * dx;=0A=
              }=0A=
            }=0A=
            if (type =3D=3D=3D 'discrete') {=0A=
              yVia =3D dy < factor * dx ? this.from.y : yVia;=0A=
            }=0A=
          }=0A=
        } else if (type =3D=3D=3D 'straightCross') {=0A=
          if (Math.abs(this.from.x - this.to.x) <=3D =
Math.abs(this.from.y - this.to.y)) {=0A=
            // up - down=0A=
            xVia =3D this.from.x;=0A=
            if (this.from.y < this.to.y) {=0A=
              yVia =3D this.to.y - (1 - factor) * dy;=0A=
            } else {=0A=
              yVia =3D this.to.y + (1 - factor) * dy;=0A=
            }=0A=
          } else if (Math.abs(this.from.x - this.to.x) > =
Math.abs(this.from.y - this.to.y)) {=0A=
            // left - right=0A=
            if (this.from.x < this.to.x) {=0A=
              xVia =3D this.to.x - (1 - factor) * dx;=0A=
            } else {=0A=
              xVia =3D this.to.x + (1 - factor) * dx;=0A=
            }=0A=
            yVia =3D this.from.y;=0A=
          }=0A=
        } else if (type =3D=3D=3D 'horizontal') {=0A=
          if (this.from.x < this.to.x) {=0A=
            xVia =3D this.to.x - (1 - factor) * dx;=0A=
          } else {=0A=
            xVia =3D this.to.x + (1 - factor) * dx;=0A=
          }=0A=
          yVia =3D this.from.y;=0A=
        } else if (type =3D=3D=3D 'vertical') {=0A=
          xVia =3D this.from.x;=0A=
          if (this.from.y < this.to.y) {=0A=
            yVia =3D this.to.y - (1 - factor) * dy;=0A=
          } else {=0A=
            yVia =3D this.to.y + (1 - factor) * dy;=0A=
          }=0A=
        } else if (type =3D=3D=3D 'curvedCW') {=0A=
          dx =3D this.to.x - this.from.x;=0A=
          dy =3D this.from.y - this.to.y;=0A=
          var radius =3D Math.sqrt(dx * dx + dy * dy);=0A=
          var pi =3D Math.PI;=0A=
=0A=
          var originalAngle =3D Math.atan2(dy, dx);=0A=
          var myAngle =3D (originalAngle + (factor * 0.5 + 0.5) * pi) % =
(2 * pi);=0A=
=0A=
          xVia =3D this.from.x + (factor * 0.5 + 0.5) * radius * =
Math.sin(myAngle);=0A=
          yVia =3D this.from.y + (factor * 0.5 + 0.5) * radius * =
Math.cos(myAngle);=0A=
        } else if (type =3D=3D=3D 'curvedCCW') {=0A=
          dx =3D this.to.x - this.from.x;=0A=
          dy =3D this.from.y - this.to.y;=0A=
          var radius =3D Math.sqrt(dx * dx + dy * dy);=0A=
          var pi =3D Math.PI;=0A=
=0A=
          var originalAngle =3D Math.atan2(dy, dx);=0A=
          var myAngle =3D (originalAngle + (-factor * 0.5 + 0.5) * pi) % =
(2 * pi);=0A=
=0A=
          xVia =3D this.from.x + (factor * 0.5 + 0.5) * radius * =
Math.sin(myAngle);=0A=
          yVia =3D this.from.y + (factor * 0.5 + 0.5) * radius * =
Math.cos(myAngle);=0A=
        } else {=0A=
          // continuous=0A=
          if (Math.abs(this.from.x - this.to.x) <=3D =
Math.abs(this.from.y - this.to.y)) {=0A=
            if (this.from.y >=3D this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dy;=0A=
                yVia =3D this.from.y - factor * dy;=0A=
                xVia =3D this.to.x < xVia ? this.to.x : xVia;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dy;=0A=
                yVia =3D this.from.y - factor * dy;=0A=
                xVia =3D this.to.x > xVia ? this.to.x : xVia;=0A=
              }=0A=
            } else if (this.from.y < this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dy;=0A=
                yVia =3D this.from.y + factor * dy;=0A=
                xVia =3D this.to.x < xVia ? this.to.x : xVia;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dy;=0A=
                yVia =3D this.from.y + factor * dy;=0A=
                xVia =3D this.to.x > xVia ? this.to.x : xVia;=0A=
              }=0A=
            }=0A=
          } else if (Math.abs(this.from.x - this.to.x) > =
Math.abs(this.from.y - this.to.y)) {=0A=
            if (this.from.y >=3D this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dx;=0A=
                yVia =3D this.from.y - factor * dx;=0A=
                yVia =3D this.to.y > yVia ? this.to.y : yVia;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dx;=0A=
                yVia =3D this.from.y - factor * dx;=0A=
                yVia =3D this.to.y > yVia ? this.to.y : yVia;=0A=
              }=0A=
            } else if (this.from.y < this.to.y) {=0A=
              if (this.from.x <=3D this.to.x) {=0A=
                xVia =3D this.from.x + factor * dx;=0A=
                yVia =3D this.from.y + factor * dx;=0A=
                yVia =3D this.to.y < yVia ? this.to.y : yVia;=0A=
              } else if (this.from.x > this.to.x) {=0A=
                xVia =3D this.from.x - factor * dx;=0A=
                yVia =3D this.from.y + factor * dx;=0A=
                yVia =3D this.to.y < yVia ? this.to.y : yVia;=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
        return { x: xVia, y: yVia };=0A=
      }=0A=
    }, {=0A=
      key: '_findBorderPosition',=0A=
      value: function _findBorderPosition(nearNode, ctx) {=0A=
        var options =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? {} : arguments[2];=0A=
=0A=
        return this._findBorderPositionBezier(nearNode, ctx, =
options.via);=0A=
      }=0A=
    }, {=0A=
      key: '_getDistanceToEdge',=0A=
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {=0A=
        var via =3D arguments.length <=3D 6 || arguments[6] =3D=3D=3D =
undefined ? this._getViaCoordinates() : arguments[6];=0A=
        // x3,y3 is the point=0A=
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, =
via);=0A=
      }=0A=
    }, {=0A=
      key: 'getPoint',=0A=
=0A=
      /**=0A=
       * Combined function of pointOnLine and pointOnBezier. This gives =
the coordinates of a point on the line at a certain percentage of the way=0A=
       * @param percentage=0A=
       * @param via=0A=
       * @returns {{x: number, y: number}}=0A=
       * @private=0A=
       */=0A=
      value: function getPoint(percentage) {=0A=
        var via =3D arguments.length <=3D 1 || arguments[1] =3D=3D=3D =
undefined ? this._getViaCoordinates() : arguments[1];=0A=
=0A=
        var t =3D percentage;=0A=
        var x =3D Math.pow(1 - t, 2) * this.from.x + 2 * t * (1 - t) * =
via.x + Math.pow(t, 2) * this.to.x;=0A=
        var y =3D Math.pow(1 - t, 2) * this.from.y + 2 * t * (1 - t) * =
via.y + Math.pow(t, 2) * this.to.y;=0A=
=0A=
        return { x: x, y: y };=0A=
      }=0A=
    }]);=0A=
=0A=
    return BezierEdgeStatic;=0A=
  })(_utilBezierEdgeBase2['default']);=0A=
=0A=
  exports['default'] =3D BezierEdgeStatic;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 84 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x2, _x3, _x4) { var _again =3D true; =
_function: while (_again) { var object =3D _x2, property =3D _x3, =
receiver =3D _x4; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x2 =3D parent; _x3 =
=3D property; _x4 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _EdgeBase2 =3D __webpack_require__(85);=0A=
=0A=
  var _EdgeBase3 =3D _interopRequireDefault(_EdgeBase2);=0A=
=0A=
  var BezierEdgeBase =3D (function (_EdgeBase) {=0A=
    _inherits(BezierEdgeBase, _EdgeBase);=0A=
=0A=
    function BezierEdgeBase(options, body, labelModule) {=0A=
      _classCallCheck(this, BezierEdgeBase);=0A=
=0A=
      _get(Object.getPrototypeOf(BezierEdgeBase.prototype), =
'constructor', this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(BezierEdgeBase, [{=0A=
      key: '_findBorderPositionBezier',=0A=
=0A=
      /**=0A=
       * This function uses binary search to look for the point where =
the bezier curve crosses the border of the node.=0A=
       *=0A=
       * @param nearNode=0A=
       * @param ctx=0A=
       * @param viaNode=0A=
       * @param nearNode=0A=
       * @param ctx=0A=
       * @param viaNode=0A=
       * @param nearNode=0A=
       * @param ctx=0A=
       * @param viaNode=0A=
       */=0A=
      value: function _findBorderPositionBezier(nearNode, ctx) {=0A=
        var viaNode =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? this._getViaCoordinates() : arguments[2];=0A=
=0A=
        var maxIterations =3D 10;=0A=
        var iteration =3D 0;=0A=
        var low =3D 0;=0A=
        var high =3D 1;=0A=
        var pos, angle, distanceToBorder, distanceToPoint, difference;=0A=
        var threshold =3D 0.2;=0A=
        var node =3D this.to;=0A=
        var from =3D false;=0A=
        if (nearNode.id =3D=3D=3D this.from.id) {=0A=
          node =3D this.from;=0A=
          from =3D true;=0A=
        }=0A=
=0A=
        while (low <=3D high && iteration < maxIterations) {=0A=
          var middle =3D (low + high) * 0.5;=0A=
=0A=
          pos =3D this.getPoint(middle, viaNode);=0A=
          angle =3D Math.atan2(node.y - pos.y, node.x - pos.x);=0A=
          distanceToBorder =3D node.distanceToBorder(ctx, angle);=0A=
          distanceToPoint =3D Math.sqrt(Math.pow(pos.x - node.x, 2) + =
Math.pow(pos.y - node.y, 2));=0A=
          difference =3D distanceToBorder - distanceToPoint;=0A=
          if (Math.abs(difference) < threshold) {=0A=
            break; // found=0A=
          } else if (difference < 0) {=0A=
            // distance to nodes is larger than distance to border --> t =
needs to be bigger if we're looking at the to node.=0A=
            if (from =3D=3D=3D false) {=0A=
              low =3D middle;=0A=
            } else {=0A=
              high =3D middle;=0A=
            }=0A=
          } else {=0A=
            if (from =3D=3D=3D false) {=0A=
              high =3D middle;=0A=
            } else {=0A=
              low =3D middle;=0A=
            }=0A=
          }=0A=
=0A=
          iteration++;=0A=
        }=0A=
        pos.t =3D middle;=0A=
=0A=
        return pos;=0A=
      }=0A=
    }, {=0A=
      key: '_getDistanceToBezierEdge',=0A=
=0A=
      /**=0A=
       * Calculate the distance between a point (x3,y3) and a line =
segment from=0A=
       * (x1,y1) to (x2,y2).=0A=
       * =
http://stackoverflow.com/questions/849211/shortest-distancae-between-a-po=
int-and-a-line-segment=0A=
       * @param {number} x1 from x=0A=
       * @param {number} y1 from y=0A=
       * @param {number} x2 to x=0A=
       * @param {number} y2 to y=0A=
       * @param {number} x3 point to check x=0A=
       * @param {number} y3 point to check y=0A=
       * @private=0A=
       */=0A=
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, =
via) {=0A=
        // x3,y3 is the point=0A=
        var minDistance =3D 1e9;=0A=
        var distance =3D undefined;=0A=
        var i =3D undefined,=0A=
            t =3D undefined,=0A=
            x =3D undefined,=0A=
            y =3D undefined;=0A=
        var lastX =3D x1;=0A=
        var lastY =3D y1;=0A=
        for (i =3D 1; i < 10; i++) {=0A=
          t =3D 0.1 * i;=0A=
          x =3D Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + =
Math.pow(t, 2) * x2;=0A=
          y =3D Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + =
Math.pow(t, 2) * y2;=0A=
          if (i > 0) {=0A=
            distance =3D this._getDistanceToLine(lastX, lastY, x, y, x3, =
y3);=0A=
            minDistance =3D distance < minDistance ? distance : =
minDistance;=0A=
          }=0A=
          lastX =3D x;=0A=
          lastY =3D y;=0A=
        }=0A=
=0A=
        return minDistance;=0A=
      }=0A=
    }]);=0A=
=0A=
    return BezierEdgeBase;=0A=
  })(_EdgeBase3['default']);=0A=
=0A=
  exports['default'] =3D BezierEdgeBase;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 85 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _slicedToArray =3D (function () { function sliceIterator(arr, i) { =
var _arr =3D []; var _n =3D true; var _d =3D false; var _e =3D =
undefined; try { for (var _i =3D arr[Symbol.iterator](), _s; !(_n =3D =
(_s =3D _i.next()).done); _n =3D true) { _arr.push(_s.value); if (i && =
_arr.length =3D=3D=3D i) break; } } catch (err) { _d =3D true; _e =3D =
err; } finally { try { if (!_n && _i['return']) _i['return'](); } =
finally { if (_d) throw _e; } } return _arr; } return function (arr, i) =
{ if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in =
Object(arr)) { return sliceIterator(arr, i); } else { throw new =
TypeError('Invalid attempt to destructure non-iterable instance'); } }; =
})();=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var EdgeBase =3D (function () {=0A=
    function EdgeBase(options, body, labelModule) {=0A=
      _classCallCheck(this, EdgeBase);=0A=
=0A=
      this.body =3D body;=0A=
      this.labelModule =3D labelModule;=0A=
      this.setOptions(options);=0A=
      this.colorDirty =3D true;=0A=
      this.color =3D {};=0A=
      this.selectionWidth =3D 2;=0A=
      this.hoverWidth =3D 1.5;=0A=
    }=0A=
=0A=
    _createClass(EdgeBase, [{=0A=
      key: 'connect',=0A=
      value: function connect() {=0A=
        this.from =3D this.body.nodes[this.options.from];=0A=
        this.to =3D this.body.nodes[this.options.to];=0A=
      }=0A=
    }, {=0A=
      key: 'cleanup',=0A=
      value: function cleanup() {=0A=
        return false;=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
        this.from =3D this.body.nodes[this.options.from];=0A=
        this.to =3D this.body.nodes[this.options.to];=0A=
        this.id =3D this.options.id;=0A=
      }=0A=
    }, {=0A=
      key: 'drawLine',=0A=
=0A=
      /**=0A=
       * Redraw a edge as a line=0A=
       * Draw this edge in the given canvas=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext("2d");=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       * @private=0A=
       */=0A=
      value: function drawLine(ctx, selected, hover) {=0A=
        // set style=0A=
        ctx.strokeStyle =3D this.getColor(ctx, selected, hover);=0A=
        ctx.lineWidth =3D this.getLineWidth(selected, hover);=0A=
        var via =3D undefined;=0A=
        if (this.options.dashes !=3D=3D false) {=0A=
          via =3D this._drawDashedLine(ctx);=0A=
        } else {=0A=
          via =3D this._drawLine(ctx);=0A=
        }=0A=
        return via;=0A=
      }=0A=
    }, {=0A=
      key: '_drawLine',=0A=
      value: function _drawLine(ctx) {=0A=
        var via =3D undefined;=0A=
        if (this.from !=3D this.to) {=0A=
          // draw line=0A=
          via =3D this._line(ctx);=0A=
        } else {=0A=
          var _getCircleData2 =3D this._getCircleData(ctx);=0A=
=0A=
          var _getCircleData22 =3D _slicedToArray(_getCircleData2, 3);=0A=
=0A=
          var x =3D _getCircleData22[0];=0A=
          var y =3D _getCircleData22[1];=0A=
          var radius =3D _getCircleData22[2];=0A=
=0A=
          this._circle(ctx, x, y, radius);=0A=
        }=0A=
        return via;=0A=
      }=0A=
    }, {=0A=
      key: '_drawDashedLine',=0A=
      value: function _drawDashedLine(ctx) {=0A=
        var via =3D undefined;=0A=
        ctx.lineCap =3D 'round';=0A=
        var pattern =3D [5, 5];=0A=
        if (Array.isArray(this.options.dashes) =3D=3D=3D true) {=0A=
          pattern =3D this.options.dashes;=0A=
        }=0A=
=0A=
        // only firefox and chrome support this method, else we use the =
legacy one.=0A=
        if (ctx.setLineDash !=3D=3D undefined) {=0A=
          ctx.save();=0A=
=0A=
          // set dash settings for chrome or firefox=0A=
          ctx.setLineDash(pattern);=0A=
          ctx.lineDashOffset =3D 0;=0A=
=0A=
          // draw the line=0A=
          if (this.from !=3D this.to) {=0A=
            // draw line=0A=
            via =3D this._line(ctx);=0A=
          } else {=0A=
            var _getCircleData3 =3D this._getCircleData(ctx);=0A=
=0A=
            var _getCircleData32 =3D _slicedToArray(_getCircleData3, 3);=0A=
=0A=
            var x =3D _getCircleData32[0];=0A=
            var y =3D _getCircleData32[1];=0A=
            var radius =3D _getCircleData32[2];=0A=
=0A=
            this._circle(ctx, x, y, radius);=0A=
          }=0A=
=0A=
          // restore the dash settings.=0A=
          ctx.setLineDash([0]);=0A=
          ctx.lineDashOffset =3D 0;=0A=
          ctx.restore();=0A=
        } else {=0A=
          // unsupporting smooth lines=0A=
          if (this.from !=3D this.to) {=0A=
            // draw line=0A=
            ctx.dashedLine(this.from.x, this.from.y, this.to.x, =
this.to.y, pattern);=0A=
          } else {=0A=
            var _getCircleData4 =3D this._getCircleData(ctx);=0A=
=0A=
            var _getCircleData42 =3D _slicedToArray(_getCircleData4, 3);=0A=
=0A=
            var x =3D _getCircleData42[0];=0A=
            var y =3D _getCircleData42[1];=0A=
            var radius =3D _getCircleData42[2];=0A=
=0A=
            this._circle(ctx, x, y, radius);=0A=
          }=0A=
          // draw shadow if enabled=0A=
          this.enableShadow(ctx);=0A=
=0A=
          ctx.stroke();=0A=
=0A=
          // disable shadows for other elements.=0A=
          this.disableShadow(ctx);=0A=
        }=0A=
        return via;=0A=
      }=0A=
    }, {=0A=
      key: 'findBorderPosition',=0A=
      value: function findBorderPosition(nearNode, ctx, options) {=0A=
        if (this.from !=3D this.to) {=0A=
          return this._findBorderPosition(nearNode, ctx, options);=0A=
        } else {=0A=
          return this._findBorderPositionCircle(nearNode, ctx, options);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'findBorderPositions',=0A=
      value: function findBorderPositions(ctx) {=0A=
        var from =3D {};=0A=
        var to =3D {};=0A=
        if (this.from !=3D this.to) {=0A=
          from =3D this._findBorderPosition(this.from, ctx);=0A=
          to =3D this._findBorderPosition(this.to, ctx);=0A=
        } else {=0A=
          var _getCircleData5 =3D this._getCircleData(ctx);=0A=
=0A=
          var _getCircleData52 =3D _slicedToArray(_getCircleData5, 3);=0A=
=0A=
          var x =3D _getCircleData52[0];=0A=
          var y =3D _getCircleData52[1];=0A=
          var radius =3D _getCircleData52[2];=0A=
=0A=
          from =3D this._findBorderPositionCircle(this.from, ctx, { x: =
x, y: y, low: 0.25, high: 0.6, direction: -1 });=0A=
          to =3D this._findBorderPositionCircle(this.from, ctx, { x: x, =
y: y, low: 0.6, high: 0.8, direction: 1 });=0A=
        }=0A=
        return { from: from, to: to };=0A=
      }=0A=
    }, {=0A=
      key: '_getCircleData',=0A=
      value: function _getCircleData(ctx) {=0A=
        var x =3D undefined,=0A=
            y =3D undefined;=0A=
        var node =3D this.from;=0A=
        var radius =3D this.options.selfReferenceSize;=0A=
=0A=
        if (ctx !=3D=3D undefined) {=0A=
          if (node.shape.width =3D=3D=3D undefined) {=0A=
            node.shape.resize(ctx);=0A=
          }=0A=
        }=0A=
=0A=
        // get circle coordinates=0A=
        if (node.shape.width > node.shape.height) {=0A=
          x =3D node.x + node.shape.width * 0.5;=0A=
          y =3D node.y - radius;=0A=
        } else {=0A=
          x =3D node.x + radius;=0A=
          y =3D node.y - node.shape.height * 0.5;=0A=
        }=0A=
        return [x, y, radius];=0A=
      }=0A=
    }, {=0A=
      key: '_pointOnCircle',=0A=
=0A=
      /**=0A=
       * Get a point on a circle=0A=
       * @param {Number} x=0A=
       * @param {Number} y=0A=
       * @param {Number} radius=0A=
       * @param {Number} percentage. Value between 0 (line start) and 1 =
(line end)=0A=
       * @return {Object} point=0A=
       * @private=0A=
       */=0A=
      value: function _pointOnCircle(x, y, radius, percentage) {=0A=
        var angle =3D percentage * 2 * Math.PI;=0A=
        return {=0A=
          x: x + radius * Math.cos(angle),=0A=
          y: y - radius * Math.sin(angle)=0A=
        };=0A=
      }=0A=
    }, {=0A=
      key: '_findBorderPositionCircle',=0A=
=0A=
      /**=0A=
       * This function uses binary search to look for the point where =
the circle crosses the border of the node.=0A=
       * @param node=0A=
       * @param ctx=0A=
       * @param options=0A=
       * @returns {*}=0A=
       * @private=0A=
       */=0A=
      value: function _findBorderPositionCircle(node, ctx, options) {=0A=
        var x =3D options.x;=0A=
        var y =3D options.y;=0A=
        var low =3D options.low;=0A=
        var high =3D options.high;=0A=
        var direction =3D options.direction;=0A=
=0A=
        var maxIterations =3D 10;=0A=
        var iteration =3D 0;=0A=
        var radius =3D this.options.selfReferenceSize;=0A=
        var pos =3D undefined,=0A=
            angle =3D undefined,=0A=
            distanceToBorder =3D undefined,=0A=
            distanceToPoint =3D undefined,=0A=
            difference =3D undefined;=0A=
        var threshold =3D 0.05;=0A=
        var middle =3D (low + high) * 0.5;=0A=
=0A=
        while (low <=3D high && iteration < maxIterations) {=0A=
          middle =3D (low + high) * 0.5;=0A=
=0A=
          pos =3D this._pointOnCircle(x, y, radius, middle);=0A=
          angle =3D Math.atan2(node.y - pos.y, node.x - pos.x);=0A=
          distanceToBorder =3D node.distanceToBorder(ctx, angle);=0A=
          distanceToPoint =3D Math.sqrt(Math.pow(pos.x - node.x, 2) + =
Math.pow(pos.y - node.y, 2));=0A=
          difference =3D distanceToBorder - distanceToPoint;=0A=
          if (Math.abs(difference) < threshold) {=0A=
            break; // found=0A=
          } else if (difference > 0) {=0A=
            // distance to nodes is larger than distance to border --> t =
needs to be bigger if we're looking at the to node.=0A=
            if (direction > 0) {=0A=
              low =3D middle;=0A=
            } else {=0A=
              high =3D middle;=0A=
            }=0A=
          } else {=0A=
            if (direction > 0) {=0A=
              high =3D middle;=0A=
            } else {=0A=
              low =3D middle;=0A=
            }=0A=
          }=0A=
          iteration++;=0A=
        }=0A=
        pos.t =3D middle;=0A=
=0A=
        return pos;=0A=
      }=0A=
    }, {=0A=
      key: 'getLineWidth',=0A=
=0A=
      /**=0A=
       * Get the line width of the edge. Depends on width and whether =
one of the=0A=
       * connected nodes is selected.=0A=
       * @return {Number} width=0A=
       * @private=0A=
       */=0A=
      value: function getLineWidth(selected, hover) {=0A=
        if (selected =3D=3D=3D true) {=0A=
          return Math.max(this.selectionWidth, 0.3 / =
this.body.view.scale);=0A=
        } else {=0A=
          if (hover =3D=3D=3D true) {=0A=
            return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);=0A=
          } else {=0A=
            return Math.max(this.options.width, 0.3 / =
this.body.view.scale);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'getColor',=0A=
      value: function getColor(ctx, selected, hover) {=0A=
        var colorOptions =3D this.options.color;=0A=
        if (colorOptions.inherit !=3D=3D false) {=0A=
          // when this is a loop edge, just use the 'from' method=0A=
          if (colorOptions.inherit =3D=3D=3D 'both' && this.from.id =
!=3D=3D this.to.id) {=0A=
            var grd =3D ctx.createLinearGradient(this.from.x, =
this.from.y, this.to.x, this.to.y);=0A=
            var fromColor =3D undefined,=0A=
                toColor =3D undefined;=0A=
            fromColor =3D this.from.options.color.highlight.border;=0A=
            toColor =3D this.to.options.color.highlight.border;=0A=
=0A=
            if (this.from.selected =3D=3D=3D false && this.to.selected =
=3D=3D=3D false) {=0A=
              fromColor =3D =
util.overrideOpacity(this.from.options.color.border, =
this.options.color.opacity);=0A=
              toColor =3D =
util.overrideOpacity(this.to.options.color.border, =
this.options.color.opacity);=0A=
            } else if (this.from.selected =3D=3D=3D true && =
this.to.selected =3D=3D=3D false) {=0A=
              toColor =3D this.to.options.color.border;=0A=
            } else if (this.from.selected =3D=3D=3D false && =
this.to.selected =3D=3D=3D true) {=0A=
              fromColor =3D this.from.options.color.border;=0A=
            }=0A=
            grd.addColorStop(0, fromColor);=0A=
            grd.addColorStop(1, toColor);=0A=
=0A=
            // -------------------- this returns -------------------- //=0A=
            return grd;=0A=
          }=0A=
=0A=
          if (this.colorDirty =3D=3D=3D true) {=0A=
            if (colorOptions.inherit =3D=3D=3D 'to') {=0A=
              this.color.highlight =3D =
this.to.options.color.highlight.border;=0A=
              this.color.hover =3D this.to.options.color.hover.border;=0A=
              this.color.color =3D =
util.overrideOpacity(this.to.options.color.border, colorOptions.opacity);=0A=
            } else {=0A=
              // (this.options.color.inherit.source =3D=3D=3D "from") {=0A=
              this.color.highlight =3D =
this.from.options.color.highlight.border;=0A=
              this.color.hover =3D this.from.options.color.hover.border;=0A=
              this.color.color =3D =
util.overrideOpacity(this.from.options.color.border, =
colorOptions.opacity);=0A=
            }=0A=
          }=0A=
        } else if (this.colorDirty =3D=3D=3D true) {=0A=
          this.color.highlight =3D colorOptions.highlight;=0A=
          this.color.hover =3D colorOptions.hover;=0A=
          this.color.color =3D util.overrideOpacity(colorOptions.color, =
colorOptions.opacity);=0A=
        }=0A=
=0A=
        // if color inherit is on and gradients are used, the function =
has already returned by now.=0A=
        this.colorDirty =3D false;=0A=
=0A=
        if (selected =3D=3D=3D true) {=0A=
          return this.color.highlight;=0A=
        } else if (hover =3D=3D=3D true) {=0A=
          return this.color.hover;=0A=
        } else {=0A=
          return this.color.color;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_circle',=0A=
=0A=
      /**=0A=
       * Draw a line from a node to itself, a circle=0A=
       * @param {CanvasRenderingContext2D} ctx=0A=
       * @param {Number} x=0A=
       * @param {Number} y=0A=
       * @param {Number} radius=0A=
       * @private=0A=
       */=0A=
      value: function _circle(ctx, x, y, radius) {=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
=0A=
        // draw a circle=0A=
        ctx.beginPath();=0A=
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);=0A=
        ctx.stroke();=0A=
=0A=
        // disable shadows for other elements.=0A=
        this.disableShadow(ctx);=0A=
      }=0A=
    }, {=0A=
      key: 'getDistanceToEdge',=0A=
=0A=
      /**=0A=
       * Calculate the distance between a point (x3,y3) and a line =
segment from=0A=
       * (x1,y1) to (x2,y2).=0A=
       * =
http://stackoverflow.com/questions/849211/shortest-distancae-between-a-po=
int-and-a-line-segment=0A=
       * @param {number} x1=0A=
       * @param {number} y1=0A=
       * @param {number} x2=0A=
       * @param {number} y2=0A=
       * @param {number} x3=0A=
       * @param {number} y3=0A=
       * @private=0A=
       */=0A=
      value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via) {=0A=
        // x3,y3 is the point=0A=
        var returnValue =3D 0;=0A=
        if (this.from !=3D this.to) {=0A=
          returnValue =3D this._getDistanceToEdge(x1, y1, x2, y2, x3, =
y3, via);=0A=
        } else {=0A=
          var _getCircleData6 =3D this._getCircleData();=0A=
=0A=
          var _getCircleData62 =3D _slicedToArray(_getCircleData6, 3);=0A=
=0A=
          var x =3D _getCircleData62[0];=0A=
          var y =3D _getCircleData62[1];=0A=
          var radius =3D _getCircleData62[2];=0A=
=0A=
          var dx =3D x - x3;=0A=
          var dy =3D y - y3;=0A=
          returnValue =3D Math.abs(Math.sqrt(dx * dx + dy * dy) - =
radius);=0A=
        }=0A=
=0A=
        if (this.labelModule.size.left < x3 && =
this.labelModule.size.left + this.labelModule.size.width > x3 && =
this.labelModule.size.top < y3 && this.labelModule.size.top + =
this.labelModule.size.height > y3) {=0A=
          return 0;=0A=
        } else {=0A=
          return returnValue;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_getDistanceToLine',=0A=
      value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {=0A=
        var px =3D x2 - x1;=0A=
        var py =3D y2 - y1;=0A=
        var something =3D px * px + py * py;=0A=
        var u =3D ((x3 - x1) * px + (y3 - y1) * py) / something;=0A=
=0A=
        if (u > 1) {=0A=
          u =3D 1;=0A=
        } else if (u < 0) {=0A=
          u =3D 0;=0A=
        }=0A=
=0A=
        var x =3D x1 + u * px;=0A=
        var y =3D y1 + u * py;=0A=
        var dx =3D x - x3;=0A=
        var dy =3D y - y3;=0A=
=0A=
        //# Note: If the actual distance does not matter,=0A=
        //# if you only want to compare what this function=0A=
        //# returns to other results of this function, you=0A=
        //# can just return the squared distance instead=0A=
        //# (i.e. remove the sqrt) to gain a little performance=0A=
=0A=
        return Math.sqrt(dx * dx + dy * dy);=0A=
      }=0A=
    }, {=0A=
      key: 'drawArrowHead',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param ctx=0A=
       * @param position=0A=
       * @param viaNode=0A=
       */=0A=
      value: function drawArrowHead(ctx, position, viaNode, selected, =
hover) {=0A=
        // set style=0A=
        ctx.strokeStyle =3D this.getColor(ctx, selected, hover);=0A=
        ctx.fillStyle =3D ctx.strokeStyle;=0A=
        ctx.lineWidth =3D this.getLineWidth(selected, hover);=0A=
=0A=
        // set lets=0A=
        var angle =3D undefined;=0A=
        var length =3D undefined;=0A=
        var arrowPos =3D undefined;=0A=
        var node1 =3D undefined;=0A=
        var node2 =3D undefined;=0A=
        var guideOffset =3D undefined;=0A=
        var scaleFactor =3D undefined;=0A=
=0A=
        if (position =3D=3D=3D 'from') {=0A=
          node1 =3D this.from;=0A=
          node2 =3D this.to;=0A=
          guideOffset =3D 0.1;=0A=
          scaleFactor =3D this.options.arrows.from.scaleFactor;=0A=
        } else if (position =3D=3D=3D 'to') {=0A=
          node1 =3D this.to;=0A=
          node2 =3D this.from;=0A=
          guideOffset =3D -0.1;=0A=
          scaleFactor =3D this.options.arrows.to.scaleFactor;=0A=
        } else {=0A=
          node1 =3D this.to;=0A=
          node2 =3D this.from;=0A=
          scaleFactor =3D this.options.arrows.middle.scaleFactor;=0A=
        }=0A=
=0A=
        // if not connected to itself=0A=
        if (node1 !=3D node2) {=0A=
          if (position !=3D=3D 'middle') {=0A=
            // draw arrow head=0A=
            if (this.options.smooth.enabled =3D=3D=3D true) {=0A=
              arrowPos =3D this.findBorderPosition(node1, ctx, { via: =
viaNode });=0A=
              var guidePos =3D this.getPoint(Math.max(0.0, Math.min(1.0, =
arrowPos.t + guideOffset)), viaNode);=0A=
              angle =3D Math.atan2(arrowPos.y - guidePos.y, arrowPos.x - =
guidePos.x);=0A=
            } else {=0A=
              angle =3D Math.atan2(node1.y - node2.y, node1.x - node2.x);=0A=
              arrowPos =3D this.findBorderPosition(node1, ctx);=0A=
            }=0A=
          } else {=0A=
            angle =3D Math.atan2(node1.y - node2.y, node1.x - node2.x);=0A=
            arrowPos =3D this.getPoint(0.6, viaNode); // this is 0.6 to =
account for the size of the arrow.=0A=
          }=0A=
          // draw arrow at the end of the line=0A=
          length =3D (10 + 5 * this.options.width) * scaleFactor;=0A=
          ctx.arrow(arrowPos.x, arrowPos.y, angle, length);=0A=
=0A=
          // draw shadow if enabled=0A=
          this.enableShadow(ctx);=0A=
          ctx.fill();=0A=
=0A=
          // disable shadows for other elements.=0A=
          this.disableShadow(ctx);=0A=
          ctx.stroke();=0A=
        } else {=0A=
          // draw circle=0A=
          var _angle =3D undefined,=0A=
              point =3D undefined;=0A=
=0A=
          var _getCircleData7 =3D this._getCircleData(ctx);=0A=
=0A=
          var _getCircleData72 =3D _slicedToArray(_getCircleData7, 3);=0A=
=0A=
          var x =3D _getCircleData72[0];=0A=
          var y =3D _getCircleData72[1];=0A=
          var radius =3D _getCircleData72[2];=0A=
=0A=
          if (position =3D=3D=3D 'from') {=0A=
            point =3D this.findBorderPosition(this.from, ctx, { x: x, y: =
y, low: 0.25, high: 0.6, direction: -1 });=0A=
            _angle =3D point.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * =
Math.PI;=0A=
          } else if (position =3D=3D=3D 'to') {=0A=
            point =3D this.findBorderPosition(this.from, ctx, { x: x, y: =
y, low: 0.6, high: 1.0, direction: 1 });=0A=
            _angle =3D point.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * =
Math.PI;=0A=
          } else {=0A=
            point =3D this._pointOnCircle(x, y, radius, 0.175);=0A=
            _angle =3D 3.9269908169872414; // =3D=3D=3D 0.175 * -2 * =
Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;=0A=
          }=0A=
=0A=
          // draw the arrowhead=0A=
          var _length =3D (10 + 5 * this.options.width) * scaleFactor;=0A=
          ctx.arrow(point.x, point.y, _angle, _length);=0A=
=0A=
          // draw shadow if enabled=0A=
          this.enableShadow(ctx);=0A=
          ctx.fill();=0A=
=0A=
          // disable shadows for other elements.=0A=
          this.disableShadow(ctx);=0A=
          ctx.stroke();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'enableShadow',=0A=
      value: function enableShadow(ctx) {=0A=
        if (this.options.shadow.enabled =3D=3D=3D true) {=0A=
          ctx.shadowColor =3D 'rgba(0,0,0,0.5)';=0A=
          ctx.shadowBlur =3D this.options.shadow.size;=0A=
          ctx.shadowOffsetX =3D this.options.shadow.x;=0A=
          ctx.shadowOffsetY =3D this.options.shadow.y;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'disableShadow',=0A=
      value: function disableShadow(ctx) {=0A=
        if (this.options.shadow.enabled =3D=3D=3D true) {=0A=
          ctx.shadowColor =3D 'rgba(0,0,0,0)';=0A=
          ctx.shadowBlur =3D 0;=0A=
          ctx.shadowOffsetX =3D 0;=0A=
          ctx.shadowOffsetY =3D 0;=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return EdgeBase;=0A=
  })();=0A=
=0A=
  exports['default'] =3D EdgeBase;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 86 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _slicedToArray =3D (function () { function sliceIterator(arr, i) { =
var _arr =3D []; var _n =3D true; var _d =3D false; var _e =3D =
undefined; try { for (var _i =3D arr[Symbol.iterator](), _s; !(_n =3D =
(_s =3D _i.next()).done); _n =3D true) { _arr.push(_s.value); if (i && =
_arr.length =3D=3D=3D i) break; } } catch (err) { _d =3D true; _e =3D =
err; } finally { try { if (!_n && _i['return']) _i['return'](); } =
finally { if (_d) throw _e; } } return _arr; } return function (arr, i) =
{ if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in =
Object(arr)) { return sliceIterator(arr, i); } else { throw new =
TypeError('Invalid attempt to destructure non-iterable instance'); } }; =
})();=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x3, _x4, _x5) { var _again =3D true; =
_function: while (_again) { var object =3D _x3, property =3D _x4, =
receiver =3D _x5; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x3 =3D parent; _x4 =
=3D property; _x5 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilCubicBezierEdgeBase =3D __webpack_require__(87);=0A=
=0A=
  var _utilCubicBezierEdgeBase2 =3D =
_interopRequireDefault(_utilCubicBezierEdgeBase);=0A=
=0A=
  var CubicBezierEdge =3D (function (_CubicBezierEdgeBase) {=0A=
    _inherits(CubicBezierEdge, _CubicBezierEdgeBase);=0A=
=0A=
    function CubicBezierEdge(options, body, labelModule) {=0A=
      _classCallCheck(this, CubicBezierEdge);=0A=
=0A=
      _get(Object.getPrototypeOf(CubicBezierEdge.prototype), =
'constructor', this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(CubicBezierEdge, [{=0A=
      key: '_line',=0A=
=0A=
      /**=0A=
       * Draw a line between two nodes=0A=
       * @param {CanvasRenderingContext2D} ctx=0A=
       * @private=0A=
       */=0A=
      value: function _line(ctx) {=0A=
        // get the coordinates of the support points.=0A=
=0A=
        var _getViaCoordinates2 =3D this._getViaCoordinates();=0A=
=0A=
        var _getViaCoordinates22 =3D _slicedToArray(_getViaCoordinates2, =
2);=0A=
=0A=
        var via1 =3D _getViaCoordinates22[0];=0A=
        var via2 =3D _getViaCoordinates22[1];=0A=
=0A=
        var returnValue =3D [via1, via2];=0A=
=0A=
        // start drawing the line.=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(this.from.x, this.from.y);=0A=
=0A=
        // fallback to normal straight edges=0A=
        if (via1.x =3D=3D=3D undefined) {=0A=
          ctx.lineTo(this.to.x, this.to.y);=0A=
          returnValue =3D undefined;=0A=
        } else {=0A=
          ctx.bezierCurveTo(via1.x, via1.y, via2.x, via2.y, this.to.x, =
this.to.y);=0A=
        }=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        ctx.stroke();=0A=
        this.disableShadow(ctx);=0A=
        return returnValue;=0A=
      }=0A=
    }, {=0A=
      key: '_getViaCoordinates',=0A=
      value: function _getViaCoordinates() {=0A=
        var dx =3D this.from.x - this.to.x;=0A=
        var dy =3D this.from.y - this.to.y;=0A=
=0A=
        var x1 =3D undefined,=0A=
            y1 =3D undefined,=0A=
            x2 =3D undefined,=0A=
            y2 =3D undefined;=0A=
        var roundness =3D this.options.smooth.roundness;;=0A=
=0A=
        // horizontal if x > y or if direction is forced or if direction =
is horizontal=0A=
        if ((Math.abs(dx) > Math.abs(dy) || =
this.options.smooth.forceDirection =3D=3D=3D true || =
this.options.smooth.forceDirection =3D=3D=3D 'horizontal') && =
this.options.smooth.forceDirection !=3D=3D 'vertical') {=0A=
          y1 =3D this.from.y;=0A=
          y2 =3D this.to.y;=0A=
          x1 =3D this.from.x - roundness * dx;=0A=
          x2 =3D this.to.x + roundness * dx;=0A=
        } else {=0A=
          y1 =3D this.from.y - roundness * dy;=0A=
          y2 =3D this.to.y + roundness * dy;=0A=
          x1 =3D this.from.x;=0A=
          x2 =3D this.to.x;=0A=
        }=0A=
=0A=
        return [{ x: x1, y: y1 }, { x: x2, y: y2 }];=0A=
      }=0A=
    }, {=0A=
      key: '_findBorderPosition',=0A=
      value: function _findBorderPosition(nearNode, ctx) {=0A=
        return this._findBorderPositionBezier(nearNode, ctx);=0A=
      }=0A=
    }, {=0A=
      key: '_getDistanceToEdge',=0A=
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {=0A=
        var _ref =3D arguments.length <=3D 6 || arguments[6] =3D=3D=3D =
undefined ? this._getViaCoordinates() : arguments[6];=0A=
=0A=
        var _ref2 =3D _slicedToArray(_ref, 2);=0A=
=0A=
        var via1 =3D _ref2[0];=0A=
        var via2 =3D _ref2[1];=0A=
        // x3,y3 is the point=0A=
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, =
via1, via2);=0A=
      }=0A=
    }, {=0A=
      key: 'getPoint',=0A=
=0A=
      /**=0A=
       * Combined function of pointOnLine and pointOnBezier. This gives =
the coordinates of a point on the line at a certain percentage of the way=0A=
       * @param percentage=0A=
       * @param via=0A=
       * @returns {{x: number, y: number}}=0A=
       * @private=0A=
       */=0A=
      value: function getPoint(percentage) {=0A=
        var _ref3 =3D arguments.length <=3D 1 || arguments[1] =3D=3D=3D =
undefined ? this._getViaCoordinates() : arguments[1];=0A=
=0A=
        var _ref32 =3D _slicedToArray(_ref3, 2);=0A=
=0A=
        var via1 =3D _ref32[0];=0A=
        var via2 =3D _ref32[1];=0A=
=0A=
        var t =3D percentage;=0A=
        var vec =3D [];=0A=
        vec[0] =3D Math.pow(1 - t, 3);=0A=
        vec[1] =3D 3 * t * Math.pow(1 - t, 2);=0A=
        vec[2] =3D 3 * Math.pow(t, 2) * (1 - t);=0A=
        vec[3] =3D Math.pow(t, 3);=0A=
        var x =3D vec[0] * this.from.x + vec[1] * via1.x + vec[2] * =
via2.x + vec[3] * this.to.x;=0A=
        var y =3D vec[0] * this.from.y + vec[1] * via1.y + vec[2] * =
via2.y + vec[3] * this.to.y;=0A=
=0A=
        return { x: x, y: y };=0A=
      }=0A=
    }]);=0A=
=0A=
    return CubicBezierEdge;=0A=
  })(_utilCubicBezierEdgeBase2['default']);=0A=
=0A=
  exports['default'] =3D CubicBezierEdge;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 87 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _BezierEdgeBase2 =3D __webpack_require__(84);=0A=
=0A=
  var _BezierEdgeBase3 =3D _interopRequireDefault(_BezierEdgeBase2);=0A=
=0A=
  var CubicBezierEdgeBase =3D (function (_BezierEdgeBase) {=0A=
    _inherits(CubicBezierEdgeBase, _BezierEdgeBase);=0A=
=0A=
    function CubicBezierEdgeBase(options, body, labelModule) {=0A=
      _classCallCheck(this, CubicBezierEdgeBase);=0A=
=0A=
      _get(Object.getPrototypeOf(CubicBezierEdgeBase.prototype), =
'constructor', this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(CubicBezierEdgeBase, [{=0A=
      key: '_getDistanceToBezierEdge',=0A=
=0A=
      /**=0A=
       * Calculate the distance between a point (x3,y3) and a line =
segment from=0A=
       * (x1,y1) to (x2,y2).=0A=
       * =
http://stackoverflow.com/questions/849211/shortest-distancae-between-a-po=
int-and-a-line-segment=0A=
       * https://en.wikipedia.org/wiki/B%C3%A9zier_curve=0A=
       * @param {number} x1 from x=0A=
       * @param {number} y1 from y=0A=
       * @param {number} x2 to x=0A=
       * @param {number} y2 to y=0A=
       * @param {number} x3 point to check x=0A=
       * @param {number} y3 point to check y=0A=
       * @private=0A=
       */=0A=
      value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, =
via1, via2) {=0A=
        // x3,y3 is the point=0A=
        var minDistance =3D 1e9;=0A=
        var distance =3D undefined;=0A=
        var i =3D undefined,=0A=
            t =3D undefined,=0A=
            x =3D undefined,=0A=
            y =3D undefined;=0A=
        var lastX =3D x1;=0A=
        var lastY =3D y1;=0A=
        var vec =3D [0, 0, 0, 0];=0A=
        for (i =3D 1; i < 10; i++) {=0A=
          t =3D 0.1 * i;=0A=
          vec[0] =3D Math.pow(1 - t, 3);=0A=
          vec[1] =3D 3 * t * Math.pow(1 - t, 2);=0A=
          vec[2] =3D 3 * Math.pow(t, 2) * (1 - t);=0A=
          vec[3] =3D Math.pow(t, 3);=0A=
          x =3D vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] =
* x2;=0A=
          y =3D vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] =
* y2;=0A=
          if (i > 0) {=0A=
            distance =3D this._getDistanceToLine(lastX, lastY, x, y, x3, =
y3);=0A=
            minDistance =3D distance < minDistance ? distance : =
minDistance;=0A=
          }=0A=
          lastX =3D x;=0A=
          lastY =3D y;=0A=
        }=0A=
=0A=
        return minDistance;=0A=
      }=0A=
    }]);=0A=
=0A=
    return CubicBezierEdgeBase;=0A=
  })(_BezierEdgeBase3['default']);=0A=
=0A=
  exports['default'] =3D CubicBezierEdgeBase;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 88 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilBezierEdgeBase =3D __webpack_require__(84);=0A=
=0A=
  var _utilBezierEdgeBase2 =3D =
_interopRequireDefault(_utilBezierEdgeBase);=0A=
=0A=
  var BezierEdgeDynamic =3D (function (_BezierEdgeBase) {=0A=
    _inherits(BezierEdgeDynamic, _BezierEdgeBase);=0A=
=0A=
    function BezierEdgeDynamic(options, body, labelModule) {=0A=
      _classCallCheck(this, BezierEdgeDynamic);=0A=
=0A=
      //this.via =3D undefined; // Here for completeness but not allowed =
to defined before super() is invoked.=0A=
      _get(Object.getPrototypeOf(BezierEdgeDynamic.prototype), =
'constructor', this).call(this, options, body, labelModule); // --> this =
calls the setOptions below=0A=
    }=0A=
=0A=
    _createClass(BezierEdgeDynamic, [{=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
        this.id =3D this.options.id;=0A=
        this.setupSupportNode();=0A=
=0A=
        // when we change the physics state of the edge, we reposition =
the support node.=0A=
        if (this.options.physics !=3D=3D options.physics) {=0A=
          this.via.setOptions({ physics: this.options.physics });=0A=
          this.positionBezierNode();=0A=
        }=0A=
        this.connect();=0A=
      }=0A=
    }, {=0A=
      key: 'connect',=0A=
      value: function connect() {=0A=
        this.from =3D this.body.nodes[this.options.from];=0A=
        this.to =3D this.body.nodes[this.options.to];=0A=
        if (this.from =3D=3D=3D undefined || this.to =3D=3D=3D undefined =
|| this.options.physics =3D=3D=3D false) {=0A=
          this.via.setOptions({ physics: false });=0A=
        } else {=0A=
          // fix weird behaviour where a selfreferencing node has =
physics enabled=0A=
          if (this.from.id =3D=3D=3D this.to.id) {=0A=
            this.via.setOptions({ physics: false });=0A=
          } else {=0A=
            this.via.setOptions({ physics: true });=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'cleanup',=0A=
=0A=
      /**=0A=
       * remove the support nodes=0A=
       * @returns {boolean}=0A=
       */=0A=
      value: function cleanup() {=0A=
        if (this.via !=3D=3D undefined) {=0A=
          delete this.body.nodes[this.via.id];=0A=
          this.via =3D undefined;=0A=
          return true;=0A=
        }=0A=
        return false;=0A=
      }=0A=
    }, {=0A=
      key: 'setupSupportNode',=0A=
=0A=
      /**=0A=
       * Bezier curves require an anchor point to calculate the smooth =
flow. These points are nodes. These nodes are invisible but=0A=
       * are used for the force calculation.=0A=
       *=0A=
       * The changed data is not called, if needed, it is returned by =
the main edge constructor.=0A=
       * @private=0A=
       */=0A=
      value: function setupSupportNode() {=0A=
        if (this.via =3D=3D=3D undefined) {=0A=
          var nodeId =3D 'edgeId:' + this.id;=0A=
          var node =3D this.body.functions.createNode({=0A=
            id: nodeId,=0A=
            shape: 'circle',=0A=
            physics: true,=0A=
            hidden: true=0A=
          });=0A=
          this.body.nodes[nodeId] =3D node;=0A=
          this.via =3D node;=0A=
          this.via.parentEdgeId =3D this.id;=0A=
          this.positionBezierNode();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'positionBezierNode',=0A=
      value: function positionBezierNode() {=0A=
        if (this.via !=3D=3D undefined && this.from !=3D=3D undefined && =
this.to !=3D=3D undefined) {=0A=
          this.via.x =3D 0.5 * (this.from.x + this.to.x);=0A=
          this.via.y =3D 0.5 * (this.from.y + this.to.y);=0A=
        } else if (this.via !=3D=3D undefined) {=0A=
          this.via.x =3D 0;=0A=
          this.via.y =3D 0;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_line',=0A=
=0A=
      /**=0A=
       * Draw a line between two nodes=0A=
       * @param {CanvasRenderingContext2D} ctx=0A=
       * @private=0A=
       */=0A=
      value: function _line(ctx) {=0A=
        // draw a straight line=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(this.from.x, this.from.y);=0A=
        ctx.quadraticCurveTo(this.via.x, this.via.y, this.to.x, =
this.to.y);=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        ctx.stroke();=0A=
        this.disableShadow(ctx);=0A=
        return this.via;=0A=
      }=0A=
    }, {=0A=
      key: 'getPoint',=0A=
=0A=
      /**=0A=
       * Combined function of pointOnLine and pointOnBezier. This gives =
the coordinates of a point on the line at a certain percentage of the way=0A=
       * @param percentage=0A=
       * @param via=0A=
       * @returns {{x: number, y: number}}=0A=
       * @private=0A=
       */=0A=
      value: function getPoint(percentage) {=0A=
        var t =3D percentage;=0A=
        var x =3D Math.pow(1 - t, 2) * this.from.x + 2 * t * (1 - t) * =
this.via.x + Math.pow(t, 2) * this.to.x;=0A=
        var y =3D Math.pow(1 - t, 2) * this.from.y + 2 * t * (1 - t) * =
this.via.y + Math.pow(t, 2) * this.to.y;=0A=
=0A=
        return { x: x, y: y };=0A=
      }=0A=
    }, {=0A=
      key: '_findBorderPosition',=0A=
      value: function _findBorderPosition(nearNode, ctx) {=0A=
        return this._findBorderPositionBezier(nearNode, ctx, this.via);=0A=
      }=0A=
    }, {=0A=
      key: '_getDistanceToEdge',=0A=
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {=0A=
        // x3,y3 is the point=0A=
        return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, =
this.via);=0A=
      }=0A=
    }]);=0A=
=0A=
    return BezierEdgeDynamic;=0A=
  })(_utilBezierEdgeBase2['default']);=0A=
=0A=
  exports['default'] =3D BezierEdgeDynamic;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 89 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _utilEdgeBase =3D __webpack_require__(85);=0A=
=0A=
  var _utilEdgeBase2 =3D _interopRequireDefault(_utilEdgeBase);=0A=
=0A=
  var StraightEdge =3D (function (_EdgeBase) {=0A=
    _inherits(StraightEdge, _EdgeBase);=0A=
=0A=
    function StraightEdge(options, body, labelModule) {=0A=
      _classCallCheck(this, StraightEdge);=0A=
=0A=
      _get(Object.getPrototypeOf(StraightEdge.prototype), 'constructor', =
this).call(this, options, body, labelModule);=0A=
    }=0A=
=0A=
    _createClass(StraightEdge, [{=0A=
      key: '_line',=0A=
=0A=
      /**=0A=
       * Draw a line between two nodes=0A=
       * @param {CanvasRenderingContext2D} ctx=0A=
       * @private=0A=
       */=0A=
      value: function _line(ctx) {=0A=
        // draw a straight line=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(this.from.x, this.from.y);=0A=
        ctx.lineTo(this.to.x, this.to.y);=0A=
        // draw shadow if enabled=0A=
        this.enableShadow(ctx);=0A=
        ctx.stroke();=0A=
        this.disableShadow(ctx);=0A=
        return undefined;=0A=
      }=0A=
    }, {=0A=
      key: 'getPoint',=0A=
=0A=
      /**=0A=
       * Combined function of pointOnLine and pointOnBezier. This gives =
the coordinates of a point on the line at a certain percentage of the way=0A=
       * @param percentage=0A=
       * @param via=0A=
       * @returns {{x: number, y: number}}=0A=
       * @private=0A=
       */=0A=
      value: function getPoint(percentage) {=0A=
        return {=0A=
          x: (1 - percentage) * this.from.x + percentage * this.to.x,=0A=
          y: (1 - percentage) * this.from.y + percentage * this.to.y=0A=
        };=0A=
      }=0A=
    }, {=0A=
      key: '_findBorderPosition',=0A=
      value: function _findBorderPosition(nearNode, ctx) {=0A=
        var node1 =3D this.to;=0A=
        var node2 =3D this.from;=0A=
        if (nearNode.id =3D=3D=3D this.from.id) {=0A=
          node1 =3D this.from;=0A=
          node2 =3D this.to;=0A=
        }=0A=
=0A=
        var angle =3D Math.atan2(node1.y - node2.y, node1.x - node2.x);=0A=
        var dx =3D node1.x - node2.x;=0A=
        var dy =3D node1.y - node2.y;=0A=
        var edgeSegmentLength =3D Math.sqrt(dx * dx + dy * dy);=0A=
        var toBorderDist =3D nearNode.distanceToBorder(ctx, angle);=0A=
        var toBorderPoint =3D (edgeSegmentLength - toBorderDist) / =
edgeSegmentLength;=0A=
=0A=
        var borderPos =3D {};=0A=
        borderPos.x =3D (1 - toBorderPoint) * node2.x + toBorderPoint * =
node1.x;=0A=
        borderPos.y =3D (1 - toBorderPoint) * node2.y + toBorderPoint * =
node1.y;=0A=
=0A=
        return borderPos;=0A=
      }=0A=
    }, {=0A=
      key: '_getDistanceToEdge',=0A=
      value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {=0A=
        // x3,y3 is the point=0A=
        return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);=0A=
      }=0A=
    }]);=0A=
=0A=
    return StraightEdge;=0A=
  })(_utilEdgeBase2['default']);=0A=
=0A=
  exports['default'] =3D StraightEdge;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 90 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _componentsPhysicsBarnesHutSolver =3D __webpack_require__(91);=0A=
=0A=
  var _componentsPhysicsBarnesHutSolver2 =3D =
_interopRequireDefault(_componentsPhysicsBarnesHutSolver);=0A=
=0A=
  var _componentsPhysicsRepulsionSolver =3D __webpack_require__(92);=0A=
=0A=
  var _componentsPhysicsRepulsionSolver2 =3D =
_interopRequireDefault(_componentsPhysicsRepulsionSolver);=0A=
=0A=
  var _componentsPhysicsHierarchicalRepulsionSolver =3D =
__webpack_require__(93);=0A=
=0A=
  var _componentsPhysicsHierarchicalRepulsionSolver2 =3D =
_interopRequireDefault(_componentsPhysicsHierarchicalRepulsionSolver);=0A=
=0A=
  var _componentsPhysicsSpringSolver =3D __webpack_require__(94);=0A=
=0A=
  var _componentsPhysicsSpringSolver2 =3D =
_interopRequireDefault(_componentsPhysicsSpringSolver);=0A=
=0A=
  var _componentsPhysicsHierarchicalSpringSolver =3D =
__webpack_require__(95);=0A=
=0A=
  var _componentsPhysicsHierarchicalSpringSolver2 =3D =
_interopRequireDefault(_componentsPhysicsHierarchicalSpringSolver);=0A=
=0A=
  var _componentsPhysicsCentralGravitySolver =3D __webpack_require__(96);=0A=
=0A=
  var _componentsPhysicsCentralGravitySolver2 =3D =
_interopRequireDefault(_componentsPhysicsCentralGravitySolver);=0A=
=0A=
  var _componentsPhysicsFA2BasedRepulsionSolver =3D =
__webpack_require__(97);=0A=
=0A=
  var _componentsPhysicsFA2BasedRepulsionSolver2 =3D =
_interopRequireDefault(_componentsPhysicsFA2BasedRepulsionSolver);=0A=
=0A=
  var _componentsPhysicsFA2BasedCentralGravitySolver =3D =
__webpack_require__(98);=0A=
=0A=
  var _componentsPhysicsFA2BasedCentralGravitySolver2 =3D =
_interopRequireDefault(_componentsPhysicsFA2BasedCentralGravitySolver);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var PhysicsEngine =3D (function () {=0A=
    function PhysicsEngine(body) {=0A=
      _classCallCheck(this, PhysicsEngine);=0A=
=0A=
      this.body =3D body;=0A=
      this.physicsBody =3D { physicsNodeIndices: [], physicsEdgeIndices: =
[], forces: {}, velocities: {} };=0A=
=0A=
      this.physicsEnabled =3D true;=0A=
      this.simulationInterval =3D 1000 / 60;=0A=
      this.requiresTimeout =3D true;=0A=
      this.previousStates =3D {};=0A=
      this.freezeCache =3D {};=0A=
      this.renderTimer =3D undefined;=0A=
      this.initialStabilizationEmitted =3D false;=0A=
=0A=
      this.stabilized =3D false;=0A=
      this.startedStabilization =3D false;=0A=
      this.stabilizationIterations =3D 0;=0A=
      this.ready =3D false; // will be set to true if the stabilize=0A=
=0A=
      // default options=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        enabled: true,=0A=
        barnesHut: {=0A=
          theta: 0.5,=0A=
          gravitationalConstant: -2000,=0A=
          centralGravity: 0.3,=0A=
          springLength: 95,=0A=
          springConstant: 0.04,=0A=
          damping: 0.09,=0A=
          avoidOverlap: 0=0A=
        },=0A=
        forceAtlas2Based: {=0A=
          theta: 0.5,=0A=
          gravitationalConstant: -50,=0A=
          centralGravity: 0.01,=0A=
          springConstant: 0.08,=0A=
          springLength: 100,=0A=
          damping: 0.4,=0A=
          avoidOverlap: 0=0A=
        },=0A=
        repulsion: {=0A=
          centralGravity: 0.2,=0A=
          springLength: 200,=0A=
          springConstant: 0.05,=0A=
          nodeDistance: 100,=0A=
          damping: 0.09,=0A=
          avoidOverlap: 0=0A=
        },=0A=
        hierarchicalRepulsion: {=0A=
          centralGravity: 0.0,=0A=
          springLength: 100,=0A=
          springConstant: 0.01,=0A=
          nodeDistance: 120,=0A=
          damping: 0.09=0A=
        },=0A=
        maxVelocity: 50,=0A=
        minVelocity: 0.1, // px/s=0A=
        solver: 'barnesHut',=0A=
        stabilization: {=0A=
          enabled: true,=0A=
          iterations: 1000, // maximum number of iteration to stabilize=0A=
          updateInterval: 50,=0A=
          onlyDynamicEdges: false,=0A=
          fit: true=0A=
        },=0A=
        timestep: 0.5=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.bindEventListeners();=0A=
    }=0A=
=0A=
    _createClass(PhysicsEngine, [{=0A=
      key: 'bindEventListeners',=0A=
      value: function bindEventListeners() {=0A=
        var _this =3D this;=0A=
=0A=
        this.body.emitter.on('initPhysics', function () {=0A=
          _this.initPhysics();=0A=
        });=0A=
        this.body.emitter.on('resetPhysics', function () {=0A=
          _this.stopSimulation();_this.ready =3D false;=0A=
        });=0A=
        this.body.emitter.on('disablePhysics', function () {=0A=
          _this.physicsEnabled =3D false;_this.stopSimulation();=0A=
        });=0A=
        this.body.emitter.on('restorePhysics', function () {=0A=
          _this.setOptions(_this.options);=0A=
          if (_this.ready =3D=3D=3D true) {=0A=
            _this.startSimulation();=0A=
          }=0A=
        });=0A=
        this.body.emitter.on('startSimulation', function () {=0A=
          if (_this.ready =3D=3D=3D true) {=0A=
            _this.startSimulation();=0A=
          }=0A=
        });=0A=
        this.body.emitter.on('stopSimulation', function () {=0A=
          _this.stopSimulation();=0A=
        });=0A=
        this.body.emitter.on('destroy', function () {=0A=
          _this.stopSimulation(false);=0A=
          _this.body.emitter.off();=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          if (options =3D=3D=3D false) {=0A=
            this.options.enabled =3D false;=0A=
            this.physicsEnabled =3D false;=0A=
            this.stopSimulation();=0A=
          } else {=0A=
            this.physicsEnabled =3D true;=0A=
            util.selectiveNotDeepExtend(['stabilization'], this.options, =
options);=0A=
            util.mergeOptions(this.options, options, 'stabilization');=0A=
=0A=
            if (options.enabled =3D=3D=3D undefined) {=0A=
              this.options.enabled =3D true;=0A=
            }=0A=
=0A=
            if (this.options.enabled =3D=3D=3D false) {=0A=
              this.physicsEnabled =3D false;=0A=
              this.stopSimulation();=0A=
            }=0A=
          }=0A=
        }=0A=
        this.init();=0A=
      }=0A=
    }, {=0A=
      key: 'init',=0A=
      value: function init() {=0A=
        var options;=0A=
        if (this.options.solver =3D=3D=3D 'forceAtlas2Based') {=0A=
          options =3D this.options.forceAtlas2Based;=0A=
          this.nodesSolver =3D new =
_componentsPhysicsFA2BasedRepulsionSolver2['default'](this.body, =
this.physicsBody, options);=0A=
          this.edgesSolver =3D new =
_componentsPhysicsSpringSolver2['default'](this.body, this.physicsBody, =
options);=0A=
          this.gravitySolver =3D new =
_componentsPhysicsFA2BasedCentralGravitySolver2['default'](this.body, =
this.physicsBody, options);=0A=
        } else if (this.options.solver =3D=3D=3D 'repulsion') {=0A=
          options =3D this.options.repulsion;=0A=
          this.nodesSolver =3D new =
_componentsPhysicsRepulsionSolver2['default'](this.body, =
this.physicsBody, options);=0A=
          this.edgesSolver =3D new =
_componentsPhysicsSpringSolver2['default'](this.body, this.physicsBody, =
options);=0A=
          this.gravitySolver =3D new =
_componentsPhysicsCentralGravitySolver2['default'](this.body, =
this.physicsBody, options);=0A=
        } else if (this.options.solver =3D=3D=3D =
'hierarchicalRepulsion') {=0A=
          options =3D this.options.hierarchicalRepulsion;=0A=
          this.nodesSolver =3D new =
_componentsPhysicsHierarchicalRepulsionSolver2['default'](this.body, =
this.physicsBody, options);=0A=
          this.edgesSolver =3D new =
_componentsPhysicsHierarchicalSpringSolver2['default'](this.body, =
this.physicsBody, options);=0A=
          this.gravitySolver =3D new =
_componentsPhysicsCentralGravitySolver2['default'](this.body, =
this.physicsBody, options);=0A=
        } else {=0A=
          // barnesHut=0A=
          options =3D this.options.barnesHut;=0A=
          this.nodesSolver =3D new =
_componentsPhysicsBarnesHutSolver2['default'](this.body, =
this.physicsBody, options);=0A=
          this.edgesSolver =3D new =
_componentsPhysicsSpringSolver2['default'](this.body, this.physicsBody, =
options);=0A=
          this.gravitySolver =3D new =
_componentsPhysicsCentralGravitySolver2['default'](this.body, =
this.physicsBody, options);=0A=
        }=0A=
=0A=
        this.modelOptions =3D options;=0A=
      }=0A=
    }, {=0A=
      key: 'initPhysics',=0A=
      value: function initPhysics() {=0A=
        if (this.physicsEnabled =3D=3D=3D true && this.options.enabled =
=3D=3D=3D true) {=0A=
          if (this.options.stabilization.enabled =3D=3D=3D true) {=0A=
            this.stabilize();=0A=
          } else {=0A=
            this.stabilized =3D false;=0A=
            this.ready =3D true;=0A=
            this.body.emitter.emit('fit', {}, true);=0A=
            this.startSimulation();=0A=
          }=0A=
        } else {=0A=
          this.ready =3D true;=0A=
          this.body.emitter.emit('fit');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'startSimulation',=0A=
=0A=
      /**=0A=
       * Start the simulation=0A=
       */=0A=
      value: function startSimulation() {=0A=
        if (this.physicsEnabled =3D=3D=3D true && this.options.enabled =
=3D=3D=3D true) {=0A=
          this.stabilized =3D false;=0A=
=0A=
          // this sets the width of all nodes initially which could be =
required for the avoidOverlap=0A=
          this.body.emitter.emit('_resizeNodes');=0A=
          if (this.viewFunction =3D=3D=3D undefined) {=0A=
            this.viewFunction =3D this.simulationStep.bind(this);=0A=
            this.body.emitter.on('initRedraw', this.viewFunction);=0A=
            this.body.emitter.emit('_startRendering');=0A=
          }=0A=
        } else {=0A=
          this.body.emitter.emit('_redraw');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'stopSimulation',=0A=
=0A=
      /**=0A=
       * Stop the simulation, force stabilization.=0A=
       */=0A=
      value: function stopSimulation() {=0A=
        var emit =3D arguments.length <=3D 0 || arguments[0] =3D=3D=3D =
undefined ? true : arguments[0];=0A=
=0A=
        this.stabilized =3D true;=0A=
        if (emit =3D=3D=3D true) {=0A=
          this._emitStabilized();=0A=
        }=0A=
        if (this.viewFunction !=3D=3D undefined) {=0A=
          this.body.emitter.off('initRedraw', this.viewFunction);=0A=
          this.viewFunction =3D undefined;=0A=
          if (emit =3D=3D=3D true) {=0A=
            this.body.emitter.emit('_stopRendering');=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'simulationStep',=0A=
=0A=
      /**=0A=
       * The viewFunction inserts this step into each renderloop. It =
calls the physics tick and handles the cleanup at stabilized.=0A=
       *=0A=
       */=0A=
      value: function simulationStep() {=0A=
        // check if the physics have settled=0A=
        var startTime =3D Date.now();=0A=
        this.physicsTick();=0A=
        var physicsTime =3D Date.now() - startTime;=0A=
=0A=
        // run double speed if it is a little graph=0A=
        if ((physicsTime < 0.4 * this.simulationInterval || =
this.runDoubleSpeed =3D=3D=3D true) && this.stabilized =3D=3D=3D false) {=0A=
          this.physicsTick();=0A=
=0A=
          // this makes sure there is no jitter. The decision is taken =
once to run it at double speed.=0A=
          this.runDoubleSpeed =3D true;=0A=
        }=0A=
=0A=
        if (this.stabilized =3D=3D=3D true) {=0A=
          if (this.stabilizationIterations > 1) {=0A=
            // trigger the 'stabilized' event.=0A=
            // The event is triggered on the next tick, to prevent the =
case that=0A=
            // it is fired while initializing the Network, in which case =
you would not=0A=
            // be able to catch it=0A=
            this.startedStabilization =3D false;=0A=
            //this._emitStabilized();=0A=
          }=0A=
          this.stopSimulation();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_emitStabilized',=0A=
      value: function _emitStabilized() {=0A=
        var _this2 =3D this;=0A=
=0A=
        if (this.stabilizationIterations > 1 || =
this.initialStabilizationEmitted =3D=3D=3D false) {=0A=
          this.initialStabilizationEmitted =3D true;=0A=
          setTimeout(function () {=0A=
            _this2.body.emitter.emit('stabilized', { iterations: =
_this2.stabilizationIterations });=0A=
            _this2.stabilizationIterations =3D 0;=0A=
          }, 0);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'physicsTick',=0A=
=0A=
      /**=0A=
       * A single simulation step (or 'tick') in the physics simulation=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function physicsTick() {=0A=
        if (this.stabilized =3D=3D=3D false) {=0A=
          this.calculateForces();=0A=
          this.stabilized =3D this.moveNodes();=0A=
=0A=
          // determine if the network has stabilzied=0A=
          if (this.stabilized =3D=3D=3D true) {=0A=
            this.revert();=0A=
          } else {=0A=
            // this is here to ensure that there is no start event when =
the network is already stable.=0A=
            if (this.startedStabilization =3D=3D=3D false) {=0A=
              this.body.emitter.emit('startStabilizing');=0A=
              this.startedStabilization =3D true;=0A=
            }=0A=
          }=0A=
=0A=
          this.stabilizationIterations++;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'updatePhysicsData',=0A=
=0A=
      /**=0A=
       * Nodes and edges can have the physics toggles on or off. A =
collection of indices is created here so we can skip the check all the =
time.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function updatePhysicsData() {=0A=
        this.physicsBody.forces =3D {};=0A=
        this.physicsBody.physicsNodeIndices =3D [];=0A=
        this.physicsBody.physicsEdgeIndices =3D [];=0A=
        var nodes =3D this.body.nodes;=0A=
        var edges =3D this.body.edges;=0A=
=0A=
        // get node indices for physics=0A=
        for (var nodeId in nodes) {=0A=
          if (nodes.hasOwnProperty(nodeId)) {=0A=
            if (nodes[nodeId].options.physics =3D=3D=3D true) {=0A=
              this.physicsBody.physicsNodeIndices.push(nodeId);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // get edge indices for physics=0A=
        for (var edgeId in edges) {=0A=
          if (edges.hasOwnProperty(edgeId)) {=0A=
            if (edges[edgeId].options.physics =3D=3D=3D true) {=0A=
              this.physicsBody.physicsEdgeIndices.push(edgeId);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // get the velocity and the forces vector=0A=
        for (var i =3D 0; i < =
this.physicsBody.physicsNodeIndices.length; i++) {=0A=
          var nodeId =3D this.physicsBody.physicsNodeIndices[i];=0A=
          this.physicsBody.forces[nodeId] =3D { x: 0, y: 0 };=0A=
=0A=
          // forces can be reset because they are recalculated. =
Velocities have to persist.=0A=
          if (this.physicsBody.velocities[nodeId] =3D=3D=3D undefined) {=0A=
            this.physicsBody.velocities[nodeId] =3D { x: 0, y: 0 };=0A=
          }=0A=
        }=0A=
=0A=
        // clean deleted nodes from the velocity vector=0A=
        for (var nodeId in this.physicsBody.velocities) {=0A=
          if (nodes[nodeId] =3D=3D=3D undefined) {=0A=
            delete this.physicsBody.velocities[nodeId];=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'revert',=0A=
=0A=
      /**=0A=
       * Revert the simulation one step. This is done so after =
stabilization, every new start of the simulation will also say =
stabilized.=0A=
       */=0A=
      value: function revert() {=0A=
        var nodeIds =3D Object.keys(this.previousStates);=0A=
        var nodes =3D this.body.nodes;=0A=
        var velocities =3D this.physicsBody.velocities;=0A=
=0A=
        for (var i =3D 0; i < nodeIds.length; i++) {=0A=
          var nodeId =3D nodeIds[i];=0A=
          if (nodes[nodeId] !=3D=3D undefined) {=0A=
            if (nodes[nodeId].options.physics =3D=3D=3D true) {=0A=
              velocities[nodeId].x =3D this.previousStates[nodeId].vx;=0A=
              velocities[nodeId].y =3D this.previousStates[nodeId].vy;=0A=
              nodes[nodeId].x =3D this.previousStates[nodeId].x;=0A=
              nodes[nodeId].y =3D this.previousStates[nodeId].y;=0A=
            }=0A=
          } else {=0A=
            delete this.previousStates[nodeId];=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'moveNodes',=0A=
=0A=
      /**=0A=
       * move the nodes one timestap and check if they are stabilized=0A=
       * @returns {boolean}=0A=
       */=0A=
      value: function moveNodes() {=0A=
        var nodesPresent =3D false;=0A=
        var nodeIndices =3D this.physicsBody.physicsNodeIndices;=0A=
        var maxVelocity =3D this.options.maxVelocity ? =
this.options.maxVelocity : 1e9;=0A=
        var stabilized =3D true;=0A=
        var vminCorrected =3D this.options.minVelocity / =
Math.max(this.body.view.scale, 0.05);=0A=
=0A=
        for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
          var nodeId =3D nodeIndices[i];=0A=
          var nodeVelocity =3D this._performStep(nodeId, maxVelocity);=0A=
          // stabilized is true if stabilized is true and velocity is =
smaller than vmin --> all nodes must be stabilized=0A=
          stabilized =3D nodeVelocity < vminCorrected && stabilized =
=3D=3D=3D true;=0A=
          nodesPresent =3D true;=0A=
        }=0A=
=0A=
        if (nodesPresent =3D=3D=3D true) {=0A=
          if (vminCorrected > 0.5 * this.options.maxVelocity) {=0A=
            return false;=0A=
          } else {=0A=
            return stabilized;=0A=
          }=0A=
        }=0A=
        return true;=0A=
      }=0A=
    }, {=0A=
      key: '_performStep',=0A=
=0A=
      /**=0A=
       * Perform the actual step=0A=
       *=0A=
       * @param nodeId=0A=
       * @param maxVelocity=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _performStep(nodeId, maxVelocity) {=0A=
        var node =3D this.body.nodes[nodeId];=0A=
        var timestep =3D this.options.timestep;=0A=
        var forces =3D this.physicsBody.forces;=0A=
        var velocities =3D this.physicsBody.velocities;=0A=
=0A=
        // store the state so we can revert=0A=
        this.previousStates[nodeId] =3D { x: node.x, y: node.y, vx: =
velocities[nodeId].x, vy: velocities[nodeId].y };=0A=
=0A=
        if (node.options.fixed.x =3D=3D=3D false) {=0A=
          var dx =3D this.modelOptions.damping * velocities[nodeId].x; =
// damping force=0A=
          var ax =3D (forces[nodeId].x - dx) / node.options.mass; // =
acceleration=0A=
          velocities[nodeId].x +=3D ax * timestep; // velocity=0A=
          velocities[nodeId].x =3D Math.abs(velocities[nodeId].x) > =
maxVelocity ? velocities[nodeId].x > 0 ? maxVelocity : -maxVelocity : =
velocities[nodeId].x;=0A=
          node.x +=3D velocities[nodeId].x * timestep; // position=0A=
        } else {=0A=
          forces[nodeId].x =3D 0;=0A=
          velocities[nodeId].x =3D 0;=0A=
        }=0A=
=0A=
        if (node.options.fixed.y =3D=3D=3D false) {=0A=
          var dy =3D this.modelOptions.damping * velocities[nodeId].y; =
// damping force=0A=
          var ay =3D (forces[nodeId].y - dy) / node.options.mass; // =
acceleration=0A=
          velocities[nodeId].y +=3D ay * timestep; // velocity=0A=
          velocities[nodeId].y =3D Math.abs(velocities[nodeId].y) > =
maxVelocity ? velocities[nodeId].y > 0 ? maxVelocity : -maxVelocity : =
velocities[nodeId].y;=0A=
          node.y +=3D velocities[nodeId].y * timestep; // position=0A=
        } else {=0A=
          forces[nodeId].y =3D 0;=0A=
          velocities[nodeId].y =3D 0;=0A=
        }=0A=
=0A=
        var totalVelocity =3D Math.sqrt(Math.pow(velocities[nodeId].x, =
2) + Math.pow(velocities[nodeId].y, 2));=0A=
        return totalVelocity;=0A=
      }=0A=
    }, {=0A=
      key: 'calculateForces',=0A=
=0A=
      /**=0A=
       * calculate the forces for one physics iteration.=0A=
       */=0A=
      value: function calculateForces() {=0A=
        this.gravitySolver.solve();=0A=
        this.nodesSolver.solve();=0A=
        this.edgesSolver.solve();=0A=
      }=0A=
    }, {=0A=
      key: '_freezeNodes',=0A=
=0A=
      /**=0A=
       * When initializing and stabilizing, we can freeze nodes with a =
predefined position. This greatly speeds up stabilization=0A=
       * because only the supportnodes for the smoothCurves have to =
settle.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _freezeNodes() {=0A=
        var nodes =3D this.body.nodes;=0A=
        for (var id in nodes) {=0A=
          if (nodes.hasOwnProperty(id)) {=0A=
            if (nodes[id].x && nodes[id].y) {=0A=
              this.freezeCache[id] =3D { x: nodes[id].options.fixed.x, =
y: nodes[id].options.fixed.y };=0A=
              nodes[id].options.fixed.x =3D true;=0A=
              nodes[id].options.fixed.y =3D true;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_restoreFrozenNodes',=0A=
=0A=
      /**=0A=
       * Unfreezes the nodes that have been frozen by =
_freezeDefinedNodes.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _restoreFrozenNodes() {=0A=
        var nodes =3D this.body.nodes;=0A=
        for (var id in nodes) {=0A=
          if (nodes.hasOwnProperty(id)) {=0A=
            if (this.freezeCache[id] !=3D=3D undefined) {=0A=
              nodes[id].options.fixed.x =3D this.freezeCache[id].x;=0A=
              nodes[id].options.fixed.y =3D this.freezeCache[id].y;=0A=
            }=0A=
          }=0A=
        }=0A=
        this.freezeCache =3D {};=0A=
      }=0A=
    }, {=0A=
      key: 'stabilize',=0A=
=0A=
      /**=0A=
       * Find a stable position for all nodes=0A=
       * @private=0A=
       */=0A=
      value: function stabilize() {=0A=
        var _this3 =3D this;=0A=
=0A=
        var iterations =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? this.options.stabilization.iterations : =
arguments[0];=0A=
=0A=
        if (typeof iterations !=3D=3D 'number') {=0A=
          console.log('The stabilize method needs a numeric amount of =
iterations. Switching to default: ', =
this.options.stabilization.iterations);=0A=
          iterations =3D this.options.stabilization.iterations;=0A=
        }=0A=
=0A=
        if (this.physicsBody.physicsNodeIndices.length =3D=3D=3D 0) {=0A=
          this.ready =3D true;=0A=
          return;=0A=
        }=0A=
=0A=
        // this sets the width of all nodes initially which could be =
required for the avoidOverlap=0A=
        this.body.emitter.emit('_resizeNodes');=0A=
=0A=
        // stop the render loop=0A=
        this.stopSimulation();=0A=
=0A=
        // set stabilze to false=0A=
        this.stabilized =3D false;=0A=
=0A=
        // block redraw requests=0A=
        this.body.emitter.emit('_blockRedraw');=0A=
        this.targetIterations =3D iterations;=0A=
=0A=
        // start the stabilization=0A=
        if (this.options.stabilization.onlyDynamicEdges =3D=3D=3D true) {=0A=
          this._freezeNodes();=0A=
        }=0A=
        this.stabilizationIterations =3D 0;=0A=
=0A=
        setTimeout(function () {=0A=
          return _this3._stabilizationBatch();=0A=
        }, 0);=0A=
      }=0A=
    }, {=0A=
      key: '_stabilizationBatch',=0A=
      value: function _stabilizationBatch() {=0A=
        var count =3D 0;=0A=
        while (this.stabilized =3D=3D=3D false && count < =
this.options.stabilization.updateInterval && =
this.stabilizationIterations < this.targetIterations) {=0A=
          this.physicsTick();=0A=
          this.stabilizationIterations++;=0A=
          count++;=0A=
        }=0A=
=0A=
        if (this.stabilized =3D=3D=3D false && =
this.stabilizationIterations < this.targetIterations) {=0A=
          this.body.emitter.emit('stabilizationProgress', { iterations: =
this.stabilizationIterations, total: this.targetIterations });=0A=
          setTimeout(this._stabilizationBatch.bind(this), 0);=0A=
        } else {=0A=
          this._finalizeStabilization();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_finalizeStabilization',=0A=
      value: function _finalizeStabilization() {=0A=
        this.body.emitter.emit('_allowRedraw');=0A=
        if (this.options.stabilization.fit =3D=3D=3D true) {=0A=
          this.body.emitter.emit('fit');=0A=
        }=0A=
=0A=
        if (this.options.stabilization.onlyDynamicEdges =3D=3D=3D true) {=0A=
          this._restoreFrozenNodes();=0A=
        }=0A=
=0A=
        this.body.emitter.emit('stabilizationIterationsDone');=0A=
        this.body.emitter.emit('_requestRedraw');=0A=
=0A=
        if (this.stabilized =3D=3D=3D true) {=0A=
          this._emitStabilized();=0A=
        } else {=0A=
          this.startSimulation();=0A=
        }=0A=
=0A=
        this.ready =3D true;=0A=
      }=0A=
    }]);=0A=
=0A=
    return PhysicsEngine;=0A=
  })();=0A=
=0A=
  exports['default'] =3D PhysicsEngine;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 91 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var BarnesHutSolver =3D (function () {=0A=
    function BarnesHutSolver(body, physicsBody, options) {=0A=
      _classCallCheck(this, BarnesHutSolver);=0A=
=0A=
      this.body =3D body;=0A=
      this.physicsBody =3D physicsBody;=0A=
      this.barnesHutTree;=0A=
      this.setOptions(options);=0A=
      this.randomSeed =3D 5;=0A=
    }=0A=
=0A=
    _createClass(BarnesHutSolver, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
        this.thetaInversed =3D 1 / this.options.theta;=0A=
        this.overlapAvoidanceFactor =3D 1 - Math.max(0, Math.min(1, =
this.options.avoidOverlap)); // if 1 then min distance =3D 0.5, if 0.5 =
then min distance =3D 0.5 + 0.5*node.shape.radius=0A=
      }=0A=
    }, {=0A=
      key: "seededRandom",=0A=
      value: function seededRandom() {=0A=
        var x =3D Math.sin(this.randomSeed++) * 10000;=0A=
        return x - Math.floor(x);=0A=
      }=0A=
    }, {=0A=
      key: "solve",=0A=
=0A=
      /**=0A=
       * This function calculates the forces the nodes apply on =
eachother based on a gravitational model.=0A=
       * The Barnes Hut method is used to speed up this N-body =
simulation.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function solve() {=0A=
        if (this.options.gravitationalConstant !=3D=3D 0 && =
this.physicsBody.physicsNodeIndices.length > 0) {=0A=
          var node =3D undefined;=0A=
          var nodes =3D this.body.nodes;=0A=
          var nodeIndices =3D this.physicsBody.physicsNodeIndices;=0A=
          var nodeCount =3D nodeIndices.length;=0A=
=0A=
          // create the tree=0A=
          var barnesHutTree =3D this._formBarnesHutTree(nodes, =
nodeIndices);=0A=
=0A=
          // for debugging=0A=
          this.barnesHutTree =3D barnesHutTree;=0A=
=0A=
          // place the nodes one by one recursively=0A=
          for (var i =3D 0; i < nodeCount; i++) {=0A=
            node =3D nodes[nodeIndices[i]];=0A=
            if (node.options.mass > 0) {=0A=
              // starting with root is irrelevant, it never passes the =
BarnesHutSolver condition=0A=
              this._getForceContribution(barnesHutTree.root.children.NW, =
node);=0A=
              this._getForceContribution(barnesHutTree.root.children.NE, =
node);=0A=
              this._getForceContribution(barnesHutTree.root.children.SW, =
node);=0A=
              this._getForceContribution(barnesHutTree.root.children.SE, =
node);=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_getForceContribution",=0A=
=0A=
      /**=0A=
       * This function traverses the barnesHutTree. It checks when it =
can approximate distant nodes with their center of mass.=0A=
       * If a region contains a single node, we check if it is not =
itself, then we apply the force.=0A=
       *=0A=
       * @param parentBranch=0A=
       * @param node=0A=
       * @private=0A=
       */=0A=
      value: function _getForceContribution(parentBranch, node) {=0A=
        // we get no force contribution from an empty region=0A=
        if (parentBranch.childrenCount > 0) {=0A=
          var dx =3D undefined,=0A=
              dy =3D undefined,=0A=
              distance =3D undefined;=0A=
=0A=
          // get the distance from the center of mass to the node.=0A=
          dx =3D parentBranch.centerOfMass.x - node.x;=0A=
          dy =3D parentBranch.centerOfMass.y - node.y;=0A=
          distance =3D Math.sqrt(dx * dx + dy * dy);=0A=
=0A=
          // BarnesHutSolver condition=0A=
          // original condition : s/d < theta =3D passed  =3D=3D=3D  d/s =
> 1/theta =3D passed=0A=
          // calcSize =3D 1/s --> d * 1/s > 1/theta =3D passed=0A=
          if (distance * parentBranch.calcSize > this.thetaInversed) {=0A=
            this._calculateForces(distance, dx, dy, node, parentBranch);=0A=
          } else {=0A=
            // Did not pass the condition, go into children if available=0A=
            if (parentBranch.childrenCount =3D=3D=3D 4) {=0A=
              this._getForceContribution(parentBranch.children.NW, node);=0A=
              this._getForceContribution(parentBranch.children.NE, node);=0A=
              this._getForceContribution(parentBranch.children.SW, node);=0A=
              this._getForceContribution(parentBranch.children.SE, node);=0A=
            } else {=0A=
              // parentBranch must have only one node, if it was empty =
we wouldnt be here=0A=
              if (parentBranch.children.data.id !=3D node.id) {=0A=
                // if it is not self=0A=
                this._calculateForces(distance, dx, dy, node, =
parentBranch);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_calculateForces",=0A=
=0A=
      /**=0A=
       * Calculate the forces based on the distance.=0A=
       *=0A=
       * @param distance=0A=
       * @param dx=0A=
       * @param dy=0A=
       * @param node=0A=
       * @param parentBranch=0A=
       * @private=0A=
       */=0A=
      value: function _calculateForces(distance, dx, dy, node, =
parentBranch) {=0A=
        if (distance =3D=3D=3D 0) {=0A=
          distance =3D 0.1;=0A=
          dx =3D distance;=0A=
        }=0A=
=0A=
        if (this.overlapAvoidanceFactor < 1) {=0A=
          distance =3D Math.max(0.1 + this.overlapAvoidanceFactor * =
node.shape.radius, distance - node.shape.radius);=0A=
        }=0A=
=0A=
        // the dividing by the distance cubed instead of squared allows =
us to get the fx and fy components without sines and cosines=0A=
        // it is shorthand for gravityforce with distance squared and fx =
=3D dx/distance * gravityForce=0A=
        var gravityForce =3D this.options.gravitationalConstant * =
parentBranch.mass * node.options.mass / Math.pow(distance, 3);=0A=
        var fx =3D dx * gravityForce;=0A=
        var fy =3D dy * gravityForce;=0A=
=0A=
        this.physicsBody.forces[node.id].x +=3D fx;=0A=
        this.physicsBody.forces[node.id].y +=3D fy;=0A=
      }=0A=
    }, {=0A=
      key: "_formBarnesHutTree",=0A=
=0A=
      /**=0A=
       * This function constructs the barnesHut tree recursively. It =
creates the root, splits it and starts placing the nodes.=0A=
       *=0A=
       * @param nodes=0A=
       * @param nodeIndices=0A=
       * @private=0A=
       */=0A=
      value: function _formBarnesHutTree(nodes, nodeIndices) {=0A=
        var node =3D undefined;=0A=
        var nodeCount =3D nodeIndices.length;=0A=
=0A=
        var minX =3D nodes[nodeIndices[0]].x;=0A=
        var minY =3D nodes[nodeIndices[0]].y;=0A=
        var maxX =3D nodes[nodeIndices[0]].x;=0A=
        var maxY =3D nodes[nodeIndices[0]].y;=0A=
=0A=
        // get the range of the nodes=0A=
        for (var i =3D 1; i < nodeCount; i++) {=0A=
          var x =3D nodes[nodeIndices[i]].x;=0A=
          var y =3D nodes[nodeIndices[i]].y;=0A=
          if (nodes[nodeIndices[i]].options.mass > 0) {=0A=
            if (x < minX) {=0A=
              minX =3D x;=0A=
            }=0A=
            if (x > maxX) {=0A=
              maxX =3D x;=0A=
            }=0A=
            if (y < minY) {=0A=
              minY =3D y;=0A=
            }=0A=
            if (y > maxY) {=0A=
              maxY =3D y;=0A=
            }=0A=
          }=0A=
        }=0A=
        // make the range a square=0A=
        var sizeDiff =3D Math.abs(maxX - minX) - Math.abs(maxY - minY); =
// difference between X and Y=0A=
        if (sizeDiff > 0) {=0A=
          minY -=3D 0.5 * sizeDiff;=0A=
          maxY +=3D 0.5 * sizeDiff;=0A=
        } // xSize > ySize=0A=
        else {=0A=
          minX +=3D 0.5 * sizeDiff;=0A=
          maxX -=3D 0.5 * sizeDiff;=0A=
        } // xSize < ySize=0A=
=0A=
        var minimumTreeSize =3D 1e-5;=0A=
        var rootSize =3D Math.max(minimumTreeSize, Math.abs(maxX - =
minX));=0A=
        var halfRootSize =3D 0.5 * rootSize;=0A=
        var centerX =3D 0.5 * (minX + maxX),=0A=
            centerY =3D 0.5 * (minY + maxY);=0A=
=0A=
        // construct the barnesHutTree=0A=
        var barnesHutTree =3D {=0A=
          root: {=0A=
            centerOfMass: { x: 0, y: 0 },=0A=
            mass: 0,=0A=
            range: {=0A=
              minX: centerX - halfRootSize, maxX: centerX + halfRootSize,=0A=
              minY: centerY - halfRootSize, maxY: centerY + halfRootSize=0A=
            },=0A=
            size: rootSize,=0A=
            calcSize: 1 / rootSize,=0A=
            children: { data: null },=0A=
            maxWidth: 0,=0A=
            level: 0,=0A=
            childrenCount: 4=0A=
          }=0A=
        };=0A=
        this._splitBranch(barnesHutTree.root);=0A=
=0A=
        // place the nodes one by one recursively=0A=
        for (var i =3D 0; i < nodeCount; i++) {=0A=
          node =3D nodes[nodeIndices[i]];=0A=
          if (node.options.mass > 0) {=0A=
            this._placeInTree(barnesHutTree.root, node);=0A=
          }=0A=
        }=0A=
=0A=
        // make global=0A=
        return barnesHutTree;=0A=
      }=0A=
    }, {=0A=
      key: "_updateBranchMass",=0A=
=0A=
      /**=0A=
       * this updates the mass of a branch. this is increased by adding =
a node.=0A=
       *=0A=
       * @param parentBranch=0A=
       * @param node=0A=
       * @private=0A=
       */=0A=
      value: function _updateBranchMass(parentBranch, node) {=0A=
        var totalMass =3D parentBranch.mass + node.options.mass;=0A=
        var totalMassInv =3D 1 / totalMass;=0A=
=0A=
        parentBranch.centerOfMass.x =3D parentBranch.centerOfMass.x * =
parentBranch.mass + node.x * node.options.mass;=0A=
        parentBranch.centerOfMass.x *=3D totalMassInv;=0A=
=0A=
        parentBranch.centerOfMass.y =3D parentBranch.centerOfMass.y * =
parentBranch.mass + node.y * node.options.mass;=0A=
        parentBranch.centerOfMass.y *=3D totalMassInv;=0A=
=0A=
        parentBranch.mass =3D totalMass;=0A=
        var biggestSize =3D Math.max(Math.max(node.height, node.radius), =
node.width);=0A=
        parentBranch.maxWidth =3D parentBranch.maxWidth < biggestSize ? =
biggestSize : parentBranch.maxWidth;=0A=
      }=0A=
    }, {=0A=
      key: "_placeInTree",=0A=
=0A=
      /**=0A=
       * determine in which branch the node will be placed.=0A=
       *=0A=
       * @param parentBranch=0A=
       * @param node=0A=
       * @param skipMassUpdate=0A=
       * @private=0A=
       */=0A=
      value: function _placeInTree(parentBranch, node, skipMassUpdate) {=0A=
        if (skipMassUpdate !=3D true || skipMassUpdate =3D=3D=3D =
undefined) {=0A=
          // update the mass of the branch.=0A=
          this._updateBranchMass(parentBranch, node);=0A=
        }=0A=
=0A=
        if (parentBranch.children.NW.range.maxX > node.x) {=0A=
          // in NW or SW=0A=
          if (parentBranch.children.NW.range.maxY > node.y) {=0A=
            // in NW=0A=
            this._placeInRegion(parentBranch, node, "NW");=0A=
          } else {=0A=
            // in SW=0A=
            this._placeInRegion(parentBranch, node, "SW");=0A=
          }=0A=
        } else {=0A=
          // in NE or SE=0A=
          if (parentBranch.children.NW.range.maxY > node.y) {=0A=
            // in NE=0A=
            this._placeInRegion(parentBranch, node, "NE");=0A=
          } else {=0A=
            // in SE=0A=
            this._placeInRegion(parentBranch, node, "SE");=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_placeInRegion",=0A=
=0A=
      /**=0A=
       * actually place the node in a region (or branch)=0A=
       *=0A=
       * @param parentBranch=0A=
       * @param node=0A=
       * @param region=0A=
       * @private=0A=
       */=0A=
      value: function _placeInRegion(parentBranch, node, region) {=0A=
        switch (parentBranch.children[region].childrenCount) {=0A=
          case 0:=0A=
            // place node here=0A=
            parentBranch.children[region].children.data =3D node;=0A=
            parentBranch.children[region].childrenCount =3D 1;=0A=
            this._updateBranchMass(parentBranch.children[region], node);=0A=
            break;=0A=
          case 1:=0A=
            // convert into children=0A=
            // if there are two nodes exactly overlapping (on init, on =
opening of cluster etc.)=0A=
            // we move one node a pixel and we do not put it in the tree.=0A=
            if (parentBranch.children[region].children.data.x =3D=3D=3D =
node.x && parentBranch.children[region].children.data.y =3D=3D=3D =
node.y) {=0A=
              node.x +=3D this.seededRandom();=0A=
              node.y +=3D this.seededRandom();=0A=
            } else {=0A=
              this._splitBranch(parentBranch.children[region]);=0A=
              this._placeInTree(parentBranch.children[region], node);=0A=
            }=0A=
            break;=0A=
          case 4:=0A=
            // place in branch=0A=
            this._placeInTree(parentBranch.children[region], node);=0A=
            break;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_splitBranch",=0A=
=0A=
      /**=0A=
       * this function splits a branch into 4 sub branches. If the =
branch contained a node, we place it in the subbranch=0A=
       * after the split is complete.=0A=
       *=0A=
       * @param parentBranch=0A=
       * @private=0A=
       */=0A=
      value: function _splitBranch(parentBranch) {=0A=
        // if the branch is shaded with a node, replace the node in the =
new subset.=0A=
        var containedNode =3D null;=0A=
        if (parentBranch.childrenCount =3D=3D=3D 1) {=0A=
          containedNode =3D parentBranch.children.data;=0A=
          parentBranch.mass =3D 0;=0A=
          parentBranch.centerOfMass.x =3D 0;=0A=
          parentBranch.centerOfMass.y =3D 0;=0A=
        }=0A=
        parentBranch.childrenCount =3D 4;=0A=
        parentBranch.children.data =3D null;=0A=
        this._insertRegion(parentBranch, "NW");=0A=
        this._insertRegion(parentBranch, "NE");=0A=
        this._insertRegion(parentBranch, "SW");=0A=
        this._insertRegion(parentBranch, "SE");=0A=
=0A=
        if (containedNode !=3D null) {=0A=
          this._placeInTree(parentBranch, containedNode);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_insertRegion",=0A=
=0A=
      /**=0A=
       * This function subdivides the region into four new segments.=0A=
       * Specifically, this inserts a single new segment.=0A=
       * It fills the children section of the parentBranch=0A=
       *=0A=
       * @param parentBranch=0A=
       * @param region=0A=
       * @param parentRange=0A=
       * @private=0A=
       */=0A=
      value: function _insertRegion(parentBranch, region) {=0A=
        var minX =3D undefined,=0A=
            maxX =3D undefined,=0A=
            minY =3D undefined,=0A=
            maxY =3D undefined;=0A=
        var childSize =3D 0.5 * parentBranch.size;=0A=
        switch (region) {=0A=
          case "NW":=0A=
            minX =3D parentBranch.range.minX;=0A=
            maxX =3D parentBranch.range.minX + childSize;=0A=
            minY =3D parentBranch.range.minY;=0A=
            maxY =3D parentBranch.range.minY + childSize;=0A=
            break;=0A=
          case "NE":=0A=
            minX =3D parentBranch.range.minX + childSize;=0A=
            maxX =3D parentBranch.range.maxX;=0A=
            minY =3D parentBranch.range.minY;=0A=
            maxY =3D parentBranch.range.minY + childSize;=0A=
            break;=0A=
          case "SW":=0A=
            minX =3D parentBranch.range.minX;=0A=
            maxX =3D parentBranch.range.minX + childSize;=0A=
            minY =3D parentBranch.range.minY + childSize;=0A=
            maxY =3D parentBranch.range.maxY;=0A=
            break;=0A=
          case "SE":=0A=
            minX =3D parentBranch.range.minX + childSize;=0A=
            maxX =3D parentBranch.range.maxX;=0A=
            minY =3D parentBranch.range.minY + childSize;=0A=
            maxY =3D parentBranch.range.maxY;=0A=
            break;=0A=
        }=0A=
=0A=
        parentBranch.children[region] =3D {=0A=
          centerOfMass: { x: 0, y: 0 },=0A=
          mass: 0,=0A=
          range: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },=0A=
          size: 0.5 * parentBranch.size,=0A=
          calcSize: 2 * parentBranch.calcSize,=0A=
          children: { data: null },=0A=
          maxWidth: 0,=0A=
          level: parentBranch.level + 1,=0A=
          childrenCount: 0=0A=
        };=0A=
      }=0A=
    }, {=0A=
      key: "_debug",=0A=
=0A=
      //---------------------------  DEBUGGING BELOW  =
---------------------------//=0A=
=0A=
      /**=0A=
       * This function is for debugging purposed, it draws the tree.=0A=
       *=0A=
       * @param ctx=0A=
       * @param color=0A=
       * @private=0A=
       */=0A=
      value: function _debug(ctx, color) {=0A=
        if (this.barnesHutTree !=3D=3D undefined) {=0A=
=0A=
          ctx.lineWidth =3D 1;=0A=
=0A=
          this._drawBranch(this.barnesHutTree.root, ctx, color);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_drawBranch",=0A=
=0A=
      /**=0A=
       * This function is for debugging purposes. It draws the branches =
recursively.=0A=
       *=0A=
       * @param branch=0A=
       * @param ctx=0A=
       * @param color=0A=
       * @private=0A=
       */=0A=
      value: function _drawBranch(branch, ctx, color) {=0A=
        if (color =3D=3D=3D undefined) {=0A=
          color =3D "#FF0000";=0A=
        }=0A=
=0A=
        if (branch.childrenCount =3D=3D=3D 4) {=0A=
          this._drawBranch(branch.children.NW, ctx);=0A=
          this._drawBranch(branch.children.NE, ctx);=0A=
          this._drawBranch(branch.children.SE, ctx);=0A=
          this._drawBranch(branch.children.SW, ctx);=0A=
        }=0A=
        ctx.strokeStyle =3D color;=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(branch.range.minX, branch.range.minY);=0A=
        ctx.lineTo(branch.range.maxX, branch.range.minY);=0A=
        ctx.stroke();=0A=
=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(branch.range.maxX, branch.range.minY);=0A=
        ctx.lineTo(branch.range.maxX, branch.range.maxY);=0A=
        ctx.stroke();=0A=
=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(branch.range.maxX, branch.range.maxY);=0A=
        ctx.lineTo(branch.range.minX, branch.range.maxY);=0A=
        ctx.stroke();=0A=
=0A=
        ctx.beginPath();=0A=
        ctx.moveTo(branch.range.minX, branch.range.maxY);=0A=
        ctx.lineTo(branch.range.minX, branch.range.minY);=0A=
        ctx.stroke();=0A=
=0A=
        /*=0A=
         if (branch.mass > 0) {=0A=
         ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, =
3*branch.mass);=0A=
         ctx.stroke();=0A=
         }=0A=
         */=0A=
      }=0A=
    }]);=0A=
=0A=
    return BarnesHutSolver;=0A=
  })();=0A=
=0A=
  exports["default"] =3D BarnesHutSolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 92 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var RepulsionSolver =3D (function () {=0A=
    function RepulsionSolver(body, physicsBody, options) {=0A=
      _classCallCheck(this, RepulsionSolver);=0A=
=0A=
      this.body =3D body;=0A=
      this.physicsBody =3D physicsBody;=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    _createClass(RepulsionSolver, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
      }=0A=
    }, {=0A=
      key: "solve",=0A=
=0A=
      /**=0A=
       * Calculate the forces the nodes apply on each other based on a =
repulsion field.=0A=
       * This field is linearly approximated.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function solve() {=0A=
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2;=0A=
=0A=
        var nodes =3D this.body.nodes;=0A=
        var nodeIndices =3D this.physicsBody.physicsNodeIndices;=0A=
        var forces =3D this.physicsBody.forces;=0A=
=0A=
        // repulsing forces between nodes=0A=
        var nodeDistance =3D this.options.nodeDistance;=0A=
=0A=
        // approximation constants=0A=
        var a =3D -2 / 3 / nodeDistance;=0A=
        var b =3D 4 / 3;=0A=
=0A=
        // we loop from i over all but the last entree in the array=0A=
        // j loops from i+1 to the last. This way we do not double count =
any of the indices, nor i =3D=3D=3D j=0A=
        for (var i =3D 0; i < nodeIndices.length - 1; i++) {=0A=
          node1 =3D nodes[nodeIndices[i]];=0A=
          for (var j =3D i + 1; j < nodeIndices.length; j++) {=0A=
            node2 =3D nodes[nodeIndices[j]];=0A=
=0A=
            dx =3D node2.x - node1.x;=0A=
            dy =3D node2.y - node1.y;=0A=
            distance =3D Math.sqrt(dx * dx + dy * dy);=0A=
=0A=
            // same condition as BarnesHutSolver, making sure nodes are =
never 100% overlapping.=0A=
            if (distance =3D=3D=3D 0) {=0A=
              distance =3D 0.1 * Math.random();=0A=
              dx =3D distance;=0A=
            }=0A=
=0A=
            if (distance < 2 * nodeDistance) {=0A=
              if (distance < 0.5 * nodeDistance) {=0A=
                repulsingForce =3D 1.0;=0A=
              } else {=0A=
                repulsingForce =3D a * distance + b; // linear approx of =
 1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))=0A=
              }=0A=
              repulsingForce =3D repulsingForce / distance;=0A=
=0A=
              fx =3D dx * repulsingForce;=0A=
              fy =3D dy * repulsingForce;=0A=
=0A=
              forces[node1.id].x -=3D fx;=0A=
              forces[node1.id].y -=3D fy;=0A=
              forces[node2.id].x +=3D fx;=0A=
              forces[node2.id].y +=3D fy;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return RepulsionSolver;=0A=
  })();=0A=
=0A=
  exports["default"] =3D RepulsionSolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 93 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var HierarchicalRepulsionSolver =3D (function () {=0A=
    function HierarchicalRepulsionSolver(body, physicsBody, options) {=0A=
      _classCallCheck(this, HierarchicalRepulsionSolver);=0A=
=0A=
      this.body =3D body;=0A=
      this.physicsBody =3D physicsBody;=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    _createClass(HierarchicalRepulsionSolver, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
      }=0A=
    }, {=0A=
      key: "solve",=0A=
=0A=
      /**=0A=
       * Calculate the forces the nodes apply on each other based on a =
repulsion field.=0A=
       * This field is linearly approximated.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function solve() {=0A=
        var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;=0A=
=0A=
        var nodes =3D this.body.nodes;=0A=
        var nodeIndices =3D this.physicsBody.physicsNodeIndices;=0A=
        var forces =3D this.physicsBody.forces;=0A=
=0A=
        // repulsing forces between nodes=0A=
        var nodeDistance =3D this.options.nodeDistance;=0A=
=0A=
        // we loop from i over all but the last entree in the array=0A=
        // j loops from i+1 to the last. This way we do not double count =
any of the indices, nor i =3D=3D=3D j=0A=
        for (i =3D 0; i < nodeIndices.length - 1; i++) {=0A=
          node1 =3D nodes[nodeIndices[i]];=0A=
          for (j =3D i + 1; j < nodeIndices.length; j++) {=0A=
            node2 =3D nodes[nodeIndices[j]];=0A=
=0A=
            // nodes only affect nodes on their level=0A=
            if (node1.level =3D=3D=3D node2.level) {=0A=
              dx =3D node2.x - node1.x;=0A=
              dy =3D node2.y - node1.y;=0A=
              distance =3D Math.sqrt(dx * dx + dy * dy);=0A=
=0A=
              var steepness =3D 0.05;=0A=
              if (distance < nodeDistance) {=0A=
                repulsingForce =3D -Math.pow(steepness * distance, 2) + =
Math.pow(steepness * nodeDistance, 2);=0A=
              } else {=0A=
                repulsingForce =3D 0;=0A=
              }=0A=
              // normalize force with=0A=
              if (distance =3D=3D=3D 0) {=0A=
                distance =3D 0.01;=0A=
              } else {=0A=
                repulsingForce =3D repulsingForce / distance;=0A=
              }=0A=
              fx =3D dx * repulsingForce;=0A=
              fy =3D dy * repulsingForce;=0A=
=0A=
              forces[node1.id].x -=3D fx;=0A=
              forces[node1.id].y -=3D fy;=0A=
              forces[node2.id].x +=3D fx;=0A=
              forces[node2.id].y +=3D fy;=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return HierarchicalRepulsionSolver;=0A=
  })();=0A=
=0A=
  exports["default"] =3D HierarchicalRepulsionSolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 94 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var SpringSolver =3D (function () {=0A=
    function SpringSolver(body, physicsBody, options) {=0A=
      _classCallCheck(this, SpringSolver);=0A=
=0A=
      this.body =3D body;=0A=
      this.physicsBody =3D physicsBody;=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    _createClass(SpringSolver, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
      }=0A=
    }, {=0A=
      key: "solve",=0A=
=0A=
      /**=0A=
       * This function calculates the springforces on the nodes, =
accounting for the support nodes.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function solve() {=0A=
        var edgeLength =3D undefined,=0A=
            edge =3D undefined;=0A=
        var edgeIndices =3D this.physicsBody.physicsEdgeIndices;=0A=
        var edges =3D this.body.edges;=0A=
        var node1 =3D undefined,=0A=
            node2 =3D undefined,=0A=
            node3 =3D undefined;=0A=
=0A=
        // forces caused by the edges, modelled as springs=0A=
        for (var i =3D 0; i < edgeIndices.length; i++) {=0A=
          edge =3D edges[edgeIndices[i]];=0A=
          if (edge.connected =3D=3D=3D true && edge.toId !=3D=3D =
edge.fromId) {=0A=
            // only calculate forces if nodes are in the same sector=0A=
            if (this.body.nodes[edge.toId] !=3D=3D undefined && =
this.body.nodes[edge.fromId] !=3D=3D undefined) {=0A=
              if (edge.edgeType.via !=3D=3D undefined) {=0A=
                edgeLength =3D edge.options.length =3D=3D=3D undefined ? =
this.options.springLength : edge.options.length;=0A=
                node1 =3D edge.to;=0A=
                node2 =3D edge.edgeType.via;=0A=
                node3 =3D edge.from;=0A=
=0A=
                this._calculateSpringForce(node1, node2, 0.5 * =
edgeLength);=0A=
                this._calculateSpringForce(node2, node3, 0.5 * =
edgeLength);=0A=
              } else {=0A=
                // the * 1.5 is here so the edge looks as large as a =
smooth edge. It does not initially because the smooth edges use=0A=
                // the support nodes which exert a repulsive force on =
the to and from nodes, making the edge appear larger.=0A=
                edgeLength =3D edge.options.length =3D=3D=3D undefined ? =
this.options.springLength * 1.5 : edge.options.length;=0A=
                this._calculateSpringForce(edge.from, edge.to, =
edgeLength);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_calculateSpringForce",=0A=
=0A=
      /**=0A=
       * This is the code actually performing the calculation for the =
function above.=0A=
       *=0A=
       * @param node1=0A=
       * @param node2=0A=
       * @param edgeLength=0A=
       * @private=0A=
       */=0A=
      value: function _calculateSpringForce(node1, node2, edgeLength) {=0A=
        var dx =3D node1.x - node2.x;=0A=
        var dy =3D node1.y - node2.y;=0A=
        var distance =3D Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);=0A=
=0A=
        // the 1/distance is so the fx and fy can be calculated without =
sine or cosine.=0A=
        var springForce =3D this.options.springConstant * (edgeLength - =
distance) / distance;=0A=
=0A=
        var fx =3D dx * springForce;=0A=
        var fy =3D dy * springForce;=0A=
=0A=
        // handle the case where one node is not part of the physcis=0A=
        if (this.physicsBody.forces[node1.id] !=3D=3D undefined) {=0A=
          this.physicsBody.forces[node1.id].x +=3D fx;=0A=
          this.physicsBody.forces[node1.id].y +=3D fy;=0A=
        }=0A=
=0A=
        if (this.physicsBody.forces[node2.id] !=3D=3D undefined) {=0A=
          this.physicsBody.forces[node2.id].x -=3D fx;=0A=
          this.physicsBody.forces[node2.id].y -=3D fy;=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return SpringSolver;=0A=
  })();=0A=
=0A=
  exports["default"] =3D SpringSolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 95 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var HierarchicalSpringSolver =3D (function () {=0A=
    function HierarchicalSpringSolver(body, physicsBody, options) {=0A=
      _classCallCheck(this, HierarchicalSpringSolver);=0A=
=0A=
      this.body =3D body;=0A=
      this.physicsBody =3D physicsBody;=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    _createClass(HierarchicalSpringSolver, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
      }=0A=
    }, {=0A=
      key: "solve",=0A=
=0A=
      /**=0A=
       * This function calculates the springforces on the nodes, =
accounting for the support nodes.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function solve() {=0A=
        var edgeLength, edge;=0A=
        var dx, dy, fx, fy, springForce, distance;=0A=
        var edges =3D this.body.edges;=0A=
        var factor =3D 0.5;=0A=
=0A=
        var edgeIndices =3D this.physicsBody.physicsEdgeIndices;=0A=
        var nodeIndices =3D this.physicsBody.physicsNodeIndices;=0A=
        var forces =3D this.physicsBody.forces;=0A=
=0A=
        // initialize the spring force counters=0A=
        for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
          var nodeId =3D nodeIndices[i];=0A=
          forces[nodeId].springFx =3D 0;=0A=
          forces[nodeId].springFy =3D 0;=0A=
        }=0A=
=0A=
        // forces caused by the edges, modelled as springs=0A=
        for (var i =3D 0; i < edgeIndices.length; i++) {=0A=
          edge =3D edges[edgeIndices[i]];=0A=
          if (edge.connected =3D=3D=3D true) {=0A=
            edgeLength =3D edge.options.length =3D=3D=3D undefined ? =
this.options.springLength : edge.options.length;=0A=
=0A=
            dx =3D edge.from.x - edge.to.x;=0A=
            dy =3D edge.from.y - edge.to.y;=0A=
            distance =3D Math.sqrt(dx * dx + dy * dy);=0A=
            distance =3D distance =3D=3D=3D 0 ? 0.01 : distance;=0A=
=0A=
            // the 1/distance is so the fx and fy can be calculated =
without sine or cosine.=0A=
            springForce =3D this.options.springConstant * (edgeLength - =
distance) / distance;=0A=
=0A=
            fx =3D dx * springForce;=0A=
            fy =3D dy * springForce;=0A=
=0A=
            if (edge.to.level !=3D edge.from.level) {=0A=
              if (forces[edge.toId] !=3D=3D undefined) {=0A=
                forces[edge.toId].springFx -=3D fx;=0A=
                forces[edge.toId].springFy -=3D fy;=0A=
              }=0A=
              if (forces[edge.fromId] !=3D=3D undefined) {=0A=
                forces[edge.fromId].springFx +=3D fx;=0A=
                forces[edge.fromId].springFy +=3D fy;=0A=
              }=0A=
            } else {=0A=
              if (forces[edge.toId] !=3D=3D undefined) {=0A=
                forces[edge.toId].x -=3D factor * fx;=0A=
                forces[edge.toId].y -=3D factor * fy;=0A=
              }=0A=
              if (forces[edge.fromId] !=3D=3D undefined) {=0A=
                forces[edge.fromId].x +=3D factor * fx;=0A=
                forces[edge.fromId].y +=3D factor * fy;=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // normalize spring forces=0A=
        var springForce =3D 1;=0A=
        var springFx, springFy;=0A=
        for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
          var nodeId =3D nodeIndices[i];=0A=
          springFx =3D Math.min(springForce, Math.max(-springForce, =
forces[nodeId].springFx));=0A=
          springFy =3D Math.min(springForce, Math.max(-springForce, =
forces[nodeId].springFy));=0A=
=0A=
          forces[nodeId].x +=3D springFx;=0A=
          forces[nodeId].y +=3D springFy;=0A=
        }=0A=
=0A=
        // retain energy balance=0A=
        var totalFx =3D 0;=0A=
        var totalFy =3D 0;=0A=
        for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
          var nodeId =3D nodeIndices[i];=0A=
          totalFx +=3D forces[nodeId].x;=0A=
          totalFy +=3D forces[nodeId].y;=0A=
        }=0A=
        var correctionFx =3D totalFx / nodeIndices.length;=0A=
        var correctionFy =3D totalFy / nodeIndices.length;=0A=
=0A=
        for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
          var nodeId =3D nodeIndices[i];=0A=
          forces[nodeId].x -=3D correctionFx;=0A=
          forces[nodeId].y -=3D correctionFy;=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return HierarchicalSpringSolver;=0A=
  })();=0A=
=0A=
  exports["default"] =3D HierarchicalSpringSolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 96 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var CentralGravitySolver =3D (function () {=0A=
    function CentralGravitySolver(body, physicsBody, options) {=0A=
      _classCallCheck(this, CentralGravitySolver);=0A=
=0A=
      this.body =3D body;=0A=
      this.physicsBody =3D physicsBody;=0A=
      this.setOptions(options);=0A=
    }=0A=
=0A=
    _createClass(CentralGravitySolver, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        this.options =3D options;=0A=
      }=0A=
    }, {=0A=
      key: "solve",=0A=
      value: function solve() {=0A=
        var dx =3D undefined,=0A=
            dy =3D undefined,=0A=
            distance =3D undefined,=0A=
            node =3D undefined;=0A=
        var nodes =3D this.body.nodes;=0A=
        var nodeIndices =3D this.physicsBody.physicsNodeIndices;=0A=
        var forces =3D this.physicsBody.forces;=0A=
=0A=
        for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
          var nodeId =3D nodeIndices[i];=0A=
          node =3D nodes[nodeId];=0A=
          dx =3D -node.x;=0A=
          dy =3D -node.y;=0A=
          distance =3D Math.sqrt(dx * dx + dy * dy);=0A=
=0A=
          this._calculateForces(distance, dx, dy, forces, node);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_calculateForces",=0A=
=0A=
      /**=0A=
       * Calculate the forces based on the distance.=0A=
       * @private=0A=
       */=0A=
      value: function _calculateForces(distance, dx, dy, forces, node) {=0A=
        var gravityForce =3D distance =3D=3D=3D 0 ? 0 : =
this.options.centralGravity / distance;=0A=
        forces[node.id].x =3D dx * gravityForce;=0A=
        forces[node.id].y =3D dy * gravityForce;=0A=
      }=0A=
    }]);=0A=
=0A=
    return CentralGravitySolver;=0A=
  })();=0A=
=0A=
  exports["default"] =3D CentralGravitySolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 97 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ("value" in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { "default": obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D "function" && superClass !=3D=3D null) { throw new =
TypeError("Super expression must either be null or a function, not " + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _BarnesHutSolver2 =3D __webpack_require__(91);=0A=
=0A=
  var _BarnesHutSolver3 =3D _interopRequireDefault(_BarnesHutSolver2);=0A=
=0A=
  var ForceAtlas2BasedRepulsionSolver =3D (function (_BarnesHutSolver) {=0A=
    _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);=0A=
=0A=
    function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) =
{=0A=
      _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);=0A=
=0A=
      =
_get(Object.getPrototypeOf(ForceAtlas2BasedRepulsionSolver.prototype), =
"constructor", this).call(this, body, physicsBody, options);=0A=
    }=0A=
=0A=
    _createClass(ForceAtlas2BasedRepulsionSolver, [{=0A=
      key: "_calculateForces",=0A=
=0A=
      /**=0A=
       * Calculate the forces based on the distance.=0A=
       *=0A=
       * @param distance=0A=
       * @param dx=0A=
       * @param dy=0A=
       * @param node=0A=
       * @param parentBranch=0A=
       * @private=0A=
       */=0A=
      value: function _calculateForces(distance, dx, dy, node, =
parentBranch) {=0A=
        if (distance =3D=3D=3D 0) {=0A=
          distance =3D 0.1 * Math.random();=0A=
          dx =3D distance;=0A=
        }=0A=
=0A=
        if (this.overlapAvoidanceFactor < 1) {=0A=
          distance =3D Math.max(0.1 + this.overlapAvoidanceFactor * =
node.shape.radius, distance - node.shape.radius);=0A=
        }=0A=
=0A=
        var degree =3D node.edges.length + 1;=0A=
        // the dividing by the distance cubed instead of squared allows =
us to get the fx and fy components without sines and cosines=0A=
        // it is shorthand for gravityforce with distance squared and fx =
=3D dx/distance * gravityForce=0A=
        var gravityForce =3D this.options.gravitationalConstant * =
parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);=0A=
        var fx =3D dx * gravityForce;=0A=
        var fy =3D dy * gravityForce;=0A=
=0A=
        this.physicsBody.forces[node.id].x +=3D fx;=0A=
        this.physicsBody.forces[node.id].y +=3D fy;=0A=
      }=0A=
    }]);=0A=
=0A=
    return ForceAtlas2BasedRepulsionSolver;=0A=
  })(_BarnesHutSolver3["default"]);=0A=
=0A=
  exports["default"] =3D ForceAtlas2BasedRepulsionSolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 98 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ("value" in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { "default": obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D "function" && superClass !=3D=3D null) { throw new =
TypeError("Super expression must either be null or a function, not " + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _CentralGravitySolver2 =3D __webpack_require__(96);=0A=
=0A=
  var _CentralGravitySolver3 =3D =
_interopRequireDefault(_CentralGravitySolver2);=0A=
=0A=
  var ForceAtlas2BasedCentralGravitySolver =3D (function =
(_CentralGravitySolver) {=0A=
    _inherits(ForceAtlas2BasedCentralGravitySolver, =
_CentralGravitySolver);=0A=
=0A=
    function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, =
options) {=0A=
      _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);=0A=
=0A=
      =
_get(Object.getPrototypeOf(ForceAtlas2BasedCentralGravitySolver.prototype=
), "constructor", this).call(this, body, physicsBody, options);=0A=
    }=0A=
=0A=
    _createClass(ForceAtlas2BasedCentralGravitySolver, [{=0A=
      key: "_calculateForces",=0A=
=0A=
      /**=0A=
       * Calculate the forces based on the distance.=0A=
       * @private=0A=
       */=0A=
      value: function _calculateForces(distance, dx, dy, forces, node) {=0A=
        if (distance > 0) {=0A=
          var degree =3D node.edges.length + 1;=0A=
          var gravityForce =3D this.options.centralGravity * degree * =
node.options.mass;=0A=
          forces[node.id].x =3D dx * gravityForce;=0A=
          forces[node.id].y =3D dy * gravityForce;=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return ForceAtlas2BasedCentralGravitySolver;=0A=
  })(_CentralGravitySolver3["default"]);=0A=
=0A=
  exports["default"] =3D ForceAtlas2BasedCentralGravitySolver;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 99 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _componentsNodesCluster =3D __webpack_require__(100);=0A=
=0A=
  var _componentsNodesCluster2 =3D =
_interopRequireDefault(_componentsNodesCluster);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var ClusterEngine =3D (function () {=0A=
    function ClusterEngine(body) {=0A=
      var _this =3D this;=0A=
=0A=
      _classCallCheck(this, ClusterEngine);=0A=
=0A=
      this.body =3D body;=0A=
      this.clusteredNodes =3D {};=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {};=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.body.emitter.on('_resetData', function () {=0A=
        _this.clusteredNodes =3D {};=0A=
      });=0A=
    }=0A=
=0A=
    _createClass(ClusterEngine, [{=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {}=0A=
      }=0A=
    }, {=0A=
      key: 'clusterByHubsize',=0A=
=0A=
      /**=0A=
      *=0A=
      * @param hubsize=0A=
      * @param options=0A=
      */=0A=
      value: function clusterByHubsize(hubsize, options) {=0A=
        if (hubsize =3D=3D=3D undefined) {=0A=
          hubsize =3D this._getHubSize();=0A=
        } else if (typeof hubsize =3D=3D=3D 'object') {=0A=
          options =3D this._checkOptions(hubsize);=0A=
          hubsize =3D this._getHubSize();=0A=
        }=0A=
=0A=
        var nodesToCluster =3D [];=0A=
        for (var i =3D 0; i < this.body.nodeIndices.length; i++) {=0A=
          var node =3D this.body.nodes[this.body.nodeIndices[i]];=0A=
          if (node.edges.length >=3D hubsize) {=0A=
            nodesToCluster.push(node.id);=0A=
          }=0A=
        }=0A=
=0A=
        for (var i =3D 0; i < nodesToCluster.length; i++) {=0A=
          this.clusterByConnection(nodesToCluster[i], options, false);=0A=
        }=0A=
        this.body.emitter.emit('_dataChanged');=0A=
      }=0A=
    }, {=0A=
      key: 'cluster',=0A=
=0A=
      /**=0A=
      * loop over all nodes, check if they adhere to the condition and =
cluster if needed.=0A=
      * @param options=0A=
      * @param refreshData=0A=
      */=0A=
      value: function cluster() {=0A=
        var options =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? {} : arguments[0];=0A=
        var refreshData =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? true : arguments[1];=0A=
=0A=
        if (options.joinCondition =3D=3D=3D undefined) {=0A=
          throw new Error('Cannot call clusterByNodeData without a =
joinCondition function in the options.');=0A=
        }=0A=
=0A=
        // check if the options object is fine, append if needed=0A=
        options =3D this._checkOptions(options);=0A=
=0A=
        var childNodesObj =3D {};=0A=
        var childEdgesObj =3D {};=0A=
=0A=
        // collect the nodes that will be in the cluster=0A=
        for (var i =3D 0; i < this.body.nodeIndices.length; i++) {=0A=
          var nodeId =3D this.body.nodeIndices[i];=0A=
          var node =3D this.body.nodes[nodeId];=0A=
          var clonedOptions =3D this._cloneOptions(node);=0A=
          if (options.joinCondition(clonedOptions) =3D=3D=3D true) {=0A=
            childNodesObj[nodeId] =3D this.body.nodes[nodeId];=0A=
=0A=
            // collect the nodes that will be in the cluster=0A=
            for (var _i =3D 0; _i < node.edges.length; _i++) {=0A=
              var edge =3D node.edges[_i];=0A=
              childEdgesObj[edge.id] =3D edge;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        this._cluster(childNodesObj, childEdgesObj, options, =
refreshData);=0A=
      }=0A=
    }, {=0A=
      key: 'clusterOutliers',=0A=
=0A=
      /**=0A=
      * Cluster all nodes in the network that have only 1 edge=0A=
      * @param options=0A=
      * @param refreshData=0A=
      */=0A=
      value: function clusterOutliers(options) {=0A=
        var refreshData =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? true : arguments[1];=0A=
=0A=
        options =3D this._checkOptions(options);=0A=
        var clusters =3D [];=0A=
=0A=
        // collect the nodes that will be in the cluster=0A=
        for (var i =3D 0; i < this.body.nodeIndices.length; i++) {=0A=
          var childNodesObj =3D {};=0A=
          var childEdgesObj =3D {};=0A=
          var nodeId =3D this.body.nodeIndices[i];=0A=
          var visibleEdges =3D 0;=0A=
          var edge =3D undefined;=0A=
          for (var j =3D 0; j < this.body.nodes[nodeId].edges.length; =
j++) {=0A=
            if (this.body.nodes[nodeId].edges[j].options.hidden =
=3D=3D=3D false) {=0A=
              visibleEdges++;=0A=
              edge =3D this.body.nodes[nodeId].edges[j];=0A=
            }=0A=
          }=0A=
=0A=
          if (visibleEdges =3D=3D=3D 1) {=0A=
            // this is an outlier=0A=
            var childNodeId =3D this._getConnectedId(edge, nodeId);=0A=
            if (childNodeId !=3D=3D nodeId) {=0A=
              if (options.joinCondition =3D=3D=3D undefined) {=0A=
                if (this._checkIfUsed(clusters, nodeId, edge.id) =
=3D=3D=3D false && this._checkIfUsed(clusters, childNodeId, edge.id) =
=3D=3D=3D false) {=0A=
                  childEdgesObj[edge.id] =3D edge;=0A=
                  childNodesObj[nodeId] =3D this.body.nodes[nodeId];=0A=
                  childNodesObj[childNodeId] =3D =
this.body.nodes[childNodeId];=0A=
                }=0A=
              } else {=0A=
                var clonedOptions =3D =
this._cloneOptions(this.body.nodes[nodeId]);=0A=
                if (options.joinCondition(clonedOptions) =3D=3D=3D true =
&& this._checkIfUsed(clusters, nodeId, edge.id) =3D=3D=3D false) {=0A=
                  childEdgesObj[edge.id] =3D edge;=0A=
                  childNodesObj[nodeId] =3D this.body.nodes[nodeId];=0A=
                }=0A=
                clonedOptions =3D =
this._cloneOptions(this.body.nodes[childNodeId]);=0A=
                if (options.joinCondition(clonedOptions) =3D=3D=3D true =
&& this._checkIfUsed(clusters, nodeId, edge.id) =3D=3D=3D false) {=0A=
                  childEdgesObj[edge.id] =3D edge;=0A=
                  childNodesObj[childNodeId] =3D =
this.body.nodes[childNodeId];=0A=
                }=0A=
              }=0A=
=0A=
              if (Object.keys(childNodesObj).length > 0 && =
Object.keys(childEdgesObj).length > 0) {=0A=
                clusters.push({ nodes: childNodesObj, edges: =
childEdgesObj });=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        for (var i =3D 0; i < clusters.length; i++) {=0A=
          this._cluster(clusters[i].nodes, clusters[i].edges, options, =
false);=0A=
        }=0A=
=0A=
        if (refreshData =3D=3D=3D true) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_checkIfUsed',=0A=
      value: function _checkIfUsed(clusters, nodeId, edgeId) {=0A=
        for (var i =3D 0; i < clusters.length; i++) {=0A=
          var cluster =3D clusters[i];=0A=
          if (cluster.nodes[nodeId] !=3D=3D undefined || =
cluster.edges[edgeId] !=3D=3D undefined) {=0A=
            return true;=0A=
          }=0A=
        }=0A=
        return false;=0A=
      }=0A=
    }, {=0A=
      key: 'clusterByConnection',=0A=
=0A=
      /**=0A=
      * suck all connected nodes of a node into the node.=0A=
      * @param nodeId=0A=
      * @param options=0A=
      * @param refreshData=0A=
      */=0A=
      value: function clusterByConnection(nodeId, options) {=0A=
        var refreshData =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? true : arguments[2];=0A=
=0A=
        // kill conditions=0A=
        if (nodeId =3D=3D=3D undefined) {=0A=
          throw new Error('No nodeId supplied to clusterByConnection!');=0A=
        }=0A=
        if (this.body.nodes[nodeId] =3D=3D=3D undefined) {=0A=
          throw new Error('The nodeId given to clusterByConnection does =
not exist!');=0A=
        }=0A=
=0A=
        var node =3D this.body.nodes[nodeId];=0A=
        options =3D this._checkOptions(options, node);=0A=
        if (options.clusterNodeProperties.x =3D=3D=3D undefined) {=0A=
          options.clusterNodeProperties.x =3D node.x;=0A=
        }=0A=
        if (options.clusterNodeProperties.y =3D=3D=3D undefined) {=0A=
          options.clusterNodeProperties.y =3D node.y;=0A=
        }=0A=
        if (options.clusterNodeProperties.fixed =3D=3D=3D undefined) {=0A=
          options.clusterNodeProperties.fixed =3D {};=0A=
          options.clusterNodeProperties.fixed.x =3D node.options.fixed.x;=0A=
          options.clusterNodeProperties.fixed.y =3D node.options.fixed.y;=0A=
        }=0A=
=0A=
        var childNodesObj =3D {};=0A=
        var childEdgesObj =3D {};=0A=
        var parentNodeId =3D node.id;=0A=
        var parentClonedOptions =3D this._cloneOptions(node);=0A=
        childNodesObj[parentNodeId] =3D node;=0A=
=0A=
        // collect the nodes that will be in the cluster=0A=
        for (var i =3D 0; i < node.edges.length; i++) {=0A=
          var edge =3D node.edges[i];=0A=
          var childNodeId =3D this._getConnectedId(edge, parentNodeId);=0A=
=0A=
          if (childNodeId !=3D=3D parentNodeId) {=0A=
            if (options.joinCondition =3D=3D=3D undefined) {=0A=
              childEdgesObj[edge.id] =3D edge;=0A=
              childNodesObj[childNodeId] =3D =
this.body.nodes[childNodeId];=0A=
            } else {=0A=
              // clone the options and insert some additional parameters =
that could be interesting.=0A=
              var childClonedOptions =3D =
this._cloneOptions(this.body.nodes[childNodeId]);=0A=
              if (options.joinCondition(parentClonedOptions, =
childClonedOptions) =3D=3D=3D true) {=0A=
                childEdgesObj[edge.id] =3D edge;=0A=
                childNodesObj[childNodeId] =3D =
this.body.nodes[childNodeId];=0A=
              }=0A=
            }=0A=
          } else {=0A=
            childEdgesObj[edge.id] =3D edge;=0A=
          }=0A=
        }=0A=
=0A=
        this._cluster(childNodesObj, childEdgesObj, options, =
refreshData);=0A=
      }=0A=
    }, {=0A=
      key: '_cloneOptions',=0A=
=0A=
      /**=0A=
      * This returns a clone of the options or options of the edge or =
node to be used for construction of new edges or check functions for new =
nodes.=0A=
      * @param objId=0A=
      * @param type=0A=
      * @returns {{}}=0A=
      * @private=0A=
      */=0A=
      value: function _cloneOptions(item, type) {=0A=
        var clonedOptions =3D {};=0A=
        if (type =3D=3D=3D undefined || type =3D=3D=3D 'node') {=0A=
          util.deepExtend(clonedOptions, item.options, true);=0A=
          clonedOptions.x =3D item.x;=0A=
          clonedOptions.y =3D item.y;=0A=
          clonedOptions.amountOfConnections =3D item.edges.length;=0A=
        } else {=0A=
          util.deepExtend(clonedOptions, item.options, true);=0A=
        }=0A=
        return clonedOptions;=0A=
      }=0A=
    }, {=0A=
      key: '_createClusterEdges',=0A=
=0A=
      /**=0A=
      * This function creates the edges that will be attached to the =
cluster.=0A=
      *=0A=
      * @param childNodesObj=0A=
      * @param childEdgesObj=0A=
      * @param newEdges=0A=
      * @param options=0A=
      * @private=0A=
      */=0A=
      value: function _createClusterEdges(childNodesObj, childEdgesObj, =
newEdges, clusterNodeProperties, clusterEdgeProperties) {=0A=
        var edge =3D undefined,=0A=
            childNodeId =3D undefined,=0A=
            childNode =3D undefined,=0A=
            toId =3D undefined,=0A=
            fromId =3D undefined,=0A=
            otherNodeId =3D undefined;=0A=
=0A=
        var childKeys =3D Object.keys(childNodesObj);=0A=
        for (var i =3D 0; i < childKeys.length; i++) {=0A=
          childNodeId =3D childKeys[i];=0A=
          childNode =3D childNodesObj[childNodeId];=0A=
=0A=
          // construct new edges from the cluster to others=0A=
          for (var j =3D 0; j < childNode.edges.length; j++) {=0A=
            edge =3D childNode.edges[j];=0A=
            childEdgesObj[edge.id] =3D edge;=0A=
=0A=
            // childNodeId position will be replaced by the cluster.=0A=
            if (edge.toId =3D=3D childNodeId) {=0A=
              // this is a double equals because ints and strings can be =
interchanged here.=0A=
              toId =3D clusterNodeProperties.id;=0A=
              fromId =3D edge.fromId;=0A=
              otherNodeId =3D fromId;=0A=
            } else {=0A=
              toId =3D edge.toId;=0A=
              fromId =3D clusterNodeProperties.id;=0A=
              otherNodeId =3D toId;=0A=
            }=0A=
=0A=
            // if the node connected to the cluster is also in the =
cluster we do not need a new edge.=0A=
            if (childNodesObj[otherNodeId] =3D=3D=3D undefined) {=0A=
              var clonedOptions =3D this._cloneOptions(edge, 'edge');=0A=
              util.deepExtend(clonedOptions, clusterEdgeProperties);=0A=
              clonedOptions.from =3D fromId;=0A=
              clonedOptions.to =3D toId;=0A=
              clonedOptions.id =3D 'clusterEdge:' + util.randomUUID();=0A=
              =
newEdges.push(this.body.functions.createEdge(clonedOptions));=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_checkOptions',=0A=
=0A=
      /**=0A=
      * This function checks the options that can be supplied to the =
different cluster functions=0A=
      * for certain fields and inserts defaults if needed=0A=
      * @param options=0A=
      * @returns {*}=0A=
      * @private=0A=
      */=0A=
      value: function _checkOptions() {=0A=
        var options =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? {} : arguments[0];=0A=
=0A=
        if (options.clusterEdgeProperties =3D=3D=3D undefined) {=0A=
          options.clusterEdgeProperties =3D {};=0A=
        }=0A=
        if (options.clusterNodeProperties =3D=3D=3D undefined) {=0A=
          options.clusterNodeProperties =3D {};=0A=
        }=0A=
=0A=
        return options;=0A=
      }=0A=
    }, {=0A=
      key: '_cluster',=0A=
=0A=
      /**=0A=
      *=0A=
      * @param {Object}    childNodesObj         | object with node =
objects, id as keys, same as childNodes except it also contains a source =
node=0A=
      * @param {Object}    childEdgesObj         | object with edge =
objects, id as keys=0A=
      * @param {Array}     options               | object with =
{clusterNodeProperties, clusterEdgeProperties, processProperties}=0A=
      * @param {Boolean}   refreshData | when true, do not wrap up=0A=
      * @private=0A=
      */=0A=
      value: function _cluster(childNodesObj, childEdgesObj, options) {=0A=
        var refreshData =3D arguments.length <=3D 3 || arguments[3] =
=3D=3D=3D undefined ? true : arguments[3];=0A=
=0A=
        // kill condition: no children so cant cluster=0A=
        if (Object.keys(childNodesObj).length =3D=3D=3D 0) {=0A=
          return;=0A=
        }=0A=
=0A=
        var clusterNodeProperties =3D util.deepExtend({}, =
options.clusterNodeProperties);=0A=
=0A=
        // construct the clusterNodeProperties=0A=
        if (options.processProperties !=3D=3D undefined) {=0A=
          // get the childNode options=0A=
          var childNodesOptions =3D [];=0A=
          for (var nodeId in childNodesObj) {=0A=
            var clonedOptions =3D =
this._cloneOptions(childNodesObj[nodeId]);=0A=
            childNodesOptions.push(clonedOptions);=0A=
          }=0A=
=0A=
          // get clusterproperties based on childNodes=0A=
          var childEdgesOptions =3D [];=0A=
          for (var edgeId in childEdgesObj) {=0A=
            // these cluster edges will be removed on creation of the =
cluster.=0A=
            if (edgeId.substr(0, 12) !=3D=3D 'clusterEdge:') {=0A=
              var clonedOptions =3D =
this._cloneOptions(childEdgesObj[edgeId], 'edge');=0A=
              childEdgesOptions.push(clonedOptions);=0A=
            }=0A=
          }=0A=
=0A=
          clusterNodeProperties =3D =
options.processProperties(clusterNodeProperties, childNodesOptions, =
childEdgesOptions);=0A=
          if (!clusterNodeProperties) {=0A=
            throw new Error('The processProperties function does not =
return properties!');=0A=
          }=0A=
        }=0A=
=0A=
        // check if we have an unique id;=0A=
        if (clusterNodeProperties.id =3D=3D=3D undefined) {=0A=
          clusterNodeProperties.id =3D 'cluster:' + util.randomUUID();=0A=
        }=0A=
        var clusterId =3D clusterNodeProperties.id;=0A=
=0A=
        if (clusterNodeProperties.label =3D=3D=3D undefined) {=0A=
          clusterNodeProperties.label =3D 'cluster';=0A=
        }=0A=
=0A=
        // give the clusterNode a postion if it does not have one.=0A=
        var pos =3D undefined;=0A=
        if (clusterNodeProperties.x =3D=3D=3D undefined) {=0A=
          pos =3D this._getClusterPosition(childNodesObj);=0A=
          clusterNodeProperties.x =3D pos.x;=0A=
        }=0A=
        if (clusterNodeProperties.y =3D=3D=3D undefined) {=0A=
          if (pos =3D=3D=3D undefined) {=0A=
            pos =3D this._getClusterPosition(childNodesObj);=0A=
          }=0A=
          clusterNodeProperties.y =3D pos.y;=0A=
        }=0A=
=0A=
        // force the ID to remain the same=0A=
        clusterNodeProperties.id =3D clusterId;=0A=
=0A=
        // create the clusterNode=0A=
        var clusterNode =3D =
this.body.functions.createNode(clusterNodeProperties, =
_componentsNodesCluster2['default']);=0A=
        clusterNode.isCluster =3D true;=0A=
        clusterNode.containedNodes =3D childNodesObj;=0A=
        clusterNode.containedEdges =3D childEdgesObj;=0A=
        // cache a copy from the cluster edge properties if we have to =
reconnect others later on=0A=
        clusterNode.clusterEdgeProperties =3D =
options.clusterEdgeProperties;=0A=
=0A=
        // finally put the cluster node into global=0A=
        this.body.nodes[clusterNodeProperties.id] =3D clusterNode;=0A=
=0A=
        // create the new edges that will connect to the cluster=0A=
        var newEdges =3D [];=0A=
        this._createClusterEdges(childNodesObj, childEdgesObj, newEdges, =
clusterNodeProperties, options.clusterEdgeProperties);=0A=
=0A=
        // disable the childEdges=0A=
        for (var edgeId in childEdgesObj) {=0A=
          if (childEdgesObj.hasOwnProperty(edgeId)) {=0A=
            if (this.body.edges[edgeId] !=3D=3D undefined) {=0A=
              var edge =3D this.body.edges[edgeId];=0A=
=0A=
              // if this is a cluster edge that is fully encompassed in =
the cluster, we want to delete it=0A=
              // this check verifies that both of the connected nodes =
are in this cluster=0A=
              if (edgeId.substr(0, 12) =3D=3D=3D 'clusterEdge:' && =
childNodesObj[edge.fromId] !=3D=3D undefined && childNodesObj[edge.toId] =
!=3D=3D undefined) {=0A=
                edge.cleanup();=0A=
                // this removes the edge from node.edges, which is why =
edgeIds is formed=0A=
                edge.disconnect();=0A=
                delete childEdgesObj[edgeId];=0A=
                delete this.body.edges[edgeId];=0A=
              } else {=0A=
                edge.setOptions({ physics: false, hidden: true });=0A=
                //edge.options.hidden =3D true;=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // disable the childNodes=0A=
        for (var nodeId in childNodesObj) {=0A=
          if (childNodesObj.hasOwnProperty(nodeId)) {=0A=
            this.clusteredNodes[nodeId] =3D { clusterId: =
clusterNodeProperties.id, node: this.body.nodes[nodeId] };=0A=
            this.body.nodes[nodeId].setOptions({ hidden: true, physics: =
false });=0A=
          }=0A=
        }=0A=
=0A=
        // push new edges to global=0A=
        for (var i =3D 0; i < newEdges.length; i++) {=0A=
          this.body.edges[newEdges[i].id] =3D newEdges[i];=0A=
          this.body.edges[newEdges[i].id].connect();=0A=
        }=0A=
=0A=
        // set ID to undefined so no duplicates arise=0A=
        clusterNodeProperties.id =3D undefined;=0A=
=0A=
        // wrap up=0A=
        if (refreshData =3D=3D=3D true) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'isCluster',=0A=
=0A=
      /**=0A=
      * Check if a node is a cluster.=0A=
      * @param nodeId=0A=
      * @returns {*}=0A=
      */=0A=
      value: function isCluster(nodeId) {=0A=
        if (this.body.nodes[nodeId] !=3D=3D undefined) {=0A=
          return this.body.nodes[nodeId].isCluster =3D=3D=3D true;=0A=
        } else {=0A=
          console.log('Node does not exist.');=0A=
          return false;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_getClusterPosition',=0A=
=0A=
      /**=0A=
      * get the position of the cluster node based on what's inside=0A=
      * @param {object} childNodesObj    | object with node objects, id =
as keys=0A=
      * @returns {{x: number, y: number}}=0A=
      * @private=0A=
      */=0A=
      value: function _getClusterPosition(childNodesObj) {=0A=
        var childKeys =3D Object.keys(childNodesObj);=0A=
        var minX =3D childNodesObj[childKeys[0]].x;=0A=
        var maxX =3D childNodesObj[childKeys[0]].x;=0A=
        var minY =3D childNodesObj[childKeys[0]].y;=0A=
        var maxY =3D childNodesObj[childKeys[0]].y;=0A=
        var node =3D undefined;=0A=
        for (var i =3D 1; i < childKeys.length; i++) {=0A=
          node =3D childNodesObj[childKeys[i]];=0A=
          minX =3D node.x < minX ? node.x : minX;=0A=
          maxX =3D node.x > maxX ? node.x : maxX;=0A=
          minY =3D node.y < minY ? node.y : minY;=0A=
          maxY =3D node.y > maxY ? node.y : maxY;=0A=
        }=0A=
=0A=
        return { x: 0.5 * (minX + maxX), y: 0.5 * (minY + maxY) };=0A=
      }=0A=
    }, {=0A=
      key: 'openCluster',=0A=
=0A=
      /**=0A=
      * Open a cluster by calling this function.=0A=
      * @param {String}  clusterNodeId | the ID of the cluster node=0A=
      * @param {Boolean} refreshData | wrap up afterwards if not true=0A=
      */=0A=
      value: function openCluster(clusterNodeId, options) {=0A=
        var refreshData =3D arguments.length <=3D 2 || arguments[2] =
=3D=3D=3D undefined ? true : arguments[2];=0A=
=0A=
        // kill conditions=0A=
        if (clusterNodeId =3D=3D=3D undefined) {=0A=
          throw new Error('No clusterNodeId supplied to openCluster.');=0A=
        }=0A=
        if (this.body.nodes[clusterNodeId] =3D=3D=3D undefined) {=0A=
          throw new Error('The clusterNodeId supplied to openCluster =
does not exist.');=0A=
        }=0A=
        if (this.body.nodes[clusterNodeId].containedNodes =3D=3D=3D =
undefined) {=0A=
          console.log('The node:' + clusterNodeId + ' is not a =
cluster.');=0A=
          return;=0A=
        }=0A=
        var clusterNode =3D this.body.nodes[clusterNodeId];=0A=
        var containedNodes =3D clusterNode.containedNodes;=0A=
        var containedEdges =3D clusterNode.containedEdges;=0A=
=0A=
        // allow the user to position the nodes after release.=0A=
        if (options !=3D=3D undefined && options.releaseFunction !=3D=3D =
undefined && typeof options.releaseFunction =3D=3D=3D 'function') {=0A=
          var positions =3D {};=0A=
          var clusterPosition =3D { x: clusterNode.x, y: clusterNode.y };=0A=
          for (var nodeId in containedNodes) {=0A=
            if (containedNodes.hasOwnProperty(nodeId)) {=0A=
              var containedNode =3D this.body.nodes[nodeId];=0A=
              positions[nodeId] =3D { x: containedNode.x, y: =
containedNode.y };=0A=
            }=0A=
          }=0A=
          var newPositions =3D options.releaseFunction(clusterPosition, =
positions);=0A=
=0A=
          for (var nodeId in containedNodes) {=0A=
            if (containedNodes.hasOwnProperty(nodeId)) {=0A=
              var containedNode =3D this.body.nodes[nodeId];=0A=
              if (newPositions[nodeId] !=3D=3D undefined) {=0A=
                containedNode.x =3D newPositions[nodeId].x || =
clusterNode.x;=0A=
                containedNode.y =3D newPositions[nodeId].y || =
clusterNode.y;=0A=
              }=0A=
            }=0A=
          }=0A=
        } else {=0A=
          // copy the position from the cluster=0A=
          for (var nodeId in containedNodes) {=0A=
            if (containedNodes.hasOwnProperty(nodeId)) {=0A=
              var containedNode =3D this.body.nodes[nodeId];=0A=
              containedNode =3D containedNodes[nodeId];=0A=
              // inherit position=0A=
              containedNode.x =3D clusterNode.x;=0A=
              containedNode.y =3D clusterNode.y;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // release nodes=0A=
        for (var nodeId in containedNodes) {=0A=
          if (containedNodes.hasOwnProperty(nodeId)) {=0A=
            var containedNode =3D this.body.nodes[nodeId];=0A=
=0A=
            // inherit speed=0A=
            containedNode.vx =3D clusterNode.vx;=0A=
            containedNode.vy =3D clusterNode.vy;=0A=
=0A=
            // we use these methods to avoid reinstantiating the shape, =
which happens with setOptions.=0A=
            //containedNode.toggleHidden(false);=0A=
            //containedNode.togglePhysics(true);=0A=
            containedNode.setOptions({ hidden: false, physics: true });=0A=
=0A=
            delete this.clusteredNodes[nodeId];=0A=
          }=0A=
        }=0A=
=0A=
        // release edges=0A=
        for (var edgeId in containedEdges) {=0A=
          if (containedEdges.hasOwnProperty(edgeId)) {=0A=
            var edge =3D containedEdges[edgeId];=0A=
            // if this edge was a temporary edge and it's connected =
nodes do not exist anymore, we remove it from the data=0A=
            if (this.body.nodes[edge.fromId] =3D=3D=3D undefined || =
this.body.nodes[edge.toId] =3D=3D=3D undefined || edge.toId =3D=3D =
clusterNodeId || edge.fromId =3D=3D clusterNodeId) {=0A=
              edge.cleanup();=0A=
              // this removes the edge from node.edges, which is why =
edgeIds is formed=0A=
              edge.disconnect();=0A=
              delete this.body.edges[edgeId];=0A=
            } else {=0A=
              // one of the nodes connected to this edge is in a =
cluster. We give the edge to that cluster so it will be released when =
that cluster is opened.=0A=
              if (this.clusteredNodes[edge.fromId] !=3D=3D undefined || =
this.clusteredNodes[edge.toId] !=3D=3D undefined) {=0A=
                var fromId =3D undefined,=0A=
                    toId =3D undefined;=0A=
                var clusteredNode =3D this.clusteredNodes[edge.fromId] =
|| this.clusteredNodes[edge.toId];=0A=
                var clusterId =3D clusteredNode.clusterId;=0A=
                var _clusterNode =3D this.body.nodes[clusterId];=0A=
                _clusterNode.containedEdges[edgeId] =3D edge;=0A=
=0A=
                if (this.clusteredNodes[edge.fromId] !=3D=3D undefined) {=0A=
                  fromId =3D clusterId;=0A=
                  toId =3D edge.toId;=0A=
                } else {=0A=
                  fromId =3D edge.fromId;=0A=
                  toId =3D clusterId;=0A=
                }=0A=
=0A=
                // if both from and to nodes are visible, we create a =
new temporary edge=0A=
                if (this.body.nodes[fromId].options.hidden !=3D=3D true =
&& this.body.nodes[toId].options.hidden !=3D=3D true) {=0A=
                  var clonedOptions =3D this._cloneOptions(edge, 'edge');=0A=
                  var id =3D 'clusterEdge:' + util.randomUUID();=0A=
                  util.deepExtend(clonedOptions, =
_clusterNode.clusterEdgeProperties);=0A=
                  util.deepExtend(clonedOptions, { from: fromId, to: =
toId, hidden: false, physics: true, id: id });=0A=
                  var newEdge =3D =
this.body.functions.createEdge(clonedOptions);=0A=
=0A=
                  this.body.edges[id] =3D newEdge;=0A=
                  this.body.edges[id].connect();=0A=
                }=0A=
              } else {=0A=
                edge.setOptions({ physics: true, hidden: false });=0A=
                //edge.options.hidden =3D false;=0A=
                //edge.togglePhysics(true);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // remove all temporary edges, make an array of ids so we don't =
remove from the list we're iterating over.=0A=
        var removeIds =3D [];=0A=
        for (var i =3D 0; i < clusterNode.edges.length; i++) {=0A=
          var edgeId =3D clusterNode.edges[i].id;=0A=
          removeIds.push(edgeId);=0A=
        }=0A=
=0A=
        // actually removing the edges=0A=
        for (var i =3D 0; i < removeIds.length; i++) {=0A=
          var edgeId =3D removeIds[i];=0A=
          this.body.edges[edgeId].cleanup();=0A=
          // this removes the edge from node.edges, which is why edgeIds =
is formed=0A=
          this.body.edges[edgeId].disconnect();=0A=
          delete this.body.edges[edgeId];=0A=
        }=0A=
=0A=
        // remove clusterNode=0A=
        this.body.nodes[clusterNodeId].cleanup();=0A=
        delete this.body.nodes[clusterNodeId];=0A=
=0A=
        if (refreshData =3D=3D=3D true) {=0A=
          this.body.emitter.emit('_dataChanged');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'getNodesInCluster',=0A=
      value: function getNodesInCluster(clusterId) {=0A=
        var nodesArray =3D [];=0A=
        if (this.isCluster(clusterId) =3D=3D=3D true) {=0A=
          var containedNodes =3D =
this.body.nodes[clusterId].containedNodes;=0A=
          for (var nodeId in containedNodes) {=0A=
            if (containedNodes.hasOwnProperty(nodeId)) {=0A=
              nodesArray.push(nodeId);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        return nodesArray;=0A=
      }=0A=
    }, {=0A=
      key: 'findNode',=0A=
=0A=
      /**=0A=
      * Get the stack clusterId's that a certain node resides in. =
cluster A -> cluster B -> cluster C -> node=0A=
      * @param nodeId=0A=
      * @returns {Array}=0A=
      * @private=0A=
      */=0A=
      value: function findNode(nodeId) {=0A=
        var stack =3D [];=0A=
        var max =3D 100;=0A=
        var counter =3D 0;=0A=
=0A=
        while (this.clusteredNodes[nodeId] !=3D=3D undefined && counter =
< max) {=0A=
          stack.push(this.clusteredNodes[nodeId].node);=0A=
          nodeId =3D this.clusteredNodes[nodeId].clusterId;=0A=
          counter++;=0A=
        }=0A=
        stack.push(this.body.nodes[nodeId]);=0A=
        return stack;=0A=
      }=0A=
    }, {=0A=
      key: '_getConnectedId',=0A=
=0A=
      /**=0A=
      * Get the Id the node is connected to=0A=
      * @param edge=0A=
      * @param nodeId=0A=
      * @returns {*}=0A=
      * @private=0A=
      */=0A=
      value: function _getConnectedId(edge, nodeId) {=0A=
        if (edge.toId !=3D nodeId) {=0A=
          return edge.toId;=0A=
        } else if (edge.fromId !=3D nodeId) {=0A=
          return edge.fromId;=0A=
        } else {=0A=
          return edge.fromId;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_getHubSize',=0A=
=0A=
      /**=0A=
      * We determine how many connections denote an important hub.=0A=
      * We take the mean + 2*std as the important hub size. (Assuming a =
normal distribution of data, ~2.2%)=0A=
      *=0A=
      * @private=0A=
      */=0A=
      value: function _getHubSize() {=0A=
        var average =3D 0;=0A=
        var averageSquared =3D 0;=0A=
        var hubCounter =3D 0;=0A=
        var largestHub =3D 0;=0A=
=0A=
        for (var i =3D 0; i < this.body.nodeIndices.length; i++) {=0A=
          var node =3D this.body.nodes[this.body.nodeIndices[i]];=0A=
          if (node.edges.length > largestHub) {=0A=
            largestHub =3D node.edges.length;=0A=
          }=0A=
          average +=3D node.edges.length;=0A=
          averageSquared +=3D Math.pow(node.edges.length, 2);=0A=
          hubCounter +=3D 1;=0A=
        }=0A=
        average =3D average / hubCounter;=0A=
        averageSquared =3D averageSquared / hubCounter;=0A=
=0A=
        var variance =3D averageSquared - Math.pow(average, 2);=0A=
        var standardDeviation =3D Math.sqrt(variance);=0A=
=0A=
        var hubThreshold =3D Math.floor(average + 2 * standardDeviation);=0A=
=0A=
        // always have at least one to cluster=0A=
        if (hubThreshold > largestHub) {=0A=
          hubThreshold =3D largestHub;=0A=
        }=0A=
=0A=
        return hubThreshold;=0A=
      }=0A=
    }]);=0A=
=0A=
    return ClusterEngine;=0A=
  })();=0A=
=0A=
  exports['default'] =3D ClusterEngine;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 100 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _get =3D function get(_x, _x2, _x3) { var _again =3D true; =
_function: while (_again) { var object =3D _x, property =3D _x2, =
receiver =3D _x3; desc =3D parent =3D getter =3D undefined; _again =3D =
false; if (object =3D=3D=3D null) object =3D Function.prototype; var =
desc =3D Object.getOwnPropertyDescriptor(object, property); if (desc =
=3D=3D=3D undefined) { var parent =3D Object.getPrototypeOf(object); if =
(parent =3D=3D=3D null) { return undefined; } else { _x =3D parent; _x2 =
=3D property; _x3 =3D receiver; _again =3D true; continue _function; } } =
else if ('value' in desc) { return desc.value; } else { var getter =3D =
desc.get; if (getter =3D=3D=3D undefined) { return undefined; } return =
getter.call(receiver); } } };=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  function _inherits(subClass, superClass) { if (typeof superClass =
!=3D=3D 'function' && superClass !=3D=3D null) { throw new =
TypeError('Super expression must either be null or a function, not ' + =
typeof superClass); } subClass.prototype =3D Object.create(superClass && =
superClass.prototype, { constructor: { value: subClass, enumerable: =
false, writable: true, configurable: true } }); if (superClass) =
subClass.__proto__ =3D superClass; }=0A=
=0A=
  var _Node2 =3D __webpack_require__(62);=0A=
=0A=
  var _Node3 =3D _interopRequireDefault(_Node2);=0A=
=0A=
  /**=0A=
   *=0A=
   */=0A=
=0A=
  var Cluster =3D (function (_Node) {=0A=
    _inherits(Cluster, _Node);=0A=
=0A=
    function Cluster(options, body, imagelist, grouplist, globalOptions) =
{=0A=
      _classCallCheck(this, Cluster);=0A=
=0A=
      _get(Object.getPrototypeOf(Cluster.prototype), 'constructor', =
this).call(this, options, body, imagelist, grouplist, globalOptions);=0A=
=0A=
      this.isCluster =3D true;=0A=
      this.containedNodes =3D {};=0A=
      this.containedEdges =3D {};=0A=
    }=0A=
=0A=
    return Cluster;=0A=
  })(_Node3['default']);=0A=
=0A=
  exports['default'] =3D Cluster;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 101 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  if (typeof window !=3D=3D 'undefined') {=0A=
    window.requestAnimationFrame =3D window.requestAnimationFrame || =
window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || =
window.msRequestAnimationFrame;=0A=
  }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var CanvasRenderer =3D (function () {=0A=
    function CanvasRenderer(body, canvas) {=0A=
      _classCallCheck(this, CanvasRenderer);=0A=
=0A=
      this.body =3D body;=0A=
      this.canvas =3D canvas;=0A=
=0A=
      this.redrawRequested =3D false;=0A=
      this.renderTimer =3D undefined;=0A=
      this.requiresTimeout =3D true;=0A=
      this.renderingActive =3D false;=0A=
      this.renderRequests =3D 0;=0A=
      this.pixelRatio =3D undefined;=0A=
      this.allowRedraw =3D true;=0A=
=0A=
      this.dragging =3D false;=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        hideEdgesOnDrag: false,=0A=
        hideNodesOnDrag: false=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this._determineBrowserMethod();=0A=
      this.bindEventListeners();=0A=
    }=0A=
=0A=
    _createClass(CanvasRenderer, [{=0A=
      key: 'bindEventListeners',=0A=
      value: function bindEventListeners() {=0A=
        var _this =3D this;=0A=
=0A=
        this.body.emitter.on('dragStart', function () {=0A=
          _this.dragging =3D true;=0A=
        });=0A=
        this.body.emitter.on('dragEnd', function () {=0A=
          return _this.dragging =3D false;=0A=
        });=0A=
        this.body.emitter.on('_resizeNodes', function () {=0A=
          return _this._resizeNodes();=0A=
        });=0A=
        this.body.emitter.on('_redraw', function () {=0A=
          if (_this.renderingActive =3D=3D=3D false) {=0A=
            _this._redraw();=0A=
          }=0A=
        });=0A=
        this.body.emitter.on('_blockRedraw', function () {=0A=
          _this.allowRedraw =3D false;=0A=
        });=0A=
        this.body.emitter.on('_allowRedraw', function () {=0A=
          _this.allowRedraw =3D true;_this.redrawRequested =3D false;=0A=
        });=0A=
        this.body.emitter.on('_requestRedraw', =
this._requestRedraw.bind(this));=0A=
        this.body.emitter.on('_startRendering', function () {=0A=
          _this.renderRequests +=3D 1;=0A=
          _this.renderingActive =3D true;=0A=
          _this._startRendering();=0A=
        });=0A=
        this.body.emitter.on('_stopRendering', function () {=0A=
          _this.renderRequests -=3D 1;=0A=
          _this.renderingActive =3D _this.renderRequests > 0;=0A=
          _this.renderTimer =3D undefined;=0A=
        });=0A=
        this.body.emitter.on('destroy', function () {=0A=
          _this.renderRequests =3D 0;=0A=
          _this.allowRedraw =3D false;=0A=
          _this.renderingActive =3D false;=0A=
          if (_this.requiresTimeout =3D=3D=3D true) {=0A=
            clearTimeout(_this.renderTimer);=0A=
          } else {=0A=
            cancelAnimationFrame(_this.renderTimer);=0A=
          }=0A=
          _this.body.emitter.off();=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          var fields =3D ['hideEdgesOnDrag', 'hideNodesOnDrag'];=0A=
          util.selectiveDeepExtend(fields, this.options, options);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_startRendering',=0A=
      value: function _startRendering() {=0A=
        if (this.renderingActive =3D=3D=3D true) {=0A=
          if (this.renderTimer =3D=3D=3D undefined) {=0A=
            if (this.requiresTimeout =3D=3D=3D true) {=0A=
              this.renderTimer =3D =
window.setTimeout(this._renderStep.bind(this), this.simulationInterval); =
// wait this.renderTimeStep milliseconds and perform the animation step =
function=0A=
            } else {=0A=
              this.renderTimer =3D =
window.requestAnimationFrame(this._renderStep.bind(this)); // wait =
this.renderTimeStep milliseconds and perform the animation step function=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_renderStep',=0A=
      value: function _renderStep() {=0A=
        if (this.renderingActive =3D=3D=3D true) {=0A=
          // reset the renderTimer so a new scheduled animation step can =
be set=0A=
          this.renderTimer =3D undefined;=0A=
=0A=
          if (this.requiresTimeout =3D=3D=3D true) {=0A=
            // this schedules a new simulation step=0A=
            this._startRendering();=0A=
          }=0A=
=0A=
          this._redraw();=0A=
=0A=
          if (this.requiresTimeout =3D=3D=3D false) {=0A=
            // this schedules a new simulation step=0A=
            this._startRendering();=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'redraw',=0A=
=0A=
      /**=0A=
       * Redraw the network with the current data=0A=
       * chart will be resized too.=0A=
       */=0A=
      value: function redraw() {=0A=
        this.body.emitter.emit('setSize');=0A=
        this._redraw();=0A=
      }=0A=
    }, {=0A=
      key: '_requestRedraw',=0A=
=0A=
      /**=0A=
       * Redraw the network with the current data=0A=
       * @param hidden | used to get the first estimate of the node =
sizes. only the nodes are drawn after which they are quickly drawn over.=0A=
       * @private=0A=
       */=0A=
      value: function _requestRedraw() {=0A=
        var _this2 =3D this;=0A=
=0A=
        if (this.redrawRequested !=3D=3D true && this.renderingActive =
=3D=3D=3D false && this.allowRedraw =3D=3D=3D true) {=0A=
          this.redrawRequested =3D true;=0A=
          if (this.requiresTimeout =3D=3D=3D true) {=0A=
            window.setTimeout(function () {=0A=
              _this2._redraw(false);=0A=
            }, 0);=0A=
          } else {=0A=
            window.requestAnimationFrame(function () {=0A=
              _this2._redraw(false);=0A=
            });=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_redraw',=0A=
      value: function _redraw() {=0A=
        var hidden =3D arguments.length <=3D 0 || arguments[0] =3D=3D=3D =
undefined ? false : arguments[0];=0A=
=0A=
        if (this.allowRedraw =3D=3D=3D true) {=0A=
          this.body.emitter.emit('initRedraw');=0A=
=0A=
          this.redrawRequested =3D false;=0A=
          var ctx =3D this.canvas.frame.canvas.getContext('2d');=0A=
=0A=
          // when the container div was hidden, this fixes it back up!=0A=
          if (this.canvas.frame.canvas.width =3D=3D=3D 0 || =
this.canvas.frame.canvas.height =3D=3D=3D 0) {=0A=
            this.canvas.setSize();=0A=
          }=0A=
=0A=
          if (this.pixelRatio =3D=3D=3D undefined) {=0A=
            this.pixelRatio =3D (window.devicePixelRatio || 1) / =
(ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || =
ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || =
ctx.backingStorePixelRatio || 1);=0A=
          }=0A=
=0A=
          ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);=0A=
=0A=
          // clear the canvas=0A=
          var w =3D this.canvas.frame.canvas.clientWidth;=0A=
          var h =3D this.canvas.frame.canvas.clientHeight;=0A=
          ctx.clearRect(0, 0, w, h);=0A=
=0A=
          // set scaling and translation=0A=
          ctx.save();=0A=
          ctx.translate(this.body.view.translation.x, =
this.body.view.translation.y);=0A=
          ctx.scale(this.body.view.scale, this.body.view.scale);=0A=
=0A=
          ctx.beginPath();=0A=
          this.body.emitter.emit('beforeDrawing', ctx);=0A=
          ctx.closePath();=0A=
=0A=
          if (hidden =3D=3D=3D false) {=0A=
            if (this.dragging =3D=3D=3D false || this.dragging =3D=3D=3D =
true && this.options.hideEdgesOnDrag =3D=3D=3D false) {=0A=
              this._drawEdges(ctx);=0A=
            }=0A=
          }=0A=
=0A=
          if (this.dragging =3D=3D=3D false || this.dragging =3D=3D=3D =
true && this.options.hideNodesOnDrag =3D=3D=3D false) {=0A=
            this._drawNodes(ctx, hidden);=0A=
          }=0A=
=0A=
          if (this.controlNodesActive =3D=3D=3D true) {=0A=
            this._drawControlNodes(ctx);=0A=
          }=0A=
=0A=
          ctx.beginPath();=0A=
          //this.physics.nodesSolver._debug(ctx,"#F00F0F");=0A=
          this.body.emitter.emit('afterDrawing', ctx);=0A=
          ctx.closePath();=0A=
          // restore original scaling and translation=0A=
          ctx.restore();=0A=
=0A=
          if (hidden =3D=3D=3D true) {=0A=
            ctx.clearRect(0, 0, w, h);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_resizeNodes',=0A=
=0A=
      /**=0A=
       * Redraw all nodes=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext('2d');=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       * @param {Boolean} [alwaysShow]=0A=
       * @private=0A=
       */=0A=
      value: function _resizeNodes() {=0A=
        var ctx =3D this.canvas.frame.canvas.getContext('2d');=0A=
        if (this.pixelRatio =3D=3D=3D undefined) {=0A=
          this.pixelRatio =3D (window.devicePixelRatio || 1) / =
(ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || =
ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || =
ctx.backingStorePixelRatio || 1);=0A=
        }=0A=
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);=0A=
        ctx.save();=0A=
        ctx.translate(this.body.view.translation.x, =
this.body.view.translation.y);=0A=
        ctx.scale(this.body.view.scale, this.body.view.scale);=0A=
=0A=
        var nodes =3D this.body.nodes;=0A=
        var node =3D undefined;=0A=
=0A=
        // resize all nodes=0A=
        for (var nodeId in nodes) {=0A=
          if (nodes.hasOwnProperty(nodeId)) {=0A=
            node =3D nodes[nodeId];=0A=
            node.resize(ctx);=0A=
            node.updateBoundingBox(ctx, node.selected);=0A=
          }=0A=
        }=0A=
=0A=
        // restore original scaling and translation=0A=
        ctx.restore();=0A=
      }=0A=
    }, {=0A=
      key: '_drawNodes',=0A=
=0A=
      /**=0A=
       * Redraw all nodes=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext('2d');=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       * @param {Boolean} [alwaysShow]=0A=
       * @private=0A=
       */=0A=
      value: function _drawNodes(ctx) {=0A=
        var alwaysShow =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        var nodes =3D this.body.nodes;=0A=
        var nodeIndices =3D this.body.nodeIndices;=0A=
        var node =3D undefined;=0A=
        var selected =3D [];=0A=
        var margin =3D 20;=0A=
        var topLeft =3D this.canvas.DOMtoCanvas({ x: -margin, y: -margin =
});=0A=
        var bottomRight =3D this.canvas.DOMtoCanvas({=0A=
          x: this.canvas.frame.canvas.clientWidth + margin,=0A=
          y: this.canvas.frame.canvas.clientHeight + margin=0A=
        });=0A=
        var viewableArea =3D { top: topLeft.y, left: topLeft.x, bottom: =
bottomRight.y, right: bottomRight.x };=0A=
=0A=
        // draw unselected nodes;=0A=
        for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
          node =3D nodes[nodeIndices[i]];=0A=
          // set selected nodes aside=0A=
          if (node.isSelected()) {=0A=
            selected.push(nodeIndices[i]);=0A=
          } else {=0A=
            if (alwaysShow =3D=3D=3D true) {=0A=
              node.draw(ctx);=0A=
            } else if (node.isBoundingBoxOverlappingWith(viewableArea) =
=3D=3D=3D true) {=0A=
              node.draw(ctx);=0A=
            } else {=0A=
              node.updateBoundingBox(ctx, node.selected);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // draw the selected nodes on top=0A=
        for (var i =3D 0; i < selected.length; i++) {=0A=
          node =3D nodes[selected[i]];=0A=
          node.draw(ctx);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_drawEdges',=0A=
=0A=
      /**=0A=
       * Redraw all edges=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext('2d');=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       * @private=0A=
       */=0A=
      value: function _drawEdges(ctx) {=0A=
        var edges =3D this.body.edges;=0A=
        var edgeIndices =3D this.body.edgeIndices;=0A=
        var edge =3D undefined;=0A=
=0A=
        for (var i =3D 0; i < edgeIndices.length; i++) {=0A=
          edge =3D edges[edgeIndices[i]];=0A=
          if (edge.connected =3D=3D=3D true) {=0A=
            edge.draw(ctx);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_drawControlNodes',=0A=
=0A=
      /**=0A=
       * Redraw all edges=0A=
       * The 2d context of a HTML canvas can be retrieved by =
canvas.getContext('2d');=0A=
       * @param {CanvasRenderingContext2D}   ctx=0A=
       * @private=0A=
       */=0A=
      value: function _drawControlNodes(ctx) {=0A=
        var edges =3D this.body.edges;=0A=
        var edgeIndices =3D this.body.edgeIndices;=0A=
        var edge =3D undefined;=0A=
=0A=
        for (var i =3D 0; i < edgeIndices.length; i++) {=0A=
          edge =3D edges[edgeIndices[i]];=0A=
          edge._drawControlNodes(ctx);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_determineBrowserMethod',=0A=
=0A=
      /**=0A=
       * Determine if the browser requires a setTimeout or a =
requestAnimationFrame. This was required because=0A=
       * some implementations (safari and IE9) did not support =
requestAnimationFrame=0A=
       * @private=0A=
       */=0A=
      value: function _determineBrowserMethod() {=0A=
        if (typeof window !=3D=3D 'undefined') {=0A=
          var browserType =3D navigator.userAgent.toLowerCase();=0A=
          this.requiresTimeout =3D false;=0A=
          if (browserType.indexOf('msie 9.0') !=3D -1) {=0A=
            // IE 9=0A=
            this.requiresTimeout =3D true;=0A=
          } else if (browserType.indexOf('safari') !=3D -1) {=0A=
            // safari=0A=
            if (browserType.indexOf('chrome') <=3D -1) {=0A=
              this.requiresTimeout =3D true;=0A=
            }=0A=
          }=0A=
        } else {=0A=
          this.requiresTimeout =3D true;=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return CanvasRenderer;=0A=
  })();=0A=
=0A=
  exports['default'] =3D CanvasRenderer;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 102 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var hammerUtil =3D __webpack_require__(27);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  /**=0A=
   * Create the main frame for the Network.=0A=
   * This function is executed once when a Network object is created. =
The frame=0A=
   * contains a canvas, and this canvas contains all objects like the =
axis and=0A=
   * nodes.=0A=
   * @private=0A=
   */=0A=
=0A=
  var Canvas =3D (function () {=0A=
    function Canvas(body) {=0A=
      _classCallCheck(this, Canvas);=0A=
=0A=
      this.body =3D body;=0A=
      this.pixelRatio =3D 1;=0A=
      this.resizeTimer =3D undefined;=0A=
      this.resizeFunction =3D this._onResize.bind(this);=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        autoResize: true,=0A=
        height: '100%',=0A=
        width: '100%'=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.bindEventListeners();=0A=
    }=0A=
=0A=
    _createClass(Canvas, [{=0A=
      key: 'bindEventListeners',=0A=
      value: function bindEventListeners() {=0A=
        var _this =3D this;=0A=
=0A=
        // bind the events=0A=
        this.body.emitter.once('resize', function (obj) {=0A=
          if (obj.width !=3D=3D 0) {=0A=
            _this.body.view.translation.x =3D obj.width * 0.5;=0A=
          }=0A=
          if (obj.height !=3D=3D 0) {=0A=
            _this.body.view.translation.y =3D obj.height * 0.5;=0A=
          }=0A=
        });=0A=
        this.body.emitter.on('setSize', this.setSize.bind(this));=0A=
        this.body.emitter.on('destroy', function () {=0A=
          _this.hammerFrame.destroy();=0A=
          _this.hammer.destroy();=0A=
          _this._cleanUp();=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        var _this2 =3D this;=0A=
=0A=
        if (options !=3D=3D undefined) {=0A=
          var fields =3D ['width', 'height', 'autoResize'];=0A=
          util.selectiveDeepExtend(fields, this.options, options);=0A=
        }=0A=
=0A=
        if (this.options.autoResize =3D=3D=3D true) {=0A=
          // automatically adapt to a changing size of the browser.=0A=
          this._cleanUp();=0A=
          this.resizeTimer =3D setInterval(function () {=0A=
            var changed =3D _this2.setSize();=0A=
            if (changed =3D=3D=3D true) {=0A=
              _this2.body.emitter.emit('_requestRedraw');=0A=
            }=0A=
          }, 1000);=0A=
          this.resizeFunction =3D this._onResize.bind(this);=0A=
          util.addEventListener(window, 'resize', this.resizeFunction);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_cleanUp',=0A=
      value: function _cleanUp() {=0A=
        // automatically adapt to a changing size of the browser.=0A=
        if (this.resizeTimer !=3D=3D undefined) {=0A=
          clearInterval(this.resizeTimer);=0A=
        }=0A=
        util.removeEventListener(window, 'resize', this.resizeFunction);=0A=
        this.resizeFunction =3D undefined;=0A=
      }=0A=
    }, {=0A=
      key: '_onResize',=0A=
      value: function _onResize() {=0A=
        this.setSize();=0A=
        this.body.emitter.emit('_redraw');=0A=
      }=0A=
    }, {=0A=
      key: '_prepareValue',=0A=
      value: function _prepareValue(value) {=0A=
        if (typeof value =3D=3D=3D 'number') {=0A=
          return value + 'px';=0A=
        } else if (typeof value =3D=3D=3D 'string') {=0A=
          if (value.indexOf('%') !=3D=3D -1 || value.indexOf('px') =
!=3D=3D -1) {=0A=
            return value;=0A=
          } else if (value.indexOf('%') =3D=3D=3D -1) {=0A=
            return value + 'px';=0A=
          }=0A=
        }=0A=
        throw new Error('Could not use the value supplie for width or =
height:' + value);=0A=
      }=0A=
    }, {=0A=
      key: '_create',=0A=
=0A=
      /**=0A=
       * Create the HTML=0A=
       */=0A=
      value: function _create() {=0A=
        // remove all elements from the container element.=0A=
        while (this.body.container.hasChildNodes()) {=0A=
          =
this.body.container.removeChild(this.body.container.firstChild);=0A=
        }=0A=
=0A=
        this.frame =3D document.createElement('div');=0A=
        this.frame.className =3D 'vis-network';=0A=
        this.frame.style.position =3D 'relative';=0A=
        this.frame.style.overflow =3D 'hidden';=0A=
        this.frame.tabIndex =3D 900; // tab index is required for =
keycharm to bind keystrokes to the div instead of the window=0A=
=0A=
        =
//////////////////////////////////////////////////////////////////=0A=
=0A=
        this.frame.canvas =3D document.createElement('canvas');=0A=
        this.frame.canvas.style.position =3D 'relative';=0A=
        this.frame.appendChild(this.frame.canvas);=0A=
=0A=
        if (!this.frame.canvas.getContext) {=0A=
          var noCanvas =3D document.createElement('DIV');=0A=
          noCanvas.style.color =3D 'red';=0A=
          noCanvas.style.fontWeight =3D 'bold';=0A=
          noCanvas.style.padding =3D '10px';=0A=
          noCanvas.innerHTML =3D 'Error: your browser does not support =
HTML canvas';=0A=
          this.frame.canvas.appendChild(noCanvas);=0A=
        } else {=0A=
          var ctx =3D this.frame.canvas.getContext('2d');=0A=
          this.pixelRatio =3D (window.devicePixelRatio || 1) / =
(ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || =
ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || =
ctx.backingStorePixelRatio || 1);=0A=
=0A=
          =
this.frame.canvas.getContext('2d').setTransform(this.pixelRatio, 0, 0, =
this.pixelRatio, 0, 0);=0A=
        }=0A=
=0A=
        // add the frame to the container element=0A=
        this.body.container.appendChild(this.frame);=0A=
=0A=
        this.body.view.scale =3D 1;=0A=
        this.body.view.translation =3D { x: 0.5 * =
this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight };=0A=
=0A=
        this._bindHammer();=0A=
      }=0A=
    }, {=0A=
      key: '_bindHammer',=0A=
=0A=
      /**=0A=
       * This function binds hammer, it can be repeated over and over =
due to the uniqueness check.=0A=
       * @private=0A=
       */=0A=
      value: function _bindHammer() {=0A=
        var _this3 =3D this;=0A=
=0A=
        if (this.hammer !=3D=3D undefined) {=0A=
          this.hammer.destroy();=0A=
        }=0A=
        this.drag =3D {};=0A=
        this.pinch =3D {};=0A=
=0A=
        // init hammer=0A=
        this.hammer =3D new Hammer(this.frame.canvas);=0A=
        this.hammer.get('pinch').set({ enable: true });=0A=
        // enable to get better response, todo: test on mobile.=0A=
        this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // =
30 is ALL_DIRECTIONS in hammer.=0A=
=0A=
        hammerUtil.onTouch(this.hammer, function (event) {=0A=
          _this3.body.eventListeners.onTouch(event);=0A=
        });=0A=
        this.hammer.on('tap', function (event) {=0A=
          _this3.body.eventListeners.onTap(event);=0A=
        });=0A=
        this.hammer.on('doubletap', function (event) {=0A=
          _this3.body.eventListeners.onDoubleTap(event);=0A=
        });=0A=
        this.hammer.on('press', function (event) {=0A=
          _this3.body.eventListeners.onHold(event);=0A=
        });=0A=
        this.hammer.on('panstart', function (event) {=0A=
          _this3.body.eventListeners.onDragStart(event);=0A=
        });=0A=
        this.hammer.on('panmove', function (event) {=0A=
          _this3.body.eventListeners.onDrag(event);=0A=
        });=0A=
        this.hammer.on('panend', function (event) {=0A=
          _this3.body.eventListeners.onDragEnd(event);=0A=
        });=0A=
        this.hammer.on('pinch', function (event) {=0A=
          _this3.body.eventListeners.onPinch(event);=0A=
        });=0A=
=0A=
        // TODO: neatly cleanup these handlers when re-creating the =
Canvas, IF these are done with hammer, event.stopPropagation will not =
work?=0A=
        this.frame.canvas.addEventListener('mousewheel', function =
(event) {=0A=
          _this3.body.eventListeners.onMouseWheel(event);=0A=
        });=0A=
        this.frame.canvas.addEventListener('DOMMouseScroll', function =
(event) {=0A=
          _this3.body.eventListeners.onMouseWheel(event);=0A=
        });=0A=
=0A=
        this.frame.canvas.addEventListener('mousemove', function (event) =
{=0A=
          _this3.body.eventListeners.onMouseMove(event);=0A=
        });=0A=
        this.frame.canvas.addEventListener('contextmenu', function =
(event) {=0A=
          _this3.body.eventListeners.onContext(event);=0A=
        });=0A=
=0A=
        this.hammerFrame =3D new Hammer(this.frame);=0A=
        hammerUtil.onRelease(this.hammerFrame, function (event) {=0A=
          _this3.body.eventListeners.onRelease(event);=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setSize',=0A=
=0A=
      /**=0A=
       * Set a new size for the network=0A=
       * @param {string} width   Width in pixels or percentage (for =
example '800px'=0A=
       *                         or '50%')=0A=
       * @param {string} height  Height in pixels or percentage  (for =
example '400px'=0A=
       *                         or '30%')=0A=
       */=0A=
      value: function setSize() {=0A=
        var width =3D arguments.length <=3D 0 || arguments[0] =3D=3D=3D =
undefined ? this.options.width : arguments[0];=0A=
        var height =3D arguments.length <=3D 1 || arguments[1] =3D=3D=3D =
undefined ? this.options.height : arguments[1];=0A=
=0A=
        width =3D this._prepareValue(width);=0A=
        height =3D this._prepareValue(height);=0A=
=0A=
        var emitEvent =3D false;=0A=
        var oldWidth =3D this.frame.canvas.width;=0A=
        var oldHeight =3D this.frame.canvas.height;=0A=
=0A=
        if (width !=3D this.options.width || height !=3D =
this.options.height || this.frame.style.width !=3D width || =
this.frame.style.height !=3D height) {=0A=
          this.frame.style.width =3D width;=0A=
          this.frame.style.height =3D height;=0A=
=0A=
          this.frame.canvas.style.width =3D '100%';=0A=
          this.frame.canvas.style.height =3D '100%';=0A=
=0A=
          this.frame.canvas.width =3D =
Math.round(this.frame.canvas.clientWidth * this.pixelRatio);=0A=
          this.frame.canvas.height =3D =
Math.round(this.frame.canvas.clientHeight * this.pixelRatio);=0A=
=0A=
          this.options.width =3D width;=0A=
          this.options.height =3D height;=0A=
=0A=
          emitEvent =3D true;=0A=
        } else {=0A=
          // this would adapt the width of the canvas to the width from =
100% if and only if=0A=
          // there is a change.=0A=
=0A=
          if (this.frame.canvas.width !=3D =
Math.round(this.frame.canvas.clientWidth * this.pixelRatio)) {=0A=
            this.frame.canvas.width =3D =
Math.round(this.frame.canvas.clientWidth * this.pixelRatio);=0A=
            emitEvent =3D true;=0A=
          }=0A=
          if (this.frame.canvas.height !=3D =
Math.round(this.frame.canvas.clientHeight * this.pixelRatio)) {=0A=
            this.frame.canvas.height =3D =
Math.round(this.frame.canvas.clientHeight * this.pixelRatio);=0A=
            emitEvent =3D true;=0A=
          }=0A=
        }=0A=
=0A=
        if (emitEvent =3D=3D=3D true) {=0A=
          this.body.emitter.emit('resize', {=0A=
            width: Math.round(this.frame.canvas.width / this.pixelRatio),=0A=
            height: Math.round(this.frame.canvas.height / =
this.pixelRatio),=0A=
            oldWidth: Math.round(oldWidth / this.pixelRatio),=0A=
            oldHeight: Math.round(oldHeight / this.pixelRatio)=0A=
          });=0A=
        }=0A=
=0A=
        return emitEvent;=0A=
      }=0A=
    }, {=0A=
      key: '_XconvertDOMtoCanvas',=0A=
=0A=
      /**=0A=
       * Convert the X coordinate in DOM-space (coordinate point in =
browser relative to the container div) to=0A=
       * the X coordinate in canvas-space (the simulation sandbox, which =
the camera looks upon)=0A=
       * @param {number} x=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _XconvertDOMtoCanvas(x) {=0A=
        return (x - this.body.view.translation.x) / this.body.view.scale;=0A=
      }=0A=
    }, {=0A=
      key: '_XconvertCanvasToDOM',=0A=
=0A=
      /**=0A=
       * Convert the X coordinate in canvas-space (the simulation =
sandbox, which the camera looks upon) to=0A=
       * the X coordinate in DOM-space (coordinate point in browser =
relative to the container div)=0A=
       * @param {number} x=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _XconvertCanvasToDOM(x) {=0A=
        return x * this.body.view.scale + this.body.view.translation.x;=0A=
      }=0A=
    }, {=0A=
      key: '_YconvertDOMtoCanvas',=0A=
=0A=
      /**=0A=
       * Convert the Y coordinate in DOM-space (coordinate point in =
browser relative to the container div) to=0A=
       * the Y coordinate in canvas-space (the simulation sandbox, which =
the camera looks upon)=0A=
       * @param {number} y=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _YconvertDOMtoCanvas(y) {=0A=
        return (y - this.body.view.translation.y) / this.body.view.scale;=0A=
      }=0A=
    }, {=0A=
      key: '_YconvertCanvasToDOM',=0A=
=0A=
      /**=0A=
       * Convert the Y coordinate in canvas-space (the simulation =
sandbox, which the camera looks upon) to=0A=
       * the Y coordinate in DOM-space (coordinate point in browser =
relative to the container div)=0A=
       * @param {number} y=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _YconvertCanvasToDOM(y) {=0A=
        return y * this.body.view.scale + this.body.view.translation.y;=0A=
      }=0A=
    }, {=0A=
      key: 'canvasToDOM',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param {object} pos   =3D {x: number, y: number}=0A=
       * @returns {{x: number, y: number}}=0A=
       * @constructor=0A=
       */=0A=
      value: function canvasToDOM(pos) {=0A=
        return { x: this._XconvertCanvasToDOM(pos.x), y: =
this._YconvertCanvasToDOM(pos.y) };=0A=
      }=0A=
    }, {=0A=
      key: 'DOMtoCanvas',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param {object} pos   =3D {x: number, y: number}=0A=
       * @returns {{x: number, y: number}}=0A=
       * @constructor=0A=
       */=0A=
      value: function DOMtoCanvas(pos) {=0A=
        return { x: this._XconvertDOMtoCanvas(pos.x), y: =
this._YconvertDOMtoCanvas(pos.y) };=0A=
      }=0A=
    }]);=0A=
=0A=
    return Canvas;=0A=
  })();=0A=
=0A=
  exports['default'] =3D Canvas;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 103 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var View =3D (function () {=0A=
    function View(body, canvas) {=0A=
      var _this =3D this;=0A=
=0A=
      _classCallCheck(this, View);=0A=
=0A=
      this.body =3D body;=0A=
      this.canvas =3D canvas;=0A=
=0A=
      this.animationSpeed =3D 1 / this.renderRefreshRate;=0A=
      this.animationEasingFunction =3D "easeInOutQuint";=0A=
      this.easingTime =3D 0;=0A=
      this.sourceScale =3D 0;=0A=
      this.targetScale =3D 0;=0A=
      this.sourceTranslation =3D 0;=0A=
      this.targetTranslation =3D 0;=0A=
      this.lockedOnNodeId =3D undefined;=0A=
      this.lockedOnNodeOffset =3D undefined;=0A=
      this.touchTime =3D 0;=0A=
=0A=
      this.viewFunction =3D undefined;=0A=
=0A=
      this.body.emitter.on("fit", this.fit.bind(this));=0A=
      this.body.emitter.on("animationFinished", function () {=0A=
        _this.body.emitter.emit("_stopRendering");=0A=
      });=0A=
      this.body.emitter.on("unlockNode", this.releaseNode.bind(this));=0A=
    }=0A=
=0A=
    _createClass(View, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions() {=0A=
        var options =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? {} : arguments[0];=0A=
=0A=
        this.options =3D options;=0A=
      }=0A=
    }, {=0A=
      key: "_getRange",=0A=
=0A=
      /**=0A=
       * Find the center position of the network=0A=
       * @private=0A=
       */=0A=
      value: function _getRange() {=0A=
        var specificNodes =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? [] : arguments[0];=0A=
=0A=
        var minY =3D 1e9,=0A=
            maxY =3D -1e9,=0A=
            minX =3D 1e9,=0A=
            maxX =3D -1e9,=0A=
            node;=0A=
        if (specificNodes.length > 0) {=0A=
          for (var i =3D 0; i < specificNodes.length; i++) {=0A=
            node =3D this.body.nodes[specificNodes[i]];=0A=
            if (minX > node.shape.boundingBox.left) {=0A=
              minX =3D node.shape.boundingBox.left;=0A=
            }=0A=
            if (maxX < node.shape.boundingBox.right) {=0A=
              maxX =3D node.shape.boundingBox.right;=0A=
            }=0A=
            if (minY > node.shape.boundingBox.top) {=0A=
              minY =3D node.shape.boundingBox.top;=0A=
            } // top is negative, bottom is positive=0A=
            if (maxY < node.shape.boundingBox.bottom) {=0A=
              maxY =3D node.shape.boundingBox.bottom;=0A=
            } // top is negative, bottom is positive=0A=
          }=0A=
        } else {=0A=
          for (var i =3D 0; i < this.body.nodeIndices.length; i++) {=0A=
            node =3D this.body.nodes[this.body.nodeIndices[i]];=0A=
            if (minX > node.shape.boundingBox.left) {=0A=
              minX =3D node.shape.boundingBox.left;=0A=
            }=0A=
            if (maxX < node.shape.boundingBox.right) {=0A=
              maxX =3D node.shape.boundingBox.right;=0A=
            }=0A=
            if (minY > node.shape.boundingBox.top) {=0A=
              minY =3D node.shape.boundingBox.top;=0A=
            } // top is negative, bottom is positive=0A=
            if (maxY < node.shape.boundingBox.bottom) {=0A=
              maxY =3D node.shape.boundingBox.bottom;=0A=
            } // top is negative, bottom is positive=0A=
          }=0A=
        }=0A=
=0A=
        if (minX =3D=3D=3D 1e9 && maxX =3D=3D=3D -1e9 && minY =3D=3D=3D =
1e9 && maxY =3D=3D=3D -1e9) {=0A=
          minY =3D 0, maxY =3D 0, minX =3D 0, maxX =3D 0;=0A=
        }=0A=
        return { minX: minX, maxX: maxX, minY: minY, maxY: maxY };=0A=
      }=0A=
    }, {=0A=
      key: "_findCenter",=0A=
=0A=
      /**=0A=
       * @param {object} range =3D {minX: minX, maxX: maxX, minY: minY, =
maxY: maxY};=0A=
       * @returns {{x: number, y: number}}=0A=
       * @private=0A=
       */=0A=
      value: function _findCenter(range) {=0A=
        return { x: 0.5 * (range.maxX + range.minX),=0A=
          y: 0.5 * (range.maxY + range.minY) };=0A=
      }=0A=
    }, {=0A=
      key: "fit",=0A=
=0A=
      /**=0A=
       * This function zooms out to fit all data on screen based on =
amount of nodes=0A=
       * @param {Object} Options=0A=
       * @param {Boolean} [initialZoom]  | zoom based on fitted formula =
or range, true =3D fitted, default =3D false;=0A=
       */=0A=
      value: function fit() {=0A=
        var options =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? { nodes: [] } : arguments[0];=0A=
        var initialZoom =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? false : arguments[1];=0A=
=0A=
        var range;=0A=
        var zoomLevel;=0A=
=0A=
        if (initialZoom =3D=3D=3D true) {=0A=
          // check if more than half of the nodes have a predefined =
position. If so, we use the range, not the approximation.=0A=
          var positionDefined =3D 0;=0A=
          for (var nodeId in this.body.nodes) {=0A=
            if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
              var node =3D this.body.nodes[nodeId];=0A=
              if (node.predefinedPosition =3D=3D=3D true) {=0A=
                positionDefined +=3D 1;=0A=
              }=0A=
            }=0A=
          }=0A=
          if (positionDefined > 0.5 * this.body.nodeIndices.length) {=0A=
            this.fit(options, false);=0A=
            return;=0A=
          }=0A=
=0A=
          range =3D this._getRange(options.nodes);=0A=
=0A=
          var numberOfNodes =3D this.body.nodeIndices.length;=0A=
          zoomLevel =3D 12.662 / (numberOfNodes + 7.4147) + 0.0964822; =
// this is obtained from fitting a dataset from 5 points with scale =
levels that looked good.=0A=
=0A=
          // correct for larger canvasses.=0A=
          var factor =3D Math.min(this.canvas.frame.canvas.clientWidth / =
600, this.canvas.frame.canvas.clientHeight / 600);=0A=
          zoomLevel *=3D factor;=0A=
        } else {=0A=
          this.body.emitter.emit("_resizeNodes");=0A=
          range =3D this._getRange(options.nodes);=0A=
=0A=
          var xDistance =3D Math.abs(range.maxX - range.minX) * 1.1;=0A=
          var yDistance =3D Math.abs(range.maxY - range.minY) * 1.1;=0A=
=0A=
          var xZoomLevel =3D this.canvas.frame.canvas.clientWidth / =
xDistance;=0A=
          var yZoomLevel =3D this.canvas.frame.canvas.clientHeight / =
yDistance;=0A=
=0A=
          zoomLevel =3D xZoomLevel <=3D yZoomLevel ? xZoomLevel : =
yZoomLevel;=0A=
        }=0A=
=0A=
        if (zoomLevel > 1.0) {=0A=
          zoomLevel =3D 1.0;=0A=
        } else if (zoomLevel =3D=3D=3D 0) {=0A=
          zoomLevel =3D 1.0;=0A=
        }=0A=
=0A=
        var center =3D this._findCenter(range);=0A=
        var animationOptions =3D { position: center, scale: zoomLevel, =
animation: options.animation };=0A=
        this.moveTo(animationOptions);=0A=
      }=0A=
    }, {=0A=
      key: "focus",=0A=
=0A=
      // animation=0A=
=0A=
      /**=0A=
       * Center a node in view.=0A=
       *=0A=
       * @param {Number} nodeId=0A=
       * @param {Number} [options]=0A=
       */=0A=
      value: function focus(nodeId) {=0A=
        var options =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? {} : arguments[1];=0A=
=0A=
        if (this.body.nodes[nodeId] !=3D=3D undefined) {=0A=
          var nodePosition =3D { x: this.body.nodes[nodeId].x, y: =
this.body.nodes[nodeId].y };=0A=
          options.position =3D nodePosition;=0A=
          options.lockedOnNode =3D nodeId;=0A=
=0A=
          this.moveTo(options);=0A=
        } else {=0A=
          console.log("Node: " + nodeId + " cannot be found.");=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "moveTo",=0A=
=0A=
      /**=0A=
       *=0A=
       * @param {Object} options  |  options.offset   =3D {x:Number, =
y:Number}   // offset from the center in DOM pixels=0A=
       *                          |  options.scale    =3D Number         =
        // scale to move to=0A=
       *                          |  options.position =3D {x:Number, =
y:Number}   // position to move to=0A=
       *                          |  options.animation =3D =
{duration:Number, easingFunction:String} || Boolean   // position to =
move to=0A=
       */=0A=
      value: function moveTo(options) {=0A=
        if (options =3D=3D=3D undefined) {=0A=
          options =3D {};=0A=
          return;=0A=
        }=0A=
        if (options.offset =3D=3D=3D undefined) {=0A=
          options.offset =3D { x: 0, y: 0 };=0A=
        }=0A=
        if (options.offset.x =3D=3D=3D undefined) {=0A=
          options.offset.x =3D 0;=0A=
        }=0A=
        if (options.offset.y =3D=3D=3D undefined) {=0A=
          options.offset.y =3D 0;=0A=
        }=0A=
        if (options.scale =3D=3D=3D undefined) {=0A=
          options.scale =3D this.body.view.scale;=0A=
        }=0A=
        if (options.position =3D=3D=3D undefined) {=0A=
          options.position =3D this.getViewPosition();=0A=
        }=0A=
        if (options.animation =3D=3D=3D undefined) {=0A=
          options.animation =3D { duration: 0 };=0A=
        }=0A=
        if (options.animation =3D=3D=3D false) {=0A=
          options.animation =3D { duration: 0 };=0A=
        }=0A=
        if (options.animation =3D=3D=3D true) {=0A=
          options.animation =3D {};=0A=
        }=0A=
        if (options.animation.duration =3D=3D=3D undefined) {=0A=
          options.animation.duration =3D 1000;=0A=
        } // default duration=0A=
        if (options.animation.easingFunction =3D=3D=3D undefined) {=0A=
          options.animation.easingFunction =3D "easeInOutQuad";=0A=
        } // default easing function=0A=
=0A=
        this.animateView(options);=0A=
      }=0A=
    }, {=0A=
      key: "animateView",=0A=
=0A=
      /**=0A=
       *=0A=
       * @param {Object} options  |  options.offset   =3D {x:Number, =
y:Number}   // offset from the center in DOM pixels=0A=
       *                          |  options.time     =3D Number         =
        // animation time in milliseconds=0A=
       *                          |  options.scale    =3D Number         =
        // scale to animate to=0A=
       *                          |  options.position =3D {x:Number, =
y:Number}   // position to animate to=0A=
       *                          |  options.easingFunction =3D String   =
        // linear, easeInQuad, easeOutQuad, easeInOutQuad,=0A=
       *                                                                 =
      // easeInCubic, easeOutCubic, easeInOutCubic,=0A=
       *                                                                 =
      // easeInQuart, easeOutQuart, easeInOutQuart,=0A=
       *                                                                 =
      // easeInQuint, easeOutQuint, easeInOutQuint=0A=
       */=0A=
      value: function animateView(options) {=0A=
        if (options =3D=3D=3D undefined) {=0A=
          return;=0A=
        }=0A=
        this.animationEasingFunction =3D =
options.animation.easingFunction;=0A=
        // release if something focussed on the node=0A=
        this.releaseNode();=0A=
        if (options.locked =3D=3D=3D true) {=0A=
          this.lockedOnNodeId =3D options.lockedOnNode;=0A=
          this.lockedOnNodeOffset =3D options.offset;=0A=
        }=0A=
=0A=
        // forcefully complete the old animation if it was still running=0A=
        if (this.easingTime !=3D 0) {=0A=
          this._transitionRedraw(true); // by setting easingtime to 1, =
we finish the animation.=0A=
        }=0A=
=0A=
        this.sourceScale =3D this.body.view.scale;=0A=
        this.sourceTranslation =3D this.body.view.translation;=0A=
        this.targetScale =3D options.scale;=0A=
=0A=
        // set the scale so the viewCenter is based on the correct zoom =
level. This is overridden in the transitionRedraw=0A=
        // but at least then we'll have the target transition=0A=
        this.body.view.scale =3D this.targetScale;=0A=
        var viewCenter =3D this.canvas.DOMtoCanvas({ x: 0.5 * =
this.canvas.frame.canvas.clientWidth, y: 0.5 * =
this.canvas.frame.canvas.clientHeight });=0A=
=0A=
        var distanceFromCenter =3D { // offset from view, distance view =
has to change by these x and y to center the node=0A=
          x: viewCenter.x - options.position.x,=0A=
          y: viewCenter.y - options.position.y=0A=
        };=0A=
        this.targetTranslation =3D {=0A=
          x: this.sourceTranslation.x + distanceFromCenter.x * =
this.targetScale + options.offset.x,=0A=
          y: this.sourceTranslation.y + distanceFromCenter.y * =
this.targetScale + options.offset.y=0A=
        };=0A=
=0A=
        // if the time is set to 0, don't do an animation=0A=
        if (options.animation.duration =3D=3D=3D 0) {=0A=
          if (this.lockedOnNodeId !=3D undefined) {=0A=
            this.viewFunction =3D this._lockedRedraw.bind(this);=0A=
            this.body.emitter.on("initRedraw", this.viewFunction);=0A=
          } else {=0A=
            this.body.view.scale =3D this.targetScale;=0A=
            this.body.view.translation =3D this.targetTranslation;=0A=
            this.body.emitter.emit("_requestRedraw");=0A=
          }=0A=
        } else {=0A=
          this.animationSpeed =3D 1 / (60 * options.animation.duration * =
0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's=0A=
          this.animationEasingFunction =3D =
options.animation.easingFunction;=0A=
=0A=
          this.viewFunction =3D this._transitionRedraw.bind(this);=0A=
          this.body.emitter.on("initRedraw", this.viewFunction);=0A=
          this.body.emitter.emit("_startRendering");=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_lockedRedraw",=0A=
=0A=
      /**=0A=
       * used to animate smoothly by hijacking the redraw function.=0A=
       * @private=0A=
       */=0A=
      value: function _lockedRedraw() {=0A=
        var nodePosition =3D { x: =
this.body.nodes[this.lockedOnNodeId].x, y: =
this.body.nodes[this.lockedOnNodeId].y };=0A=
        var viewCenter =3D this.canvas.DOMtoCanvas({ x: 0.5 * =
this.canvas.frame.canvas.clientWidth, y: 0.5 * =
this.canvas.frame.canvas.clientHeight });=0A=
        var distanceFromCenter =3D { // offset from view, distance view =
has to change by these x and y to center the node=0A=
          x: viewCenter.x - nodePosition.x,=0A=
          y: viewCenter.y - nodePosition.y=0A=
        };=0A=
        var sourceTranslation =3D this.body.view.translation;=0A=
        var targetTranslation =3D {=0A=
          x: sourceTranslation.x + distanceFromCenter.x * =
this.body.view.scale + this.lockedOnNodeOffset.x,=0A=
          y: sourceTranslation.y + distanceFromCenter.y * =
this.body.view.scale + this.lockedOnNodeOffset.y=0A=
        };=0A=
=0A=
        this.body.view.translation =3D targetTranslation;=0A=
      }=0A=
    }, {=0A=
      key: "releaseNode",=0A=
      value: function releaseNode() {=0A=
        if (this.lockedOnNodeId !=3D=3D undefined && this.viewFunction =
!=3D=3D undefined) {=0A=
          this.body.emitter.off("initRedraw", this.viewFunction);=0A=
          this.lockedOnNodeId =3D undefined;=0A=
          this.lockedOnNodeOffset =3D undefined;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_transitionRedraw",=0A=
=0A=
      /**=0A=
       *=0A=
       * @param easingTime=0A=
       * @private=0A=
       */=0A=
      value: function _transitionRedraw() {=0A=
        var finished =3D arguments.length <=3D 0 || arguments[0] =
=3D=3D=3D undefined ? false : arguments[0];=0A=
=0A=
        this.easingTime +=3D this.animationSpeed;=0A=
        this.easingTime =3D finished =3D=3D=3D true ? 1.0 : =
this.easingTime;=0A=
=0A=
        var progress =3D =
util.easingFunctions[this.animationEasingFunction](this.easingTime);=0A=
=0A=
        this.body.view.scale =3D this.sourceScale + (this.targetScale - =
this.sourceScale) * progress;=0A=
        this.body.view.translation =3D {=0A=
          x: this.sourceTranslation.x + (this.targetTranslation.x - =
this.sourceTranslation.x) * progress,=0A=
          y: this.sourceTranslation.y + (this.targetTranslation.y - =
this.sourceTranslation.y) * progress=0A=
        };=0A=
=0A=
        // cleanup=0A=
        if (this.easingTime >=3D 1.0) {=0A=
          this.body.emitter.off("initRedraw", this.viewFunction);=0A=
          this.easingTime =3D 0;=0A=
          if (this.lockedOnNodeId !=3D undefined) {=0A=
            this.viewFunction =3D this._lockedRedraw.bind(this);=0A=
            this.body.emitter.on("initRedraw", this.viewFunction);=0A=
          }=0A=
          this.body.emitter.emit("animationFinished");=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "getScale",=0A=
      value: function getScale() {=0A=
        return this.body.view.scale;=0A=
      }=0A=
    }, {=0A=
      key: "getViewPosition",=0A=
      value: function getViewPosition() {=0A=
        return this.canvas.DOMtoCanvas({ x: 0.5 * =
this.canvas.frame.canvas.clientWidth, y: 0.5 * =
this.canvas.frame.canvas.clientHeight });=0A=
      }=0A=
    }]);=0A=
=0A=
    return View;=0A=
  })();=0A=
=0A=
  exports["default"] =3D View;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 104 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _interopRequireDefault(obj) { return obj && obj.__esModule ? =
obj : { 'default': obj }; }=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var _componentsNavigationHandler =3D __webpack_require__(105);=0A=
=0A=
  var _componentsNavigationHandler2 =3D =
_interopRequireDefault(_componentsNavigationHandler);=0A=
=0A=
  var _componentsPopup =3D __webpack_require__(106);=0A=
=0A=
  var _componentsPopup2 =3D _interopRequireDefault(_componentsPopup);=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var InteractionHandler =3D (function () {=0A=
    function InteractionHandler(body, canvas, selectionHandler) {=0A=
      _classCallCheck(this, InteractionHandler);=0A=
=0A=
      this.body =3D body;=0A=
      this.canvas =3D canvas;=0A=
      this.selectionHandler =3D selectionHandler;=0A=
      this.navigationHandler =3D new =
_componentsNavigationHandler2['default'](body, canvas);=0A=
=0A=
      // bind the events from hammer to functions in this object=0A=
      this.body.eventListeners.onTap =3D this.onTap.bind(this);=0A=
      this.body.eventListeners.onTouch =3D this.onTouch.bind(this);=0A=
      this.body.eventListeners.onDoubleTap =3D =
this.onDoubleTap.bind(this);=0A=
      this.body.eventListeners.onHold =3D this.onHold.bind(this);=0A=
      this.body.eventListeners.onDragStart =3D =
this.onDragStart.bind(this);=0A=
      this.body.eventListeners.onDrag =3D this.onDrag.bind(this);=0A=
      this.body.eventListeners.onDragEnd =3D this.onDragEnd.bind(this);=0A=
      this.body.eventListeners.onMouseWheel =3D =
this.onMouseWheel.bind(this);=0A=
      this.body.eventListeners.onPinch =3D this.onPinch.bind(this);=0A=
      this.body.eventListeners.onMouseMove =3D =
this.onMouseMove.bind(this);=0A=
      this.body.eventListeners.onRelease =3D this.onRelease.bind(this);=0A=
      this.body.eventListeners.onContext =3D this.onContext.bind(this);=0A=
=0A=
      this.touchTime =3D 0;=0A=
      this.drag =3D {};=0A=
      this.pinch =3D {};=0A=
      this.popup =3D undefined;=0A=
      this.popupObj =3D undefined;=0A=
      this.popupTimer =3D undefined;=0A=
=0A=
      this.body.functions.getPointer =3D this.getPointer.bind(this);=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        dragNodes: true,=0A=
        dragView: true,=0A=
        hover: false,=0A=
        keyboard: {=0A=
          enabled: false,=0A=
          speed: { x: 10, y: 10, zoom: 0.02 },=0A=
          bindToWindow: true=0A=
        },=0A=
        navigationButtons: false,=0A=
        tooltipDelay: 300,=0A=
        zoomView: true=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.bindEventListeners();=0A=
    }=0A=
=0A=
    _createClass(InteractionHandler, [{=0A=
      key: 'bindEventListeners',=0A=
      value: function bindEventListeners() {=0A=
        var _this =3D this;=0A=
=0A=
        this.body.emitter.on('destroy', function () {=0A=
          clearTimeout(_this.popupTimer);=0A=
          delete _this.body.functions.getPointer;=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          // extend all but the values in fields=0A=
          var fields =3D ['hideEdgesOnDrag', 'hideNodesOnDrag', =
'keyboard', 'multiselect', 'selectable', 'selectConnectedEdges'];=0A=
          util.selectiveNotDeepExtend(fields, this.options, options);=0A=
=0A=
          // merge the keyboard options in.=0A=
          util.mergeOptions(this.options, options, 'keyboard');=0A=
=0A=
          if (options.tooltip) {=0A=
            util.extend(this.options.tooltip, options.tooltip);=0A=
            if (options.tooltip.color) {=0A=
              this.options.tooltip.color =3D =
util.parseColor(options.tooltip.color);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        this.navigationHandler.setOptions(this.options);=0A=
      }=0A=
    }, {=0A=
      key: 'getPointer',=0A=
=0A=
      /**=0A=
       * Get the pointer location from a touch location=0A=
       * @param {{x: Number, y: Number}} touch=0A=
       * @return {{x: Number, y: Number}} pointer=0A=
       * @private=0A=
       */=0A=
      value: function getPointer(touch) {=0A=
        return {=0A=
          x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),=0A=
          y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)=0A=
        };=0A=
      }=0A=
    }, {=0A=
      key: 'onTouch',=0A=
=0A=
      /**=0A=
       * On start of a touch gesture, store the pointer=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function onTouch(event) {=0A=
        if (new Date().valueOf() - this.touchTime > 50) {=0A=
          this.drag.pointer =3D this.getPointer(event.center);=0A=
          this.drag.pinched =3D false;=0A=
          this.pinch.scale =3D this.body.view.scale;=0A=
          // to avoid double fireing of this event because we have two =
hammer instances. (on canvas and on frame)=0A=
          this.touchTime =3D new Date().valueOf();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'onTap',=0A=
=0A=
      /**=0A=
       * handle tap/click event: select/unselect a node=0A=
       * @private=0A=
       */=0A=
      value: function onTap(event) {=0A=
        var pointer =3D this.getPointer(event.center);=0A=
        var multiselect =3D this.selectionHandler.options.multiselect && =
(event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);=0A=
=0A=
        this.checkSelectionChanges(pointer, event, multiselect);=0A=
        this.selectionHandler._generateClickEvent('click', event, =
pointer);=0A=
      }=0A=
    }, {=0A=
      key: 'onDoubleTap',=0A=
=0A=
      /**=0A=
       * handle doubletap event=0A=
       * @private=0A=
       */=0A=
      value: function onDoubleTap(event) {=0A=
        var pointer =3D this.getPointer(event.center);=0A=
        this.selectionHandler._generateClickEvent('doubleClick', event, =
pointer);=0A=
      }=0A=
    }, {=0A=
      key: 'onHold',=0A=
=0A=
      /**=0A=
       * handle long tap event: multi select nodes=0A=
       * @private=0A=
       */=0A=
      value: function onHold(event) {=0A=
        var pointer =3D this.getPointer(event.center);=0A=
        var multiselect =3D this.selectionHandler.options.multiselect;=0A=
=0A=
        this.checkSelectionChanges(pointer, event, multiselect);=0A=
=0A=
        this.selectionHandler._generateClickEvent('click', event, =
pointer);=0A=
        this.selectionHandler._generateClickEvent('hold', event, =
pointer);=0A=
      }=0A=
    }, {=0A=
      key: 'onRelease',=0A=
=0A=
      /**=0A=
       * handle the release of the screen=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function onRelease(event) {=0A=
        if (new Date().valueOf() - this.touchTime > 10) {=0A=
          var pointer =3D this.getPointer(event.center);=0A=
          this.selectionHandler._generateClickEvent('release', event, =
pointer);=0A=
          // to avoid double fireing of this event because we have two =
hammer instances. (on canvas and on frame)=0A=
          this.touchTime =3D new Date().valueOf();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'onContext',=0A=
      value: function onContext(event) {=0A=
        var pointer =3D this.getPointer({ x: event.clientX, y: =
event.clientY });=0A=
        this.selectionHandler._generateClickEvent('oncontext', event, =
pointer);=0A=
      }=0A=
    }, {=0A=
      key: 'checkSelectionChanges',=0A=
=0A=
      /**=0A=
       *=0A=
       * @param pointer=0A=
       * @param add=0A=
       */=0A=
      value: function checkSelectionChanges(pointer, event) {=0A=
        var add =3D arguments.length <=3D 2 || arguments[2] =3D=3D=3D =
undefined ? false : arguments[2];=0A=
=0A=
        var previouslySelectedEdgeCount =3D =
this.selectionHandler._getSelectedEdgeCount();=0A=
        var previouslySelectedNodeCount =3D =
this.selectionHandler._getSelectedNodeCount();=0A=
        var previousSelection =3D this.selectionHandler.getSelection();=0A=
        var selected =3D undefined;=0A=
        if (add =3D=3D=3D true) {=0A=
          selected =3D =
this.selectionHandler.selectAdditionalOnPoint(pointer);=0A=
        } else {=0A=
          selected =3D this.selectionHandler.selectOnPoint(pointer);=0A=
        }=0A=
        var selectedEdgesCount =3D =
this.selectionHandler._getSelectedEdgeCount();=0A=
        var selectedNodesCount =3D =
this.selectionHandler._getSelectedNodeCount();=0A=
        var currentSelection =3D this.selectionHandler.getSelection();=0A=
=0A=
        var _determineIfDifferent2 =3D =
this._determineIfDifferent(previousSelection, currentSelection);=0A=
=0A=
        var nodesChanges =3D _determineIfDifferent2.nodesChanges;=0A=
        var edgesChanges =3D _determineIfDifferent2.edgesChanges;=0A=
=0A=
        if (selectedNodesCount - previouslySelectedNodeCount > 0) {=0A=
          // node was selected=0A=
          this.selectionHandler._generateClickEvent('selectNode', event, =
pointer);=0A=
          selected =3D true;=0A=
        } else if (selectedNodesCount - previouslySelectedNodeCount < 0) =
{=0A=
          // node was deselected=0A=
          this.selectionHandler._generateClickEvent('deselectNode', =
event, pointer, previousSelection);=0A=
          selected =3D true;=0A=
        } else if (selectedNodesCount =3D=3D=3D =
previouslySelectedNodeCount && nodesChanges =3D=3D=3D true) {=0A=
          this.selectionHandler._generateClickEvent('deselectNode', =
event, pointer, previousSelection);=0A=
          this.selectionHandler._generateClickEvent('selectNode', event, =
pointer);=0A=
          selected =3D true;=0A=
        }=0A=
=0A=
        if (selectedEdgesCount - previouslySelectedEdgeCount > 0) {=0A=
          // edge was selected=0A=
          this.selectionHandler._generateClickEvent('selectEdge', event, =
pointer);=0A=
          selected =3D true;=0A=
        } else if (selectedEdgesCount - previouslySelectedEdgeCount < 0) =
{=0A=
          // edge was deselected=0A=
          this.selectionHandler._generateClickEvent('deselectEdge', =
event, pointer, previousSelection);=0A=
          selected =3D true;=0A=
        } else if (selectedEdgesCount =3D=3D=3D =
previouslySelectedEdgeCount && edgesChanges =3D=3D=3D true) {=0A=
          this.selectionHandler._generateClickEvent('deselectEdge', =
event, pointer, previousSelection);=0A=
          this.selectionHandler._generateClickEvent('selectEdge', event, =
pointer);=0A=
          selected =3D true;=0A=
        }=0A=
=0A=
        if (selected =3D=3D=3D true) {=0A=
          // select or unselect=0A=
          this.selectionHandler._generateClickEvent('select', event, =
pointer);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_determineIfDifferent',=0A=
=0A=
      /**=0A=
       * This function checks if the nodes and edges previously selected =
have changed.=0A=
       * @param previousSelection=0A=
       * @param currentSelection=0A=
       * @returns {{nodesChanges: boolean, edgesChanges: boolean}}=0A=
       * @private=0A=
       */=0A=
      value: function _determineIfDifferent(previousSelection, =
currentSelection) {=0A=
        var nodesChanges =3D false;=0A=
        var edgesChanges =3D false;=0A=
=0A=
        for (var i =3D 0; i < previousSelection.nodes.length; i++) {=0A=
          if (currentSelection.nodes.indexOf(previousSelection.nodes[i]) =
=3D=3D=3D -1) {=0A=
            nodesChanges =3D true;=0A=
          }=0A=
        }=0A=
        for (var i =3D 0; i < currentSelection.nodes.length; i++) {=0A=
          if =
(previousSelection.nodes.indexOf(previousSelection.nodes[i]) =3D=3D=3D =
-1) {=0A=
            nodesChanges =3D true;=0A=
          }=0A=
        }=0A=
        for (var i =3D 0; i < previousSelection.edges.length; i++) {=0A=
          if (currentSelection.edges.indexOf(previousSelection.edges[i]) =
=3D=3D=3D -1) {=0A=
            edgesChanges =3D true;=0A=
          }=0A=
        }=0A=
        for (var i =3D 0; i < currentSelection.edges.length; i++) {=0A=
          if =
(previousSelection.edges.indexOf(previousSelection.edges[i]) =3D=3D=3D =
-1) {=0A=
            edgesChanges =3D true;=0A=
          }=0A=
        }=0A=
=0A=
        return { nodesChanges: nodesChanges, edgesChanges: edgesChanges =
};=0A=
      }=0A=
    }, {=0A=
      key: 'onDragStart',=0A=
=0A=
      /**=0A=
       * This function is called by onDragStart.=0A=
       * It is separated out because we can then overload it for the =
datamanipulation system.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function onDragStart(event) {=0A=
        //in case the touch event was triggered on an external div, do =
the initial touch now.=0A=
        if (this.drag.pointer =3D=3D=3D undefined) {=0A=
          this.onTouch(event);=0A=
        }=0A=
=0A=
        // note: drag.pointer is set in onTouch to get the initial touch =
location=0A=
        var node =3D this.selectionHandler.getNodeAt(this.drag.pointer);=0A=
=0A=
        this.drag.dragging =3D true;=0A=
        this.drag.selection =3D [];=0A=
        this.drag.translation =3D util.extend({}, =
this.body.view.translation); // copy the object=0A=
        this.drag.nodeId =3D undefined;=0A=
=0A=
        if (node !=3D=3D undefined && this.options.dragNodes =3D=3D=3D =
true) {=0A=
          this.drag.nodeId =3D node.id;=0A=
          // select the clicked node if not yet selected=0A=
          if (node.isSelected() =3D=3D=3D false) {=0A=
            this.selectionHandler.unselectAll();=0A=
            this.selectionHandler.selectObject(node);=0A=
          }=0A=
=0A=
          // after select to contain the node=0A=
          this.selectionHandler._generateClickEvent('dragStart', event, =
this.drag.pointer);=0A=
=0A=
          var selection =3D this.selectionHandler.selectionObj.nodes;=0A=
          // create an array with the selected nodes and their original =
location and status=0A=
          for (var nodeId in selection) {=0A=
            if (selection.hasOwnProperty(nodeId)) {=0A=
              var object =3D selection[nodeId];=0A=
              var s =3D {=0A=
                id: object.id,=0A=
                node: object,=0A=
=0A=
                // store original x, y, xFixed and yFixed, make the node =
temporarily Fixed=0A=
                x: object.x,=0A=
                y: object.y,=0A=
                xFixed: object.options.fixed.x,=0A=
                yFixed: object.options.fixed.y=0A=
              };=0A=
=0A=
              object.options.fixed.x =3D true;=0A=
              object.options.fixed.y =3D true;=0A=
=0A=
              this.drag.selection.push(s);=0A=
            }=0A=
          }=0A=
        } else {=0A=
          // fallback if no node is selected and thus the view is =
dragged.=0A=
          this.selectionHandler._generateClickEvent('dragStart', event, =
this.drag.pointer, undefined, true);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'onDrag',=0A=
=0A=
      /**=0A=
       * handle drag event=0A=
       * @private=0A=
       */=0A=
      value: function onDrag(event) {=0A=
        var _this2 =3D this;=0A=
=0A=
        if (this.drag.pinched =3D=3D=3D true) {=0A=
          return;=0A=
        }=0A=
=0A=
        // remove the focus on node if it is focussed on by the =
focusOnNode=0A=
        this.body.emitter.emit('unlockNode');=0A=
=0A=
        var pointer =3D this.getPointer(event.center);=0A=
=0A=
        var selection =3D this.drag.selection;=0A=
        if (selection && selection.length && this.options.dragNodes =
=3D=3D=3D true) {=0A=
          (function () {=0A=
            _this2.selectionHandler._generateClickEvent('dragging', =
event, pointer);=0A=
=0A=
            // calculate delta's and new location=0A=
            var deltaX =3D pointer.x - _this2.drag.pointer.x;=0A=
            var deltaY =3D pointer.y - _this2.drag.pointer.y;=0A=
=0A=
            // update position of all selected nodes=0A=
            selection.forEach(function (selection) {=0A=
              var node =3D selection.node;=0A=
              // only move the node if it was not fixed initially=0A=
              if (selection.xFixed =3D=3D=3D false) {=0A=
                node.x =3D =
_this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(sel=
ection.x) + deltaX);=0A=
              }=0A=
              // only move the node if it was not fixed initially=0A=
              if (selection.yFixed =3D=3D=3D false) {=0A=
                node.y =3D =
_this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(sel=
ection.y) + deltaY);=0A=
              }=0A=
            });=0A=
=0A=
            // start the simulation of the physics=0A=
            _this2.body.emitter.emit('startSimulation');=0A=
          })();=0A=
        } else {=0A=
          // move the network=0A=
          if (this.options.dragView =3D=3D=3D true) {=0A=
            this.selectionHandler._generateClickEvent('dragging', event, =
pointer, undefined, true);=0A=
=0A=
            // if the drag was not started properly because the click =
started outside the network div, start it now.=0A=
            if (this.drag.pointer =3D=3D=3D undefined) {=0A=
              this.onDragStart(event);=0A=
              return;=0A=
            }=0A=
            var diffX =3D pointer.x - this.drag.pointer.x;=0A=
            var diffY =3D pointer.y - this.drag.pointer.y;=0A=
=0A=
            this.body.view.translation =3D { x: this.drag.translation.x =
+ diffX, y: this.drag.translation.y + diffY };=0A=
            this.body.emitter.emit('_redraw');=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'onDragEnd',=0A=
=0A=
      /**=0A=
       * handle drag start event=0A=
       * @private=0A=
       */=0A=
      value: function onDragEnd(event) {=0A=
        this.drag.dragging =3D false;=0A=
        var selection =3D this.drag.selection;=0A=
        if (selection && selection.length) {=0A=
          selection.forEach(function (s) {=0A=
            // restore original xFixed and yFixed=0A=
            s.node.options.fixed.x =3D s.xFixed;=0A=
            s.node.options.fixed.y =3D s.yFixed;=0A=
          });=0A=
          this.selectionHandler._generateClickEvent('dragEnd', event, =
this.getPointer(event.center));=0A=
          this.body.emitter.emit('startSimulation');=0A=
        } else {=0A=
          this.selectionHandler._generateClickEvent('dragEnd', event, =
this.getPointer(event.center), undefined, true);=0A=
          this.body.emitter.emit('_requestRedraw');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'onPinch',=0A=
=0A=
      /**=0A=
       * Handle pinch event=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function onPinch(event) {=0A=
        var pointer =3D this.getPointer(event.center);=0A=
=0A=
        this.drag.pinched =3D true;=0A=
        if (this.pinch['scale'] =3D=3D=3D undefined) {=0A=
          this.pinch.scale =3D 1;=0A=
        }=0A=
=0A=
        // TODO: enabled moving while pinching?=0A=
        var scale =3D this.pinch.scale * event.scale;=0A=
        this.zoom(scale, pointer);=0A=
      }=0A=
    }, {=0A=
      key: 'zoom',=0A=
=0A=
      /**=0A=
       * Zoom the network in or out=0A=
       * @param {Number} scale a number around 1, and between 0.01 and 10=0A=
       * @param {{x: Number, y: Number}} pointer    Position on screen=0A=
       * @return {Number} appliedScale    scale is limited within the =
boundaries=0A=
       * @private=0A=
       */=0A=
      value: function zoom(scale, pointer) {=0A=
        if (this.options.zoomView =3D=3D=3D true) {=0A=
          var scaleOld =3D this.body.view.scale;=0A=
          if (scale < 0.00001) {=0A=
            scale =3D 0.00001;=0A=
          }=0A=
          if (scale > 10) {=0A=
            scale =3D 10;=0A=
          }=0A=
=0A=
          var preScaleDragPointer =3D undefined;=0A=
          if (this.drag !=3D=3D undefined) {=0A=
            if (this.drag.dragging =3D=3D=3D true) {=0A=
              preScaleDragPointer =3D =
this.canvas.DOMtoCanvas(this.drag.pointer);=0A=
            }=0A=
          }=0A=
          // + this.canvas.frame.canvas.clientHeight / 2=0A=
          var translation =3D this.body.view.translation;=0A=
=0A=
          var scaleFrac =3D scale / scaleOld;=0A=
          var tx =3D (1 - scaleFrac) * pointer.x + translation.x * =
scaleFrac;=0A=
          var ty =3D (1 - scaleFrac) * pointer.y + translation.y * =
scaleFrac;=0A=
=0A=
          this.body.view.scale =3D scale;=0A=
          this.body.view.translation =3D { x: tx, y: ty };=0A=
=0A=
          if (preScaleDragPointer !=3D undefined) {=0A=
            var postScaleDragPointer =3D =
this.canvas.canvasToDOM(preScaleDragPointer);=0A=
            this.drag.pointer.x =3D postScaleDragPointer.x;=0A=
            this.drag.pointer.y =3D postScaleDragPointer.y;=0A=
          }=0A=
=0A=
          this.body.emitter.emit('_requestRedraw');=0A=
=0A=
          if (scaleOld < scale) {=0A=
            this.body.emitter.emit('zoom', { direction: '+', scale: =
this.body.view.scale });=0A=
          } else {=0A=
            this.body.emitter.emit('zoom', { direction: '-', scale: =
this.body.view.scale });=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'onMouseWheel',=0A=
=0A=
      /**=0A=
       * Event handler for mouse wheel event, used to zoom the timeline=0A=
       * See http://adomas.org/javascript-mouse-wheel/=0A=
       *     https://github.com/EightMedia/hammer.js/issues/256=0A=
       * @param {MouseEvent}  event=0A=
       * @private=0A=
       */=0A=
      value: function onMouseWheel(event) {=0A=
        // retrieve delta=0A=
        var delta =3D 0;=0A=
        if (event.wheelDelta) {=0A=
          /* IE/Opera. */=0A=
          delta =3D event.wheelDelta / 120;=0A=
        } else if (event.detail) {=0A=
          /* Mozilla case. */=0A=
          // In Mozilla, sign of delta is different than in IE.=0A=
          // Also, delta is multiple of 3.=0A=
          delta =3D -event.detail / 3;=0A=
        }=0A=
=0A=
        // If delta is nonzero, handle it.=0A=
        // Basically, delta is now positive if wheel was scrolled up,=0A=
        // and negative, if wheel was scrolled down.=0A=
        if (delta !=3D=3D 0) {=0A=
=0A=
          // calculate the new scale=0A=
          var scale =3D this.body.view.scale;=0A=
          var zoom =3D delta / 10;=0A=
          if (delta < 0) {=0A=
            zoom =3D zoom / (1 - zoom);=0A=
          }=0A=
          scale *=3D 1 + zoom;=0A=
=0A=
          // calculate the pointer location=0A=
          var pointer =3D this.getPointer({ x: event.clientX, y: =
event.clientY });=0A=
=0A=
          // apply the new scale=0A=
          this.zoom(scale, pointer);=0A=
        }=0A=
=0A=
        // Prevent default actions caused by mouse wheel.=0A=
        event.preventDefault();=0A=
      }=0A=
    }, {=0A=
      key: 'onMouseMove',=0A=
=0A=
      /**=0A=
       * Mouse move handler for checking whether the title moves over a =
node with a title.=0A=
       * @param  {Event} event=0A=
       * @private=0A=
       */=0A=
      value: function onMouseMove(event) {=0A=
        var _this3 =3D this;=0A=
=0A=
        var pointer =3D this.getPointer({ x: event.clientX, y: =
event.clientY });=0A=
        var popupVisible =3D false;=0A=
=0A=
        // check if the previously selected node is still selected=0A=
        if (this.popup !=3D=3D undefined) {=0A=
          if (this.popup.hidden =3D=3D=3D false) {=0A=
            this._checkHidePopup(pointer);=0A=
          }=0A=
=0A=
          // if the popup was not hidden above=0A=
          if (this.popup.hidden =3D=3D=3D false) {=0A=
            popupVisible =3D true;=0A=
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);=0A=
            this.popup.show();=0A=
          }=0A=
        }=0A=
=0A=
        // if we bind the keyboard to the div, we have to highlight it =
to use it. This highlights it on mouse over.=0A=
        if (this.options.keyboard.bindToWindow =3D=3D=3D false && =
this.options.keyboard.enabled =3D=3D=3D true) {=0A=
          this.canvas.frame.focus();=0A=
        }=0A=
=0A=
        // start a timeout that will check if the mouse is positioned =
above an element=0A=
        if (popupVisible =3D=3D=3D false) {=0A=
          if (this.popupTimer !=3D=3D undefined) {=0A=
            clearInterval(this.popupTimer); // stop any running =
calculationTimer=0A=
            this.popupTimer =3D undefined;=0A=
          }=0A=
          if (!this.drag.dragging) {=0A=
            this.popupTimer =3D setTimeout(function () {=0A=
              return _this3._checkShowPopup(pointer);=0A=
            }, this.options.tooltipDelay);=0A=
          }=0A=
        }=0A=
=0A=
        /**=0A=
        * Adding hover highlights=0A=
        */=0A=
        if (this.options.hover =3D=3D=3D true) {=0A=
          // adding hover highlights=0A=
          var obj =3D this.selectionHandler.getNodeAt(pointer);=0A=
          if (obj =3D=3D=3D undefined) {=0A=
            obj =3D this.selectionHandler.getEdgeAt(pointer);=0A=
          }=0A=
          this.selectionHandler.hoverObject(obj);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_checkShowPopup',=0A=
=0A=
      /**=0A=
       * Check if there is an element on the given position in the =
network=0A=
       * (a node or edge). If so, and if this element has a title,=0A=
       * show a popup window with its title.=0A=
       *=0A=
       * @param {{x:Number, y:Number}} pointer=0A=
       * @private=0A=
       */=0A=
      value: function _checkShowPopup(pointer) {=0A=
        var x =3D this.canvas._XconvertDOMtoCanvas(pointer.x);=0A=
        var y =3D this.canvas._YconvertDOMtoCanvas(pointer.y);=0A=
        var pointerObj =3D {=0A=
          left: x,=0A=
          top: y,=0A=
          right: x,=0A=
          bottom: y=0A=
        };=0A=
=0A=
        var previousPopupObjId =3D this.popupObj =3D=3D=3D undefined ? =
undefined : this.popupObj.id;=0A=
        var nodeUnderCursor =3D false;=0A=
        var popupType =3D 'node';=0A=
=0A=
        // check if a node is under the cursor.=0A=
        if (this.popupObj =3D=3D=3D undefined) {=0A=
          // search the nodes for overlap, select the top one in case of =
multiple nodes=0A=
          var nodeIndices =3D this.body.nodeIndices;=0A=
          var nodes =3D this.body.nodes;=0A=
          var node =3D undefined;=0A=
          var overlappingNodes =3D [];=0A=
          for (var i =3D 0; i < nodeIndices.length; i++) {=0A=
            node =3D nodes[nodeIndices[i]];=0A=
            if (node.isOverlappingWith(pointerObj) =3D=3D=3D true) {=0A=
              if (node.getTitle() !=3D=3D undefined) {=0A=
                overlappingNodes.push(nodeIndices[i]);=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          if (overlappingNodes.length > 0) {=0A=
            // if there are overlapping nodes, select the last one, this =
is the one which is drawn on top of the others=0A=
            this.popupObj =3D =
nodes[overlappingNodes[overlappingNodes.length - 1]];=0A=
            // if you hover over a node, the title of the edge is not =
supposed to be shown.=0A=
            nodeUnderCursor =3D true;=0A=
          }=0A=
        }=0A=
=0A=
        if (this.popupObj =3D=3D=3D undefined && nodeUnderCursor =
=3D=3D=3D false) {=0A=
          // search the edges for overlap=0A=
          var edgeIndices =3D this.body.edgeIndices;=0A=
          var edges =3D this.body.edges;=0A=
          var edge =3D undefined;=0A=
          var overlappingEdges =3D [];=0A=
          for (var i =3D 0; i < edgeIndices.length; i++) {=0A=
            edge =3D edges[edgeIndices[i]];=0A=
            if (edge.isOverlappingWith(pointerObj) =3D=3D=3D true) {=0A=
              if (edge.connected =3D=3D=3D true && edge.getTitle() =
!=3D=3D undefined) {=0A=
                overlappingEdges.push(edgeIndices[i]);=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          if (overlappingEdges.length > 0) {=0A=
            this.popupObj =3D =
edges[overlappingEdges[overlappingEdges.length - 1]];=0A=
            popupType =3D 'edge';=0A=
          }=0A=
        }=0A=
=0A=
        if (this.popupObj !=3D=3D undefined) {=0A=
          // show popup message window=0A=
          if (this.popupObj.id !=3D=3D previousPopupObjId) {=0A=
            if (this.popup =3D=3D=3D undefined) {=0A=
              this.popup =3D new =
_componentsPopup2['default'](this.canvas.frame);=0A=
            }=0A=
=0A=
            this.popup.popupTargetType =3D popupType;=0A=
            this.popup.popupTargetId =3D this.popupObj.id;=0A=
=0A=
            // adjust a small offset such that the mouse cursor is =
located in the=0A=
            // bottom left location of the popup, and you can easily =
move over the=0A=
            // popup area=0A=
            this.popup.setPosition(pointer.x + 3, pointer.y - 5);=0A=
            this.popup.setText(this.popupObj.getTitle());=0A=
            this.popup.show();=0A=
            this.body.emitter.emit('showPopup', this.popupObj.id);=0A=
          }=0A=
        } else {=0A=
          if (this.popup !=3D=3D undefined) {=0A=
            this.popup.hide();=0A=
            this.body.emitter.emit('hidePopup');=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_checkHidePopup',=0A=
=0A=
      /**=0A=
       * Check if the popup must be hidden, which is the case when the =
mouse is no=0A=
       * longer hovering on the object=0A=
       * @param {{x:Number, y:Number}} pointer=0A=
       * @private=0A=
       */=0A=
      value: function _checkHidePopup(pointer) {=0A=
        var pointerObj =3D =
this.selectionHandler._pointerToPositionObject(pointer);=0A=
=0A=
        var stillOnObj =3D false;=0A=
        if (this.popup.popupTargetType =3D=3D=3D 'node') {=0A=
          if (this.body.nodes[this.popup.popupTargetId] !=3D=3D =
undefined) {=0A=
            stillOnObj =3D =
this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);=0A=
=0A=
            // if the mouse is still one the node, we have to check if =
it is not also on one that is drawn on top of it.=0A=
            // we initially only check stillOnObj because this is much =
faster.=0A=
            if (stillOnObj =3D=3D=3D true) {=0A=
              var overNode =3D this.selectionHandler.getNodeAt(pointer);=0A=
              stillOnObj =3D overNode.id =3D=3D=3D =
this.popup.popupTargetId;=0A=
            }=0A=
          }=0A=
        } else {=0A=
          if (this.selectionHandler.getNodeAt(pointer) =3D=3D=3D =
undefined) {=0A=
            if (this.body.edges[this.popup.popupTargetId] !=3D=3D =
undefined) {=0A=
              stillOnObj =3D =
this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        if (stillOnObj =3D=3D=3D false) {=0A=
          this.popupObj =3D undefined;=0A=
          this.popup.hide();=0A=
          this.body.emitter.emit('hidePopup');=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return InteractionHandler;=0A=
  })();=0A=
=0A=
  exports['default'] =3D InteractionHandler;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 105 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var hammerUtil =3D __webpack_require__(27);=0A=
  var keycharm =3D __webpack_require__(41);=0A=
=0A=
  var NavigationHandler =3D (function () {=0A=
    function NavigationHandler(body, canvas) {=0A=
      var _this =3D this;=0A=
=0A=
      _classCallCheck(this, NavigationHandler);=0A=
=0A=
      this.body =3D body;=0A=
      this.canvas =3D canvas;=0A=
=0A=
      this.iconsCreated =3D false;=0A=
      this.navigationHammers =3D [];=0A=
      this.boundFunctions =3D {};=0A=
      this.touchTime =3D 0;=0A=
      this.activated =3D false;=0A=
=0A=
      this.body.emitter.on('activate', function () {=0A=
        _this.activated =3D true;_this.configureKeyboardBindings();=0A=
      });=0A=
      this.body.emitter.on('deactivate', function () {=0A=
        _this.activated =3D false;_this.configureKeyboardBindings();=0A=
      });=0A=
      this.body.emitter.on('destroy', function () {=0A=
        if (_this.keycharm !=3D=3D undefined) {=0A=
          _this.keycharm.destroy();=0A=
        }=0A=
      });=0A=
=0A=
      this.options =3D {};=0A=
    }=0A=
=0A=
    _createClass(NavigationHandler, [{=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          this.options =3D options;=0A=
          this.create();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'create',=0A=
      value: function create() {=0A=
        if (this.options.navigationButtons =3D=3D=3D true) {=0A=
          if (this.iconsCreated =3D=3D=3D false) {=0A=
            this.loadNavigationElements();=0A=
          }=0A=
        } else if (this.iconsCreated =3D=3D=3D true) {=0A=
          this.cleanNavigation();=0A=
        }=0A=
=0A=
        this.configureKeyboardBindings();=0A=
      }=0A=
    }, {=0A=
      key: 'cleanNavigation',=0A=
      value: function cleanNavigation() {=0A=
        // clean hammer bindings=0A=
        if (this.navigationHammers.length !=3D 0) {=0A=
          for (var i =3D 0; i < this.navigationHammers.length; i++) {=0A=
            this.navigationHammers[i].destroy();=0A=
          }=0A=
          this.navigationHammers =3D [];=0A=
        }=0A=
=0A=
        // clean up previous navigation items=0A=
        if (this.navigationDOM && this.navigationDOM['wrapper'] && =
this.navigationDOM['wrapper'].parentNode) {=0A=
          =
this.navigationDOM['wrapper'].parentNode.removeChild(this.navigationDOM['=
wrapper']);=0A=
        }=0A=
=0A=
        this.iconsCreated =3D false;=0A=
      }=0A=
    }, {=0A=
      key: 'loadNavigationElements',=0A=
=0A=
      /**=0A=
       * Creation of the navigation controls nodes. They are drawn over =
the rest of the nodes and are not affected by scale and translation=0A=
       * they have a triggerFunction which is called on click. If the =
position of the navigation controls is dependent=0A=
       * on this.frame.canvas.clientWidth or =
this.frame.canvas.clientHeight, we flag horizontalAlignLeft and =
verticalAlignTop false.=0A=
       * This means that the location will be corrected by the =
_relocateNavigation function on a size change of the canvas.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function loadNavigationElements() {=0A=
        var _this2 =3D this;=0A=
=0A=
        this.cleanNavigation();=0A=
=0A=
        this.navigationDOM =3D {};=0A=
        var navigationDivs =3D ['up', 'down', 'left', 'right', 'zoomIn', =
'zoomOut', 'zoomExtends'];=0A=
        var navigationDivActions =3D ['_moveUp', '_moveDown', =
'_moveLeft', '_moveRight', '_zoomIn', '_zoomOut', '_fit'];=0A=
=0A=
        this.navigationDOM['wrapper'] =3D document.createElement('div');=0A=
        this.navigationDOM['wrapper'].className =3D 'vis-navigation';=0A=
        this.canvas.frame.appendChild(this.navigationDOM['wrapper']);=0A=
=0A=
        for (var i =3D 0; i < navigationDivs.length; i++) {=0A=
          this.navigationDOM[navigationDivs[i]] =3D =
document.createElement('div');=0A=
          this.navigationDOM[navigationDivs[i]].className =3D =
'vis-button vis-' + navigationDivs[i];=0A=
          =
this.navigationDOM['wrapper'].appendChild(this.navigationDOM[navigationDi=
vs[i]]);=0A=
=0A=
          var hammer =3D new =
Hammer(this.navigationDOM[navigationDivs[i]]);=0A=
          if (navigationDivActions[i] =3D=3D=3D '_fit') {=0A=
            hammerUtil.onTouch(hammer, this._fit.bind(this));=0A=
          } else {=0A=
            hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, =
navigationDivActions[i]));=0A=
          }=0A=
=0A=
          this.navigationHammers.push(hammer);=0A=
        }=0A=
=0A=
        // use a hammer for the release so we do not require the one =
used in the rest of the network=0A=
        // the one the rest uses can be overloaded by the manipulation =
system.=0A=
        var hammerFrame =3D new Hammer(this.canvas.frame);=0A=
        hammerUtil.onRelease(hammerFrame, function () {=0A=
          _this2._stopMovement();=0A=
        });=0A=
        this.navigationHammers.push(hammerFrame);=0A=
=0A=
        this.iconsCreated =3D true;=0A=
      }=0A=
    }, {=0A=
      key: 'bindToRedraw',=0A=
      value: function bindToRedraw(action) {=0A=
        if (this.boundFunctions[action] =3D=3D=3D undefined) {=0A=
          this.boundFunctions[action] =3D this[action].bind(this);=0A=
          this.body.emitter.on('initRedraw', =
this.boundFunctions[action]);=0A=
          this.body.emitter.emit('_startRendering');=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'unbindFromRedraw',=0A=
      value: function unbindFromRedraw(action) {=0A=
        if (this.boundFunctions[action] !=3D=3D undefined) {=0A=
          this.body.emitter.off('initRedraw', =
this.boundFunctions[action]);=0A=
          this.body.emitter.emit('_stopRendering');=0A=
          delete this.boundFunctions[action];=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_fit',=0A=
=0A=
      /**=0A=
       * this stops all movement induced by the navigation buttons=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _fit() {=0A=
        if (new Date().valueOf() - this.touchTime > 700) {=0A=
          // TODO: fix ugly hack to avoid hammer's double fireing of =
event (because we use release?)=0A=
          this.body.emitter.emit('fit', { duration: 700 });=0A=
          this.touchTime =3D new Date().valueOf();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_stopMovement',=0A=
=0A=
      /**=0A=
       * this stops all movement induced by the navigation buttons=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _stopMovement() {=0A=
        for (var boundAction in this.boundFunctions) {=0A=
          if (this.boundFunctions.hasOwnProperty(boundAction)) {=0A=
            this.body.emitter.off('initRedraw', =
this.boundFunctions[boundAction]);=0A=
            this.body.emitter.emit('_stopRendering');=0A=
          }=0A=
        }=0A=
        this.boundFunctions =3D {};=0A=
      }=0A=
    }, {=0A=
      key: '_moveUp',=0A=
      value: function _moveUp() {=0A=
        this.body.view.translation.y +=3D this.options.keyboard.speed.y;=0A=
      }=0A=
    }, {=0A=
      key: '_moveDown',=0A=
      value: function _moveDown() {=0A=
        this.body.view.translation.y -=3D this.options.keyboard.speed.y;=0A=
      }=0A=
    }, {=0A=
      key: '_moveLeft',=0A=
      value: function _moveLeft() {=0A=
        this.body.view.translation.x +=3D this.options.keyboard.speed.x;=0A=
      }=0A=
    }, {=0A=
      key: '_moveRight',=0A=
      value: function _moveRight() {=0A=
        this.body.view.translation.x -=3D this.options.keyboard.speed.x;=0A=
      }=0A=
    }, {=0A=
      key: '_zoomIn',=0A=
      value: function _zoomIn() {=0A=
        this.body.view.scale *=3D 1 + this.options.keyboard.speed.zoom;=0A=
        this.body.emitter.emit('zoom', { direction: '+', scale: =
this.body.view.scale });=0A=
      }=0A=
    }, {=0A=
      key: '_zoomOut',=0A=
      value: function _zoomOut() {=0A=
        this.body.view.scale /=3D 1 + this.options.keyboard.speed.zoom;=0A=
        this.body.emitter.emit('zoom', { direction: '-', scale: =
this.body.view.scale });=0A=
      }=0A=
    }, {=0A=
      key: 'configureKeyboardBindings',=0A=
=0A=
      /**=0A=
       * bind all keys using keycharm.=0A=
       */=0A=
      value: function configureKeyboardBindings() {=0A=
        var _this3 =3D this;=0A=
=0A=
        if (this.keycharm !=3D=3D undefined) {=0A=
          this.keycharm.destroy();=0A=
        }=0A=
=0A=
        if (this.options.keyboard.enabled =3D=3D=3D true) {=0A=
          if (this.options.keyboard.bindToWindow =3D=3D=3D true) {=0A=
            this.keycharm =3D keycharm({ container: window, =
preventDefault: true });=0A=
          } else {=0A=
            this.keycharm =3D keycharm({ container: this.canvas.frame, =
preventDefault: true });=0A=
          }=0A=
=0A=
          this.keycharm.reset();=0A=
=0A=
          if (this.activated =3D=3D=3D true) {=0A=
            this.keycharm.bind('up', function () {=0A=
              _this3.bindToRedraw('_moveUp');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('down', function () {=0A=
              _this3.bindToRedraw('_moveDown');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('left', function () {=0A=
              _this3.bindToRedraw('_moveLeft');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('right', function () {=0A=
              _this3.bindToRedraw('_moveRight');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('=3D', function () {=0A=
              _this3.bindToRedraw('_zoomIn');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('num+', function () {=0A=
              _this3.bindToRedraw('_zoomIn');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('num-', function () {=0A=
              _this3.bindToRedraw('_zoomOut');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('-', function () {=0A=
              _this3.bindToRedraw('_zoomOut');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('[', function () {=0A=
              _this3.bindToRedraw('_zoomOut');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind(']', function () {=0A=
              _this3.bindToRedraw('_zoomIn');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('pageup', function () {=0A=
              _this3.bindToRedraw('_zoomIn');=0A=
            }, 'keydown');=0A=
            this.keycharm.bind('pagedown', function () {=0A=
              _this3.bindToRedraw('_zoomOut');=0A=
            }, 'keydown');=0A=
=0A=
            this.keycharm.bind('up', function () {=0A=
              _this3.unbindFromRedraw('_moveUp');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('down', function () {=0A=
              _this3.unbindFromRedraw('_moveDown');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('left', function () {=0A=
              _this3.unbindFromRedraw('_moveLeft');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('right', function () {=0A=
              _this3.unbindFromRedraw('_moveRight');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('=3D', function () {=0A=
              _this3.unbindFromRedraw('_zoomIn');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('num+', function () {=0A=
              _this3.unbindFromRedraw('_zoomIn');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('num-', function () {=0A=
              _this3.unbindFromRedraw('_zoomOut');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('-', function () {=0A=
              _this3.unbindFromRedraw('_zoomOut');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('[', function () {=0A=
              _this3.unbindFromRedraw('_zoomOut');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind(']', function () {=0A=
              _this3.unbindFromRedraw('_zoomIn');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('pageup', function () {=0A=
              _this3.unbindFromRedraw('_zoomIn');=0A=
            }, 'keyup');=0A=
            this.keycharm.bind('pagedown', function () {=0A=
              _this3.unbindFromRedraw('_zoomOut');=0A=
            }, 'keyup');=0A=
          }=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return NavigationHandler;=0A=
  })();=0A=
=0A=
  exports['default'] =3D NavigationHandler;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 106 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * Popup is a class to create a popup window with some text=0A=
   * @param {Element}  container     The container object.=0A=
   * @param {Number} [x]=0A=
   * @param {Number} [y]=0A=
   * @param {String} [text]=0A=
   * @param {Object} [style]     An object containing borderColor,=0A=
   *                             backgroundColor, etc.=0A=
   */=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var Popup =3D (function () {=0A=
    function Popup(container) {=0A=
      _classCallCheck(this, Popup);=0A=
=0A=
      this.container =3D container;=0A=
=0A=
      this.x =3D 0;=0A=
      this.y =3D 0;=0A=
      this.padding =3D 5;=0A=
      this.hidden =3D false;=0A=
=0A=
      // create the frame=0A=
      this.frame =3D document.createElement('div');=0A=
      this.frame.className =3D 'vis-network-tooltip';=0A=
      this.container.appendChild(this.frame);=0A=
    }=0A=
=0A=
    _createClass(Popup, [{=0A=
      key: 'setPosition',=0A=
=0A=
      /**=0A=
       * @param {number} x   Horizontal position of the popup window=0A=
       * @param {number} y   Vertical position of the popup window=0A=
       */=0A=
      value: function setPosition(x, y) {=0A=
        this.x =3D parseInt(x);=0A=
        this.y =3D parseInt(y);=0A=
      }=0A=
    }, {=0A=
      key: 'setText',=0A=
=0A=
      /**=0A=
       * Set the content for the popup window. This can be HTML code or =
text.=0A=
       * @param {string | Element} content=0A=
       */=0A=
      value: function setText(content) {=0A=
        if (content instanceof Element) {=0A=
          this.frame.innerHTML =3D '';=0A=
          this.frame.appendChild(content);=0A=
        } else {=0A=
          this.frame.innerHTML =3D content; // string containing text or =
HTML=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'show',=0A=
=0A=
      /**=0A=
       * Show the popup window=0A=
       * @param {boolean} [doShow]    Show or hide the window=0A=
       */=0A=
      value: function show(doShow) {=0A=
        if (doShow =3D=3D=3D undefined) {=0A=
          doShow =3D true;=0A=
        }=0A=
=0A=
        if (doShow =3D=3D=3D true) {=0A=
          var height =3D this.frame.clientHeight;=0A=
          var width =3D this.frame.clientWidth;=0A=
          var maxHeight =3D this.frame.parentNode.clientHeight;=0A=
          var maxWidth =3D this.frame.parentNode.clientWidth;=0A=
=0A=
          var top =3D this.y - height;=0A=
          if (top + height + this.padding > maxHeight) {=0A=
            top =3D maxHeight - height - this.padding;=0A=
          }=0A=
          if (top < this.padding) {=0A=
            top =3D this.padding;=0A=
          }=0A=
=0A=
          var left =3D this.x;=0A=
          if (left + width + this.padding > maxWidth) {=0A=
            left =3D maxWidth - width - this.padding;=0A=
          }=0A=
          if (left < this.padding) {=0A=
            left =3D this.padding;=0A=
          }=0A=
=0A=
          this.frame.style.left =3D left + 'px';=0A=
          this.frame.style.top =3D top + 'px';=0A=
          this.frame.style.visibility =3D 'visible';=0A=
          this.hidden =3D false;=0A=
        } else {=0A=
          this.hide();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'hide',=0A=
=0A=
      /**=0A=
       * Hide the popup window=0A=
       */=0A=
      value: function hide() {=0A=
        this.hidden =3D true;=0A=
        this.frame.style.visibility =3D 'hidden';=0A=
      }=0A=
    }]);=0A=
=0A=
    return Popup;=0A=
  })();=0A=
=0A=
  exports['default'] =3D Popup;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 107 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var Node =3D __webpack_require__(62);=0A=
  var Edge =3D __webpack_require__(82);=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var SelectionHandler =3D (function () {=0A=
    function SelectionHandler(body, canvas) {=0A=
      var _this =3D this;=0A=
=0A=
      _classCallCheck(this, SelectionHandler);=0A=
=0A=
      this.body =3D body;=0A=
      this.canvas =3D canvas;=0A=
      this.selectionObj =3D { nodes: [], edges: [] };=0A=
      this.hoverObj =3D { nodes: {}, edges: {} };=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        multiselect: false,=0A=
        selectable: true,=0A=
        selectConnectedEdges: true,=0A=
        hoverConnectedEdges: true=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.body.emitter.on("_dataChanged", function () {=0A=
        _this.updateSelection();=0A=
      });=0A=
    }=0A=
=0A=
    _createClass(SelectionHandler, [{=0A=
      key: "setOptions",=0A=
      value: function setOptions(options) {=0A=
        if (options !=3D=3D undefined) {=0A=
          var fields =3D ["multiselect", "hoverConnectedEdges", =
"selectable", "selectConnectedEdges"];=0A=
          util.selectiveDeepExtend(fields, this.options, options);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "selectOnPoint",=0A=
=0A=
      /**=0A=
       * handles the selection part of the tap;=0A=
       *=0A=
       * @param {Object} pointer=0A=
       * @private=0A=
       */=0A=
      value: function selectOnPoint(pointer) {=0A=
        var selected =3D false;=0A=
        if (this.options.selectable =3D=3D=3D true) {=0A=
          var obj =3D this.getNodeAt(pointer) || this.getEdgeAt(pointer);=0A=
=0A=
          // unselect after getting the objects in order to restore =
width and height.=0A=
          this.unselectAll();=0A=
=0A=
          if (obj !=3D=3D undefined) {=0A=
            selected =3D this.selectObject(obj);=0A=
          }=0A=
          this.body.emitter.emit("_requestRedraw");=0A=
        }=0A=
        return selected;=0A=
      }=0A=
    }, {=0A=
      key: "selectAdditionalOnPoint",=0A=
      value: function selectAdditionalOnPoint(pointer) {=0A=
        var selectionChanged =3D false;=0A=
        if (this.options.selectable =3D=3D=3D true) {=0A=
          var obj =3D this.getNodeAt(pointer) || this.getEdgeAt(pointer);=0A=
=0A=
          if (obj !=3D=3D undefined) {=0A=
            selectionChanged =3D true;=0A=
            if (obj.isSelected() =3D=3D=3D true) {=0A=
              this.deselectObject(obj);=0A=
            } else {=0A=
              this.selectObject(obj);=0A=
            }=0A=
=0A=
            this.body.emitter.emit("_requestRedraw");=0A=
          }=0A=
        }=0A=
        return selectionChanged;=0A=
      }=0A=
    }, {=0A=
      key: "_generateClickEvent",=0A=
      value: function _generateClickEvent(eventType, event, pointer, =
oldSelection) {=0A=
        var emptySelection =3D arguments.length <=3D 4 || arguments[4] =
=3D=3D=3D undefined ? false : arguments[4];=0A=
=0A=
        var properties =3D undefined;=0A=
        if (emptySelection =3D=3D=3D true) {=0A=
          properties =3D { nodes: [], edges: [] };=0A=
        } else {=0A=
          properties =3D this.getSelection();=0A=
        }=0A=
        properties["pointer"] =3D {=0A=
          DOM: { x: pointer.x, y: pointer.y },=0A=
          canvas: this.canvas.DOMtoCanvas(pointer)=0A=
        };=0A=
        properties["event"] =3D event;=0A=
=0A=
        if (oldSelection !=3D=3D undefined) {=0A=
          properties["previousSelection"] =3D oldSelection;=0A=
        }=0A=
        this.body.emitter.emit(eventType, properties);=0A=
      }=0A=
    }, {=0A=
      key: "selectObject",=0A=
      value: function selectObject(obj) {=0A=
        var highlightEdges =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? this.options.selectConnectedEdges : arguments[1];=0A=
=0A=
        if (obj !=3D=3D undefined) {=0A=
          if (obj instanceof Node) {=0A=
            if (highlightEdges =3D=3D=3D true) {=0A=
              this._selectConnectedEdges(obj);=0A=
            }=0A=
          }=0A=
          obj.select();=0A=
          this._addToSelection(obj);=0A=
          return true;=0A=
        }=0A=
        return false;=0A=
      }=0A=
    }, {=0A=
      key: "deselectObject",=0A=
      value: function deselectObject(obj) {=0A=
        if (obj.isSelected() =3D=3D=3D true) {=0A=
          obj.selected =3D false;=0A=
          this._removeFromSelection(obj);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_getAllNodesOverlappingWith",=0A=
=0A=
      /**=0A=
       * retrieve all nodes overlapping with given object=0A=
       * @param {Object} object  An object with parameters left, top, =
right, bottom=0A=
       * @return {Number[]}   An array with id's of the overlapping nodes=0A=
       * @private=0A=
       */=0A=
      value: function _getAllNodesOverlappingWith(object) {=0A=
        var overlappingNodes =3D [];=0A=
        var nodes =3D this.body.nodes;=0A=
        for (var i =3D 0; i < this.body.nodeIndices.length; i++) {=0A=
          var nodeId =3D this.body.nodeIndices[i];=0A=
          if (nodes[nodeId].isOverlappingWith(object)) {=0A=
            overlappingNodes.push(nodeId);=0A=
          }=0A=
        }=0A=
        return overlappingNodes;=0A=
      }=0A=
    }, {=0A=
      key: "_pointerToPositionObject",=0A=
=0A=
      /**=0A=
       * Return a position object in canvasspace from a single point in =
screenspace=0A=
       *=0A=
       * @param pointer=0A=
       * @returns {{left: number, top: number, right: number, bottom: =
number}}=0A=
       * @private=0A=
       */=0A=
      value: function _pointerToPositionObject(pointer) {=0A=
        var canvasPos =3D this.canvas.DOMtoCanvas(pointer);=0A=
        return {=0A=
          left: canvasPos.x - 1,=0A=
          top: canvasPos.y + 1,=0A=
          right: canvasPos.x + 1,=0A=
          bottom: canvasPos.y - 1=0A=
        };=0A=
      }=0A=
    }, {=0A=
      key: "getNodeAt",=0A=
=0A=
      /**=0A=
       * Get the top node at the a specific point (like a click)=0A=
       *=0A=
       * @param {{x: Number, y: Number}} pointer=0A=
       * @return {Node | undefined} node=0A=
       * @private=0A=
       */=0A=
      value: function getNodeAt(pointer) {=0A=
        var returnNode =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? true : arguments[1];=0A=
=0A=
        // we first check if this is an navigation controls element=0A=
        var positionObject =3D this._pointerToPositionObject(pointer);=0A=
        var overlappingNodes =3D =
this._getAllNodesOverlappingWith(positionObject);=0A=
        // if there are overlapping nodes, select the last one, this is =
the=0A=
        // one which is drawn on top of the others=0A=
        if (overlappingNodes.length > 0) {=0A=
          if (returnNode =3D=3D=3D true) {=0A=
            return =
this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];=0A=
          } else {=0A=
            return overlappingNodes[overlappingNodes.length - 1];=0A=
          }=0A=
        } else {=0A=
          return undefined;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_getEdgesOverlappingWith",=0A=
=0A=
      /**=0A=
       * retrieve all edges overlapping with given object, selector is =
around center=0A=
       * @param {Object} object  An object with parameters left, top, =
right, bottom=0A=
       * @return {Number[]}   An array with id's of the overlapping nodes=0A=
       * @private=0A=
       */=0A=
      value: function _getEdgesOverlappingWith(object, overlappingEdges) =
{=0A=
        var edges =3D this.body.edges;=0A=
        for (var i =3D 0; i < this.body.edgeIndices.length; i++) {=0A=
          var edgeId =3D this.body.edgeIndices[i];=0A=
          if (edges[edgeId].isOverlappingWith(object)) {=0A=
            overlappingEdges.push(edgeId);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_getAllEdgesOverlappingWith",=0A=
=0A=
      /**=0A=
       * retrieve all nodes overlapping with given object=0A=
       * @param {Object} object  An object with parameters left, top, =
right, bottom=0A=
       * @return {Number[]}   An array with id's of the overlapping nodes=0A=
       * @private=0A=
       */=0A=
      value: function _getAllEdgesOverlappingWith(object) {=0A=
        var overlappingEdges =3D [];=0A=
        this._getEdgesOverlappingWith(object, overlappingEdges);=0A=
        return overlappingEdges;=0A=
      }=0A=
    }, {=0A=
      key: "getEdgeAt",=0A=
=0A=
      /**=0A=
       * Place holder. To implement change the getNodeAt to a =
_getObjectAt. Have the _getObjectAt call=0A=
       * getNodeAt and _getEdgesAt, then priortize the selection to user =
preferences.=0A=
       *=0A=
       * @param pointer=0A=
       * @returns {undefined}=0A=
       * @private=0A=
       */=0A=
      value: function getEdgeAt(pointer) {=0A=
        var returnEdge =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? true : arguments[1];=0A=
=0A=
        var positionObject =3D this._pointerToPositionObject(pointer);=0A=
        var overlappingEdges =3D =
this._getAllEdgesOverlappingWith(positionObject);=0A=
=0A=
        if (overlappingEdges.length > 0) {=0A=
          if (returnEdge =3D=3D=3D true) {=0A=
            return =
this.body.edges[overlappingEdges[overlappingEdges.length - 1]];=0A=
          } else {=0A=
            return overlappingEdges[overlappingEdges.length - 1];=0A=
          }=0A=
        } else {=0A=
          return undefined;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_addToSelection",=0A=
=0A=
      /**=0A=
       * Add object to the selection array.=0A=
       *=0A=
       * @param obj=0A=
       * @private=0A=
       */=0A=
      value: function _addToSelection(obj) {=0A=
        if (obj instanceof Node) {=0A=
          this.selectionObj.nodes[obj.id] =3D obj;=0A=
        } else {=0A=
          this.selectionObj.edges[obj.id] =3D obj;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_addToHover",=0A=
=0A=
      /**=0A=
       * Add object to the selection array.=0A=
       *=0A=
       * @param obj=0A=
       * @private=0A=
       */=0A=
      value: function _addToHover(obj) {=0A=
        if (obj instanceof Node) {=0A=
          this.hoverObj.nodes[obj.id] =3D obj;=0A=
        } else {=0A=
          this.hoverObj.edges[obj.id] =3D obj;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_removeFromSelection",=0A=
=0A=
      /**=0A=
       * Remove a single option from selection.=0A=
       *=0A=
       * @param {Object} obj=0A=
       * @private=0A=
       */=0A=
      value: function _removeFromSelection(obj) {=0A=
        if (obj instanceof Node) {=0A=
          delete this.selectionObj.nodes[obj.id];=0A=
        } else {=0A=
          delete this.selectionObj.edges[obj.id];=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "unselectAll",=0A=
=0A=
      /**=0A=
       * Unselect all. The selectionObj is useful for this.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function unselectAll() {=0A=
        for (var nodeId in this.selectionObj.nodes) {=0A=
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
            this.selectionObj.nodes[nodeId].unselect();=0A=
          }=0A=
        }=0A=
        for (var edgeId in this.selectionObj.edges) {=0A=
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {=0A=
            this.selectionObj.edges[edgeId].unselect();=0A=
          }=0A=
        }=0A=
=0A=
        this.selectionObj =3D { nodes: {}, edges: {} };=0A=
      }=0A=
    }, {=0A=
      key: "_getSelectedNodeCount",=0A=
=0A=
      /**=0A=
       * return the number of selected nodes=0A=
       *=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _getSelectedNodeCount() {=0A=
        var count =3D 0;=0A=
        for (var nodeId in this.selectionObj.nodes) {=0A=
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
            count +=3D 1;=0A=
          }=0A=
        }=0A=
        return count;=0A=
      }=0A=
    }, {=0A=
      key: "_getSelectedNode",=0A=
=0A=
      /**=0A=
       * return the selected node=0A=
       *=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _getSelectedNode() {=0A=
        for (var nodeId in this.selectionObj.nodes) {=0A=
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
            return this.selectionObj.nodes[nodeId];=0A=
          }=0A=
        }=0A=
        return undefined;=0A=
      }=0A=
    }, {=0A=
      key: "_getSelectedEdge",=0A=
=0A=
      /**=0A=
       * return the selected edge=0A=
       *=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _getSelectedEdge() {=0A=
        for (var edgeId in this.selectionObj.edges) {=0A=
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {=0A=
            return this.selectionObj.edges[edgeId];=0A=
          }=0A=
        }=0A=
        return undefined;=0A=
      }=0A=
    }, {=0A=
      key: "_getSelectedEdgeCount",=0A=
=0A=
      /**=0A=
       * return the number of selected edges=0A=
       *=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _getSelectedEdgeCount() {=0A=
        var count =3D 0;=0A=
        for (var edgeId in this.selectionObj.edges) {=0A=
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {=0A=
            count +=3D 1;=0A=
          }=0A=
        }=0A=
        return count;=0A=
      }=0A=
    }, {=0A=
      key: "_getSelectedObjectCount",=0A=
=0A=
      /**=0A=
       * return the number of selected objects.=0A=
       *=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _getSelectedObjectCount() {=0A=
        var count =3D 0;=0A=
        for (var nodeId in this.selectionObj.nodes) {=0A=
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
            count +=3D 1;=0A=
          }=0A=
        }=0A=
        for (var edgeId in this.selectionObj.edges) {=0A=
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {=0A=
            count +=3D 1;=0A=
          }=0A=
        }=0A=
        return count;=0A=
      }=0A=
    }, {=0A=
      key: "_selectionIsEmpty",=0A=
=0A=
      /**=0A=
       * Check if anything is selected=0A=
       *=0A=
       * @returns {boolean}=0A=
       * @private=0A=
       */=0A=
      value: function _selectionIsEmpty() {=0A=
        for (var nodeId in this.selectionObj.nodes) {=0A=
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
            return false;=0A=
          }=0A=
        }=0A=
        for (var edgeId in this.selectionObj.edges) {=0A=
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {=0A=
            return false;=0A=
          }=0A=
        }=0A=
        return true;=0A=
      }=0A=
    }, {=0A=
      key: "_clusterInSelection",=0A=
=0A=
      /**=0A=
       * check if one of the selected nodes is a cluster.=0A=
       *=0A=
       * @returns {boolean}=0A=
       * @private=0A=
       */=0A=
      value: function _clusterInSelection() {=0A=
        for (var nodeId in this.selectionObj.nodes) {=0A=
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
            if (this.selectionObj.nodes[nodeId].clusterSize > 1) {=0A=
              return true;=0A=
            }=0A=
          }=0A=
        }=0A=
        return false;=0A=
      }=0A=
    }, {=0A=
      key: "_selectConnectedEdges",=0A=
=0A=
      /**=0A=
       * select the edges connected to the node that is being selected=0A=
       *=0A=
       * @param {Node} node=0A=
       * @private=0A=
       */=0A=
      value: function _selectConnectedEdges(node) {=0A=
        for (var i =3D 0; i < node.edges.length; i++) {=0A=
          var edge =3D node.edges[i];=0A=
          edge.select();=0A=
          this._addToSelection(edge);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_hoverConnectedEdges",=0A=
=0A=
      /**=0A=
       * select the edges connected to the node that is being selected=0A=
       *=0A=
       * @param {Node} node=0A=
       * @private=0A=
       */=0A=
      value: function _hoverConnectedEdges(node) {=0A=
        for (var i =3D 0; i < node.edges.length; i++) {=0A=
          var edge =3D node.edges[i];=0A=
          edge.hover =3D true;=0A=
          this._addToHover(edge);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "_unselectConnectedEdges",=0A=
=0A=
      /**=0A=
       * unselect the edges connected to the node that is being selected=0A=
       *=0A=
       * @param {Node} node=0A=
       * @private=0A=
       */=0A=
      value: function _unselectConnectedEdges(node) {=0A=
        for (var i =3D 0; i < node.edges.length; i++) {=0A=
          var edge =3D node.edges[i];=0A=
          edge.unselect();=0A=
          this._removeFromSelection(edge);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "blurObject",=0A=
=0A=
      /**=0A=
       * This is called when someone clicks on a node. either select or =
deselect it.=0A=
       * If there is an existing selection and we don't want to append =
to it, clear the existing selection=0A=
       *=0A=
       * @param {Node || Edge} object=0A=
       * @private=0A=
       */=0A=
      value: function blurObject(object) {=0A=
        if (object.hover =3D=3D=3D true) {=0A=
          object.hover =3D false;=0A=
          if (object instanceof Node) {=0A=
            this.body.emitter.emit("blurNode", { node: object.id });=0A=
          } else {=0A=
            this.body.emitter.emit("blurEdge", { edge: object.id });=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "hoverObject",=0A=
=0A=
      /**=0A=
       * This is called when someone clicks on a node. either select or =
deselect it.=0A=
       * If there is an existing selection and we don't want to append =
to it, clear the existing selection=0A=
       *=0A=
       * @param {Node || Edge} object=0A=
       * @private=0A=
       */=0A=
      value: function hoverObject(object) {=0A=
        var hoverChanged =3D false;=0A=
        // remove all node hover highlights=0A=
        for (var nodeId in this.hoverObj.nodes) {=0A=
          if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {=0A=
            if (object =3D=3D=3D undefined || object instanceof Node && =
object.id !=3D nodeId || object instanceof Edge) {=0A=
              this.blurObject(this.hoverObj.nodes[nodeId]);=0A=
              delete this.hoverObj.nodes[nodeId];=0A=
              hoverChanged =3D true;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // removing all edge hover highlights=0A=
        for (var edgeId in this.hoverObj.edges) {=0A=
          if (this.hoverObj.edges.hasOwnProperty(edgeId)) {=0A=
            // if the hover has been changed here it means that the node =
has been hovered over or off=0A=
            // we then do not use the blurObject method here.=0A=
            if (hoverChanged =3D=3D=3D true) {=0A=
              this.hoverObj.edges[edgeId].hover =3D false;=0A=
              delete this.hoverObj.edges[edgeId];=0A=
            }=0A=
            // if the blur remains the same and the object is undefined =
(mouse off), we blur the edge=0A=
            else if (object =3D=3D=3D undefined) {=0A=
              this.blurObject(this.hoverObj.edges[edgeId]);=0A=
              delete this.hoverObj.edges[edgeId];=0A=
              hoverChanged =3D true;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        if (object !=3D=3D undefined) {=0A=
          if (object.hover =3D=3D=3D false) {=0A=
            object.hover =3D true;=0A=
            this._addToHover(object);=0A=
            hoverChanged =3D true;=0A=
            if (object instanceof Node) {=0A=
              this.body.emitter.emit("hoverNode", { node: object.id });=0A=
            } else {=0A=
              this.body.emitter.emit("hoverEdge", { edge: object.id });=0A=
            }=0A=
          }=0A=
          if (object instanceof Node && this.options.hoverConnectedEdges =
=3D=3D=3D true) {=0A=
            this._hoverConnectedEdges(object);=0A=
          }=0A=
        }=0A=
=0A=
        if (hoverChanged =3D=3D=3D true) {=0A=
          this.body.emitter.emit("_requestRedraw");=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: "getSelection",=0A=
=0A=
      /**=0A=
       *=0A=
       * retrieve the currently selected objects=0A=
       * @return {{nodes: Array.<String>, edges: Array.<String>}} =
selection=0A=
       */=0A=
      value: function getSelection() {=0A=
        var nodeIds =3D this.getSelectedNodes();=0A=
        var edgeIds =3D this.getSelectedEdges();=0A=
        return { nodes: nodeIds, edges: edgeIds };=0A=
      }=0A=
    }, {=0A=
      key: "getSelectedNodes",=0A=
=0A=
      /**=0A=
       *=0A=
       * retrieve the currently selected nodes=0A=
       * @return {String[]} selection    An array with the ids of the=0A=
       *                                            selected nodes.=0A=
       */=0A=
      value: function getSelectedNodes() {=0A=
        var idArray =3D [];=0A=
        if (this.options.selectable =3D=3D=3D true) {=0A=
          for (var nodeId in this.selectionObj.nodes) {=0A=
            if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
              idArray.push(nodeId);=0A=
            }=0A=
          }=0A=
        }=0A=
        return idArray;=0A=
      }=0A=
    }, {=0A=
      key: "getSelectedEdges",=0A=
=0A=
      /**=0A=
       *=0A=
       * retrieve the currently selected edges=0A=
       * @return {Array} selection    An array with the ids of the=0A=
       *                                            selected nodes.=0A=
       */=0A=
      value: function getSelectedEdges() {=0A=
        var idArray =3D [];=0A=
        if (this.options.selectable =3D=3D=3D true) {=0A=
          for (var edgeId in this.selectionObj.edges) {=0A=
            if (this.selectionObj.edges.hasOwnProperty(edgeId)) {=0A=
              idArray.push(edgeId);=0A=
            }=0A=
          }=0A=
        }=0A=
        return idArray;=0A=
      }=0A=
    }, {=0A=
      key: "selectNodes",=0A=
=0A=
      /**=0A=
       * select zero or more nodes with the option to highlight edges=0A=
       * @param {Number[] | String[]} selection     An array with the =
ids of the=0A=
       *                                            selected nodes.=0A=
       * @param {boolean} [highlightEdges]=0A=
       */=0A=
      value: function selectNodes(selection) {=0A=
        var highlightEdges =3D arguments.length <=3D 1 || arguments[1] =
=3D=3D=3D undefined ? true : arguments[1];=0A=
=0A=
        var i =3D undefined,=0A=
            id =3D undefined;=0A=
=0A=
        if (!selection || selection.length =3D=3D=3D undefined) throw =
"Selection must be an array with ids";=0A=
=0A=
        // first unselect any selected node=0A=
        this.unselectAll();=0A=
=0A=
        for (i =3D 0; i < selection.length; i++) {=0A=
          id =3D selection[i];=0A=
=0A=
          var node =3D this.body.nodes[id];=0A=
          if (!node) {=0A=
            throw new RangeError("Node with id \"" + id + "\" not =
found");=0A=
          }=0A=
          this.selectObject(node, highlightEdges);=0A=
        }=0A=
        this.body.emitter.emit("_requestRedraw");=0A=
      }=0A=
    }, {=0A=
      key: "selectEdges",=0A=
=0A=
      /**=0A=
       * select zero or more edges=0A=
       * @param {Number[] | String[]} selection     An array with the =
ids of the=0A=
       *                                            selected nodes.=0A=
       */=0A=
      value: function selectEdges(selection) {=0A=
        var i =3D undefined,=0A=
            id =3D undefined;=0A=
=0A=
        if (!selection || selection.length =3D=3D=3D undefined) throw =
"Selection must be an array with ids";=0A=
=0A=
        // first unselect any selected objects=0A=
        this.unselectAll();=0A=
=0A=
        for (i =3D 0; i < selection.length; i++) {=0A=
          id =3D selection[i];=0A=
=0A=
          var edge =3D this.body.edges[id];=0A=
          if (!edge) {=0A=
            throw new RangeError("Edge with id \"" + id + "\" not =
found");=0A=
          }=0A=
          this.selectObject(edge);=0A=
        }=0A=
        this.body.emitter.emit("_requestRedraw");=0A=
      }=0A=
    }, {=0A=
      key: "updateSelection",=0A=
=0A=
      /**=0A=
       * Validate the selection: remove ids of nodes which no longer =
exist=0A=
       * @private=0A=
       */=0A=
      value: function updateSelection() {=0A=
        for (var nodeId in this.selectionObj.nodes) {=0A=
          if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {=0A=
            if (!this.body.nodes.hasOwnProperty(nodeId)) {=0A=
              delete this.selectionObj.nodes[nodeId];=0A=
            }=0A=
          }=0A=
        }=0A=
        for (var edgeId in this.selectionObj.edges) {=0A=
          if (this.selectionObj.edges.hasOwnProperty(edgeId)) {=0A=
            if (!this.body.edges.hasOwnProperty(edgeId)) {=0A=
              delete this.selectionObj.edges[edgeId];=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return SelectionHandler;=0A=
  })();=0A=
=0A=
  exports["default"] =3D SelectionHandler;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 108 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
=0A=
  var LayoutEngine =3D (function () {=0A=
    function LayoutEngine(body) {=0A=
      _classCallCheck(this, LayoutEngine);=0A=
=0A=
      this.body =3D body;=0A=
=0A=
      this.initialRandomSeed =3D Math.round(Math.random() * 1000000);=0A=
      this.randomSeed =3D this.initialRandomSeed;=0A=
      this.options =3D {};=0A=
      this.optionsBackup =3D {};=0A=
=0A=
      this.defaultOptions =3D {=0A=
        randomSeed: undefined,=0A=
        hierarchical: {=0A=
          enabled: false,=0A=
          levelSeparation: 150,=0A=
          direction: 'UD', // UD, DU, LR, RL=0A=
          sortMethod: 'hubsize' // hubsize, directed=0A=
        }=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.hierarchicalLevels =3D {};=0A=
=0A=
      this.bindEventListeners();=0A=
    }=0A=
=0A=
    _createClass(LayoutEngine, [{=0A=
      key: 'bindEventListeners',=0A=
      value: function bindEventListeners() {=0A=
        var _this =3D this;=0A=
=0A=
        this.body.emitter.on('_dataChanged', function () {=0A=
          _this.setupHierarchicalLayout();=0A=
        });=0A=
        this.body.emitter.on('_resetHierarchicalLayout', function () {=0A=
          _this.setupHierarchicalLayout();=0A=
        });=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
      value: function setOptions(options, allOptions) {=0A=
        if (options !=3D=3D undefined) {=0A=
          var prevHierarchicalState =3D =
this.options.hierarchical.enabled;=0A=
=0A=
          util.mergeOptions(this.options, options, 'hierarchical');=0A=
          if (options.randomSeed !=3D=3D undefined) {=0A=
            this.initialRandomSeed =3D options.randomSeed;=0A=
          }=0A=
=0A=
          if (this.options.hierarchical.enabled =3D=3D=3D true) {=0A=
            if (prevHierarchicalState =3D=3D=3D true) {=0A=
              // refresh the overridden options for nodes and edges.=0A=
              this.body.emitter.emit('refresh', true);=0A=
            }=0A=
=0A=
            // make sure the level seperation is the right way up=0A=
            if (this.options.hierarchical.direction =3D=3D=3D 'RL' || =
this.options.hierarchical.direction =3D=3D=3D 'DU') {=0A=
              if (this.options.hierarchical.levelSeparation > 0) {=0A=
                this.options.hierarchical.levelSeparation *=3D -1;=0A=
              }=0A=
            } else {=0A=
              if (this.options.hierarchical.levelSeparation < 0) {=0A=
                this.options.hierarchical.levelSeparation *=3D -1;=0A=
              }=0A=
            }=0A=
=0A=
            this.body.emitter.emit('_resetHierarchicalLayout');=0A=
            // because the hierarchical system needs it's own physics =
and smooth curve settings, we adapt the other options if needed.=0A=
            return this.adaptAllOptions(allOptions);=0A=
          } else {=0A=
            if (prevHierarchicalState =3D=3D=3D true) {=0A=
              // refresh the overridden options for nodes and edges.=0A=
              this.body.emitter.emit('refresh');=0A=
              return util.deepExtend(allOptions, this.optionsBackup);=0A=
            }=0A=
          }=0A=
        }=0A=
        return allOptions;=0A=
      }=0A=
    }, {=0A=
      key: 'adaptAllOptions',=0A=
      value: function adaptAllOptions(allOptions) {=0A=
        if (this.options.hierarchical.enabled =3D=3D=3D true) {=0A=
          // set the physics=0A=
          if (allOptions.physics =3D=3D=3D undefined || =
allOptions.physics =3D=3D=3D true) {=0A=
            allOptions.physics =3D { solver: 'hierarchicalRepulsion' };=0A=
            this.optionsBackup.physics =3D { solver: 'barnesHut' };=0A=
          } else if (typeof allOptions.physics =3D=3D=3D 'object') {=0A=
            this.optionsBackup.physics =3D { solver: 'barnesHut' };=0A=
            if (allOptions.physics.solver !=3D=3D undefined) {=0A=
              this.optionsBackup.physics =3D { solver: =
allOptions.physics.solver };=0A=
            }=0A=
            allOptions.physics['solver'] =3D 'hierarchicalRepulsion';=0A=
          } else if (allOptions.physics !=3D=3D false) {=0A=
            this.optionsBackup.physics =3D { solver: 'barnesHut' };=0A=
            allOptions.physics['solver'] =3D 'hierarchicalRepulsion';=0A=
          }=0A=
=0A=
          // get the type of static smooth curve in case it is required=0A=
          var type =3D 'horizontal';=0A=
          if (this.options.hierarchical.direction =3D=3D=3D 'RL' || =
this.options.hierarchical.direction =3D=3D=3D 'LR') {=0A=
            type =3D 'vertical';=0A=
          }=0A=
=0A=
          // disable smooth curves if nothing is defined. If smooth =
curves have been turned on, turn them into static smooth curves.=0A=
          if (allOptions.edges =3D=3D=3D undefined) {=0A=
            this.optionsBackup.edges =3D { smooth: { enabled: true, =
type: 'dynamic' } };=0A=
            allOptions.edges =3D { smooth: false };=0A=
          } else if (allOptions.edges.smooth =3D=3D=3D undefined) {=0A=
            this.optionsBackup.edges =3D { smooth: { enabled: true, =
type: 'dynamic' } };=0A=
            allOptions.edges.smooth =3D false;=0A=
          } else {=0A=
            if (typeof allOptions.edges.smooth =3D=3D=3D 'boolean') {=0A=
              this.optionsBackup.edges =3D { smooth: =
allOptions.edges.smooth };=0A=
              allOptions.edges.smooth =3D { enabled: =
allOptions.edges.smooth, type: type };=0A=
            } else {=0A=
              // allow custom types except for dynamic=0A=
              if (allOptions.edges.smooth.type !=3D=3D undefined && =
allOptions.edges.smooth.type !=3D=3D 'dynamic') {=0A=
                type =3D allOptions.edges.smooth.type;=0A=
              }=0A=
=0A=
              this.optionsBackup.edges =3D {=0A=
                smooth: allOptions.edges.smooth.enabled =3D=3D=3D =
undefined ? true : allOptions.edges.smooth.enabled,=0A=
                type: allOptions.edges.smooth.type =3D=3D=3D undefined ? =
'dynamic' : allOptions.edges.smooth.type,=0A=
                roundness: allOptions.edges.smooth.roundness =3D=3D=3D =
undefined ? 0.5 : allOptions.edges.smooth.roundness,=0A=
                forceDirection: allOptions.edges.smooth.forceDirection =
=3D=3D=3D undefined ? false : allOptions.edges.smooth.forceDirection=0A=
              };=0A=
              allOptions.edges.smooth =3D {=0A=
                enabled: allOptions.edges.smooth.enabled =3D=3D=3D =
undefined ? true : allOptions.edges.smooth.enabled,=0A=
                type: type,=0A=
                roundness: allOptions.edges.smooth.roundness =3D=3D=3D =
undefined ? 0.5 : allOptions.edges.smooth.roundness,=0A=
                forceDirection: allOptions.edges.smooth.forceDirection =
=3D=3D=3D undefined ? false : allOptions.edges.smooth.forceDirection=0A=
              };=0A=
            }=0A=
          }=0A=
=0A=
          // force all edges into static smooth curves. Only applies to =
edges that do not use the global options for smooth.=0A=
          this.body.emitter.emit('_forceDisableDynamicCurves', type);=0A=
        }=0A=
        return allOptions;=0A=
      }=0A=
    }, {=0A=
      key: 'seededRandom',=0A=
      value: function seededRandom() {=0A=
        var x =3D Math.sin(this.randomSeed++) * 10000;=0A=
        return x - Math.floor(x);=0A=
      }=0A=
    }, {=0A=
      key: 'positionInitially',=0A=
      value: function positionInitially(nodesArray) {=0A=
        if (this.options.hierarchical.enabled !=3D=3D true) {=0A=
          this.randomSeed =3D this.initialRandomSeed;=0A=
          for (var i =3D 0; i < nodesArray.length; i++) {=0A=
            var node =3D nodesArray[i];=0A=
            var radius =3D 10 * 0.1 * nodesArray.length + 10;=0A=
            var angle =3D 2 * Math.PI * this.seededRandom();=0A=
            if (node.x =3D=3D=3D undefined) {=0A=
              node.x =3D radius * Math.cos(angle);=0A=
            }=0A=
            if (node.y =3D=3D=3D undefined) {=0A=
              node.y =3D radius * Math.sin(angle);=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'getSeed',=0A=
      value: function getSeed() {=0A=
        return this.initialRandomSeed;=0A=
      }=0A=
    }, {=0A=
      key: 'setupHierarchicalLayout',=0A=
=0A=
      /**=0A=
       * This is the main function to layout the nodes in a hierarchical =
way.=0A=
       * It checks if the node details are supplied correctly=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function setupHierarchicalLayout() {=0A=
        if (this.options.hierarchical.enabled =3D=3D=3D true && =
this.body.nodeIndices.length > 0) {=0A=
          // get the size of the largest hubs and check if the user has =
defined a level for a node.=0A=
          var node =3D undefined,=0A=
              nodeId =3D undefined;=0A=
          var definedLevel =3D false;=0A=
          var undefinedLevel =3D false;=0A=
          this.hierarchicalLevels =3D {};=0A=
          this.nodeSpacing =3D 100;=0A=
=0A=
          for (nodeId in this.body.nodes) {=0A=
            if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
              node =3D this.body.nodes[nodeId];=0A=
              if (node.options.level !=3D=3D undefined) {=0A=
                definedLevel =3D true;=0A=
                this.hierarchicalLevels[nodeId] =3D node.options.level;=0A=
              } else {=0A=
                undefinedLevel =3D true;=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          // if the user defined some levels but not all, alert and run =
without hierarchical layout=0A=
          if (undefinedLevel =3D=3D=3D true && definedLevel =3D=3D=3D =
true) {=0A=
            throw new Error('To use the hierarchical layout, nodes =
require either no predefined levels or levels have to be defined for all =
nodes.');=0A=
            return;=0A=
          } else {=0A=
            // setup the system to use hierarchical method.=0A=
            //this._changeConstants();=0A=
=0A=
            // define levels if undefined by the users. Based on hubsize=0A=
            if (undefinedLevel =3D=3D=3D true) {=0A=
              if (this.options.hierarchical.sortMethod =3D=3D=3D =
'hubsize') {=0A=
                this._determineLevelsByHubsize();=0A=
              } else if (this.options.hierarchical.sortMethod =3D=3D=3D =
'directed' || 'direction') {=0A=
                this._determineLevelsDirected();=0A=
              }=0A=
            }=0A=
=0A=
            // check the distribution of the nodes per level.=0A=
            var distribution =3D this._getDistribution();=0A=
=0A=
            // place the nodes on the canvas.=0A=
            this._placeNodesByHierarchy(distribution);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_placeNodesByHierarchy',=0A=
=0A=
      /**=0A=
       * This function places the nodes on the canvas based on the =
hierarchial distribution.=0A=
       *=0A=
       * @param {Object} distribution | obtained by the function =
this._getDistribution()=0A=
       * @private=0A=
       */=0A=
      value: function _placeNodesByHierarchy(distribution) {=0A=
        var nodeId =3D undefined,=0A=
            node =3D undefined;=0A=
        this.positionedNodes =3D {};=0A=
        // start placing all the level 0 nodes first. Then recursively =
position their branches.=0A=
        for (var level in distribution) {=0A=
          if (distribution.hasOwnProperty(level)) {=0A=
            for (nodeId in distribution[level].nodes) {=0A=
              if (distribution[level].nodes.hasOwnProperty(nodeId)) {=0A=
=0A=
                node =3D distribution[level].nodes[nodeId];=0A=
=0A=
                if (this.options.hierarchical.direction =3D=3D=3D 'UD' =
|| this.options.hierarchical.direction =3D=3D=3D 'DU') {=0A=
                  if (node.x =3D=3D=3D undefined) {=0A=
                    node.x =3D distribution[level].distance;=0A=
                  }=0A=
                  distribution[level].distance =3D node.x + =
this.nodeSpacing;=0A=
                } else {=0A=
                  if (node.y =3D=3D=3D undefined) {=0A=
                    node.y =3D distribution[level].distance;=0A=
                  }=0A=
                  distribution[level].distance =3D node.y + =
this.nodeSpacing;=0A=
                }=0A=
=0A=
                this.positionedNodes[nodeId] =3D true;=0A=
                this._placeBranchNodes(node.edges, node.id, =
distribution, level);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_getDistribution',=0A=
=0A=
      /**=0A=
       * This function get the distribution of levels based on hubsize=0A=
       *=0A=
       * @returns {Object}=0A=
       * @private=0A=
       */=0A=
      value: function _getDistribution() {=0A=
        var distribution =3D {};=0A=
        var nodeId =3D undefined,=0A=
            node =3D undefined;=0A=
=0A=
        // we fix Y because the hierarchy is vertical, we fix X so we do =
not give a node an x position for a second time.=0A=
        // the fix of X is removed after the x value has been set.=0A=
        for (nodeId in this.body.nodes) {=0A=
          if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
            node =3D this.body.nodes[nodeId];=0A=
            var level =3D this.hierarchicalLevels[nodeId] =3D=3D=3D =
undefined ? 0 : this.hierarchicalLevels[nodeId];=0A=
            if (this.options.hierarchical.direction =3D=3D=3D 'UD' || =
this.options.hierarchical.direction =3D=3D=3D 'DU') {=0A=
              node.y =3D this.options.hierarchical.levelSeparation * =
level;=0A=
              node.options.fixed.y =3D true;=0A=
            } else {=0A=
              node.x =3D this.options.hierarchical.levelSeparation * =
level;=0A=
              node.options.fixed.x =3D true;=0A=
            }=0A=
            if (distribution[level] =3D=3D=3D undefined) {=0A=
              distribution[level] =3D { amount: 0, nodes: {}, distance: =
0 };=0A=
            }=0A=
            distribution[level].amount +=3D 1;=0A=
            distribution[level].nodes[nodeId] =3D node;=0A=
          }=0A=
        }=0A=
        return distribution;=0A=
      }=0A=
    }, {=0A=
      key: '_getHubSize',=0A=
=0A=
      /**=0A=
       * Get the hubsize from all remaining unlevelled nodes.=0A=
       *=0A=
       * @returns {number}=0A=
       * @private=0A=
       */=0A=
      value: function _getHubSize() {=0A=
        var hubSize =3D 0;=0A=
        for (var nodeId in this.body.nodes) {=0A=
          if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
            var node =3D this.body.nodes[nodeId];=0A=
            if (this.hierarchicalLevels[nodeId] =3D=3D=3D undefined) {=0A=
              hubSize =3D node.edges.length < hubSize ? hubSize : =
node.edges.length;=0A=
            }=0A=
          }=0A=
        }=0A=
        return hubSize;=0A=
      }=0A=
    }, {=0A=
      key: '_determineLevelsByHubsize',=0A=
=0A=
      /**=0A=
       * this function allocates nodes in levels based on the recursive =
branching from the largest hubs.=0A=
       *=0A=
       * @param hubsize=0A=
       * @private=0A=
       */=0A=
      value: function _determineLevelsByHubsize() {=0A=
        var nodeId =3D undefined,=0A=
            node =3D undefined;=0A=
        var hubSize =3D 1;=0A=
=0A=
        while (hubSize > 0) {=0A=
          // determine hubs=0A=
          hubSize =3D this._getHubSize();=0A=
          if (hubSize =3D=3D=3D 0) break;=0A=
=0A=
          for (nodeId in this.body.nodes) {=0A=
            if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
              node =3D this.body.nodes[nodeId];=0A=
              if (node.edges.length =3D=3D=3D hubSize) {=0A=
                this._setLevelByHubsize(0, node);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_setLevelByHubsize',=0A=
=0A=
      /**=0A=
       * this function is called recursively to enumerate the barnches =
of the largest hubs and give each node a level.=0A=
       *=0A=
       * @param level=0A=
       * @param edges=0A=
       * @param parentId=0A=
       * @private=0A=
       */=0A=
      value: function _setLevelByHubsize(level, node) {=0A=
        if (this.hierarchicalLevels[node.id] !=3D=3D undefined) return;=0A=
=0A=
        var childNode =3D undefined;=0A=
        this.hierarchicalLevels[node.id] =3D level;=0A=
        for (var i =3D 0; i < node.edges.length; i++) {=0A=
          if (node.edges[i].toId =3D=3D=3D node.id) {=0A=
            childNode =3D node.edges[i].from;=0A=
          } else {=0A=
            childNode =3D node.edges[i].to;=0A=
          }=0A=
          this._setLevelByHubsize(level + 1, childNode);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_determineLevelsDirected',=0A=
=0A=
      /**=0A=
       * this function allocates nodes in levels based on the direction =
of the edges=0A=
       *=0A=
       * @param hubsize=0A=
       * @private=0A=
       */=0A=
      value: function _determineLevelsDirected() {=0A=
        var nodeId =3D undefined,=0A=
            node =3D undefined;=0A=
        var minLevel =3D 10000;=0A=
=0A=
        // set first node to source=0A=
        for (nodeId in this.body.nodes) {=0A=
          if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
            node =3D this.body.nodes[nodeId];=0A=
            this._setLevelDirected(minLevel, node);=0A=
          }=0A=
        }=0A=
=0A=
        // get the minimum level=0A=
        for (nodeId in this.body.nodes) {=0A=
          if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
            minLevel =3D this.hierarchicalLevels[nodeId] < minLevel ? =
this.hierarchicalLevels[nodeId] : minLevel;=0A=
          }=0A=
        }=0A=
=0A=
        // subtract the minimum from the set so we have a range starting =
from 0=0A=
        for (nodeId in this.body.nodes) {=0A=
          if (this.body.nodes.hasOwnProperty(nodeId)) {=0A=
            this.hierarchicalLevels[nodeId] -=3D minLevel;=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_setLevelDirected',=0A=
=0A=
      /**=0A=
       * this function is called recursively to enumerate the branched =
of the first node and give each node a level based on edge direction=0A=
       *=0A=
       * @param level=0A=
       * @param edges=0A=
       * @param parentId=0A=
       * @private=0A=
       */=0A=
      value: function _setLevelDirected(level, node) {=0A=
        if (this.hierarchicalLevels[node.id] !=3D=3D undefined) return;=0A=
=0A=
        var childNode =3D undefined;=0A=
        this.hierarchicalLevels[node.id] =3D level;=0A=
=0A=
        for (var i =3D 0; i < node.edges.length; i++) {=0A=
          if (node.edges[i].toId =3D=3D=3D node.id) {=0A=
            childNode =3D node.edges[i].from;=0A=
            this._setLevelDirected(level - 1, childNode);=0A=
          } else {=0A=
            childNode =3D node.edges[i].to;=0A=
            this._setLevelDirected(level + 1, childNode);=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_placeBranchNodes',=0A=
=0A=
      /**=0A=
       * This is a recursively called function to enumerate the branches =
from the largest hubs and place the nodes=0A=
       * on a X position that ensures there will be no overlap.=0A=
       *=0A=
       * @param edges=0A=
       * @param parentId=0A=
       * @param distribution=0A=
       * @param parentLevel=0A=
       * @private=0A=
       */=0A=
      value: function _placeBranchNodes(edges, parentId, distribution, =
parentLevel) {=0A=
        for (var i =3D 0; i < edges.length; i++) {=0A=
          var childNode =3D undefined;=0A=
          var parentNode =3D undefined;=0A=
          if (edges[i].toId =3D=3D=3D parentId) {=0A=
            childNode =3D edges[i].from;=0A=
            parentNode =3D edges[i].to;=0A=
          } else {=0A=
            childNode =3D edges[i].to;=0A=
            parentNode =3D edges[i].from;=0A=
          }=0A=
          var childNodeLevel =3D this.hierarchicalLevels[childNode.id];=0A=
=0A=
          if (this.positionedNodes[childNode.id] =3D=3D=3D undefined) {=0A=
            // if a node is conneceted to another node on the same level =
(or higher (means lower level))!, this is not handled here.=0A=
            if (childNodeLevel > parentLevel) {=0A=
              if (this.options.hierarchical.direction =3D=3D=3D 'UD' || =
this.options.hierarchical.direction =3D=3D=3D 'DU') {=0A=
                if (childNode.x =3D=3D=3D undefined) {=0A=
                  childNode.x =3D =
Math.max(distribution[childNodeLevel].distance, parentNode.x);=0A=
                }=0A=
                distribution[childNodeLevel].distance =3D childNode.x + =
this.nodeSpacing;=0A=
                this.positionedNodes[childNode.id] =3D true;=0A=
              } else {=0A=
                if (childNode.y =3D=3D=3D undefined) {=0A=
                  childNode.y =3D =
Math.max(distribution[childNodeLevel].distance, parentNode.y);=0A=
                }=0A=
                distribution[childNodeLevel].distance =3D childNode.y + =
this.nodeSpacing;=0A=
              }=0A=
              this.positionedNodes[childNode.id] =3D true;=0A=
=0A=
              if (childNode.edges.length > 1) {=0A=
                this._placeBranchNodes(childNode.edges, childNode.id, =
distribution, childNodeLevel);=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return LayoutEngine;=0A=
  })();=0A=
=0A=
  exports['default'] =3D LayoutEngine;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 109 */=0A=
/***/ function(module, exports, __webpack_require__) {=0A=
=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ('value' in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError('Cannot call a class as a =
function'); } }=0A=
=0A=
  var util =3D __webpack_require__(7);=0A=
  var Hammer =3D __webpack_require__(3);=0A=
  var hammerUtil =3D __webpack_require__(27);=0A=
=0A=
  /**=0A=
   * clears the toolbar div element of children=0A=
   *=0A=
   * @private=0A=
   */=0A=
=0A=
  var ManipulationSystem =3D (function () {=0A=
    function ManipulationSystem(body, canvas, selectionHandler) {=0A=
      var _this =3D this;=0A=
=0A=
      _classCallCheck(this, ManipulationSystem);=0A=
=0A=
      this.body =3D body;=0A=
      this.canvas =3D canvas;=0A=
      this.selectionHandler =3D selectionHandler;=0A=
=0A=
      this.editMode =3D false;=0A=
      this.manipulationDiv =3D undefined;=0A=
      this.editModeDiv =3D undefined;=0A=
      this.closeDiv =3D undefined;=0A=
=0A=
      this.manipulationHammers =3D [];=0A=
      this.temporaryUIFunctions =3D {};=0A=
      this.temporaryEventFunctions =3D [];=0A=
=0A=
      this.touchTime =3D 0;=0A=
      this.temporaryIds =3D { nodes: [], edges: [] };=0A=
      this.guiEnabled =3D false;=0A=
      this.inMode =3D false;=0A=
      this.selectedControlNode =3D undefined;=0A=
=0A=
      this.options =3D {};=0A=
      this.defaultOptions =3D {=0A=
        enabled: false,=0A=
        initiallyActive: false,=0A=
        addNode: true,=0A=
        addEdge: true,=0A=
        editNode: undefined,=0A=
        editEdge: true,=0A=
        deleteNode: true,=0A=
        deleteEdge: true,=0A=
        controlNodeStyle: {=0A=
          shape: 'dot',=0A=
          size: 6,=0A=
          color: { background: '#ff0000', border: '#3c3c3c', highlight: =
{ background: '#07f968', border: '#3c3c3c' } },=0A=
          borderWidth: 2,=0A=
          borderWidthSelected: 2=0A=
        }=0A=
      };=0A=
      util.extend(this.options, this.defaultOptions);=0A=
=0A=
      this.body.emitter.on('destroy', function () {=0A=
        _this._clean();=0A=
      });=0A=
      this.body.emitter.on('_dataChanged', this._restore.bind(this));=0A=
      this.body.emitter.on('_resetData', this._restore.bind(this));=0A=
    }=0A=
=0A=
    _createClass(ManipulationSystem, [{=0A=
      key: '_restore',=0A=
=0A=
      /**=0A=
       * If something changes in the data during editing, switch back to =
the initial datamanipulation state and close all edit modes.=0A=
       * @private=0A=
       */=0A=
      value: function _restore() {=0A=
        if (this.inMode !=3D=3D false) {=0A=
          if (this.options.initiallyActive =3D=3D=3D true) {=0A=
            this.enableEditMode();=0A=
          } else {=0A=
            this.disableEditMode();=0A=
          }=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'setOptions',=0A=
=0A=
      /**=0A=
       * Set the Options=0A=
       * @param options=0A=
       */=0A=
      value: function setOptions(options, allOptions, globalOptions) {=0A=
        if (allOptions !=3D=3D undefined) {=0A=
          if (allOptions.locale !=3D=3D undefined) {=0A=
            this.options.locale =3D allOptions.locale;=0A=
          } else {=0A=
            this.options.locale =3D globalOptions.locale;=0A=
          }=0A=
          if (allOptions.locales !=3D=3D undefined) {=0A=
            this.options.locales =3D allOptions.locales;=0A=
          } else {=0A=
            this.options.locales =3D globalOptions.locales;=0A=
          }=0A=
        }=0A=
=0A=
        if (options !=3D=3D undefined) {=0A=
          if (typeof options =3D=3D=3D 'boolean') {=0A=
            this.options.enabled =3D options;=0A=
          } else {=0A=
            this.options.enabled =3D true;=0A=
            util.deepExtend(this.options, options);=0A=
          }=0A=
          if (this.options.initiallyActive =3D=3D=3D true) {=0A=
            this.editMode =3D true;=0A=
          }=0A=
          this._setup();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'toggleEditMode',=0A=
=0A=
      /**=0A=
       * Enable or disable edit-mode. Draws the DOM required and cleans =
up after itself.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function toggleEditMode() {=0A=
        if (this.editMode =3D=3D=3D true) {=0A=
          this.disableEditMode();=0A=
        } else {=0A=
          this.enableEditMode();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'enableEditMode',=0A=
      value: function enableEditMode() {=0A=
        this.editMode =3D true;=0A=
=0A=
        this._clean();=0A=
        if (this.guiEnabled =3D=3D=3D true) {=0A=
          this.manipulationDiv.style.display =3D 'block';=0A=
          this.closeDiv.style.display =3D 'block';=0A=
          this.editModeDiv.style.display =3D 'none';=0A=
          this.showManipulatorToolbar();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'disableEditMode',=0A=
      value: function disableEditMode() {=0A=
        this.editMode =3D false;=0A=
=0A=
        this._clean();=0A=
        if (this.guiEnabled =3D=3D=3D true) {=0A=
          this.manipulationDiv.style.display =3D 'none';=0A=
          this.closeDiv.style.display =3D 'none';=0A=
          this.editModeDiv.style.display =3D 'block';=0A=
          this._createEditButton();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'showManipulatorToolbar',=0A=
=0A=
      /**=0A=
       * Creates the main toolbar. Removes functions bound to the select =
event. Binds all the buttons of the toolbar.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function showManipulatorToolbar() {=0A=
        // restore the state of any bound functions or events, remove =
control nodes, restore physics=0A=
        this._clean();=0A=
=0A=
        // reset global letiables=0A=
        this.manipulationDOM =3D {};=0A=
=0A=
        // if the gui is enabled, draw all elements.=0A=
        if (this.guiEnabled =3D=3D=3D true) {=0A=
          // a _restore will hide these menus=0A=
          this.editMode =3D true;=0A=
          this.manipulationDiv.style.display =3D 'block';=0A=
          this.closeDiv.style.display =3D 'block';=0A=
=0A=
          var selectedNodeCount =3D =
this.selectionHandler._getSelectedNodeCount();=0A=
          var selectedEdgeCount =3D =
this.selectionHandler._getSelectedEdgeCount();=0A=
          var selectedTotalCount =3D selectedNodeCount + =
selectedEdgeCount;=0A=
          var locale =3D this.options.locales[this.options.locale];=0A=
          var needSeperator =3D false;=0A=
=0A=
          if (this.options.addNode !=3D=3D false) {=0A=
            this._createAddNodeButton(locale);=0A=
            needSeperator =3D true;=0A=
          }=0A=
          if (this.options.addEdge !=3D=3D false) {=0A=
            if (needSeperator =3D=3D=3D true) {=0A=
              this._createSeperator(1);=0A=
            } else {=0A=
              needSeperator =3D true;=0A=
            }=0A=
            this._createAddEdgeButton(locale);=0A=
          }=0A=
=0A=
          if (selectedNodeCount =3D=3D=3D 1 && typeof =
this.options.editNode =3D=3D=3D 'function') {=0A=
            if (needSeperator =3D=3D=3D true) {=0A=
              this._createSeperator(2);=0A=
            } else {=0A=
              needSeperator =3D true;=0A=
            }=0A=
            this._createEditNodeButton(locale);=0A=
          } else if (selectedEdgeCount =3D=3D=3D 1 && selectedNodeCount =
=3D=3D=3D 0 && this.options.editEdge !=3D=3D false) {=0A=
            if (needSeperator =3D=3D=3D true) {=0A=
              this._createSeperator(3);=0A=
            } else {=0A=
              needSeperator =3D true;=0A=
            }=0A=
            this._createEditEdgeButton(locale);=0A=
          }=0A=
=0A=
          // remove buttons=0A=
          if (selectedTotalCount !=3D=3D 0) {=0A=
            if (selectedNodeCount > 0 && this.options.deleteNode !=3D=3D =
false) {=0A=
              if (needSeperator =3D=3D=3D true) {=0A=
                this._createSeperator(4);=0A=
              }=0A=
              this._createDeleteButton(locale);=0A=
            } else if (selectedNodeCount =3D=3D=3D 0 && =
this.options.deleteEdge !=3D=3D false) {=0A=
              if (needSeperator =3D=3D=3D true) {=0A=
                this._createSeperator(4);=0A=
              }=0A=
              this._createDeleteButton(locale);=0A=
            }=0A=
          }=0A=
=0A=
          // bind the close button=0A=
          this._bindHammerToDiv(this.closeDiv, =
this.toggleEditMode.bind(this));=0A=
=0A=
          // refresh this bar based on what has been selected=0A=
          this._temporaryBindEvent('select', =
this.showManipulatorToolbar.bind(this));=0A=
        }=0A=
=0A=
        // redraw to show any possible changes=0A=
        this.body.emitter.emit('_redraw');=0A=
      }=0A=
    }, {=0A=
      key: 'addNodeMode',=0A=
=0A=
      /**=0A=
       * Create the toolbar for adding Nodes=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function addNodeMode() {=0A=
        // when using the gui, enable edit mode if it wasnt already.=0A=
        if (this.editMode !=3D=3D true) {=0A=
          this.enableEditMode();=0A=
        }=0A=
=0A=
        // restore the state of any bound functions or events, remove =
control nodes, restore physics=0A=
        this._clean();=0A=
=0A=
        this.inMode =3D 'addNode';=0A=
        if (this.guiEnabled =3D=3D=3D true) {=0A=
          var locale =3D this.options.locales[this.options.locale];=0A=
          this.manipulationDOM =3D {};=0A=
          this._createBackButton(locale);=0A=
          this._createSeperator();=0A=
          this._createDescription(locale['addDescription'] || =
this.options.locales['en']['addDescription']);=0A=
=0A=
          // bind the close button=0A=
          this._bindHammerToDiv(this.closeDiv, =
this.toggleEditMode.bind(this));=0A=
        }=0A=
=0A=
        this._temporaryBindEvent('click', =
this._performAddNode.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: 'editNode',=0A=
=0A=
      /**=0A=
       * call the bound function to handle the editing of the node. The =
node has to be selected.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function editNode() {=0A=
        var _this2 =3D this;=0A=
=0A=
        // when using the gui, enable edit mode if it wasnt already.=0A=
        if (this.editMode !=3D=3D true) {=0A=
          this.enableEditMode();=0A=
        }=0A=
=0A=
        // restore the state of any bound functions or events, remove =
control nodes, restore physics=0A=
        this._clean();=0A=
        var node =3D this.selectionHandler._getSelectedNode();=0A=
        if (node !=3D=3D undefined) {=0A=
          this.inMode =3D 'editNode';=0A=
          if (typeof this.options.editNode =3D=3D=3D 'function') {=0A=
            if (node.isCluster !=3D=3D true) {=0A=
              var data =3D util.deepExtend({}, node.options, true);=0A=
              data.x =3D node.x;=0A=
              data.y =3D node.y;=0A=
=0A=
              if (this.options.editNode.length =3D=3D=3D 2) {=0A=
                this.options.editNode(data, function (finalizedData) {=0A=
                  if (finalizedData !=3D=3D null && finalizedData =
!=3D=3D undefined && _this2.inMode =3D=3D=3D 'editNode') {=0A=
                    // if for whatever reason the mode has changes (due =
to dataset change) disregard the callback) {=0A=
                    =
_this2.body.data.nodes.getDataSet().update(finalizedData);=0A=
                  }=0A=
                  _this2.showManipulatorToolbar();=0A=
                });=0A=
              } else {=0A=
                throw new Error('The function for edit does not support =
two arguments (data, callback)');=0A=
              }=0A=
            } else {=0A=
              =
alert(this.options.locales[this.options.locale]['editClusterError'] || =
this.options.locales['en']['editClusterError']);=0A=
            }=0A=
          } else {=0A=
            throw new Error('No function has been configured to handle =
the editing of nodes.');=0A=
          }=0A=
        } else {=0A=
          this.showManipulatorToolbar();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'addEdgeMode',=0A=
=0A=
      /**=0A=
       * create the toolbar to connect nodes=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function addEdgeMode() {=0A=
        // when using the gui, enable edit mode if it wasnt already.=0A=
        if (this.editMode !=3D=3D true) {=0A=
          this.enableEditMode();=0A=
        }=0A=
=0A=
        // restore the state of any bound functions or events, remove =
control nodes, restore physics=0A=
        this._clean();=0A=
=0A=
        this.inMode =3D 'addEdge';=0A=
        if (this.guiEnabled =3D=3D=3D true) {=0A=
          var locale =3D this.options.locales[this.options.locale];=0A=
          this.manipulationDOM =3D {};=0A=
          this._createBackButton(locale);=0A=
          this._createSeperator();=0A=
          this._createDescription(locale['edgeDescription'] || =
this.options.locales['en']['edgeDescription']);=0A=
=0A=
          // bind the close button=0A=
          this._bindHammerToDiv(this.closeDiv, =
this.toggleEditMode.bind(this));=0A=
        }=0A=
=0A=
        // temporarily overload functions=0A=
        this._temporaryBindUI('onTouch', this._handleConnect.bind(this));=0A=
        this._temporaryBindUI('onDragEnd', =
this._finishConnect.bind(this));=0A=
        this._temporaryBindUI('onDrag', =
this._dragControlNode.bind(this));=0A=
        this._temporaryBindUI('onRelease', =
this._finishConnect.bind(this));=0A=
=0A=
        this._temporaryBindUI('onDragStart', function () {});=0A=
        this._temporaryBindUI('onHold', function () {});=0A=
      }=0A=
    }, {=0A=
      key: 'editEdgeMode',=0A=
=0A=
      /**=0A=
       * create the toolbar to edit edges=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function editEdgeMode() {=0A=
        var _this3 =3D this;=0A=
=0A=
        // when using the gui, enable edit mode if it wasnt already.=0A=
        if (this.editMode !=3D=3D true) {=0A=
          this.enableEditMode();=0A=
        }=0A=
=0A=
        // restore the state of any bound functions or events, remove =
control nodes, restore physics=0A=
        this._clean();=0A=
=0A=
        this.inMode =3D 'editEdge';=0A=
        if (this.guiEnabled =3D=3D=3D true) {=0A=
          var locale =3D this.options.locales[this.options.locale];=0A=
          this.manipulationDOM =3D {};=0A=
          this._createBackButton(locale);=0A=
          this._createSeperator();=0A=
          this._createDescription(locale['editEdgeDescription'] || =
this.options.locales['en']['editEdgeDescription']);=0A=
=0A=
          // bind the close button=0A=
          this._bindHammerToDiv(this.closeDiv, =
this.toggleEditMode.bind(this));=0A=
        }=0A=
=0A=
        this.edgeBeingEditedId =3D =
this.selectionHandler.getSelectedEdges()[0];=0A=
        if (this.edgeBeingEditedId !=3D=3D undefined) {=0A=
          (function () {=0A=
            var edge =3D _this3.body.edges[_this3.edgeBeingEditedId];=0A=
=0A=
            // create control nodes=0A=
            var controlNodeFrom =3D =
_this3._getNewTargetNode(edge.from.x, edge.from.y);=0A=
            var controlNodeTo =3D _this3._getNewTargetNode(edge.to.x, =
edge.to.y);=0A=
=0A=
            _this3.temporaryIds.nodes.push(controlNodeFrom.id);=0A=
            _this3.temporaryIds.nodes.push(controlNodeTo.id);=0A=
=0A=
            _this3.body.nodes[controlNodeFrom.id] =3D controlNodeFrom;=0A=
            _this3.body.nodeIndices.push(controlNodeFrom.id);=0A=
            _this3.body.nodes[controlNodeTo.id] =3D controlNodeTo;=0A=
            _this3.body.nodeIndices.push(controlNodeTo.id);=0A=
=0A=
            // temporarily overload UI functions, cleaned up =
automatically because of _temporaryBindUI=0A=
            _this3._temporaryBindUI('onTouch', =
_this3._controlNodeTouch.bind(_this3)); // used to get the position=0A=
            _this3._temporaryBindUI('onTap', function () {}); // disabled=0A=
            _this3._temporaryBindUI('onHold', function () {}); // =
disabled=0A=
            _this3._temporaryBindUI('onDragStart', =
_this3._controlNodeDragStart.bind(_this3)); // used to select control =
node=0A=
            _this3._temporaryBindUI('onDrag', =
_this3._controlNodeDrag.bind(_this3)); // used to drag control node=0A=
            _this3._temporaryBindUI('onDragEnd', =
_this3._controlNodeDragEnd.bind(_this3)); // used to connect or revert =
control nodes=0A=
            _this3._temporaryBindUI('onMouseMove', function () {}); // =
disabled=0A=
=0A=
            // create function to position control nodes correctly on =
movement=0A=
            // automatically cleaned up because we use the temporary bind=0A=
            _this3._temporaryBindEvent('beforeDrawing', function (ctx) {=0A=
              var positions =3D edge.edgeType.findBorderPositions(ctx);=0A=
              if (controlNodeFrom.selected =3D=3D=3D false) {=0A=
                controlNodeFrom.x =3D positions.from.x;=0A=
                controlNodeFrom.y =3D positions.from.y;=0A=
              }=0A=
              if (controlNodeTo.selected =3D=3D=3D false) {=0A=
                controlNodeTo.x =3D positions.to.x;=0A=
                controlNodeTo.y =3D positions.to.y;=0A=
              }=0A=
            });=0A=
=0A=
            _this3.body.emitter.emit('_redraw');=0A=
          })();=0A=
        } else {=0A=
          this.showManipulatorToolbar();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: 'deleteSelected',=0A=
=0A=
      /**=0A=
       * delete everything in the selection=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function deleteSelected() {=0A=
        var _this4 =3D this;=0A=
=0A=
        // when using the gui, enable edit mode if it wasnt already.=0A=
        if (this.editMode !=3D=3D true) {=0A=
          this.enableEditMode();=0A=
        }=0A=
=0A=
        // restore the state of any bound functions or events, remove =
control nodes, restore physics=0A=
        this._clean();=0A=
=0A=
        this.inMode =3D 'delete';=0A=
        var selectedNodes =3D this.selectionHandler.getSelectedNodes();=0A=
        var selectedEdges =3D this.selectionHandler.getSelectedEdges();=0A=
        var deleteFunction =3D undefined;=0A=
        if (selectedNodes.length > 0) {=0A=
          for (var i =3D 0; i < selectedNodes.length; i++) {=0A=
            if (this.body.nodes[selectedNodes[i]].isCluster =3D=3D=3D =
true) {=0A=
              =
alert(this.options.locales[this.options.locale]['deleteClusterError'] || =
this.options.locales['en']['deleteClusterError']);=0A=
              return;=0A=
            }=0A=
          }=0A=
=0A=
          if (typeof this.options.deleteNode =3D=3D=3D 'function') {=0A=
            deleteFunction =3D this.options.deleteNode;=0A=
          }=0A=
        } else if (selectedEdges.length > 0) {=0A=
          if (typeof this.options.deleteEdge =3D=3D=3D 'function') {=0A=
            deleteFunction =3D this.options.deleteEdge;=0A=
          }=0A=
        }=0A=
=0A=
        if (typeof deleteFunction =3D=3D=3D 'function') {=0A=
          var data =3D { nodes: selectedNodes, edges: selectedEdges };=0A=
          if (deleteFunction.length =3D=3D=3D 2) {=0A=
            deleteFunction(data, function (finalizedData) {=0A=
              if (finalizedData !=3D=3D null && finalizedData !=3D=3D =
undefined && _this4.inMode =3D=3D=3D 'delete') {=0A=
                // if for whatever reason the mode has changes (due to =
dataset change) disregard the callback) {=0A=
                =
_this4.body.data.edges.getDataSet().remove(finalizedData.edges);=0A=
                =
_this4.body.data.nodes.getDataSet().remove(finalizedData.nodes);=0A=
                _this4.body.emitter.emit('startSimulation');=0A=
                _this4.showManipulatorToolbar();=0A=
              } else {=0A=
                _this4.body.emitter.emit('startSimulation');=0A=
                _this4.showManipulatorToolbar();=0A=
              }=0A=
            });=0A=
          } else {=0A=
            throw new Error('The function for delete does not support =
two arguments (data, callback)');=0A=
          }=0A=
        } else {=0A=
          this.body.data.edges.getDataSet().remove(selectedEdges);=0A=
          this.body.data.nodes.getDataSet().remove(selectedNodes);=0A=
          this.body.emitter.emit('startSimulation');=0A=
          this.showManipulatorToolbar();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_setup',=0A=
=0A=
      //********************************************** PRIVATE =
***************************************//=0A=
=0A=
      /**=0A=
       * draw or remove the DOM=0A=
       * @private=0A=
       */=0A=
      value: function _setup() {=0A=
        if (this.options.enabled =3D=3D=3D true) {=0A=
          // Enable the GUI=0A=
          this.guiEnabled =3D true;=0A=
=0A=
          this._createWrappers();=0A=
          if (this.editMode =3D=3D=3D false) {=0A=
            this._createEditButton();=0A=
          } else {=0A=
            this.showManipulatorToolbar();=0A=
          }=0A=
        } else {=0A=
          this._removeManipulationDOM();=0A=
=0A=
          // disable the gui=0A=
          this.guiEnabled =3D false;=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_createWrappers',=0A=
=0A=
      /**=0A=
       * create the div overlays that contain the DOM=0A=
       * @private=0A=
       */=0A=
      value: function _createWrappers() {=0A=
        // load the manipulator HTML elements. All styling done in css.=0A=
        if (this.manipulationDiv =3D=3D=3D undefined) {=0A=
          this.manipulationDiv =3D document.createElement('div');=0A=
          this.manipulationDiv.className =3D 'vis-manipulation';=0A=
          if (this.editMode =3D=3D=3D true) {=0A=
            this.manipulationDiv.style.display =3D 'block';=0A=
          } else {=0A=
            this.manipulationDiv.style.display =3D 'none';=0A=
          }=0A=
          this.canvas.frame.appendChild(this.manipulationDiv);=0A=
        }=0A=
=0A=
        // container for the edit button.=0A=
        if (this.editModeDiv =3D=3D=3D undefined) {=0A=
          this.editModeDiv =3D document.createElement('div');=0A=
          this.editModeDiv.className =3D 'vis-edit-mode';=0A=
          if (this.editMode =3D=3D=3D true) {=0A=
            this.editModeDiv.style.display =3D 'none';=0A=
          } else {=0A=
            this.editModeDiv.style.display =3D 'block';=0A=
          }=0A=
          this.canvas.frame.appendChild(this.editModeDiv);=0A=
        }=0A=
=0A=
        // container for the close div button=0A=
        if (this.closeDiv =3D=3D=3D undefined) {=0A=
          this.closeDiv =3D document.createElement('div');=0A=
          this.closeDiv.className =3D 'vis-close';=0A=
          this.closeDiv.style.display =3D =
this.manipulationDiv.style.display;=0A=
          this.canvas.frame.appendChild(this.closeDiv);=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_getNewTargetNode',=0A=
=0A=
      /**=0A=
       * generate a new target node. Used for creating new edges and =
editing edges=0A=
       * @param x=0A=
       * @param y=0A=
       * @returns {*}=0A=
       * @private=0A=
       */=0A=
      value: function _getNewTargetNode(x, y) {=0A=
        var controlNodeStyle =3D util.deepExtend({}, =
this.options.controlNodeStyle);=0A=
=0A=
        controlNodeStyle.id =3D 'targetNode' + util.randomUUID();=0A=
        controlNodeStyle.hidden =3D false;=0A=
        controlNodeStyle.physics =3D false;=0A=
        controlNodeStyle.x =3D x;=0A=
        controlNodeStyle.y =3D y;=0A=
=0A=
        return this.body.functions.createNode(controlNodeStyle);=0A=
      }=0A=
    }, {=0A=
      key: '_createEditButton',=0A=
=0A=
      /**=0A=
       * Create the edit button=0A=
       */=0A=
      value: function _createEditButton() {=0A=
        // restore everything to it's original state (if applicable)=0A=
        this._clean();=0A=
=0A=
        // reset the manipulationDOM=0A=
        this.manipulationDOM =3D {};=0A=
=0A=
        // empty the editModeDiv=0A=
        util.recursiveDOMDelete(this.editModeDiv);=0A=
=0A=
        // create the contents for the editMode button=0A=
        var locale =3D this.options.locales[this.options.locale];=0A=
        var button =3D this._createButton('editMode', 'vis-button =
vis-edit vis-edit-mode', locale['edit'] || =
this.options.locales['en']['edit']);=0A=
        this.editModeDiv.appendChild(button);=0A=
=0A=
        // bind a hammer listener to the button, calling the function =
toggleEditMode.=0A=
        this._bindHammerToDiv(button, this.toggleEditMode.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: '_clean',=0A=
=0A=
      /**=0A=
       * this function cleans up after everything this module does. =
Temporary elements, functions and events are removed, physics restored, =
hammers removed.=0A=
       * @private=0A=
       */=0A=
      value: function _clean() {=0A=
        // not in mode=0A=
        this.inMode =3D false;=0A=
=0A=
        // _clean the divs=0A=
        if (this.guiEnabled =3D=3D=3D true) {=0A=
          util.recursiveDOMDelete(this.editModeDiv);=0A=
          util.recursiveDOMDelete(this.manipulationDiv);=0A=
=0A=
          // removes all the bindings and overloads=0A=
          this._cleanManipulatorHammers();=0A=
        }=0A=
=0A=
        // remove temporary nodes and edges=0A=
        this._cleanupTemporaryNodesAndEdges();=0A=
=0A=
        // restore overloaded UI functions=0A=
        this._unbindTemporaryUIs();=0A=
=0A=
        // remove the temporaryEventFunctions=0A=
        this._unbindTemporaryEvents();=0A=
=0A=
        // restore the physics if required=0A=
        this.body.emitter.emit('restorePhysics');=0A=
      }=0A=
    }, {=0A=
      key: '_cleanManipulatorHammers',=0A=
=0A=
      /**=0A=
       * Each dom element has it's own hammer. They are stored in =
this.manipulationHammers. This cleans them up.=0A=
       * @private=0A=
       */=0A=
      value: function _cleanManipulatorHammers() {=0A=
        // _clean hammer bindings=0A=
        if (this.manipulationHammers.length !=3D 0) {=0A=
          for (var i =3D 0; i < this.manipulationHammers.length; i++) {=0A=
            this.manipulationHammers[i].destroy();=0A=
          }=0A=
          this.manipulationHammers =3D [];=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_removeManipulationDOM',=0A=
=0A=
      /**=0A=
       * Remove all DOM elements created by this module.=0A=
       * @private=0A=
       */=0A=
      value: function _removeManipulationDOM() {=0A=
        // removes all the bindings and overloads=0A=
        this._clean();=0A=
=0A=
        // empty the manipulation divs=0A=
        util.recursiveDOMDelete(this.manipulationDiv);=0A=
        util.recursiveDOMDelete(this.editModeDiv);=0A=
        util.recursiveDOMDelete(this.closeDiv);=0A=
=0A=
        // remove the manipulation divs=0A=
        if (this.manipulationDiv) {=0A=
          this.canvas.frame.removeChild(this.manipulationDiv);=0A=
        }=0A=
        if (this.editModeDiv) {=0A=
          this.canvas.frame.removeChild(this.editModeDiv);=0A=
        }=0A=
        if (this.closeDiv) {=0A=
          this.canvas.frame.removeChild(this.manipulationDiv);=0A=
        }=0A=
=0A=
        // set the references to undefined=0A=
        this.manipulationDiv =3D undefined;=0A=
        this.editModeDiv =3D undefined;=0A=
        this.closeDiv =3D undefined;=0A=
      }=0A=
    }, {=0A=
      key: '_createSeperator',=0A=
=0A=
      /**=0A=
       * create a seperator line. the index is to differentiate in the =
manipulation dom=0A=
       * @param index=0A=
       * @private=0A=
       */=0A=
      value: function _createSeperator() {=0A=
        var index =3D arguments.length <=3D 0 || arguments[0] =3D=3D=3D =
undefined ? 1 : arguments[0];=0A=
=0A=
        this.manipulationDOM['seperatorLineDiv' + index] =3D =
document.createElement('div');=0A=
        this.manipulationDOM['seperatorLineDiv' + index].className =3D =
'vis-separator-line';=0A=
        =
this.manipulationDiv.appendChild(this.manipulationDOM['seperatorLineDiv' =
+ index]);=0A=
      }=0A=
    }, {=0A=
      key: '_createAddNodeButton',=0A=
=0A=
      // ----------------------    DOM functions for buttons    =
--------------------------//=0A=
=0A=
      value: function _createAddNodeButton(locale) {=0A=
        var button =3D this._createButton('addNode', 'vis-button =
vis-add', locale['addNode'] || this.options.locales['en']['addNode']);=0A=
        this.manipulationDiv.appendChild(button);=0A=
        this._bindHammerToDiv(button, this.addNodeMode.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: '_createAddEdgeButton',=0A=
      value: function _createAddEdgeButton(locale) {=0A=
        var button =3D this._createButton('addEdge', 'vis-button =
vis-connect', locale['addEdge'] || =
this.options.locales['en']['addEdge']);=0A=
        this.manipulationDiv.appendChild(button);=0A=
        this._bindHammerToDiv(button, this.addEdgeMode.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: '_createEditNodeButton',=0A=
      value: function _createEditNodeButton(locale) {=0A=
        var button =3D this._createButton('editNode', 'vis-button =
vis-edit', locale['editNode'] || this.options.locales['en']['editNode']);=0A=
        this.manipulationDiv.appendChild(button);=0A=
        this._bindHammerToDiv(button, this.editNode.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: '_createEditEdgeButton',=0A=
      value: function _createEditEdgeButton(locale) {=0A=
        var button =3D this._createButton('editEdge', 'vis-button =
vis-edit', locale['editEdge'] || this.options.locales['en']['editEdge']);=0A=
        this.manipulationDiv.appendChild(button);=0A=
        this._bindHammerToDiv(button, this.editEdgeMode.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: '_createDeleteButton',=0A=
      value: function _createDeleteButton(locale) {=0A=
        var button =3D this._createButton('delete', 'vis-button =
vis-delete', locale['del'] || this.options.locales['en']['del']);=0A=
        this.manipulationDiv.appendChild(button);=0A=
        this._bindHammerToDiv(button, this.deleteSelected.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: '_createBackButton',=0A=
      value: function _createBackButton(locale) {=0A=
        var button =3D this._createButton('back', 'vis-button vis-back', =
locale['back'] || this.options.locales['en']['back']);=0A=
        this.manipulationDiv.appendChild(button);=0A=
        this._bindHammerToDiv(button, =
this.showManipulatorToolbar.bind(this));=0A=
      }=0A=
    }, {=0A=
      key: '_createButton',=0A=
      value: function _createButton(id, className, label) {=0A=
        var labelClassName =3D arguments.length <=3D 3 || arguments[3] =
=3D=3D=3D undefined ? 'vis-label' : arguments[3];=0A=
=0A=
        this.manipulationDOM[id + 'Div'] =3D =
document.createElement('div');=0A=
        this.manipulationDOM[id + 'Div'].className =3D className;=0A=
        this.manipulationDOM[id + 'Label'] =3D =
document.createElement('div');=0A=
        this.manipulationDOM[id + 'Label'].className =3D labelClassName;=0A=
        this.manipulationDOM[id + 'Label'].innerHTML =3D label;=0A=
        this.manipulationDOM[id + =
'Div'].appendChild(this.manipulationDOM[id + 'Label']);=0A=
        return this.manipulationDOM[id + 'Div'];=0A=
      }=0A=
    }, {=0A=
      key: '_createDescription',=0A=
      value: function _createDescription(label) {=0A=
        =
this.manipulationDiv.appendChild(this._createButton('description', =
'vis-button vis-none', label));=0A=
      }=0A=
    }, {=0A=
      key: '_temporaryBindEvent',=0A=
=0A=
      // -------------------------- End of DOM functions for buttons =
------------------------------//=0A=
=0A=
      /**=0A=
       * this binds an event until cleanup by the clean functions.=0A=
       * @param event=0A=
       * @param newFunction=0A=
       * @private=0A=
       */=0A=
      value: function _temporaryBindEvent(event, newFunction) {=0A=
        this.temporaryEventFunctions.push({ event: event, boundFunction: =
newFunction });=0A=
        this.body.emitter.on(event, newFunction);=0A=
      }=0A=
    }, {=0A=
      key: '_temporaryBindUI',=0A=
=0A=
      /**=0A=
       * this overrides an UI function until cleanup by the clean =
function=0A=
       * @param UIfunctionName=0A=
       * @param newFunction=0A=
       * @private=0A=
       */=0A=
      value: function _temporaryBindUI(UIfunctionName, newFunction) {=0A=
        if (this.body.eventListeners[UIfunctionName] !=3D=3D undefined) {=0A=
          this.temporaryUIFunctions[UIfunctionName] =3D =
this.body.eventListeners[UIfunctionName];=0A=
          this.body.eventListeners[UIfunctionName] =3D newFunction;=0A=
        } else {=0A=
          throw new Error('This UI function does not exist. Typo? You =
tried: ' + UIfunctionName + ' possible are: ' + =
JSON.stringify(Object.keys(this.body.eventListeners)));=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_unbindTemporaryUIs',=0A=
=0A=
      /**=0A=
       * Restore the overridden UI functions to their original state.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _unbindTemporaryUIs() {=0A=
        for (var functionName in this.temporaryUIFunctions) {=0A=
          if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {=0A=
            this.body.eventListeners[functionName] =3D =
this.temporaryUIFunctions[functionName];=0A=
            delete this.temporaryUIFunctions[functionName];=0A=
          }=0A=
        }=0A=
        this.temporaryUIFunctions =3D {};=0A=
      }=0A=
    }, {=0A=
      key: '_unbindTemporaryEvents',=0A=
=0A=
      /**=0A=
       * Unbind the events created by _temporaryBindEvent=0A=
       * @private=0A=
       */=0A=
      value: function _unbindTemporaryEvents() {=0A=
        for (var i =3D 0; i < this.temporaryEventFunctions.length; i++) {=0A=
          var eventName =3D this.temporaryEventFunctions[i].event;=0A=
          var boundFunction =3D =
this.temporaryEventFunctions[i].boundFunction;=0A=
          this.body.emitter.off(eventName, boundFunction);=0A=
        }=0A=
        this.temporaryEventFunctions =3D [];=0A=
      }=0A=
    }, {=0A=
      key: '_bindHammerToDiv',=0A=
=0A=
      /**=0A=
       * Bind an hammer instance to a DOM element.=0A=
       * @param domElement=0A=
       * @param funct=0A=
       */=0A=
      value: function _bindHammerToDiv(domElement, boundFunction) {=0A=
        var hammer =3D new Hammer(domElement, {});=0A=
        hammerUtil.onTouch(hammer, boundFunction);=0A=
        this.manipulationHammers.push(hammer);=0A=
      }=0A=
    }, {=0A=
      key: '_cleanupTemporaryNodesAndEdges',=0A=
=0A=
      /**=0A=
       * Neatly clean up temporary edges and nodes=0A=
       * @private=0A=
       */=0A=
      value: function _cleanupTemporaryNodesAndEdges() {=0A=
        // _clean temporary edges=0A=
        for (var i =3D 0; i < this.temporaryIds.edges.length; i++) {=0A=
          this.body.edges[this.temporaryIds.edges[i]].disconnect();=0A=
          delete this.body.edges[this.temporaryIds.edges[i]];=0A=
          var indexTempEdge =3D =
this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);=0A=
          if (indexTempEdge !=3D=3D -1) {=0A=
            this.body.edgeIndices.splice(indexTempEdge, 1);=0A=
          }=0A=
        }=0A=
=0A=
        // _clean temporary nodes=0A=
        for (var i =3D 0; i < this.temporaryIds.nodes.length; i++) {=0A=
          delete this.body.nodes[this.temporaryIds.nodes[i]];=0A=
          var indexTempNode =3D =
this.body.nodeIndices.indexOf(this.temporaryIds.nodes[i]);=0A=
          if (indexTempNode !=3D=3D -1) {=0A=
            this.body.nodeIndices.splice(indexTempNode, 1);=0A=
          }=0A=
        }=0A=
=0A=
        this.temporaryIds =3D { nodes: [], edges: [] };=0A=
      }=0A=
    }, {=0A=
      key: '_controlNodeTouch',=0A=
=0A=
      // ------------------------------------------ EDIT EDGE FUNCTIONS =
-----------------------------------------//=0A=
=0A=
      /**=0A=
       * the touch is used to get the position of the initial click=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function _controlNodeTouch(event) {=0A=
        this.selectionHandler.unselectAll();=0A=
        this.lastTouch =3D this.body.functions.getPointer(event.center);=0A=
        this.lastTouch.translation =3D util.extend({}, =
this.body.view.translation); // copy the object=0A=
      }=0A=
    }, {=0A=
      key: '_controlNodeDragStart',=0A=
=0A=
      /**=0A=
       * the drag start is used to mark one of the control nodes as =
selected.=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function _controlNodeDragStart(event) {=0A=
        var pointer =3D this.lastTouch;=0A=
        var pointerObj =3D =
this.selectionHandler._pointerToPositionObject(pointer);=0A=
        var from =3D this.body.nodes[this.temporaryIds.nodes[0]];=0A=
        var to =3D this.body.nodes[this.temporaryIds.nodes[1]];=0A=
        var edge =3D this.body.edges[this.edgeBeingEditedId];=0A=
        this.selectedControlNode =3D undefined;=0A=
=0A=
        var fromSelect =3D from.isOverlappingWith(pointerObj);=0A=
        var toSelect =3D to.isOverlappingWith(pointerObj);=0A=
=0A=
        if (fromSelect =3D=3D=3D true) {=0A=
          this.selectedControlNode =3D from;=0A=
          edge.edgeType.from =3D from;=0A=
        } else if (toSelect =3D=3D=3D true) {=0A=
          this.selectedControlNode =3D to;=0A=
          edge.edgeType.to =3D to;=0A=
        }=0A=
=0A=
        this.body.emitter.emit('_redraw');=0A=
      }=0A=
    }, {=0A=
      key: '_controlNodeDrag',=0A=
=0A=
      /**=0A=
       * dragging the control nodes or the canvas=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function _controlNodeDrag(event) {=0A=
        this.body.emitter.emit('disablePhysics');=0A=
        var pointer =3D this.body.functions.getPointer(event.center);=0A=
        var pos =3D this.canvas.DOMtoCanvas(pointer);=0A=
=0A=
        if (this.selectedControlNode !=3D=3D undefined) {=0A=
          this.selectedControlNode.x =3D pos.x;=0A=
          this.selectedControlNode.y =3D pos.y;=0A=
        } else {=0A=
          // if the drag was not started properly because the click =
started outside the network div, start it now.=0A=
          var diffX =3D pointer.x - this.lastTouch.x;=0A=
          var diffY =3D pointer.y - this.lastTouch.y;=0A=
          this.body.view.translation =3D { x: =
this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + =
diffY };=0A=
        }=0A=
        this.body.emitter.emit('_redraw');=0A=
      }=0A=
    }, {=0A=
      key: '_controlNodeDragEnd',=0A=
=0A=
      /**=0A=
       * connecting or restoring the control nodes.=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function _controlNodeDragEnd(event) {=0A=
        var pointer =3D this.body.functions.getPointer(event.center);=0A=
        var pointerObj =3D =
this.selectionHandler._pointerToPositionObject(pointer);=0A=
        var edge =3D this.body.edges[this.edgeBeingEditedId];=0A=
=0A=
        var overlappingNodeIds =3D =
this.selectionHandler._getAllNodesOverlappingWith(pointerObj);=0A=
        var node =3D undefined;=0A=
        for (var i =3D overlappingNodeIds.length - 1; i >=3D 0; i--) {=0A=
          if (overlappingNodeIds[i] !=3D=3D this.selectedControlNode.id) =
{=0A=
            node =3D this.body.nodes[overlappingNodeIds[i]];=0A=
            break;=0A=
          }=0A=
        }=0A=
=0A=
        // perform the connection=0A=
        if (node !=3D=3D undefined && this.selectedControlNode !=3D=3D =
undefined) {=0A=
          if (node.isCluster =3D=3D=3D true) {=0A=
            =
alert(this.options.locales[this.options.locale]['createEdgeError'] || =
this.options.locales['en']['createEdgeError']);=0A=
          } else {=0A=
            var from =3D this.body.nodes[this.temporaryIds.nodes[0]];=0A=
            if (this.selectedControlNode.id =3D=3D=3D from.id) {=0A=
              this._performEditEdge(node.id, edge.to.id);=0A=
            } else {=0A=
              this._performEditEdge(edge.from.id, node.id);=0A=
            }=0A=
          }=0A=
        } else {=0A=
          edge.updateEdgeType();=0A=
          this.body.emitter.emit('restorePhysics');=0A=
        }=0A=
        this.body.emitter.emit('_redraw');=0A=
      }=0A=
    }, {=0A=
      key: '_handleConnect',=0A=
=0A=
      // ------------------------------------ END OF EDIT EDGE FUNCTIONS =
-----------------------------------------//=0A=
=0A=
      // ------------------------------------------- ADD EDGE FUNCTIONS =
-----------------------------------------//=0A=
      /**=0A=
       * the function bound to the selection event. It checks if you =
want to connect a cluster and changes the description=0A=
       * to walk the user through the process.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _handleConnect(event) {=0A=
        // check to avoid double fireing of this function.=0A=
        if (new Date().valueOf() - this.touchTime > 100) {=0A=
          this.lastTouch =3D =
this.body.functions.getPointer(event.center);=0A=
          this.lastTouch.translation =3D util.extend({}, =
this.body.view.translation); // copy the object=0A=
=0A=
          var pointer =3D this.lastTouch;=0A=
          var node =3D this.selectionHandler.getNodeAt(pointer);=0A=
=0A=
          if (node !=3D=3D undefined) {=0A=
            if (node.isCluster =3D=3D=3D true) {=0A=
              =
alert(this.options.locales[this.options.locale]['createEdgeError'] || =
this.options.locales['en']['createEdgeError']);=0A=
            } else {=0A=
              // create a node the temporary line can look at=0A=
              var targetNode =3D this._getNewTargetNode(node.x, node.y);=0A=
              this.body.nodes[targetNode.id] =3D targetNode;=0A=
              this.body.nodeIndices.push(targetNode.id);=0A=
=0A=
              // create a temporary edge=0A=
              var connectionEdge =3D this.body.functions.createEdge({=0A=
                id: 'connectionEdge' + util.randomUUID(),=0A=
                from: node.id,=0A=
                to: targetNode.id,=0A=
                physics: false,=0A=
                smooth: {=0A=
                  enabled: true,=0A=
                  type: 'continuous',=0A=
                  roundness: 0.5=0A=
                }=0A=
              });=0A=
              this.body.edges[connectionEdge.id] =3D connectionEdge;=0A=
              this.body.edgeIndices.push(connectionEdge.id);=0A=
=0A=
              this.temporaryIds.nodes.push(targetNode.id);=0A=
              this.temporaryIds.edges.push(connectionEdge.id);=0A=
            }=0A=
          }=0A=
          this.touchTime =3D new Date().valueOf();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_dragControlNode',=0A=
      value: function _dragControlNode(event) {=0A=
        var pointer =3D this.body.functions.getPointer(event.center);=0A=
        if (this.temporaryIds.nodes[0] !=3D=3D undefined) {=0A=
          var targetNode =3D =
this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp =
node in the add edge mode.=0A=
          targetNode.x =3D this.canvas._XconvertDOMtoCanvas(pointer.x);=0A=
          targetNode.y =3D this.canvas._YconvertDOMtoCanvas(pointer.y);=0A=
          this.body.emitter.emit('_redraw');=0A=
        } else {=0A=
          var diffX =3D pointer.x - this.lastTouch.x;=0A=
          var diffY =3D pointer.y - this.lastTouch.y;=0A=
          this.body.view.translation =3D { x: =
this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + =
diffY };=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_finishConnect',=0A=
=0A=
      /**=0A=
       * Connect the new edge to the target if one exists, otherwise =
remove temp line=0A=
       * @param event=0A=
       * @private=0A=
       */=0A=
      value: function _finishConnect(event) {=0A=
        var pointer =3D this.body.functions.getPointer(event.center);=0A=
        var pointerObj =3D =
this.selectionHandler._pointerToPositionObject(pointer);=0A=
=0A=
        // remember the edge id=0A=
        var connectFromId =3D undefined;=0A=
        if (this.temporaryIds.edges[0] !=3D=3D undefined) {=0A=
          connectFromId =3D =
this.body.edges[this.temporaryIds.edges[0]].fromId;=0A=
        }=0A=
=0A=
        // get the overlapping node but NOT the temporary node;=0A=
        var overlappingNodeIds =3D =
this.selectionHandler._getAllNodesOverlappingWith(pointerObj);=0A=
        var node =3D undefined;=0A=
        for (var i =3D overlappingNodeIds.length - 1; i >=3D 0; i--) {=0A=
          // if the node id is NOT a temporary node, accept the node.=0A=
          if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) =
=3D=3D=3D -1) {=0A=
            node =3D this.body.nodes[overlappingNodeIds[i]];=0A=
            break;=0A=
          }=0A=
        }=0A=
=0A=
        // clean temporary nodes and edges.=0A=
        this._cleanupTemporaryNodesAndEdges();=0A=
=0A=
        // perform the connection=0A=
        if (node !=3D=3D undefined) {=0A=
          if (node.isCluster =3D=3D=3D true) {=0A=
            =
alert(this.options.locales[this.options.locale]['createEdgeError'] || =
this.options.locales['en']['createEdgeError']);=0A=
          } else {=0A=
            if (this.body.nodes[connectFromId] !=3D=3D undefined && =
this.body.nodes[node.id] !=3D=3D undefined) {=0A=
              this._performAddEdge(connectFromId, node.id);=0A=
            }=0A=
          }=0A=
        }=0A=
        this.body.emitter.emit('_redraw');=0A=
      }=0A=
    }, {=0A=
      key: '_performAddNode',=0A=
=0A=
      // --------------------------------------- END OF ADD EDGE =
FUNCTIONS -------------------------------------//=0A=
=0A=
      // ------------------------------ Performing all the actual data =
manipulation ------------------------//=0A=
=0A=
      /**=0A=
       * Adds a node on the specified location=0A=
       */=0A=
      value: function _performAddNode(clickData) {=0A=
        var _this5 =3D this;=0A=
=0A=
        var defaultData =3D {=0A=
          id: util.randomUUID(),=0A=
          x: clickData.pointer.canvas.x,=0A=
          y: clickData.pointer.canvas.y,=0A=
          label: 'new'=0A=
        };=0A=
=0A=
        if (typeof this.options.addNode =3D=3D=3D 'function') {=0A=
          if (this.options.addNode.length =3D=3D=3D 2) {=0A=
            this.options.addNode(defaultData, function (finalizedData) {=0A=
              if (finalizedData !=3D=3D null && finalizedData !=3D=3D =
undefined && _this5.inMode =3D=3D=3D 'addNode') {=0A=
                // if for whatever reason the mode has changes (due to =
dataset change) disregard the callback=0A=
                _this5.body.data.nodes.getDataSet().add(finalizedData);=0A=
                _this5.showManipulatorToolbar();=0A=
              }=0A=
            });=0A=
          } else {=0A=
            throw new Error('The function for add does not support two =
arguments (data,callback)');=0A=
            this.showManipulatorToolbar();=0A=
          }=0A=
        } else {=0A=
          this.body.data.nodes.getDataSet().add(defaultData);=0A=
          this.showManipulatorToolbar();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_performAddEdge',=0A=
=0A=
      /**=0A=
       * connect two nodes with a new edge.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _performAddEdge(sourceNodeId, targetNodeId) {=0A=
        var _this6 =3D this;=0A=
=0A=
        var defaultData =3D { from: sourceNodeId, to: targetNodeId };=0A=
        if (typeof this.options.addEdge =3D=3D=3D 'function') {=0A=
          if (this.options.addEdge.length =3D=3D=3D 2) {=0A=
            this.options.addEdge(defaultData, function (finalizedData) {=0A=
              if (finalizedData !=3D=3D null && finalizedData !=3D=3D =
undefined && _this6.inMode =3D=3D=3D 'addEdge') {=0A=
                // if for whatever reason the mode has changes (due to =
dataset change) disregard the callback=0A=
                _this6.body.data.edges.getDataSet().add(finalizedData);=0A=
                _this6.selectionHandler.unselectAll();=0A=
                _this6.showManipulatorToolbar();=0A=
              }=0A=
            });=0A=
          } else {=0A=
            throw new Error('The function for connect does not support =
two arguments (data,callback)');=0A=
          }=0A=
        } else {=0A=
          this.body.data.edges.getDataSet().add(defaultData);=0A=
          this.selectionHandler.unselectAll();=0A=
          this.showManipulatorToolbar();=0A=
        }=0A=
      }=0A=
    }, {=0A=
      key: '_performEditEdge',=0A=
=0A=
      /**=0A=
       * connect two nodes with a new edge.=0A=
       *=0A=
       * @private=0A=
       */=0A=
      value: function _performEditEdge(sourceNodeId, targetNodeId) {=0A=
        var _this7 =3D this;=0A=
=0A=
        var defaultData =3D { id: this.edgeBeingEditedId, from: =
sourceNodeId, to: targetNodeId };=0A=
        if (typeof this.options.editEdge =3D=3D=3D 'function') {=0A=
          if (this.options.editEdge.length =3D=3D=3D 2) {=0A=
            this.options.editEdge(defaultData, function (finalizedData) {=0A=
              if (finalizedData =3D=3D=3D null || finalizedData =
=3D=3D=3D undefined || _this7.inMode !=3D=3D 'editEdge') {=0A=
                // if for whatever reason the mode has changes (due to =
dataset change) disregard the callback) {=0A=
                _this7.body.edges[defaultData.id].updateEdgeType();=0A=
                _this7.body.emitter.emit('_redraw');=0A=
              } else {=0A=
                =
_this7.body.data.edges.getDataSet().update(finalizedData);=0A=
                _this7.selectionHandler.unselectAll();=0A=
                _this7.showManipulatorToolbar();=0A=
              }=0A=
            });=0A=
          } else {=0A=
            throw new Error('The function for edit does not support two =
arguments (data, callback)');=0A=
          }=0A=
        } else {=0A=
          this.body.data.edges.getDataSet().update(defaultData);=0A=
          this.selectionHandler.unselectAll();=0A=
          this.showManipulatorToolbar();=0A=
        }=0A=
      }=0A=
    }]);=0A=
=0A=
    return ManipulationSystem;=0A=
  })();=0A=
=0A=
  exports['default'] =3D ManipulationSystem;=0A=
  module.exports =3D exports['default'];=0A=
=0A=
/***/ },=0A=
/* 110 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * This object contains all possible options. It will check if the =
types are correct, if required if the option is one=0A=
   * of the allowed values.=0A=
   *=0A=
   * __any__ means that the name of the property does not matter.=0A=
   * __type__ is a required field for all objects and contains the =
allowed types of all objects=0A=
   */=0A=
  'use strict';=0A=
=0A=
  Object.defineProperty(exports, '__esModule', {=0A=
    value: true=0A=
  });=0A=
  var string =3D 'string';=0A=
  var boolean =3D 'boolean';=0A=
  var number =3D 'number';=0A=
  var array =3D 'array';=0A=
  var object =3D 'object'; // should only be in a __type__ property=0A=
  var dom =3D 'dom';=0A=
  var any =3D 'any';=0A=
=0A=
  var allOptions =3D {=0A=
    configure: {=0A=
      enabled: { boolean: boolean },=0A=
      filter: { boolean: boolean, string: string, array: array, =
'function': 'function' },=0A=
      container: { dom: dom },=0A=
      showButton: { boolean: boolean },=0A=
      __type__: { object: object, boolean: boolean, string: string, =
array: array, 'function': 'function' }=0A=
    },=0A=
    edges: {=0A=
      arrows: {=0A=
        to: { enabled: { boolean: boolean }, scaleFactor: { number: =
number }, __type__: { object: object, boolean: boolean } },=0A=
        middle: { enabled: { boolean: boolean }, scaleFactor: { number: =
number }, __type__: { object: object, boolean: boolean } },=0A=
        from: { enabled: { boolean: boolean }, scaleFactor: { number: =
number }, __type__: { object: object, boolean: boolean } },=0A=
        __type__: { string: ['from', 'to', 'middle'], object: object }=0A=
      },=0A=
      color: {=0A=
        color: { string: string },=0A=
        highlight: { string: string },=0A=
        hover: { string: string },=0A=
        inherit: { string: ['from', 'to', 'both'], boolean: boolean },=0A=
        opacity: { number: number },=0A=
        __type__: { object: object, string: string }=0A=
      },=0A=
      dashes: { boolean: boolean, array: array },=0A=
      font: {=0A=
        color: { string: string },=0A=
        size: { number: number }, // px=0A=
        face: { string: string },=0A=
        background: { string: string },=0A=
        strokeWidth: { number: number }, // px=0A=
        strokeColor: { string: string },=0A=
        align: { string: ['horizontal', 'top', 'middle', 'bottom'] },=0A=
        __type__: { object: object, string: string }=0A=
      },=0A=
      hidden: { boolean: boolean },=0A=
      hoverWidth: { 'function': 'function', number: number },=0A=
      label: { string: string, 'undefined': 'undefined' },=0A=
      labelHighlightBold: { boolean: boolean },=0A=
      length: { number: number, 'undefined': 'undefined' },=0A=
      physics: { boolean: boolean },=0A=
      scaling: {=0A=
        min: { number: number },=0A=
        max: { number: number },=0A=
        label: {=0A=
          enabled: { boolean: boolean },=0A=
          min: { number: number },=0A=
          max: { number: number },=0A=
          maxVisible: { number: number },=0A=
          drawThreshold: { number: number },=0A=
          __type__: { object: object, boolean: boolean }=0A=
        },=0A=
        customScalingFunction: { 'function': 'function' },=0A=
        __type__: { object: object }=0A=
      },=0A=
      selectionWidth: { 'function': 'function', number: number },=0A=
      selfReferenceSize: { number: number },=0A=
      shadow: {=0A=
        enabled: { boolean: boolean },=0A=
        size: { number: number },=0A=
        x: { number: number },=0A=
        y: { number: number },=0A=
        __type__: { object: object, boolean: boolean }=0A=
      },=0A=
      smooth: {=0A=
        enabled: { boolean: boolean },=0A=
        type: { string: ['dynamic', 'continuous', 'discrete', =
'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', =
'curvedCCW', 'cubicBezier'] },=0A=
        roundness: { number: number },=0A=
        forceDirection: { string: ['horizontal', 'vertical', 'none'], =
boolean: boolean },=0A=
        __type__: { object: object, boolean: boolean }=0A=
      },=0A=
      title: { string: string, 'undefined': 'undefined' },=0A=
      width: { number: number },=0A=
      value: { number: number, 'undefined': 'undefined' },=0A=
      __type__: { object: object }=0A=
    },=0A=
    groups: {=0A=
      useDefaultGroups: { boolean: boolean },=0A=
      __any__: 'get from nodes, will be overwritten below',=0A=
      __type__: { object: object }=0A=
    },=0A=
    interaction: {=0A=
      dragNodes: { boolean: boolean },=0A=
      dragView: { boolean: boolean },=0A=
      hideEdgesOnDrag: { boolean: boolean },=0A=
      hideNodesOnDrag: { boolean: boolean },=0A=
      hover: { boolean: boolean },=0A=
      keyboard: {=0A=
        enabled: { boolean: boolean },=0A=
        speed: { x: { number: number }, y: { number: number }, zoom: { =
number: number }, __type__: { object: object } },=0A=
        bindToWindow: { boolean: boolean },=0A=
        __type__: { object: object, boolean: boolean }=0A=
      },=0A=
      multiselect: { boolean: boolean },=0A=
      navigationButtons: { boolean: boolean },=0A=
      selectable: { boolean: boolean },=0A=
      selectConnectedEdges: { boolean: boolean },=0A=
      hoverConnectedEdges: { boolean: boolean },=0A=
      tooltipDelay: { number: number },=0A=
      zoomView: { boolean: boolean },=0A=
      __type__: { object: object }=0A=
    },=0A=
    layout: {=0A=
      randomSeed: { 'undefined': 'undefined', number: number },=0A=
      hierarchical: {=0A=
        enabled: { boolean: boolean },=0A=
        levelSeparation: { number: number },=0A=
        direction: { string: ['UD', 'DU', 'LR', 'RL'] }, // UD, DU, LR, =
RL=0A=
        sortMethod: { string: ['hubsize', 'directed'] }, // hubsize, =
directed=0A=
        __type__: { object: object, boolean: boolean }=0A=
      },=0A=
      __type__: { object: object }=0A=
    },=0A=
    manipulation: {=0A=
      enabled: { boolean: boolean },=0A=
      initiallyActive: { boolean: boolean },=0A=
      addNode: { boolean: boolean, 'function': 'function' },=0A=
      addEdge: { boolean: boolean, 'function': 'function' },=0A=
      editNode: { 'function': 'function' },=0A=
      editEdge: { boolean: boolean, 'function': 'function' },=0A=
      deleteNode: { boolean: boolean, 'function': 'function' },=0A=
      deleteEdge: { boolean: boolean, 'function': 'function' },=0A=
      controlNodeStyle: 'get from nodes, will be overwritten below',=0A=
      __type__: { object: object, boolean: boolean }=0A=
    },=0A=
    nodes: {=0A=
      borderWidth: { number: number },=0A=
      borderWidthSelected: { number: number, 'undefined': 'undefined' },=0A=
      brokenImage: { string: string, 'undefined': 'undefined' },=0A=
      color: {=0A=
        border: { string: string },=0A=
        background: { string: string },=0A=
        highlight: {=0A=
          border: { string: string },=0A=
          background: { string: string },=0A=
          __type__: { object: object, string: string }=0A=
        },=0A=
        hover: {=0A=
          border: { string: string },=0A=
          background: { string: string },=0A=
          __type__: { object: object, string: string }=0A=
        },=0A=
        __type__: { object: object, string: string }=0A=
      },=0A=
      fixed: {=0A=
        x: { boolean: boolean },=0A=
        y: { boolean: boolean },=0A=
        __type__: { object: object, boolean: boolean }=0A=
      },=0A=
      font: {=0A=
        color: { string: string },=0A=
        size: { number: number }, // px=0A=
        face: { string: string },=0A=
        background: { string: string },=0A=
        strokeWidth: { number: number }, // px=0A=
        strokeColor: { string: string },=0A=
        __type__: { object: object, string: string }=0A=
      },=0A=
      group: { string: string, number: number, 'undefined': 'undefined' =
},=0A=
      hidden: { boolean: boolean },=0A=
      icon: {=0A=
        face: { string: string },=0A=
        code: { string: string }, //'\uf007',=0A=
        size: { number: number }, //50,=0A=
        color: { string: string },=0A=
        __type__: { object: object }=0A=
      },=0A=
      id: { string: string, number: number },=0A=
      image: { string: string, 'undefined': 'undefined' }, // --> URL=0A=
      label: { string: string, 'undefined': 'undefined' },=0A=
      labelHighlightBold: { boolean: boolean },=0A=
      level: { number: number, 'undefined': 'undefined' },=0A=
      mass: { number: number },=0A=
      physics: { boolean: boolean },=0A=
      scaling: {=0A=
        min: { number: number },=0A=
        max: { number: number },=0A=
        label: {=0A=
          enabled: { boolean: boolean },=0A=
          min: { number: number },=0A=
          max: { number: number },=0A=
          maxVisible: { number: number },=0A=
          drawThreshold: { number: number },=0A=
          __type__: { object: object, boolean: boolean }=0A=
        },=0A=
        customScalingFunction: { 'function': 'function' },=0A=
        __type__: { object: object }=0A=
      },=0A=
      shadow: {=0A=
        enabled: { boolean: boolean },=0A=
        size: { number: number },=0A=
        x: { number: number },=0A=
        y: { number: number },=0A=
        __type__: { object: object, boolean: boolean }=0A=
      },=0A=
      shape: { string: ['ellipse', 'circle', 'database', 'box', 'text', =
'image', 'circularImage', 'diamond', 'dot', 'star', 'triangle', =
'triangleDown', 'square', 'icon'] },=0A=
      shapeProperties: {=0A=
        borderDashes: { boolean: boolean, array: array },=0A=
        borderRadius: { number: number },=0A=
        useImageSize: { boolean: boolean },=0A=
        __type__: { object: object }=0A=
      },=0A=
      size: { number: number },=0A=
      title: { string: string, 'undefined': 'undefined' },=0A=
      value: { number: number, 'undefined': 'undefined' },=0A=
      x: { number: number },=0A=
      y: { number: number },=0A=
      __type__: { object: object }=0A=
    },=0A=
    physics: {=0A=
      enabled: { boolean: boolean },=0A=
      barnesHut: {=0A=
        gravitationalConstant: { number: number },=0A=
        centralGravity: { number: number },=0A=
        springLength: { number: number },=0A=
        springConstant: { number: number },=0A=
        damping: { number: number },=0A=
        avoidOverlap: { number: number },=0A=
        __type__: { object: object }=0A=
      },=0A=
      forceAtlas2Based: {=0A=
        gravitationalConstant: { number: number },=0A=
        centralGravity: { number: number },=0A=
        springLength: { number: number },=0A=
        springConstant: { number: number },=0A=
        damping: { number: number },=0A=
        avoidOverlap: { number: number },=0A=
        __type__: { object: object }=0A=
      },=0A=
      repulsion: {=0A=
        centralGravity: { number: number },=0A=
        springLength: { number: number },=0A=
        springConstant: { number: number },=0A=
        nodeDistance: { number: number },=0A=
        damping: { number: number },=0A=
        __type__: { object: object }=0A=
      },=0A=
      hierarchicalRepulsion: {=0A=
        centralGravity: { number: number },=0A=
        springLength: { number: number },=0A=
        springConstant: { number: number },=0A=
        nodeDistance: { number: number },=0A=
        damping: { number: number },=0A=
        __type__: { object: object }=0A=
      },=0A=
      maxVelocity: { number: number },=0A=
      minVelocity: { number: number }, // px/s=0A=
      solver: { string: ['barnesHut', 'repulsion', =
'hierarchicalRepulsion', 'forceAtlas2Based'] },=0A=
      stabilization: {=0A=
        enabled: { boolean: boolean },=0A=
        iterations: { number: number }, // maximum number of iteration =
to stabilize=0A=
        updateInterval: { number: number },=0A=
        onlyDynamicEdges: { boolean: boolean },=0A=
        fit: { boolean: boolean },=0A=
        __type__: { object: object, boolean: boolean }=0A=
      },=0A=
      timestep: { number: number },=0A=
      __type__: { object: object, boolean: boolean }=0A=
    },=0A=
=0A=
    //globals :=0A=
    autoResize: { boolean: boolean },=0A=
    clickToUse: { boolean: boolean },=0A=
    locale: { string: string },=0A=
    locales: {=0A=
      __any__: { any: any },=0A=
      __type__: { object: object }=0A=
    },=0A=
    height: { string: string },=0A=
    width: { string: string },=0A=
    __type__: { object: object }=0A=
  };=0A=
=0A=
  allOptions.groups.__any__ =3D allOptions.nodes;=0A=
  allOptions.manipulation.controlNodeStyle =3D allOptions.nodes;=0A=
=0A=
  var configureOptions =3D {=0A=
    nodes: {=0A=
      borderWidth: [1, 0, 10, 1],=0A=
      borderWidthSelected: [2, 0, 10, 1],=0A=
      color: {=0A=
        border: ['color', '#2B7CE9'],=0A=
        background: ['color', '#97C2FC'],=0A=
        highlight: {=0A=
          border: ['color', '#2B7CE9'],=0A=
          background: ['color', '#D2E5FF']=0A=
        },=0A=
        hover: {=0A=
          border: ['color', '#2B7CE9'],=0A=
          background: ['color', '#D2E5FF']=0A=
        }=0A=
      },=0A=
      fixed: {=0A=
        x: false,=0A=
        y: false=0A=
      },=0A=
      font: {=0A=
        color: ['color', '#343434'],=0A=
        size: [14, 0, 100, 1], // px=0A=
        face: ['arial', 'verdana', 'tahoma'],=0A=
        background: ['color', 'none'],=0A=
        strokeWidth: [0, 0, 50, 1], // px=0A=
        strokeColor: ['color', '#ffffff']=0A=
      },=0A=
      //group: 'string',=0A=
      hidden: false,=0A=
      labelHighlightBold: true,=0A=
      //icon: {=0A=
      //  face: 'string',  //'FontAwesome',=0A=
      //  code: 'string',  //'\uf007',=0A=
      //  size: [50, 0, 200, 1],  //50,=0A=
      //  color: ['color','#2B7CE9']   //'#aa00ff'=0A=
      //},=0A=
      //image: 'string', // --> URL=0A=
      physics: true,=0A=
      scaling: {=0A=
        min: [10, 0, 200, 1],=0A=
        max: [30, 0, 200, 1],=0A=
        label: {=0A=
          enabled: false,=0A=
          min: [14, 0, 200, 1],=0A=
          max: [30, 0, 200, 1],=0A=
          maxVisible: [30, 0, 200, 1],=0A=
          drawThreshold: [5, 0, 20, 1]=0A=
        }=0A=
      },=0A=
      shadow: {=0A=
        enabled: false,=0A=
        size: [10, 0, 20, 1],=0A=
        x: [5, -30, 30, 1],=0A=
        y: [5, -30, 30, 1]=0A=
      },=0A=
      shape: ['ellipse', 'box', 'circle', 'database', 'diamond', 'dot', =
'square', 'star', 'text', 'triangle', 'triangleDown'],=0A=
      shapeProperties: {=0A=
        borderDashes: false,=0A=
        borderRadius: [6, 0, 20, 1],=0A=
        useImageSize: false=0A=
      },=0A=
      size: [25, 0, 200, 1]=0A=
    },=0A=
    edges: {=0A=
      arrows: {=0A=
        to: { enabled: false, scaleFactor: [1, 0, 3, 0.05] }, // boolean =
/ {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}=0A=
        middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05] },=0A=
        from: { enabled: false, scaleFactor: [1, 0, 3, 0.05] }=0A=
      },=0A=
      color: {=0A=
        color: ['color', '#848484'],=0A=
        highlight: ['color', '#848484'],=0A=
        hover: ['color', '#848484'],=0A=
        inherit: ['from', 'to', 'both', true, false],=0A=
        opacity: [1, 0, 1, 0.05]=0A=
      },=0A=
      dashes: false,=0A=
      font: {=0A=
        color: ['color', '#343434'],=0A=
        size: [14, 0, 100, 1], // px=0A=
        face: ['arial', 'verdana', 'tahoma'],=0A=
        background: ['color', 'none'],=0A=
        strokeWidth: [2, 0, 50, 1], // px=0A=
        strokeColor: ['color', '#ffffff'],=0A=
        align: ['horizontal', 'top', 'middle', 'bottom']=0A=
      },=0A=
      hidden: false,=0A=
      hoverWidth: [1.5, 0, 5, 0.1],=0A=
      labelHighlightBold: true,=0A=
      physics: true,=0A=
      scaling: {=0A=
        min: [1, 0, 100, 1],=0A=
        max: [15, 0, 100, 1],=0A=
        label: {=0A=
          enabled: true,=0A=
          min: [14, 0, 200, 1],=0A=
          max: [30, 0, 200, 1],=0A=
          maxVisible: [30, 0, 200, 1],=0A=
          drawThreshold: [5, 0, 20, 1]=0A=
        }=0A=
      },=0A=
      selectionWidth: [1.5, 0, 5, 0.1],=0A=
      selfReferenceSize: [20, 0, 200, 1],=0A=
      shadow: {=0A=
        enabled: false,=0A=
        size: [10, 0, 20, 1],=0A=
        x: [5, -30, 30, 1],=0A=
        y: [5, -30, 30, 1]=0A=
      },=0A=
      smooth: {=0A=
        enabled: true,=0A=
        type: ['dynamic', 'continuous', 'discrete', 'diagonalCross', =
'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', =
'cubicBezier'],=0A=
        forceDirection: ['horizontal', 'vertical', 'none'],=0A=
        roundness: [0.5, 0, 1, 0.05]=0A=
      },=0A=
      width: [1, 0, 30, 1]=0A=
    },=0A=
    layout: {=0A=
      //randomSeed: [0, 0, 500, 1],=0A=
      hierarchical: {=0A=
        enabled: false,=0A=
        levelSeparation: [150, 20, 500, 5],=0A=
        direction: ['UD', 'DU', 'LR', 'RL'], // UD, DU, LR, RL=0A=
        sortMethod: ['hubsize', 'directed'] // hubsize, directed=0A=
      }=0A=
    },=0A=
    interaction: {=0A=
      dragNodes: true,=0A=
      dragView: true,=0A=
      hideEdgesOnDrag: false,=0A=
      hideNodesOnDrag: false,=0A=
      hover: false,=0A=
      keyboard: {=0A=
        enabled: false,=0A=
        speed: { x: [10, 0, 40, 1], y: [10, 0, 40, 1], zoom: [0.02, 0, =
0.1, 0.005] },=0A=
        bindToWindow: true=0A=
      },=0A=
      multiselect: false,=0A=
      navigationButtons: false,=0A=
      selectable: true,=0A=
      selectConnectedEdges: true,=0A=
      hoverConnectedEdges: true,=0A=
      tooltipDelay: [300, 0, 1000, 25],=0A=
      zoomView: true=0A=
    },=0A=
    manipulation: {=0A=
      enabled: false,=0A=
      initiallyActive: false=0A=
    },=0A=
    physics: {=0A=
      enabled: true,=0A=
      barnesHut: {=0A=
        //theta: [0.5, 0.1, 1, 0.05],=0A=
        gravitationalConstant: [-2000, -30000, 0, 50],=0A=
        centralGravity: [0.3, 0, 10, 0.05],=0A=
        springLength: [95, 0, 500, 5],=0A=
        springConstant: [0.04, 0, 1.2, 0.005],=0A=
        damping: [0.09, 0, 1, 0.01],=0A=
        avoidOverlap: [0, 0, 1, 0.01]=0A=
      },=0A=
      forceAtlas2Based: {=0A=
        //theta: [0.5, 0.1, 1, 0.05],=0A=
        gravitationalConstant: [-50, -500, 0, 1],=0A=
        centralGravity: [0.01, 0, 1, 0.005],=0A=
        springLength: [95, 0, 500, 5],=0A=
        springConstant: [0.08, 0, 1.2, 0.005],=0A=
        damping: [0.4, 0, 1, 0.01],=0A=
        avoidOverlap: [0, 0, 1, 0.01]=0A=
      },=0A=
      repulsion: {=0A=
        centralGravity: [0.2, 0, 10, 0.05],=0A=
        springLength: [200, 0, 500, 5],=0A=
        springConstant: [0.05, 0, 1.2, 0.005],=0A=
        nodeDistance: [100, 0, 500, 5],=0A=
        damping: [0.09, 0, 1, 0.01]=0A=
      },=0A=
      hierarchicalRepulsion: {=0A=
        centralGravity: [0.2, 0, 10, 0.05],=0A=
        springLength: [100, 0, 500, 5],=0A=
        springConstant: [0.01, 0, 1.2, 0.005],=0A=
        nodeDistance: [120, 0, 500, 5],=0A=
        damping: [0.09, 0, 1, 0.01]=0A=
      },=0A=
      maxVelocity: [50, 0, 150, 1],=0A=
      minVelocity: [0.1, 0.01, 0.5, 0.01],=0A=
      solver: ['barnesHut', 'forceAtlas2Based', 'repulsion', =
'hierarchicalRepulsion'],=0A=
      timestep: [0.5, 0.01, 1, 0.01]=0A=
    },=0A=
    global: {=0A=
      locale: ['en', 'nl']=0A=
    }=0A=
  };=0A=
=0A=
  exports.allOptions =3D allOptions;=0A=
  exports.configureOptions =3D configureOptions;=0A=
=0A=
/***/ },=0A=
/* 111 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * Canvas shapes used by Network=0A=
   */=0A=
  'use strict';=0A=
=0A=
  if (typeof CanvasRenderingContext2D !=3D=3D 'undefined') {=0A=
=0A=
    /**=0A=
     * Draw a circle shape=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.circle =3D function (x, y, r) {=0A=
      this.beginPath();=0A=
      this.arc(x, y, r, 0, 2 * Math.PI, false);=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * Draw a square shape=0A=
     * @param {Number} x horizontal center=0A=
     * @param {Number} y vertical center=0A=
     * @param {Number} r   size, width and height of the square=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.square =3D function (x, y, r) {=0A=
      this.beginPath();=0A=
      this.rect(x - r, y - r, r * 2, r * 2);=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * Draw a triangle shape=0A=
     * @param {Number} x horizontal center=0A=
     * @param {Number} y vertical center=0A=
     * @param {Number} r   radius, half the length of the sides of the =
triangle=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.triangle =3D function (x, y, r) {=0A=
      // http://en.wikipedia.org/wiki/Equilateral_triangle=0A=
      this.beginPath();=0A=
=0A=
      // the change in radius and the offset is here to center the shape=0A=
      r *=3D 1.15;=0A=
      y +=3D 0.275 * r;=0A=
=0A=
      var s =3D r * 2;=0A=
      var s2 =3D s / 2;=0A=
      var ir =3D Math.sqrt(3) / 6 * s; // radius of inner circle=0A=
      var h =3D Math.sqrt(s * s - s2 * s2); // height=0A=
=0A=
      this.moveTo(x, y - (h - ir));=0A=
      this.lineTo(x + s2, y + ir);=0A=
      this.lineTo(x - s2, y + ir);=0A=
      this.lineTo(x, y - (h - ir));=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * Draw a triangle shape in downward orientation=0A=
     * @param {Number} x horizontal center=0A=
     * @param {Number} y vertical center=0A=
     * @param {Number} r radius=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.triangleDown =3D function (x, y, =
r) {=0A=
      // http://en.wikipedia.org/wiki/Equilateral_triangle=0A=
      this.beginPath();=0A=
=0A=
      // the change in radius and the offset is here to center the shape=0A=
      r *=3D 1.15;=0A=
      y -=3D 0.275 * r;=0A=
=0A=
      var s =3D r * 2;=0A=
      var s2 =3D s / 2;=0A=
      var ir =3D Math.sqrt(3) / 6 * s; // radius of inner circle=0A=
      var h =3D Math.sqrt(s * s - s2 * s2); // height=0A=
=0A=
      this.moveTo(x, y + (h - ir));=0A=
      this.lineTo(x + s2, y - ir);=0A=
      this.lineTo(x - s2, y - ir);=0A=
      this.lineTo(x, y + (h - ir));=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * Draw a star shape, a star with 5 points=0A=
     * @param {Number} x horizontal center=0A=
     * @param {Number} y vertical center=0A=
     * @param {Number} r   radius, half the length of the sides of the =
triangle=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.star =3D function (x, y, r) {=0A=
      // =
http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/=0A=
      this.beginPath();=0A=
=0A=
      // the change in radius and the offset is here to center the shape=0A=
      r *=3D 0.82;=0A=
      y +=3D 0.1 * r;=0A=
=0A=
      for (var n =3D 0; n < 10; n++) {=0A=
        var radius =3D n % 2 =3D=3D=3D 0 ? r * 1.3 : r * 0.5;=0A=
        this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - =
radius * Math.cos(n * 2 * Math.PI / 10));=0A=
      }=0A=
=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * Draw a Diamond shape=0A=
     * @param {Number} x horizontal center=0A=
     * @param {Number} y vertical center=0A=
     * @param {Number} r   radius, half the length of the sides of the =
triangle=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.diamond =3D function (x, y, r) {=0A=
      // =
http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/=0A=
      this.beginPath();=0A=
=0A=
      this.lineTo(x, y + r);=0A=
      this.lineTo(x + r, y);=0A=
      this.lineTo(x, y - r);=0A=
      this.lineTo(x - r, y);=0A=
=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * =
http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangl=
e-on-html-canvas=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.roundRect =3D function (x, y, w, =
h, r) {=0A=
      var r2d =3D Math.PI / 180;=0A=
      if (w - 2 * r < 0) {=0A=
        r =3D w / 2;=0A=
      } //ensure that the radius isn't too large for x=0A=
      if (h - 2 * r < 0) {=0A=
        r =3D h / 2;=0A=
      } //ensure that the radius isn't too large for y=0A=
      this.beginPath();=0A=
      this.moveTo(x + r, y);=0A=
      this.lineTo(x + w - r, y);=0A=
      this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);=0A=
      this.lineTo(x + w, y + h - r);=0A=
      this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);=0A=
      this.lineTo(x + r, y + h);=0A=
      this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);=0A=
      this.lineTo(x, y + r);=0A=
      this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * =
http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-c=
anvas=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.ellipse =3D function (x, y, w, h) =
{=0A=
      var kappa =3D .5522848,=0A=
          ox =3D w / 2 * kappa,=0A=
          // control point offset horizontal=0A=
      oy =3D h / 2 * kappa,=0A=
          // control point offset vertical=0A=
      xe =3D x + w,=0A=
          // x-end=0A=
      ye =3D y + h,=0A=
          // y-end=0A=
      xm =3D x + w / 2,=0A=
          // x-middle=0A=
      ym =3D y + h / 2; // y-middle=0A=
=0A=
      this.beginPath();=0A=
      this.moveTo(x, ym);=0A=
      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);=0A=
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);=0A=
      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);=0A=
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * =
http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-c=
anvas=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.database =3D function (x, y, w, =
h) {=0A=
      var f =3D 1 / 3;=0A=
      var wEllipse =3D w;=0A=
      var hEllipse =3D h * f;=0A=
=0A=
      var kappa =3D .5522848,=0A=
          ox =3D wEllipse / 2 * kappa,=0A=
          // control point offset horizontal=0A=
      oy =3D hEllipse / 2 * kappa,=0A=
          // control point offset vertical=0A=
      xe =3D x + wEllipse,=0A=
          // x-end=0A=
      ye =3D y + hEllipse,=0A=
          // y-end=0A=
      xm =3D x + wEllipse / 2,=0A=
          // x-middle=0A=
      ym =3D y + hEllipse / 2,=0A=
          // y-middle=0A=
      ymb =3D y + (h - hEllipse / 2),=0A=
          // y-midlle, bottom ellipse=0A=
      yeb =3D y + h; // y-end, bottom ellipse=0A=
=0A=
      this.beginPath();=0A=
      this.moveTo(xe, ym);=0A=
=0A=
      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);=0A=
      this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);=0A=
=0A=
      this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);=0A=
      this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);=0A=
=0A=
      this.lineTo(xe, ymb);=0A=
=0A=
      this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);=0A=
      this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);=0A=
=0A=
      this.lineTo(x, ym);=0A=
    };=0A=
=0A=
    /**=0A=
     * Draw an arrow point (no line)=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.arrow =3D function (x, y, angle, =
length) {=0A=
      // tail=0A=
      var xt =3D x - length * Math.cos(angle);=0A=
      var yt =3D y - length * Math.sin(angle);=0A=
=0A=
      // inner tail=0A=
      var xi =3D x - length * 0.9 * Math.cos(angle);=0A=
      var yi =3D y - length * 0.9 * Math.sin(angle);=0A=
=0A=
      // left=0A=
      var xl =3D xt + length / 3 * Math.cos(angle + 0.5 * Math.PI);=0A=
      var yl =3D yt + length / 3 * Math.sin(angle + 0.5 * Math.PI);=0A=
=0A=
      // right=0A=
      var xr =3D xt + length / 3 * Math.cos(angle - 0.5 * Math.PI);=0A=
      var yr =3D yt + length / 3 * Math.sin(angle - 0.5 * Math.PI);=0A=
=0A=
      this.beginPath();=0A=
      this.moveTo(x, y);=0A=
      this.lineTo(xl, yl);=0A=
      this.lineTo(xi, yi);=0A=
      this.lineTo(xr, yr);=0A=
      this.closePath();=0A=
    };=0A=
=0A=
    /**=0A=
     * Sets up the dashedLine functionality for drawing=0A=
     * Original code came from =
http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas=0A=
     * @author David Jordan=0A=
     * @date 2012-08-08=0A=
     */=0A=
    CanvasRenderingContext2D.prototype.dashedLine =3D function (x, y, =
x2, y2, pattern) {=0A=
      this.beginPath();=0A=
      this.moveTo(x, y);=0A=
=0A=
      var patternLength =3D pattern.length;=0A=
      var dx =3D x2 - x;=0A=
      var dy =3D y2 - y;=0A=
      var slope =3D dy / dx;=0A=
      var distRemaining =3D Math.sqrt(dx * dx + dy * dy);=0A=
      var patternIndex =3D 0;=0A=
      var draw =3D true;=0A=
      var xStep =3D 0;=0A=
      var dashLength =3D pattern[0];=0A=
=0A=
      while (distRemaining >=3D 0.1) {=0A=
        dashLength =3D pattern[patternIndex++ % patternLength];=0A=
        if (dashLength > distRemaining) {=0A=
          dashLength =3D distRemaining;=0A=
        }=0A=
=0A=
        xStep =3D Math.sqrt(dashLength * dashLength / (1 + slope * =
slope));=0A=
        xStep =3D dx < 0 ? -xStep : xStep;=0A=
        x +=3D xStep;=0A=
        y +=3D slope * xStep;=0A=
=0A=
        if (draw =3D=3D=3D true) {=0A=
          this.lineTo(x, y);=0A=
        } else {=0A=
          this.moveTo(x, y);=0A=
        }=0A=
=0A=
        distRemaining -=3D dashLength;=0A=
        draw =3D !draw;=0A=
      }=0A=
    };=0A=
  }=0A=
=0A=
/***/ },=0A=
/* 112 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * Parse a text source containing data in DOT language into a JSON =
object.=0A=
   * The object contains two lists: one with nodes and one with edges.=0A=
   *=0A=
   * DOT language reference: http://www.graphviz.org/doc/info/lang.html=0A=
   *=0A=
   * DOT language attributes: http://graphviz.org/content/attrs=0A=
   *=0A=
   * @param {String} data     Text containing a graph in DOT-notation=0A=
   * @return {Object} graph   An object containing two parameters:=0A=
   *                          {Object[]} nodes=0A=
   *                          {Object[]} edges=0A=
   */=0A=
  'use strict';=0A=
=0A=
  function parseDOT(data) {=0A=
    dot =3D data;=0A=
    return parseGraph();=0A=
  }=0A=
=0A=
  // mapping of attributes from DOT (the keys) to vis.js (the values)=0A=
  var NODE_ATTR_MAPPING =3D {=0A=
    'fontsize': 'font.size',=0A=
    'fontcolor': 'font.color',=0A=
    'labelfontcolor': 'font.color',=0A=
    'fontname': 'font.face',=0A=
    'color': ['color.border', 'color.background'],=0A=
    'fillcolor': 'color.background',=0A=
    'tooltip': 'title',=0A=
    'labeltooltip': 'title'=0A=
  };=0A=
  var EDGE_ATTR_MAPPING =3D Object.create(NODE_ATTR_MAPPING);=0A=
  EDGE_ATTR_MAPPING.color =3D 'color.color';=0A=
=0A=
  // token types enumeration=0A=
  var TOKENTYPE =3D {=0A=
    NULL: 0,=0A=
    DELIMITER: 1,=0A=
    IDENTIFIER: 2,=0A=
    UNKNOWN: 3=0A=
  };=0A=
=0A=
  // map with all delimiters=0A=
  var DELIMITERS =3D {=0A=
    '{': true,=0A=
    '}': true,=0A=
    '[': true,=0A=
    ']': true,=0A=
    ';': true,=0A=
    '=3D': true,=0A=
    ',': true,=0A=
=0A=
    '->': true,=0A=
    '--': true=0A=
  };=0A=
=0A=
  var dot =3D ''; // current dot file=0A=
  var index =3D 0; // current index in dot file=0A=
  var c =3D ''; // current token character in expr=0A=
  var token =3D ''; // current token=0A=
  var tokenType =3D TOKENTYPE.NULL; // type of the token=0A=
=0A=
  /**=0A=
   * Get the first character from the dot file.=0A=
   * The character is stored into the char c. If the end of the dot file =
is=0A=
   * reached, the function puts an empty string in c.=0A=
   */=0A=
  function first() {=0A=
    index =3D 0;=0A=
    c =3D dot.charAt(0);=0A=
  }=0A=
=0A=
  /**=0A=
   * Get the next character from the dot file.=0A=
   * The character is stored into the char c. If the end of the dot file =
is=0A=
   * reached, the function puts an empty string in c.=0A=
   */=0A=
  function next() {=0A=
    index++;=0A=
    c =3D dot.charAt(index);=0A=
  }=0A=
=0A=
  /**=0A=
   * Preview the next character from the dot file.=0A=
   * @return {String} cNext=0A=
   */=0A=
  function nextPreview() {=0A=
    return dot.charAt(index + 1);=0A=
  }=0A=
=0A=
  /**=0A=
   * Test whether given character is alphabetic or numeric=0A=
   * @param {String} c=0A=
   * @return {Boolean} isAlphaNumeric=0A=
   */=0A=
  var regexAlphaNumeric =3D /[a-zA-Z_0-9.:#]/;=0A=
  function isAlphaNumeric(c) {=0A=
    return regexAlphaNumeric.test(c);=0A=
  }=0A=
=0A=
  /**=0A=
   * Merge all options of object b into object b=0A=
   * @param {Object} a=0A=
   * @param {Object} b=0A=
   * @return {Object} a=0A=
   */=0A=
  function merge(a, b) {=0A=
    if (!a) {=0A=
      a =3D {};=0A=
    }=0A=
=0A=
    if (b) {=0A=
      for (var name in b) {=0A=
        if (b.hasOwnProperty(name)) {=0A=
          a[name] =3D b[name];=0A=
        }=0A=
      }=0A=
    }=0A=
    return a;=0A=
  }=0A=
=0A=
  /**=0A=
   * Set a value in an object, where the provided parameter name can be a=0A=
   * path with nested parameters. For example:=0A=
   *=0A=
   *     var obj =3D {a: 2};=0A=
   *     setValue(obj, 'b.c', 3);     // obj =3D {a: 2, b: {c: 3}}=0A=
   *=0A=
   * @param {Object} obj=0A=
   * @param {String} path  A parameter name or dot-separated parameter =
path,=0A=
   *                      like "color.highlight.border".=0A=
   * @param {*} value=0A=
   */=0A=
  function setValue(obj, path, value) {=0A=
    var keys =3D path.split('.');=0A=
    var o =3D obj;=0A=
    while (keys.length) {=0A=
      var key =3D keys.shift();=0A=
      if (keys.length) {=0A=
        // this isn't the end point=0A=
        if (!o[key]) {=0A=
          o[key] =3D {};=0A=
        }=0A=
        o =3D o[key];=0A=
      } else {=0A=
        // this is the end point=0A=
        o[key] =3D value;=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Add a node to a graph object. If there is already a node with=0A=
   * the same id, their attributes will be merged.=0A=
   * @param {Object} graph=0A=
   * @param {Object} node=0A=
   */=0A=
  function addNode(graph, node) {=0A=
    var i, len;=0A=
    var current =3D null;=0A=
=0A=
    // find root graph (in case of subgraph)=0A=
    var graphs =3D [graph]; // list with all graphs from current graph =
to root graph=0A=
    var root =3D graph;=0A=
    while (root.parent) {=0A=
      graphs.push(root.parent);=0A=
      root =3D root.parent;=0A=
    }=0A=
=0A=
    // find existing node (at root level) by its id=0A=
    if (root.nodes) {=0A=
      for (i =3D 0, len =3D root.nodes.length; i < len; i++) {=0A=
        if (node.id =3D=3D=3D root.nodes[i].id) {=0A=
          current =3D root.nodes[i];=0A=
          break;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    if (!current) {=0A=
      // this is a new node=0A=
      current =3D {=0A=
        id: node.id=0A=
      };=0A=
      if (graph.node) {=0A=
        // clone default attributes=0A=
        current.attr =3D merge(current.attr, graph.node);=0A=
      }=0A=
    }=0A=
=0A=
    // add node to this (sub)graph and all its parent graphs=0A=
    for (i =3D graphs.length - 1; i >=3D 0; i--) {=0A=
      var g =3D graphs[i];=0A=
=0A=
      if (!g.nodes) {=0A=
        g.nodes =3D [];=0A=
      }=0A=
      if (g.nodes.indexOf(current) =3D=3D=3D -1) {=0A=
        g.nodes.push(current);=0A=
      }=0A=
    }=0A=
=0A=
    // merge attributes=0A=
    if (node.attr) {=0A=
      current.attr =3D merge(current.attr, node.attr);=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Add an edge to a graph object=0A=
   * @param {Object} graph=0A=
   * @param {Object} edge=0A=
   */=0A=
  function addEdge(graph, edge) {=0A=
    if (!graph.edges) {=0A=
      graph.edges =3D [];=0A=
    }=0A=
    graph.edges.push(edge);=0A=
    if (graph.edge) {=0A=
      var attr =3D merge({}, graph.edge); // clone default attributes=0A=
      edge.attr =3D merge(attr, edge.attr); // merge attributes=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Create an edge to a graph object=0A=
   * @param {Object} graph=0A=
   * @param {String | Number | Object} from=0A=
   * @param {String | Number | Object} to=0A=
   * @param {String} type=0A=
   * @param {Object | null} attr=0A=
   * @return {Object} edge=0A=
   */=0A=
  function createEdge(graph, from, to, type, attr) {=0A=
    var edge =3D {=0A=
      from: from,=0A=
      to: to,=0A=
      type: type=0A=
    };=0A=
=0A=
    if (graph.edge) {=0A=
      edge.attr =3D merge({}, graph.edge); // clone default attributes=0A=
    }=0A=
    edge.attr =3D merge(edge.attr || {}, attr); // merge attributes=0A=
=0A=
    return edge;=0A=
  }=0A=
=0A=
  /**=0A=
   * Get next token in the current dot file.=0A=
   * The token and token type are available as token and tokenType=0A=
   */=0A=
  function getToken() {=0A=
    tokenType =3D TOKENTYPE.NULL;=0A=
    token =3D '';=0A=
=0A=
    // skip over whitespaces=0A=
    while (c =3D=3D=3D ' ' || c =3D=3D=3D '\t' || c =3D=3D=3D '\n' || c =
=3D=3D=3D '\r') {=0A=
      // space, tab, enter=0A=
      next();=0A=
    }=0A=
=0A=
    do {=0A=
      var isComment =3D false;=0A=
=0A=
      // skip comment=0A=
      if (c =3D=3D=3D '#') {=0A=
        // find the previous non-space character=0A=
        var i =3D index - 1;=0A=
        while (dot.charAt(i) =3D=3D=3D ' ' || dot.charAt(i) =3D=3D=3D =
'\t') {=0A=
          i--;=0A=
        }=0A=
        if (dot.charAt(i) =3D=3D=3D '\n' || dot.charAt(i) =3D=3D=3D '') {=0A=
          // the # is at the start of a line, this is indeed a line =
comment=0A=
          while (c !=3D '' && c !=3D '\n') {=0A=
            next();=0A=
          }=0A=
          isComment =3D true;=0A=
        }=0A=
      }=0A=
      if (c =3D=3D=3D '/' && nextPreview() =3D=3D=3D '/') {=0A=
        // skip line comment=0A=
        while (c !=3D '' && c !=3D '\n') {=0A=
          next();=0A=
        }=0A=
        isComment =3D true;=0A=
      }=0A=
      if (c =3D=3D=3D '/' && nextPreview() =3D=3D=3D '*') {=0A=
        // skip block comment=0A=
        while (c !=3D '') {=0A=
          if (c =3D=3D=3D '*' && nextPreview() =3D=3D=3D '/') {=0A=
            // end of block comment found. skip these last two characters=0A=
            next();=0A=
            next();=0A=
            break;=0A=
          } else {=0A=
            next();=0A=
          }=0A=
        }=0A=
        isComment =3D true;=0A=
      }=0A=
=0A=
      // skip over whitespaces=0A=
      while (c =3D=3D=3D ' ' || c =3D=3D=3D '\t' || c =3D=3D=3D '\n' || =
c =3D=3D=3D '\r') {=0A=
        // space, tab, enter=0A=
        next();=0A=
      }=0A=
    } while (isComment);=0A=
=0A=
    // check for end of dot file=0A=
    if (c =3D=3D=3D '') {=0A=
      // token is still empty=0A=
      tokenType =3D TOKENTYPE.DELIMITER;=0A=
      return;=0A=
    }=0A=
=0A=
    // check for delimiters consisting of 2 characters=0A=
    var c2 =3D c + nextPreview();=0A=
    if (DELIMITERS[c2]) {=0A=
      tokenType =3D TOKENTYPE.DELIMITER;=0A=
      token =3D c2;=0A=
      next();=0A=
      next();=0A=
      return;=0A=
    }=0A=
=0A=
    // check for delimiters consisting of 1 character=0A=
    if (DELIMITERS[c]) {=0A=
      tokenType =3D TOKENTYPE.DELIMITER;=0A=
      token =3D c;=0A=
      next();=0A=
      return;=0A=
    }=0A=
=0A=
    // check for an identifier (number or string)=0A=
    // TODO: more precise parsing of numbers/strings (and the port =
separator ':')=0A=
    if (isAlphaNumeric(c) || c =3D=3D=3D '-') {=0A=
      token +=3D c;=0A=
      next();=0A=
=0A=
      while (isAlphaNumeric(c)) {=0A=
        token +=3D c;=0A=
        next();=0A=
      }=0A=
      if (token =3D=3D=3D 'false') {=0A=
        token =3D false; // convert to boolean=0A=
      } else if (token =3D=3D=3D 'true') {=0A=
        token =3D true; // convert to boolean=0A=
      } else if (!isNaN(Number(token))) {=0A=
        token =3D Number(token); // convert to number=0A=
      }=0A=
      tokenType =3D TOKENTYPE.IDENTIFIER;=0A=
      return;=0A=
    }=0A=
=0A=
    // check for a string enclosed by double quotes=0A=
    if (c =3D=3D=3D '"') {=0A=
      next();=0A=
      while (c !=3D '' && (c !=3D '"' || c =3D=3D=3D '"' && =
nextPreview() =3D=3D=3D '"')) {=0A=
        token +=3D c;=0A=
        if (c =3D=3D=3D '"') {=0A=
          // skip the escape character=0A=
          next();=0A=
        }=0A=
        next();=0A=
      }=0A=
      if (c !=3D '"') {=0A=
        throw newSyntaxError('End of string " expected');=0A=
      }=0A=
      next();=0A=
      tokenType =3D TOKENTYPE.IDENTIFIER;=0A=
      return;=0A=
    }=0A=
=0A=
    // something unknown is found, wrong characters, a syntax error=0A=
    tokenType =3D TOKENTYPE.UNKNOWN;=0A=
    while (c !=3D '') {=0A=
      token +=3D c;=0A=
      next();=0A=
    }=0A=
    throw new SyntaxError('Syntax error in part "' + chop(token, 30) + =
'"');=0A=
  }=0A=
=0A=
  /**=0A=
   * Parse a graph.=0A=
   * @returns {Object} graph=0A=
   */=0A=
  function parseGraph() {=0A=
    var graph =3D {};=0A=
=0A=
    first();=0A=
    getToken();=0A=
=0A=
    // optional strict keyword=0A=
    if (token =3D=3D=3D 'strict') {=0A=
      graph.strict =3D true;=0A=
      getToken();=0A=
    }=0A=
=0A=
    // graph or digraph keyword=0A=
    if (token =3D=3D=3D 'graph' || token =3D=3D=3D 'digraph') {=0A=
      graph.type =3D token;=0A=
      getToken();=0A=
    }=0A=
=0A=
    // optional graph id=0A=
    if (tokenType =3D=3D=3D TOKENTYPE.IDENTIFIER) {=0A=
      graph.id =3D token;=0A=
      getToken();=0A=
    }=0A=
=0A=
    // open angle bracket=0A=
    if (token !=3D '{') {=0A=
      throw newSyntaxError('Angle bracket { expected');=0A=
    }=0A=
    getToken();=0A=
=0A=
    // statements=0A=
    parseStatements(graph);=0A=
=0A=
    // close angle bracket=0A=
    if (token !=3D '}') {=0A=
      throw newSyntaxError('Angle bracket } expected');=0A=
    }=0A=
    getToken();=0A=
=0A=
    // end of file=0A=
    if (token !=3D=3D '') {=0A=
      throw newSyntaxError('End of file expected');=0A=
    }=0A=
    getToken();=0A=
=0A=
    // remove temporary default options=0A=
    delete graph.node;=0A=
    delete graph.edge;=0A=
    delete graph.graph;=0A=
=0A=
    return graph;=0A=
  }=0A=
=0A=
  /**=0A=
   * Parse a list with statements.=0A=
   * @param {Object} graph=0A=
   */=0A=
  function parseStatements(graph) {=0A=
    while (token !=3D=3D '' && token !=3D '}') {=0A=
      parseStatement(graph);=0A=
      if (token =3D=3D=3D ';') {=0A=
        getToken();=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Parse a single statement. Can be a an attribute statement, node=0A=
   * statement, a series of node statements and edge statements, or a=0A=
   * parameter.=0A=
   * @param {Object} graph=0A=
   */=0A=
  function parseStatement(graph) {=0A=
    // parse subgraph=0A=
    var subgraph =3D parseSubgraph(graph);=0A=
    if (subgraph) {=0A=
      // edge statements=0A=
      parseEdge(graph, subgraph);=0A=
=0A=
      return;=0A=
    }=0A=
=0A=
    // parse an attribute statement=0A=
    var attr =3D parseAttributeStatement(graph);=0A=
    if (attr) {=0A=
      return;=0A=
    }=0A=
=0A=
    // parse node=0A=
    if (tokenType !=3D TOKENTYPE.IDENTIFIER) {=0A=
      throw newSyntaxError('Identifier expected');=0A=
    }=0A=
    var id =3D token; // id can be a string or a number=0A=
    getToken();=0A=
=0A=
    if (token =3D=3D=3D '=3D') {=0A=
      // id statement=0A=
      getToken();=0A=
      if (tokenType !=3D TOKENTYPE.IDENTIFIER) {=0A=
        throw newSyntaxError('Identifier expected');=0A=
      }=0A=
      graph[id] =3D token;=0A=
      getToken();=0A=
      // TODO: implement comma separated list with "a_list: ID=3DID =
[','] [a_list] "=0A=
    } else {=0A=
      parseNodeStatement(graph, id);=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Parse a subgraph=0A=
   * @param {Object} graph    parent graph object=0A=
   * @return {Object | null} subgraph=0A=
   */=0A=
  function parseSubgraph(graph) {=0A=
    var subgraph =3D null;=0A=
=0A=
    // optional subgraph keyword=0A=
    if (token =3D=3D=3D 'subgraph') {=0A=
      subgraph =3D {};=0A=
      subgraph.type =3D 'subgraph';=0A=
      getToken();=0A=
=0A=
      // optional graph id=0A=
      if (tokenType =3D=3D=3D TOKENTYPE.IDENTIFIER) {=0A=
        subgraph.id =3D token;=0A=
        getToken();=0A=
      }=0A=
    }=0A=
=0A=
    // open angle bracket=0A=
    if (token =3D=3D=3D '{') {=0A=
      getToken();=0A=
=0A=
      if (!subgraph) {=0A=
        subgraph =3D {};=0A=
      }=0A=
      subgraph.parent =3D graph;=0A=
      subgraph.node =3D graph.node;=0A=
      subgraph.edge =3D graph.edge;=0A=
      subgraph.graph =3D graph.graph;=0A=
=0A=
      // statements=0A=
      parseStatements(subgraph);=0A=
=0A=
      // close angle bracket=0A=
      if (token !=3D '}') {=0A=
        throw newSyntaxError('Angle bracket } expected');=0A=
      }=0A=
      getToken();=0A=
=0A=
      // remove temporary default options=0A=
      delete subgraph.node;=0A=
      delete subgraph.edge;=0A=
      delete subgraph.graph;=0A=
      delete subgraph.parent;=0A=
=0A=
      // register at the parent graph=0A=
      if (!graph.subgraphs) {=0A=
        graph.subgraphs =3D [];=0A=
      }=0A=
      graph.subgraphs.push(subgraph);=0A=
    }=0A=
=0A=
    return subgraph;=0A=
  }=0A=
=0A=
  /**=0A=
   * parse an attribute statement like "node [shape=3Dcircle =
fontSize=3D16]".=0A=
   * Available keywords are 'node', 'edge', 'graph'.=0A=
   * The previous list with default attributes will be replaced=0A=
   * @param {Object} graph=0A=
   * @returns {String | null} keyword Returns the name of the parsed =
attribute=0A=
   *                                  (node, edge, graph), or null if =
nothing=0A=
   *                                  is parsed.=0A=
   */=0A=
  function parseAttributeStatement(graph) {=0A=
    // attribute statements=0A=
    if (token =3D=3D=3D 'node') {=0A=
      getToken();=0A=
=0A=
      // node attributes=0A=
      graph.node =3D parseAttributeList();=0A=
      return 'node';=0A=
    } else if (token =3D=3D=3D 'edge') {=0A=
      getToken();=0A=
=0A=
      // edge attributes=0A=
      graph.edge =3D parseAttributeList();=0A=
      return 'edge';=0A=
    } else if (token =3D=3D=3D 'graph') {=0A=
      getToken();=0A=
=0A=
      // graph attributes=0A=
      graph.graph =3D parseAttributeList();=0A=
      return 'graph';=0A=
    }=0A=
=0A=
    return null;=0A=
  }=0A=
=0A=
  /**=0A=
   * parse a node statement=0A=
   * @param {Object} graph=0A=
   * @param {String | Number} id=0A=
   */=0A=
  function parseNodeStatement(graph, id) {=0A=
    // node statement=0A=
    var node =3D {=0A=
      id: id=0A=
    };=0A=
    var attr =3D parseAttributeList();=0A=
    if (attr) {=0A=
      node.attr =3D attr;=0A=
    }=0A=
    addNode(graph, node);=0A=
=0A=
    // edge statements=0A=
    parseEdge(graph, id);=0A=
  }=0A=
=0A=
  /**=0A=
   * Parse an edge or a series of edges=0A=
   * @param {Object} graph=0A=
   * @param {String | Number} from        Id of the from node=0A=
   */=0A=
  function parseEdge(graph, from) {=0A=
    while (token =3D=3D=3D '->' || token =3D=3D=3D '--') {=0A=
      var to;=0A=
      var type =3D token;=0A=
      getToken();=0A=
=0A=
      var subgraph =3D parseSubgraph(graph);=0A=
      if (subgraph) {=0A=
        to =3D subgraph;=0A=
      } else {=0A=
        if (tokenType !=3D TOKENTYPE.IDENTIFIER) {=0A=
          throw newSyntaxError('Identifier or subgraph expected');=0A=
        }=0A=
        to =3D token;=0A=
        addNode(graph, {=0A=
          id: to=0A=
        });=0A=
        getToken();=0A=
      }=0A=
=0A=
      // parse edge attributes=0A=
      var attr =3D parseAttributeList();=0A=
=0A=
      // create edge=0A=
      var edge =3D createEdge(graph, from, to, type, attr);=0A=
      addEdge(graph, edge);=0A=
=0A=
      from =3D to;=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Parse a set with attributes,=0A=
   * for example [label=3D"1.000", shape=3Dsolid]=0A=
   * @return {Object | null} attr=0A=
   */=0A=
  function parseAttributeList() {=0A=
    var attr =3D null;=0A=
=0A=
    while (token =3D=3D=3D '[') {=0A=
      getToken();=0A=
      attr =3D {};=0A=
      while (token !=3D=3D '' && token !=3D ']') {=0A=
        if (tokenType !=3D TOKENTYPE.IDENTIFIER) {=0A=
          throw newSyntaxError('Attribute name expected');=0A=
        }=0A=
        var name =3D token;=0A=
=0A=
        getToken();=0A=
        if (token !=3D '=3D') {=0A=
          throw newSyntaxError('Equal sign =3D expected');=0A=
        }=0A=
        getToken();=0A=
=0A=
        if (tokenType !=3D TOKENTYPE.IDENTIFIER) {=0A=
          throw newSyntaxError('Attribute value expected');=0A=
        }=0A=
        var value =3D token;=0A=
        setValue(attr, name, value); // name can be a path=0A=
=0A=
        getToken();=0A=
        if (token =3D=3D ',') {=0A=
          getToken();=0A=
        }=0A=
      }=0A=
=0A=
      if (token !=3D ']') {=0A=
        throw newSyntaxError('Bracket ] expected');=0A=
      }=0A=
      getToken();=0A=
    }=0A=
=0A=
    return attr;=0A=
  }=0A=
=0A=
  /**=0A=
   * Create a syntax error with extra information on current token and =
index.=0A=
   * @param {String} message=0A=
   * @returns {SyntaxError} err=0A=
   */=0A=
  function newSyntaxError(message) {=0A=
    return new SyntaxError(message + ', got "' + chop(token, 30) + '" =
(char ' + index + ')');=0A=
  }=0A=
=0A=
  /**=0A=
   * Chop off text after a maximum length=0A=
   * @param {String} text=0A=
   * @param {Number} maxLength=0A=
   * @returns {String}=0A=
   */=0A=
  function chop(text, maxLength) {=0A=
    return text.length <=3D maxLength ? text : text.substr(0, 27) + =
'...';=0A=
  }=0A=
=0A=
  /**=0A=
   * Execute a function fn for each pair of elements in two arrays=0A=
   * @param {Array | *} array1=0A=
   * @param {Array | *} array2=0A=
   * @param {function} fn=0A=
   */=0A=
  function forEach2(array1, array2, fn) {=0A=
    if (Array.isArray(array1)) {=0A=
      array1.forEach(function (elem1) {=0A=
        if (Array.isArray(array2)) {=0A=
          array2.forEach(function (elem2) {=0A=
            fn(elem1, elem2);=0A=
          });=0A=
        } else {=0A=
          fn(elem1, array2);=0A=
        }=0A=
      });=0A=
    } else {=0A=
      if (Array.isArray(array2)) {=0A=
        array2.forEach(function (elem2) {=0A=
          fn(array1, elem2);=0A=
        });=0A=
      } else {=0A=
        fn(array1, array2);=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * Set a nested property on an object=0A=
   * When nested objects are missing, they will be created.=0A=
   * For example setProp({}, 'font.color', 'red') will return {font: =
{color: 'red'}}=0A=
   * @param {Object} object=0A=
   * @param {string} path   A dot separated string like 'font.color'=0A=
   * @param {*} value       Value for the property=0A=
   * @return {Object} Returns the original object, allows for chaining.=0A=
   */=0A=
  function setProp(object, path, value) {=0A=
    var names =3D path.split('.');=0A=
    var prop =3D names.pop();=0A=
=0A=
    // traverse over the nested objects=0A=
    var obj =3D object;=0A=
    for (var i =3D 0; i < names.length; i++) {=0A=
      var name =3D names[i];=0A=
      if (!(name in obj)) {=0A=
        obj[name] =3D {};=0A=
      }=0A=
      obj =3D obj[name];=0A=
    }=0A=
=0A=
    // set the property value=0A=
    obj[prop] =3D value;=0A=
=0A=
    return object;=0A=
  }=0A=
=0A=
  /**=0A=
   * Convert an object with DOT attributes to their vis.js equivalents.=0A=
   * @param {Object} attr     Object with DOT attributes=0A=
   * @param {Object} mapping=0A=
   * @return {Object}         Returns an object with vis.js attributes=0A=
   */=0A=
  function convertAttr(attr, mapping) {=0A=
    var converted =3D {};=0A=
=0A=
    for (var prop in attr) {=0A=
      if (attr.hasOwnProperty(prop)) {=0A=
        var visProp =3D mapping[prop];=0A=
        if (Array.isArray(visProp)) {=0A=
          visProp.forEach(function (visPropI) {=0A=
            setProp(converted, visPropI, attr[prop]);=0A=
          });=0A=
        } else if (typeof visProp =3D=3D=3D 'string') {=0A=
          setProp(converted, visProp, attr[prop]);=0A=
        } else {=0A=
          setProp(converted, prop, attr[prop]);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    return converted;=0A=
  }=0A=
=0A=
  /**=0A=
   * Convert a string containing a graph in DOT language into a map =
containing=0A=
   * with nodes and edges in the format of graph.=0A=
   * @param {String} data         Text containing a graph in DOT-notation=0A=
   * @return {Object} graphData=0A=
   */=0A=
  function DOTToGraph(data) {=0A=
    // parse the DOT file=0A=
    var dotData =3D parseDOT(data);=0A=
    var graphData =3D {=0A=
      nodes: [],=0A=
      edges: [],=0A=
      options: {}=0A=
    };=0A=
=0A=
    // copy the nodes=0A=
    if (dotData.nodes) {=0A=
      dotData.nodes.forEach(function (dotNode) {=0A=
        var graphNode =3D {=0A=
          id: dotNode.id,=0A=
          label: String(dotNode.label || dotNode.id)=0A=
        };=0A=
        merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));=0A=
        if (graphNode.image) {=0A=
          graphNode.shape =3D 'image';=0A=
        }=0A=
        graphData.nodes.push(graphNode);=0A=
      });=0A=
    }=0A=
=0A=
    // copy the edges=0A=
    if (dotData.edges) {=0A=
      /**=0A=
       * Convert an edge in DOT format to an edge with VisGraph format=0A=
       * @param {Object} dotEdge=0A=
       * @returns {Object} graphEdge=0A=
       */=0A=
      var convertEdge =3D function convertEdge(dotEdge) {=0A=
        var graphEdge =3D {=0A=
          from: dotEdge.from,=0A=
          to: dotEdge.to=0A=
        };=0A=
        merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));=0A=
        graphEdge.arrows =3D dotEdge.type =3D=3D=3D '->' ? 'to' : =
undefined;=0A=
=0A=
        return graphEdge;=0A=
      };=0A=
=0A=
      dotData.edges.forEach(function (dotEdge) {=0A=
        var from, to;=0A=
        if (dotEdge.from instanceof Object) {=0A=
          from =3D dotEdge.from.nodes;=0A=
        } else {=0A=
          from =3D {=0A=
            id: dotEdge.from=0A=
          };=0A=
        }=0A=
=0A=
        // TODO: support of solid/dotted/dashed edges (attr =3D 'style')=0A=
        // TODO: support for attributes 'dir' and 'arrowhead' (edge =
arrows)=0A=
=0A=
        if (dotEdge.to instanceof Object) {=0A=
          to =3D dotEdge.to.nodes;=0A=
        } else {=0A=
          to =3D {=0A=
            id: dotEdge.to=0A=
          };=0A=
        }=0A=
=0A=
        if (dotEdge.from instanceof Object && dotEdge.from.edges) {=0A=
          dotEdge.from.edges.forEach(function (subEdge) {=0A=
            var graphEdge =3D convertEdge(subEdge);=0A=
            graphData.edges.push(graphEdge);=0A=
          });=0A=
        }=0A=
=0A=
        forEach2(from, to, function (from, to) {=0A=
          var subEdge =3D createEdge(graphData, from.id, to.id, =
dotEdge.type, dotEdge.attr);=0A=
          var graphEdge =3D convertEdge(subEdge);=0A=
          graphData.edges.push(graphEdge);=0A=
        });=0A=
=0A=
        if (dotEdge.to instanceof Object && dotEdge.to.edges) {=0A=
          dotEdge.to.edges.forEach(function (subEdge) {=0A=
            var graphEdge =3D convertEdge(subEdge);=0A=
            graphData.edges.push(graphEdge);=0A=
          });=0A=
        }=0A=
      });=0A=
    }=0A=
=0A=
    // copy the options=0A=
    if (dotData.attr) {=0A=
      graphData.options =3D dotData.attr;=0A=
    }=0A=
=0A=
    return graphData;=0A=
  }=0A=
=0A=
  // exports=0A=
  exports.parseDOT =3D parseDOT;=0A=
  exports.DOTToGraph =3D DOTToGraph;=0A=
=0A=
/***/ },=0A=
/* 113 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  'use strict';=0A=
=0A=
  function parseGephi(gephiJSON, optionsObj) {=0A=
    var edges =3D [];=0A=
    var nodes =3D [];=0A=
    var options =3D {=0A=
      edges: {=0A=
        inheritColor: false=0A=
      },=0A=
      nodes: {=0A=
        fixed: false,=0A=
        parseColor: false=0A=
      }=0A=
    };=0A=
=0A=
    if (optionsObj !=3D=3D undefined) {=0A=
      if (optionsObj.fixed !=3D=3D undefined) {=0A=
        options.nodes.fixed =3D optionsObj.fixed;=0A=
      }=0A=
      if (optionsObj.parseColor !=3D=3D undefined) {=0A=
        options.nodes.parseColor =3D optionsObj.parseColor;=0A=
      }=0A=
      if (optionsObj.inheritColor !=3D=3D undefined) {=0A=
        options.edges.inheritColor =3D optionsObj.inheritColor;=0A=
      }=0A=
    }=0A=
=0A=
    var gEdges =3D gephiJSON.edges;=0A=
    var gNodes =3D gephiJSON.nodes;=0A=
    for (var i =3D 0; i < gEdges.length; i++) {=0A=
      var edge =3D {};=0A=
      var gEdge =3D gEdges[i];=0A=
      edge['id'] =3D gEdge.id;=0A=
      edge['from'] =3D gEdge.source;=0A=
      edge['to'] =3D gEdge.target;=0A=
      edge['attributes'] =3D gEdge.attributes;=0A=
      //    edge['value'] =3D gEdge.attributes !=3D=3D undefined ? =
gEdge.attributes.Weight : undefined;=0A=
      //    edge['width'] =3D edge['value'] !=3D=3D undefined ? =
undefined : edgegEdge.size;=0A=
      if (gEdge.color && options.inheritColor =3D=3D=3D false) {=0A=
        edge['color'] =3D gEdge.color;=0A=
      }=0A=
      edges.push(edge);=0A=
    }=0A=
=0A=
    for (var i =3D 0; i < gNodes.length; i++) {=0A=
      var node =3D {};=0A=
      var gNode =3D gNodes[i];=0A=
      node['id'] =3D gNode.id;=0A=
      node['attributes'] =3D gNode.attributes;=0A=
      node['title'] =3D gNode.title;=0A=
      node['x'] =3D gNode.x;=0A=
      node['y'] =3D gNode.y;=0A=
      node['label'] =3D gNode.label;=0A=
      if (options.nodes.parseColor =3D=3D=3D true) {=0A=
        node['color'] =3D gNode.color;=0A=
      } else {=0A=
        node['color'] =3D gNode.color !=3D=3D undefined ? { background: =
gNode.color, border: gNode.color, highlight: { background: gNode.color, =
border: gNode.color }, hover: { background: gNode.color, border: =
gNode.color } } : undefined;=0A=
      }=0A=
      node['size'] =3D gNode.size;=0A=
      node['fixed'] =3D options.nodes.fixed && gNode.x !=3D=3D undefined =
&& gNode.y !=3D=3D undefined;=0A=
      nodes.push(node);=0A=
    }=0A=
=0A=
    return { nodes: nodes, edges: edges };=0A=
  }=0A=
=0A=
  exports.parseGephi =3D parseGephi;=0A=
=0A=
/***/ },=0A=
/* 114 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  /**=0A=
   * @class Images=0A=
   * This class loads images and keeps them stored.=0A=
   */=0A=
  "use strict";=0A=
=0A=
  Object.defineProperty(exports, "__esModule", {=0A=
      value: true=0A=
  });=0A=
=0A=
  var _createClass =3D (function () { function defineProperties(target, =
props) { for (var i =3D 0; i < props.length; i++) { var descriptor =3D =
props[i]; descriptor.enumerable =3D descriptor.enumerable || false; =
descriptor.configurable =3D true; if ("value" in descriptor) =
descriptor.writable =3D true; Object.defineProperty(target, =
descriptor.key, descriptor); } } return function (Constructor, =
protoProps, staticProps) { if (protoProps) =
defineProperties(Constructor.prototype, protoProps); if (staticProps) =
defineProperties(Constructor, staticProps); return Constructor; }; })();=0A=
=0A=
  function _classCallCheck(instance, Constructor) { if (!(instance =
instanceof Constructor)) { throw new TypeError("Cannot call a class as a =
function"); } }=0A=
=0A=
  var Images =3D (function () {=0A=
      function Images(callback) {=0A=
          _classCallCheck(this, Images);=0A=
=0A=
          this.images =3D {};=0A=
          this.imageBroken =3D {};=0A=
          this.callback =3D callback;=0A=
      }=0A=
=0A=
      _createClass(Images, [{=0A=
          key: "_addImageToCache",=0A=
=0A=
          /**=0A=
           * @param {string} url                      The Url to cache =
the image as =0A=
            * @return {Image} imageToLoadBrokenUrlOn  The image object=0A=
           */=0A=
          value: function _addImageToCache(url, imageToCache) {=0A=
              // IE11 fix -- thanks dponch!=0A=
              if (imageToCache.width =3D=3D=3D 0) {=0A=
                  document.body.appendChild(imageToCache);=0A=
                  imageToCache.width =3D imageToCache.offsetWidth;=0A=
                  imageToCache.height =3D imageToCache.offsetHeight;=0A=
                  document.body.removeChild(imageToCache);=0A=
              }=0A=
=0A=
              this.images[url] =3D imageToCache;=0A=
          }=0A=
      }, {=0A=
          key: "_tryloadBrokenUrl",=0A=
=0A=
          /**=0A=
           * @param {string} url                      The original Url =
that failed to load, if the broken image is successfully loaded it will =
be added to the cache using this Url as the key so that subsequent =
requests for this Url will return the broken image=0A=
           * @param {string} brokenUrl                Url the broken =
image to try and load=0A=
           * @return {Image} imageToLoadBrokenUrlOn   The image object=0A=
           */=0A=
          value: function _tryloadBrokenUrl(url, brokenUrl, =
imageToLoadBrokenUrlOn) {=0A=
              var _this =3D this;=0A=
=0A=
              //If any of the parameters aren't specified then exit the =
function because nothing constructive can be done=0A=
              if (url =3D=3D=3D undefined || brokenUrl =3D=3D=3D =
undefined || imageToLoadBrokenUrlOn =3D=3D=3D undefined) return;=0A=
=0A=
              //Clear the old subscription to the error event and put a =
new in place that only handle errors in loading the brokenImageUrl=0A=
              imageToLoadBrokenUrlOn.onerror =3D function () {=0A=
                  console.error("Could not load brokenImage:", =
brokenUrl);=0A=
                  //Add an empty image to the cache so that when =
subsequent load calls are made for the url we don't try load the image =
and broken image again=0A=
                  _this._addImageToCache(url, new Image());=0A=
              };=0A=
=0A=
              //Set the source of the image to the brokenUrl, this is =
actually what kicks off the loading of the broken image=0A=
              imageToLoadBrokenUrlOn.src =3D brokenUrl;=0A=
          }=0A=
      }, {=0A=
          key: "_redrawWithImage",=0A=
=0A=
          /**=0A=
           * @return {Image} imageToRedrawWith The images that will be =
passed to the callback when it is invoked=0A=
           */=0A=
          value: function _redrawWithImage(imageToRedrawWith) {=0A=
              if (this.callback) {=0A=
                  this.callback(imageToRedrawWith);=0A=
              }=0A=
          }=0A=
      }, {=0A=
          key: "load",=0A=
=0A=
          /**=0A=
           * @param {string} url          Url of the image=0A=
           * @param {string} brokenUrl    Url of an image to use if the =
url image is not found=0A=
           * @return {Image} img          The image object=0A=
           */=0A=
          value: function load(url, brokenUrl, id) {=0A=
              var _this2 =3D this;=0A=
=0A=
              //Try and get the image from the cache, if successful then =
return the cached image  =0A=
              var cachedImage =3D this.images[url];=0A=
              if (cachedImage) return cachedImage;=0A=
=0A=
              //Create a new image=0A=
              var img =3D new Image();=0A=
=0A=
              //Subscribe to the event that is raised if the image loads =
successfully=0A=
              img.onload =3D function () {=0A=
                  //Add the image to the cache and then request a redraw=0A=
                  _this2._addImageToCache(url, img);=0A=
                  _this2._redrawWithImage(img);=0A=
              };=0A=
=0A=
              //Subscribe to the event that is raised if the image fails =
to load=0A=
              img.onerror =3D function () {=0A=
                  console.error("Could not load image:", url);=0A=
                  //Try and load the image specified by the brokenUrl =
using=0A=
                  _this2._tryloadBrokenUrl(url, brokenUrl, img);=0A=
              };=0A=
=0A=
              //Set the source of the image to the url, this is actuall =
what kicks off the loading of the image=0A=
              img.src =3D url;=0A=
=0A=
              //Return the new image=0A=
              return img;=0A=
          }=0A=
      }]);=0A=
=0A=
      return Images;=0A=
  })();=0A=
=0A=
  exports["default"] =3D Images;=0A=
  module.exports =3D exports["default"];=0A=
=0A=
/***/ },=0A=
/* 115 */=0A=
/***/ function(module, exports) {=0A=
=0A=
  // English=0A=
  'use strict';=0A=
=0A=
  exports['en'] =3D {=0A=
    edit: 'Edit',=0A=
    del: 'Delete selected',=0A=
    back: 'Back',=0A=
    addNode: 'Add Node',=0A=
    addEdge: 'Add Edge',=0A=
    editNode: 'Edit Node',=0A=
    editEdge: 'Edit Edge',=0A=
    addDescription: 'Click in an empty space to place a new node.',=0A=
    edgeDescription: 'Click on a node and drag the edge to another node =
to connect them.',=0A=
    editEdgeDescription: 'Click on the control points and drag them to a =
node to connect to it.',=0A=
    createEdgeError: 'Cannot link edges to a cluster.',=0A=
    deleteClusterError: 'Clusters cannot be deleted.',=0A=
    editClusterError: 'Clusters cannot be edited.'=0A=
  };=0A=
  exports['en_EN'] =3D exports['en'];=0A=
  exports['en_US'] =3D exports['en'];=0A=
=0A=
  // Dutch=0A=
  exports['nl'] =3D {=0A=
    edit: 'Wijzigen',=0A=
    del: 'Selectie verwijderen',=0A=
    back: 'Terug',=0A=
    addNode: 'Node toevoegen',=0A=
    addEdge: 'Link toevoegen',=0A=
    editNode: 'Node wijzigen',=0A=
    editEdge: 'Link wijzigen',=0A=
    addDescription: 'Klik op een leeg gebied om een nieuwe node te =
maken.',=0A=
    edgeDescription: 'Klik op een node en sleep de link naar een andere =
node om ze te verbinden.',=0A=
    editEdgeDescription: 'Klik op de verbindingspunten en sleep ze naar =
een node om daarmee te verbinden.',=0A=
    createEdgeError: 'Kan geen link maken naar een cluster.',=0A=
    deleteClusterError: 'Clusters kunnen niet worden verwijderd.',=0A=
    editClusterError: 'Clusters kunnen niet worden aangepast.'=0A=
  };=0A=
  exports['nl_NL'] =3D exports['nl'];=0A=
  exports['nl_BE'] =3D exports['nl'];=0A=
=0A=
/***/ }=0A=
/******/ ])=0A=
});=0A=
;
------=_NextPart_000_0000_01D0E0D4.83203900
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://visjs.org/examples/googleAnalytics.js

(function (i, s, o, g, r, a, m) {=0A=
  i['GoogleAnalyticsObject'] =3D r;=0A=
  i[r] =3D i[r] || function () {=0A=
      (i[r].q =3D i[r].q || []).push(arguments)=0A=
    }, i[r].l =3D 1 * new Date();=0A=
  a =3D s.createElement(o), m =3D s.getElementsByTagName(o)[0];=0A=
  a.async =3D 1;=0A=
  a.src =3D g;=0A=
  m.parentNode.insertBefore(a, m)=0A=
})(window, document, 'script', =
'//www.google-analytics.com/analytics.js', 'ga');=0A=
ga('create', 'UA-61231638-1', 'auto');=0A=
ga('send', 'pageview');
------=_NextPart_000_0000_01D0E0D4.83203900--
